\input texinfo @c -*-texinfo-*-

@comment %**start of header
@setfilename sdoc.info
@include version.texi
@settitle Using and building source code libraries
@c @syncodeindex fn cp
@c @syncodeindex vr cp
@c @syncodeindex tp cp
@comment %**end of header

@setchapternewpage odd
@ifinfo
Copyright @copyright{} 2009 Masatake YAMATO
Copyright @copyright{} 2009 Red hat, K.K.
@end ifinfo

@dircategory Understanding source code
@direntry
* ソースコード基地の利用と運用: (sdoc)       ソースコード基地の利用と運用
@end direntry

@titlepage
@title ソースコード基地の利用と運用
@author Masatake YAMATO (@email{yamato@@redhat.com})
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2009 Masatake YAMATO
Copyright @copyright{} 2009 Red hat, K.K.
@c @insertcopying
@end titlepage

@ifnottex
@node Top
@top ソースコード基地の利用と運用
@end ifnottex

ソースコード基地とは、あなたや同僚が読む可能性のあるソースコードがある
べきところに配置されていて、ダウンロード待ちもインストール待ちも、イン
ストールされたファイル群を捜す手間も無く、ソフトウェアの動作について疑
問に思ったその瞬間すぐにソースコードリーディングを開始できるような作業
環境を指す筆者の造語です。
ソースコードリーディングの嗜みがあれば、知的欲望を満す場所として、ある
いは怒りの発散の場所として、ソースコード基地は理想的な環境です。

そんな環境を実現できるでしょうか？ 筆者はオープンソースソフトウェア群か
ら成るOSに対するサポート、コンサルテーション、トレーニングをサービスと
して提供する会社に勤務する傍ら、4年を費して擬似的なソースコード基地を構
築し、同僚とともに利用しています。

「擬似的に」というのは以下のような意味です: (1) 読む可能性のある全ての
ソフトウェアを知ることはできないので、業務の範囲で読む可能性がありかつ
一般に入手可能なものを対象とした、(2) 疑問に思った瞬間にソースコードリー
ディングを開始することはできないが、命名規則を十分に工夫したディレクト
リ構造中にソースコードを配置し、それをNFSで共有することで、職場のネット
ワークを利用している限り十分短い時間で開始できるようにした。

本文章ではまず、既に構築されたソースコード基地の利用方法を説明します。
私の同僚であれば、ソースコード基地の利用方法だけを知っていれば、それだ
けで便利ははずです。

次に、ソースコード基地の設置、運用手順について説明します。設置、運用は
プログラムを用いてある程度自動化できるようにまとめてあります。それらの
プログラムと自動化が十分でない部分の注意について説明します。設置された
ソースコード基地が無ければ自分で設置するしかありません。設置したソース
コード基地にソースコードを追加していき規模が増してくると、さまざまなト
ラブルが発生します。それらに対する対処方法も説明します。

最後にソースコード基地の拡張方法を説明します。設置、運用プログラムには、
設置、運用処理のいつくかの箇所に、登録しておいたユーザ独自プログラムを
実行するためのフック、プラグイン機構が用意されています。その機構を利用し
てソースコード基地の様々な側面を拡張できます。


@menu
* ソースコード基地の利用(共有ファイルシステム上)::
* ソースコード基地の利用(ホームディレクトリ内)::
* ソースコード基地の設置と保守::
* ソースコード基地の拡張::
* Index::
@end menu

@c =====================================================================
@node ソースコード基地の利用(共有ファイルシステム上)
@chapter ソースコード基地の利用(共有ファイルシステム上)
「擬似的な」ソースコード基地では、十分に工夫した一貫した命名規則による
ディレクトリ構造中にソースコードファイルの配置しています。そしてそのトッ
プディレクトリをNFSで共有しています。

職場では@code{sources}という名前のホストがNFSサーバを担当しています。そ
こでこの文章でも@code{sources}という名前をホスト名に使うことにします。
早速マウントしてみましょう。

@example
# mkdir -p /srv/sources
# mount sources:/srv/sources /srv/sources
# cd /srv/sources
# ls
attic dists packages plugins sources
@end example

マウント先@file{/srv/sources}というマウント先は今のところ変更できません。
複数の目的でシンボリックリンクを取り回す必要があったため、その名前が設置用プログラムに
ハードコードされているためです。

@menu
* sources上のソースコード::
* トップレベルのディレクトリ構造::
* pvrのディレクトリ構造::
* pvr/pluginsのディレクトリ構造::
* attic/cradlesのディレクトリ構造::
@end menu

@node sources上のソースコード
@section sources上のソースコード
@code{sources}上にどういった種類のソースコードが配置されるか、というの
は設置時の設定によります。後に説明しますが、設置時の設定は
@file{/srv/sources/attic/cradles}以下に格納されます。ここでは筆者が
職場に設置したsourcesを例に説明します。

sources上には重複も含めて1.5Tバイトほどのソースコードがあります。次の
表に、ソースコードの取得先と取得対象種別、sourcesへの追加の方針を示します。

@multitable @columnfractions .4 .4 .2
@c @headitem 取得先 @tab 対象 @tab 追加方針

@item ftp.redhat.com                @tab *.src.rpm @tab non-gc
@item kojipkgs.fedoraproject.org    @tab *.src.rpm @tab gc
@item www.jpackage.org              @tab *.src.rpm @tab gc
@item rpmfusion-free-rawhide-source @tab *.src.rpm @tab gc
@item lcopy.sys                     @tab vcsによる @tab vcsによる

@end multitable

sources設置プログラムの拡張機構を用いれば*src.rpm以外の方法でまとめられ
たソースコードもsourcesに配置できるはずですが、もともとsourcesが筆者の
業務に由来しているため、既にsourcesに配置されているソースコードのほとん
どが*src.rpm形式で入手できるものばかりです。この*.src.rpmを展開の後、有
用そうな後処理を加え、パッケージ間のディレクトリ名の衝突を避けて配置してあ
ります。

運用用のプログラムは毎日取得先にある対象が更新されていなか調べています。
追加方針にgcとある場合、同名のパッケージに対するソースコードの新しいバー
ジョンが取得先でみつかった場合、sources上にある古いバージョンに対するソー
スコードを削除して、新しいものを配置します。non-gcとある場合、古いバー
ジョンを削除せずに、新しいバージョンを追加します。

例えば @code{foo}というパッケージを考えます。@code{sources}には
@file{foo-1.1.src.rpm}のソースコードが既に配置済みだとします。ここで
fooの取得先が@file{foo-1.2.src.rpm}の存在が検出されたとします。gcの場合
@file{foo-1.1.src.rpm}の内容を配置した @file{foo/1.1}を削除の後
@file{foo/1.2}を用意して、そこに@file{foo-1.2.src.rpm}の内容を配置しま
す。一方non-gcの場合@file{foo/1.1}をそのままにして、@file{foo/1.2}を用
意して、そこに@file{foo-1.2.src.rpm}の内容を配置します。

@code{ftp.redhat.com}は、最も業務で頻繁に用いるはずです。最近アップデート
されたパッケージよりは、(顧客の使う)古いバージョンに関する調査が頻発するので
追加方針をnon-gcとしています。

@code{kojipkgs.fedoraproject.org}, @code{www.jpackage.org},
@code{rpmfusion-free-rawhide-source}は、必ずしも業務に必要ないかもしれ
ませんが、最近のオープンソース世界の動向や、将来の製品候補のコードレベ
ルで調査するのに役立つはずです。

@code{lcopy.sys}は変り種です。唯一対象を*src.rpmとしません。lcopy.sysは
ソースコードの入手にgit, svn, cvsといったバージョン管理システムを使いま
す。入手先となるリポジトリはsources構築時に指定します。最初にチェックア
ウトして、以降毎日アップデートします。現状では、linuxカーネルの開発元で
あるgit.kernel.orgなどがリポジトリとして指定されています。特定のソフト
ウェアの最新動向を追跡することができます。

入手先がどこであれ、十分に工夫した一貫した命名規則によるディレクトリ構
造中にソースコードファイルを配置しているため、どのソフトウェア(あるいは
パッケージ)のソースコードであれ、それを/srv/sourcesからみつけるのは容易
です。以降その命名規則を説明します。

@node トップレベルのディレクトリ構造
@section トップレベルのディレクトリ構造
sources, packages, dists, plugins, attic

@node pvrのディレクトリ構造
@section pvrのディレクトリ構造

specs.spec
pre-build
archives
vanilla
plugins

@node attic/cradlesのディレクトリ構造
@section attic/cradlesのディレクトリ構造

@node ソースコード基地の設置と保守
@chapter ソースコード基地の設置と保守
srpmix, sop, sbuild, lcopy

@node ソースコード基地の拡張
@chapter ソースコード基地の拡張
srpmix: spec rewrite rules, package-plugins, dist-plugin, top-plugin
sbuild: builder
sop: mirror-engine
lcopy: backend

@contents
@bye
