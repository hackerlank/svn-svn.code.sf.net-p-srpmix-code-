\input texinfo   @c -*-texinfo-*-
@comment %**start of header
@setfilename intcs.info
@include version.texi
@settitle 詳解 Cluster2
@c @syncodeindex fn cp
@c @syncodeindex vr cp
@c @syncodeindex tp cp
@comment %**end of header

@dircategory Using Source code
@direntry
* 詳解 Cluster2: (intcs)       詳解 Cluster2
@end direntry

@titlepage
@title 詳解 Cluster2
@author Masatake YAMATO (@email{yamato@@redhat.com})
@page
@vskip 0pt plus 1filll
@c @insertcopying
@end titlepage


@alias comp  = code
@alias pkg   = code
@alias proto = code


@ifnottex
@node Top
@top 詳解 Cluster2
本文章ではCluster2の内部構造について解説します。
ソースコードを活用してCluster 2のトラブルシューティングを実施するための
基礎となる知識の提供を目的とています。
@end ifnottex

@menu
* コンポーネントとパッケージの関係::
* ネットワーク通信プロトコル::
* コンポーネント間の通信経路::
* コンポーネントのステート::
* コンフィギュレーションの指定方法::
* ログの活用::
@end menu

@node コンポーネントとパッケージの関係
@chapter  コンポーネントとパッケージの関係
Cluster2は複数のパッケージに分割され、さらにそのパッケージのなかに複数
のコンポーネントが含まれています。コンポーネントにはツールやサービスデー
モンといった実行ファイルやライブラリが含まれます。

Cluster2が深遠だと感じる理由の一つは、協調して動作する目新しいコンポー
ネントが多数存在していることにあります。クラスターの様々な機能が細かく
コンポーネントに分解されていることに加え、Cluster1のソフトウェア資産を
活かすために、コンポーネントが増えています。

Cluster2の前身Cluster1では、クラスターソフトウェアの中枢部分がLinuxカー
ネルのモジュールとして提供されていました。Cluster2の開発の目的の一つは、
その中枢部分をカーネル空間からユーザ空間で動作するサーバopenaisで置き換
えることでした。一方である程度成功を収めていたCluster1の周辺ソフトウェ
アについては、そのままCluster2でも使い続けようとしました。そのため
Cluster2 には、Cluster1の周辺ソフトウェアを動作させるための互換レイヤと
も言うべきコンポーネントが含まれています。

Cluster2について理解していこうとすると、このコンポーネントの数と格闘す
ることになります。後回しにせず先にコンポーネントの名前を全て覚えてしま
いましょう。各コンポーネントの役割については、この文章のなかで徐々に説
明していきます。

また、各コンポーネントがどのパッケージに所属しているかを把握しておきま
す。ログやpsコマンドの出力といったプログラムの実行によって得られる情報
においては、主にコンポーネントの名前が使われます。一方ソースコードはパッ
ケージを単位として編成されています。従って実行によって得られた情報を元
にソースコードを調査する場合、前もって各コンポーネントがどのパッケージ
に所属しているか知っておくことが望ましいです。

@multitable @columnfractions .3 .3 .2 .5
@cindex コンポーネント
@c @headitem コンポーネント @tab 種類 @tab パッケージ @tab 役割
@headitem コンポーネント @tab 種類 @tab パッケージ @tab 役割
@item @comp{aiexec}
@tab サービスデーモン
@tab @pkg{openais}
@tab クラスターコア

@item @comp{service_cman.lcrso}
@tab DLL
@tab @pkg{cman}
@tab Quorateを提供する。

@item @comp{libcman.so}
@tab DLL
@tab @pkg{cman}
@tab aisexecプロセスの外から service_cman.lcrso を利用するためのライブラリ

@item @comp{cman}
@tab 起動スクリプト
@tab @pkg{cman}
@tab Cluster2 特有の設定の元でaiexecを起動します。
      
@item @comp{cman_tool}
@tab コマンド
@tab @pkg{cman}
@tab XXX

@item @comp{ccsd}
@tab サービスデーモン
@tab @pkg{cman}
@tab XXX

@item @comp{ccs_tool}
@tab コマンド
@tab @pkg{cman}
@tab XXX

@item @comp{fenced}
@tab サービスデーモン
@tab @pkg{cman}
@tab XXX

@item fenceエージェント
@tab ユーティリティコマンド
@tab @pkg{cman}
@tab フェンシングを実行する。ハードウェアに応じて様々な実装がある。

@item @comp{fence_tool}
@tab コマンド
@tab @pkg{cman}
@tab XXX

@item @comp{fence_node}
@tab コマンド
@tab @pkg{cman}
@tab XXX

@item @comp{groupd}
@tab サービスデーモン
@tab @pkg{cman}
@tab XXX

@item @comp{group_tool}
@tab コマンド
@tab @pkg{cman}
@tab XXX

@item @comp{libgroup}
@tab スタティックライブラリ
@tab @pkg{cman}
@tab Quorum disk

@item @comp{qdiskd}
@tab サービスデーモン
@tab @pkg{cman}
@tab XXX

@item @comp{rgmanager}
@tab 起動スクリプト
@tab @pkg{rgmanager}
@tab XXX

@item @comp{clurgmgrd}
@tab サービスデーモン
@tab @pkg{rgmanager}
@tab フェイルオーバーするサービスを監視、管理する

@item @comp{clurmtabd}
@tab XXX        
@tab @pkg{rgmanager}
@tab XXX

@end multitable


@node ネットワーク通信プロトコル
@chapter ネットワーク通信プロトコル

Cluster2のネットワーク通信プロトコルスタックを以下に示します。

プロトコルの名称は、筆者が独自に与えたものです。筆者はCluster2のプロト
コル群に対するwiresharkのprotocol dissector群を開発中です。プロトコルの
名称は、そのprotocol dissector群で使っているものです。

@proto{corosync_}というプレフィックスは、Cluster3からとったものです。
Cluster2の保守と並行してCluster2の後継にあたるCluster3が開発中です。
Cluster2向けに開発していたprotocol dissector群ですが、Cluster3の
通信も扱えるようにしたいと考え、いくつかの固有名詞をCluster3から借用して
います。

そのプロトコルの通信を実装しているコンポーネントを<...>の部分に記しました。

@proto{totem}という名称は、aisexecのノード間通信で採用しているアリゴリズム
に由来します。                  @c cite

@verbatim
(ip)                     <linux>
  (udp)                  <linux>
    corosync_totemnet    <aisexec>
      corosync_totemsrp  <aisexec>
        corosync_totempg <aisexec>
          openais_cman   <service_cman.lcrso>
            rgmanager    <clurgmgrd>
          openais_a      <aisexec>
            openais_cpg  <aisexec>
              groupd     <groupd>
            openais_evt  <aisexec>
            openais_clm  <aisexec>
          flowcontrol    <aisexec?>
          sync           <aisexec?>
@end verbatim

@node コンポーネント間の通信経路
@chapter コンポーネント間の通信経路
@c 誰が起動するのか、通信経路の確立方法

@node コンポーネントのステート
@chapter  コンポーネントのステート

@node コンフィギュレーションの指定方法
@chapter コンフィギュレーションの指定方法

@node ログの活用
@chapter ログの活用

@contents
@bye
