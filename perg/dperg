;; -*- scheme -*-
(use file.util)
(use gauche.parseopt)
(use gauche.process)
(use gauche.selector)
(use es.src.syslog)
(use es.dest.syslog)
(use text.html-lite)
(use text.tree)
(use srfi-1)

(define basename->packages (make-hash-table 'equal?))
(load "./hash.scm" :error-if-not-found #f)


(debug-print-width #f)

(define (show-help prog n)
  (format #t "~a [--limit-group=N] [--limit-list=N] [--format=es|html] DIST < /var/log/message\n" prog)
  (exit n))


(define (cmd->package cmd dist)
  (cond
   ((equal? cmd "kernel")
    (values "kernel" "2.6.18-164.el5"))
   ((equal? cmd "rsyslogd")
    (values "rsyslog" "2.0.6-1.el5"))
   ((equal? cmd "dhclient")
    (values "dhcp" "3.0.5-21.el5"))
   ((equal? cmd "pulseaudio")
    (values "pulseaudio" "0.9.21-5.fc13"))
   (else
    (let1 pv (hash-table-get basename->packages cmd #f)
      (if pv
	  (apply values (car pv))
	  (begin 
	    (format (current-error-port) ";; package for ~s is unknown\n" cmd)
	    (values #f #f))
	  )))))

(define (package-version->xgettxt pkg ver)
  (if pkg
      (format "/srv/sources/sources/~a/~a/~a/plugins/xgettext/xgettext.out"
	      (substring pkg 0 1)
	      pkg
	      ver)
      #f))

(define-class <perg> ()
  ((package-version :init-keyword :package-version)
   (logs     :init-form    (list))
   (unsolved :init-form    (make-tree-map equal? 
					  (lambda (a b)
					    (>= (string-length a) 
						(string-length b)))))
   (in-process :init-form (make-hash-table 'equal?))
   (resolved :init-form    (make-hash-table 'equal?))
   ))

(define perg-cmd "./perg")
(define (run-perg xgettext limit)
  (let ((limit-flag (format "--limit=~d" limit)))
    (run-process `(,perg-cmd "--format=es" ,limit-flag = ,xgettext) 
			      :input :pipe
			      :output :pipe)
    ))

(define-method estimate-mp ((perg <perg>) xgettext)
  (if (equal? "kernel" (car (ref perg 'package-version)))
      XFORK
      1))

(define-method run ((perg <perg>) (limit <integer>))
  (let* ((xgettext (if (symbol? (ref perg 'package-version))
		       (ref perg 'package-version)
		       (apply package-version->xgettxt (ref perg 'package-version))))
	 (mp       (estimate-mp perg xgettext))
	 (run-perg$ (cute run-perg xgettext limit)))
    (cond
     ((and (string? xgettext)
	   (file-is-readable? xgettext))
      (let1 procs (map (lambda (_) (run-perg$)) (iota mp))
	(values procs
		(map process-input procs)
		(map process-output procs))))
     (else
      (values (list) (list) (list))))))

(define-method push-log! ((perg <perg>) log)
  ;;
  (push! (ref perg 'logs) log)
  (unless (string? (cadr (memq :msg log)))
    log)
  (tree-map-push! (ref perg 'unsolved) (cadr (memq :msg log)) log)
  )

(define-method pop-log! ((perg <perg>))
  (let1 r (tree-map-pop-min! (ref perg 'unsolved))
    (if r 
	(begin
	  (hash-table-put! (ref perg 'in-process) (car r) (cdr r))
	  (car (cdr r)))
	#f)))

(define-method empty! ((perg <perg>))
  (tree-map-clear! (ref perg 'unsolved)))

(define-method empty? ((perg <perg>))
  (not (tree-map-min (ref perg 'unsolved))))


(define-method resolved ((perg <perg>) resolved-data)
  (let1 logs (hash-table-get (ref perg 'in-process) (cadr resolved-data) #f)
    (map
     (lambda (log)
       (let1 resolved-data (list-copy resolved-data)
	 (set-car! (cdr (memq :date resolved-data))
		   (cadr (memq :date log)))
	 (set-car! (cdr (memq :host resolved-data))
		   (cadr (memq :host log)))
	 (set-car! (cdr (memq :cmd resolved-data))
		   (cadr (memq :cmd log)))
	 (set-car! (cdr (memq :pid resolved-data))
		   (cadr (memq :pid log)))
	 (set-car! (cdr (memq :line-number resolved-data))
		   (cadr (memq :line-number log)))
	 resolved-data
	 ))
     logs)))

(define-method resolved? ((perg <perg>) msg)
  (hash-table-get (ref perg 'resolved) msg #f)
  )

(define-method add-log! (pergs log linum dist)
  (let1 cmd-k (memq :cmd log)
    (let* ((cmd (if cmd-k 
		   (or (cadr cmd-k) 'not-given)
		   'raw))
	   )
      (let1 perg (or (hash-table-get pergs cmd #f)
		     (let1 perg (make <perg> :package-version
				      (if (string? cmd)
					  (receive (pkg ver) (cmd->package cmd dist)
			 		    (list pkg ver)
					    )
					  cmd))
		       (hash-table-put! pergs cmd perg)
		       perg))
	(push-log! perg (attach-line-number log linum))))))

(define (attach-line-number log n)
  (reverse (cons n (cons :line-number (reverse log)))))

(define (prepare-pergs dist)
  (let loop ((raw-log (read-line))
	     (n 0)
	     (pergs (make-hash-table 'equal?)))
      (if (eof-object? raw-log)
	  pergs
	  (let1 log ((with-module es.src.syslog syslog) raw-log)
	    (add-log! pergs log n dist)
	    (loop (read-line) (+ n 1) pergs)))))

(define (writeln r oport)
  (write r oport)
  (newline oport))

;; (take-group '((:msg "a") (:msg "a") (:msg "a") (:msg "b") (:msg "b") (:msg "c") (:msg "c") (:msg "d") (:msg "d") ) 3)
(define (take-group filelines limit)
  (if (null? filelines)
      filelines
      (let1 get-msg (lambda (xgettext) (cadr (memq :msg xgettext)))
	(let loop ((key          (get-msg (car filelines)))
		   (candidate    (car filelines))
		   (rest         (cdr filelines))
		   (result       (list))
		   (n            0))
	  (cond
	   ((eq? n limit)
	    (reverse result))
	   ((equal? (get-msg candidate) key)
	    (if (null? rest)
		(reverse (cons candidate result))
		(loop key (car rest) (cdr rest) (cons candidate result) n)))
	   (else
	    (loop (get-msg candidate) candidate rest result (+ n 1))))))))

(define-method run (pergs limit-group limit-list)
  (let ((selector (make <selector>))
	(n-procs 0)
	(result   (list)))
    (for-each
     (lambda (perg)
       (receive (procs write-targets read-targets) (run perg limit-list)
	 (if (null? procs)
	     (set! result (append (ref perg 'logs) result))
	     (for-each 
	      (lambda (proc write-target read-target)
		(set! n-procs (+ n-procs 1))
		(selector-add! selector write-target
			       (lambda (output flag)
				 (let1 log (pop-log! perg)
				   (when log
				     (guard (e
					     (else (begin (selector-delete! selector output #f #f)
							  (empty! perg))))
				       (writeln `(log ,(cadr (memq :msg log)) 
						      :date ,(cadr (memq :date log))
						      :host ,(cadr (memq :host log))
						      :cmd  ,(cadr (memq :cmd log))
						      :pid  ,(cadr (memq :pid log))
						      :line-number ,(cadr (memq :line-number log))
						      :package-version ,(ref perg 'package-version)) 
						output))))
				 (when (empty? perg)
				   (ref perg 'package-version)
				   (selector-delete! selector output #f #f)
				   (close-output-port output)))
			       '(w))
		(selector-add! selector read-target
			       (lambda (input flag)
				 (let1 log (read input)
				   (if (eof-object? log)
				       (begin (selector-delete! selector input #f #f)
					      (close-input-port input)
					      (process-wait proc)
					      (set! n-procs (- n-procs 1)))
				       (let1 filelines (cadr (memq :filelines log))
					 (set-car! (cdr (memq :filelines log)) 
						   (take-group filelines limit-group))
					 (set! result (append (resolved perg log) result))))))
			       '(r)))
	     procs write-targets read-targets))))
     (hash-table-values pergs))
    (let loop ()
      (when (< 0 n-procs)
	(let1 result (selector-select selector)
	  (unless (eq? result 0)
	    (loop)))))
    (sort result
	  (lambda (a b)
	    (< (cadr (memq :line-number a))
	       (cadr (memq :line-number b)))))))

(define (log->syslog log)
  (cons 'syslog (cons :msg (cdr log))))

(define (make-href package version file line)
  ;http://srpmix.org/api/browse.cgi?path=dists/centos5u2/packages/k/kernel/pre-build/kernel-2.6.18/linux-2.6.18.x86_64/arch/x86_64/kernel/audit.c&display=font-lock#linum:25
  (format "http://srpmix.org/api/browse.cgi?path=dists/centos5u2/packages/~a/~a/~a&display=font-lock#linum:~d"
	  (substring package 0 1)
	  package
	  file
	  line))
  #;(format "file:///srv/sources/sources/~a/~a/~a/~a"
	  (substring package 0 1)
	  package
	  version
	  file
	  )


(define (report-log-group groups package version log-line-len)
  (map
   (lambda (group)
     (let* ((head (car group))
	    (msg (cadr (memq :msg head)))
	    (score (cadr (memq :match-chars head))))
       (html:tr
	(html:th :valign "top" 
		 (html:pre (format "~,,,,5s/~d ~s" 
				   score
				   log-line-len
				   (html-escape-string msg)))
		 (html:td
		  (map 
		   (lambda (xgettext)
		     (html:ul
		      (html:li (html:pre (html:a :href (make-href 
							package
							version
							(cadr (memq :file xgettext))
							(cadr (memq :line xgettext)))
						 (format "~a:~d" 
							 (cadr (memq :file xgettext))
							 (cadr (memq :line xgettext))
							 ))))))
		   group))))))
   groups))

(define (report-log r)
  (let* ((filelines (cadr (memq :filelines r)))
	 (n-filelines (length filelines))
	 (log-line ((with-module es.dest.syslog syslog) (log->syslog r)))
	 (log-line-len (string-length (cadr r)))
	 (package-version (cadr (memq :package-version r)))
	 (package (car package-version))
	 (version (cadr package-version)))

    (list
     (html:pre :class "log"
	       (html:a :href "" (format "[~d]" n-filelines))
	       (string-append " "
			      (html-escape-string
			       log-line)))
     (html:table :border #f :class "xgettext"
		 (html:caption :align "top" (html:pre (format "~a/~a"
							      package
							      version)))
		 (report-log-group 
		  (let1 get-msg (lambda (xgettext) 
				  (cadr (memq :msg xgettext)))
		    (let loop ((filelines filelines)
			       (result (list))
			       (current-group (list))
			       (msg #f))
		      (if (null? filelines)
			  (reverse (cons (reverse current-group) result))
			  (if msg
			      (let ((xgettext (car filelines))
				    (filelines (cdr filelines)))
				(if (equal? msg (get-msg xgettext))
				    (loop filelines result (cons xgettext current-group) msg)
				    (loop filelines (cons (reverse current-group) result) 
					  (list xgettext)
					  (get-msg xgettext))))
			      (loop filelines result current-group (get-msg (car filelines)))))))
		  package
		  version
		  log-line-len)
		 )
     (html:hr))))

(define (report-syslog r)
  (list (html:pre 
	 (string-append "[ ] "
			(html-escape-string 
			 ((with-module es.dest.syslog syslog) r))))
	(html:hr)))

(define (report results fmt)
  (case fmt
    ('es
     (for-each
      writeln
      results))
    ('html
     (display
      (tree->string
       (html:html
	(html:head
	 (html:script :language"JavaScript"
		      ))
	(html:body
	  (map
	   (lambda (r)
	     (case (car r)
	       ('log (report-log r))
	       ('syslog (report-syslog r))))
	   results)))
       )))))

(define XFORK 1)
(define (main args)
  (let-args (cdr args)
      ((help "h|help" => (cute show-help (car args) 0))
       (xfork "xfork=i" 1)
       (limit-list "limit-list=i" 100)
       (limit-group "limit-group=i" 10)
       (report-format "format=y" 'html)
       . rest)
    (set! XFORK xfork)
    (if (eq? (length rest) 1)
	(report (run (prepare-pergs (car rest)) limit-group limit-list)
		report-format
		)
	(with-output-to-port (current-error-port)
	  (lambda ()
	    (show-help (car args) 1))))))

;; (define-class <reporter> ()
;;   ((expected :init-value 0)
;;    (queue    :init-form  (make-tree-map eq? 
;; 					<))))
;; (define-class <html-report> (<reporter>)
;;   ((result :init-form (list))))

;; (define-method print-header ((reporter <reporter>))
;;   )
;; (define-method print-footer ((reporter <reporter>))
;;   )
;; (define-method print-element ((reporter <reporter>) log)
;;   )
;; (define-method resolved ((reporter <reporter>) log)
;;   (let ((log-i (cadr (memq :line-number log)))
;; 	(expected (ref reporter 'expected)))
;;     (if (eq? log-i expected)
;; 	(begin (print-element log)
;; 	       (set! (ref reporter 'expected)
;; 		   (+ 1 expected))
;; 	       (try-next reporter))
;; 	(tree-map-put! (ref reporter 'queue)
;; 		       log-i
;; 		       log))))
;; (define-method try-next ((reporter <reporter>))
;;   (let ((kv (tree-map-min (ref reporter 'queue)))
;; 	(expected (ref reporter 'expected)))
;;     (when (and kv (eq? (car kv) expected))
;;       (tree-map-pop-min! (ref reporter 'queue))
;;       (set! (ref reporter 'expected) (+ expected 1))
;;       (print-element reporter (cdr v))
;;       (try-next reporter))))
