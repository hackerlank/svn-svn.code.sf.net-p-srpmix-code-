;; -*- scheme -*-
(use file.util)
(use gauche.parseopt)
(use gauche.process)
(use gauche.selector)
(use es.src.syslog)
(use es.dest.syslog)
(use text.html-lite)
(use text.tree)
(use srfi-1)

(define basename->packages (make-hash-table 'equal?))
(load "./hash.scm" :error-if-not-found #f)


(debug-print-width #f)

(define (show-help prog n)
  (format #t "~a [--limit=N] [--format=es|html] DIST < /var/log/message\n" prog)
  (exit n))


(define (cmd->package cmd dist)
  (cond
   ((equal? cmd "kernel")
    (values "kernel" "2.6.18-164.el5"))
   ((equal? cmd "rsyslogd")
    (values "rsyslog" "2.0.6-1.el5"))
   ((equal? cmd "dhclient")
    (values "dhcp" "3.0.5-21.el5"))
   ((equal? cmd "pulseaudio")
    (values "pulseaudio" "0.9.21-5.fc13"))
   (else
    (let1 pv (hash-table-get basename->packages cmd #f)
      (if pv
	  (apply values (car pv))
	  (begin 
	    (format (current-error-port) ";; package for ~s is unknown\n" cmd)
	    (values #f #f))
	  )))))

(define (package-version->xgettxt pkg ver)
  (if pkg
      (format "/srv/sources/sources/~a/~a/~a/plugins/xgettext/xgettext.out"
	      (substring pkg 0 1)
	      pkg
	      ver)
      #f))

(define-class <perg> ()
  ((package-version :init-keyword :package-version)
   (logs     :init-form    (list))
   (unsolved :init-form    (make-tree-map equal? 
					  (lambda (a b)
					    (>= (string-length a) 
						(string-length b)))))
   (in-process :init-form (make-hash-table 'equal?))
   (resolved :init-form    (make-hash-table 'equal?))
   ))

(define perg-cmd "./perg")
(define-method run ((perg <perg>) (limit <integer>))
  (let ((xgettext (if (symbol? (ref perg 'package-version))
		      (ref perg 'package-version)
		      (apply package-version->xgettxt (ref perg 'package-version))))
	(limit-flag (format "--limit=~d" limit)))
    (cond
     ((and (string? xgettext)
	   (file-is-readable? xgettext))
      (let1 proc (run-process `(,perg-cmd "--format=es" ,limit-flag = ,xgettext) 
			      :input :pipe
			      :output :pipe)
	(values proc
		(process-input proc)
		(process-output proc)
		)))
     (else
      (values #f #f #f)))))

(define-method push-log! ((perg <perg>) log)
  ;;
  (push! (ref perg 'logs) log)
  (unless (string? (cadr (memq :msg log)))
    log)
  (tree-map-push! (ref perg 'unsolved) (cadr (memq :msg log)) log)
  )

(define-method pop-log! ((perg <perg>))
  (let1 r (tree-map-pop-min! (ref perg 'unsolved))
	(hash-table-put! (ref perg 'in-process) (car r) (cdr r))
	(car (cdr r))))

(define-method empty! ((perg <perg>))
  (tree-map-clear! (ref perg 'unsolved)))

(define-method empty? ((perg <perg>))
  (not (tree-map-min (ref perg 'unsolved))))


(define-method resolved ((perg <perg>) resolved-data)
  (let1 logs (hash-table-get (ref perg 'in-process) (cadr resolved-data) #f)
    (map
     (lambda (log)
       (let1 resolved-data (list-copy resolved-data)
	 (set-car! (cdr (memq :date resolved-data))
		   (cadr (memq :date log)))
	 (set-car! (cdr (memq :host resolved-data))
		   (cadr (memq :host log)))
	 (set-car! (cdr (memq :cmd resolved-data))
		   (cadr (memq :cmd log)))
	 (set-car! (cdr (memq :pid resolved-data))
		   (cadr (memq :pid log)))
	 (set-car! (cdr (memq :line-number resolved-data))
		   (cadr (memq :line-number log)))
	 resolved-data
	 ))
     logs)))

(define-method resolved? ((perg <perg>) msg)
  (hash-table-get (ref perg 'resolved) msg #f)
  )


(define-method add-log! (pergs log dist)
  (let1 cmd-k (memq :cmd log)
    (let1 cmd (if cmd-k 
		 (or (cadr cmd-k) 'not-given)
		 'raw)
      (let1 perg (or (hash-table-get pergs cmd #f)
		     (let1 perg (make <perg> :package-version
				      (if (string? cmd)
					  (receive (pkg ver) (cmd->package cmd dist)
			 		    (list pkg ver)
					    )
					  cmd))
		       (hash-table-put! pergs cmd perg)
		       perg))
	(push-log! perg log)))))

(define (attach-line-number log n)
  (reverse (cons n (cons :line-number (reverse log)))))


(define (prepare-pergs dist)
  (let loop ((raw-log (read-line))
	     (n 0)
	     (pergs (make-hash-table 'equal?)))
      (if (eof-object? raw-log)
	  pergs
	  (let1 log ((with-module es.src.syslog syslog) raw-log)
	    (add-log! pergs (attach-line-number log n) dist)
	    (loop (read-line) (+ n 1) pergs)))))

(define (writeln r oport)
  (write r oport)
  (newline oport))

(define-method run (pergs limit)
  (let ((selector (make <selector>))
	(n-procs 0)
	(result   (list)))
    (for-each
     (lambda (perg)
       (receive (proc write-target read-target) (run perg limit)
	 (if proc
	     (begin
	       (set! n-procs (+ n-procs 1))
	       (selector-add! selector write-target
			      (lambda (output flag)
				(let1 log (pop-log! perg)
				  (guard (e
					  (else (begin (selector-delete! selector output #f #f)
						       (empty! perg))))
				    (writeln `(log ,(cadr (memq :msg log)) 
						   :date ,(cadr (memq :date log))
						   :host ,(cadr (memq :host log))
						   :cmd  ,(cadr (memq :cmd log))
						   :pid  ,(cadr (memq :pid log))
						   :line-number ,(cadr (memq :line-number log))
						   :package-version ,(ref perg 'package-version)) 
					     output)))
				(when (empty? perg)
				  (ref perg 'package-version)
				  (selector-delete! selector output #f #f)
				  (close-output-port output)))
			      '(w))
	       (selector-add! selector read-target
			      (lambda (input flag)
				(let1 log (read input)
				  (if (eof-object? log)
				      (begin (selector-delete! selector input #f #f)
					     (close-input-port input)
					     (process-wait proc)
					     (set! n-procs (- n-procs 1)))
				      (let1 filelines (cadr (memq :filelines log))
					(when (< limit (length filelines))
					  (set-car! (cdr (memq :filelines log)) (take filelines limit)))
					(set! result (append (resolved perg log) result))))))
			      '(r)))
	     (set! result (append (ref perg 'logs) result)))))
     (hash-table-values pergs))
    (let loop ()
      (when (< 0 n-procs)
	(let1 result (selector-select selector)
	  (unless (eq? result 0)
	    (loop)))))
    (sort result
	  (lambda (a b)
	    (< (cadr (memq :line-number a))
	       (cadr (memq :line-number b)))))))

(define (log->syslog log)
  (cons 'syslog (cons :msg (cdr log))))

(define (make-href package version file line)
  ;http://srpmix.org/api/browse.cgi?path=dists/centos5u2/packages/k/kernel/pre-build/kernel-2.6.18/linux-2.6.18.x86_64/arch/x86_64/kernel/audit.c&display=font-lock#linum:25
  (format "http://srpmix.org/api/browse.cgi?path=dists/centos5u2/packages/~a/~a/~a&display=font-lock#linum:~d"
	  (substring package 0 1)
	  package
	  file
	  line))
  #;(format "file:///srv/sources/sources/~a/~a/~a/~a"
	  (substring package 0 1)
	  package
	  version
	  file
	  )


(define (report-log r limit)
  (let* ((filelines (cadr (memq :filelines r)))
	 (n-filelines (length filelines))
	 (log-line ((with-module es.dest.syslog syslog) (log->syslog r)))
	 (log-line-len (string-length (cadr r)))
	 (package-version (cadr (memq :package-version r))))

    (list
     (html:pre :class "log"
	       (html:a :href "" (format "[~d]" n-filelines))
	       (string-append " "
			      (html-escape-string
			       log-line)))
     (html:table :class "package-version"
		 (html:tr
		  (html:td (html:pre (car package-version)))
		  (html:td (html:pre (cadr package-version)))))
     (html:table :border #f :class "xgettext"
		 (map 
		  (lambda (xgettext)
		    (html:tr
		     (html:th (html:pre (format "~,,,,5s/~d" 
						(cadr (memq :match-chars xgettext))
						log-line-len)))
		     (html:td (html:pre (html:a :href (make-href 
						       (car package-version)
						       (cadr package-version)
						       (cadr (memq :file xgettext))
						       (cadr (memq :line xgettext)))
						(cadr (memq :msg xgettext)))))
					;(html:td (html:pre (car package-version)))
					;(html:td (html:pre (cadr package-version)))
		     (html:td (html:pre (format "~a:~d" 
						(cadr (memq :file xgettext))
						(cadr (memq :line xgettext))
						)))
		     ))
		  (if (< limit n-filelines)
		      (take filelines limit)
		      filelines))
		 )
     (html:hr)
     )
    ))

(define (report-syslog r limit)
  (list (html:pre 
	 (string-append "[ ] "
			(html-escape-string 
			 ((with-module es.dest.syslog syslog) r))))
	(html:hr)))

(define (report results fmt limit)
  (case fmt
    ('es
     (for-each
      writeln
      results))
    ('html
     (display
      (tree->string
       (html:html
	(html:head
	 (html:script :language"JavaScript"
		      ))
	(html:body
	  (map
	   (lambda (r)
	     (case (car r)
	       ('log (report-log r limit))
	       ('syslog (report-syslog r limit))))
	   results)))
       )))))

(define (main args)
  (let-args (cdr args)
      ((help "h|help" => (cut show-help name 0))
       (limit "limit=i" 15)
       (report-format "format=y" 'html)
       . rest)
    (if (eq? (length rest) 1)
	(report (run (prepare-pergs (car rest)) limit)
		report-format
		limit)
	(with-output-to-port (current-error-port)
	  (lambda ()
	    (show-help (car args) 1))))))

;; (define-class <reporter> ()
;;   ((expected :init-value 0)
;;    (queue    :init-form  (make-tree-map eq? 
;; 					<))))
;; (define-class <html-report> (<reporter>)
;;   ((result :init-form (list))))

;; (define-method print-header ((reporter <reporter>))
;;   )
;; (define-method print-footer ((reporter <reporter>))
;;   )
;; (define-method print-element ((reporter <reporter>) log)
;;   )
;; (define-method resolved ((reporter <reporter>) log)
;;   (let ((log-i (cadr (memq :line-number log)))
;; 	(expected (ref reporter 'expected)))
;;     (if (eq? log-i expected)
;; 	(begin (print-element log)
;; 	       (set! (ref reporter 'expected)
;; 		   (+ 1 expected))
;; 	       (try-next reporter))
;; 	(tree-map-put! (ref reporter 'queue)
;; 		       log-i
;; 		       log))))
;; (define-method try-next ((reporter <reporter>))
;;   (let ((kv (tree-map-min (ref reporter 'queue)))
;; 	(expected (ref reporter 'expected)))
;;     (when (and kv (eq? (car kv) expected))
;;       (tree-map-pop-min! (ref reporter 'queue))
;;       (set! (ref reporter 'expected) (+ expected 1))
;;       (print-element reporter (cdr v))
;;       (try-next reporter))))
