;; -*- scheme -*-
(use trapeagle.pp-common)
(use trapeagle.graft)
(use trapeagle.stripper)
(use trapeagle.serialize)

(use gauche.parseopt)
(use gauche.vport)
(use file.util)
(use file.filter)


(define-class <graft-input-port> (<virtual-input-port>)
  ((ports :init-keyword :ports :init-form (list))
   (current-input-port :allocation :virtual
		       :slot-ref (lambda (self)
				   (let1 head (ref self 'ports)
				     (if (null? head)
					 #f
					 (car head)))))))

(define (shift-iports! self)
  (if (null? (ref self 'ports))
      #f
      (update! (ref self 'ports) 
	       (lambda (ports) (cdr ports)))))

(define (getb self)
  (let1 iport (ref self 'current-input-port)
    (if iport 
	(let1 b (read-byte iport)
	  (if (eof-object? b)
	      (begin (shift-iports! self)
		     (getb self))
	      b))
	(eof-object))))

(define (ready self char-ready??)
  (let1 checker (if char-ready?? char-ready? byte-ready?)
    (let1 iport (ref self 'current-input-port)
      (if iport 
	  (let1 b (checker iport)
	    (if b
		b
		(begin (shift-iports! self)
		       (ready self char-ready??))))
	  #f))))

(define-method initialize ((self <graft-input-port>) initargs)
  (next-method)
  (set! (ref self 'getb) 
	(pa$ getb self))
  (set! (ref self 'ready) 
	(pa$ ready self)))

;(define read$ (pa$ read (make <grafter> :input-port (make <serializer>))))
(define read$ 
  (pa$ 
   read
   (make <grafter>
     :input-port (make <stripper> 
		   :rules '(
			    (* * :args)
			    (* read :xargs 1)
			    (* read :args)
			    (* write :xargs 1)
			    (* write :args)
			    )
		   :input-port (make <serializer> :debug #t)))))

(define (show-help prog n)
  (format #t "~a --help\n" prog)
  (format #t "~a [--debug]\n" prog)
  (exit n))

(define (serialize+stripe iport oport)
  (let1 iport (make <stripper> 
		:rules '(
			 (* * :args)
			 (* read :xargs 1)
			 (* read :args)
			 (* write :xargs 1)
			 (* write :args)
			 )
		:input-port (make <serializer> 
			      :input-port iport
			      :debug #t))
    (let loop ((r (read iport)))
      (unless (eof-object? r)
	(write r oport)
	(newline oport)
	(loop (read iport))))))

(define (writeln o oport)
  (write o oport)
  (newline oport))
 
;; (trapeagle-pp graft-map n0 n1)
(define (make-graft-map iport oport)
  (let1 proc-table (make-hash-table 'eq?)
    (let loop ((r (read iport)))
      (unless (eof-object? r)
	(when (eq? (car r) 'strace)
	  (case (cadr r)
	    ('unfinished
	     (let ((pid (cadr (memq :pid r))))
	       (if (ref proc-table pid #f)
		   (errorf "duplicated unsolved unfinished pair for ~d\nold: ~s\nnew: ~s\n"
			   pid (ref proc-table pid) r)
		   (hash-table-put! proc-table pid r))))
	    ('resumed
	     (let* ((pid (cadr (memq :pid r)))
		    (unfinished  (ref proc-table pid #f)))
	       (if unfinished
		   (writeln `(trapeagle-pp graft-map
					   ,(cadr (memq :index unfinished))
					   ,(cadr (memq :index r))
					   :pid ,pid)
			    oport)
		   (errorf "Unblanced unfinished/resumed pair for ~d\nresumed: ~s\n" pid r)
		   )))))
	(loop (read iport))))
    (hash-table-map proc-table (lambda (pid unfinished)
				 (writeln `(trapeagle-pp graft-map
							 ,(cadr (memq :index unfinished))
							 #f
							 :pid ,pid)
					  oport)))))

(define (apply-map iport oport)
  (let1 unfinished/resumed (make-hash-table 'eq?)
    (let loop ((r (read iport)))
      (unless (eof-object? r)
	(case (car r)
	  ('trapeagle-pp
	   (when (eq? (cadr r) 'graft-map)
	     (set! (ref unfinished/resumed (caddr r)) (cadddr r))
	     (when (cadddr r)
	       (set! (ref unfinished/resumed (cadddr r)) (caddr r)))))
	  ('strace
	   (case (cadr r)
	     ('unfinished
	      (let1 index (cadr (memq :index r))
		(write (append r (list :resumed? (ref unfinished/resumed index))) oport)
		(newline oport)))
	     ('resumed
	      (let1 index (cadr (memq :index r))
		(write (append r (list :unfinished? (ref unfinished/resumed index))) oport)
		(newline oport)))
	     (else
	      (write r oport)
	      (newline oport)))))
	(loop (read iport))))))

(define (main args)
  (let-args (cdr args)
      ((help "h|help" => (cute show-help (car args) 0))
       (debug "debug"))
    (let* ((i (current-input-port))
	   (o (open-output-file "/tmp/serialize+strip.es")))
      (serialize+stripe i o)
      (close-output-port o))
    (let* ((i (open-input-file "/tmp/serialize+strip.es"))
	   (o (open-output-file "/tmp/graft-map.es")))
      (make-graft-map i o)
      (close-output-port o)
      (close-input-port i))
    (let* ((i (make <graft-input-port>
		:ports (list
			(open-input-file "/tmp/graft-map.es")
			(open-input-file "/tmp/serialize+strip.es"))))
	   (o (current-output-port)))
      (apply-map i o)))
  0)
