#!/bin/sh
#| -*- scheme -*- |#
:; exec gosh -- $0 "$@"

;; Copyright (C) 2010 Masatake YAMATO

;; This library is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This library is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this library.  If not, see <http://www.gnu.org/licenses/>.
;;
;; Author: Masatake YAMATO <yamato@redhat.com>
;;
(use file.util)
(use gauche.sequence)
(use gauche.parseopt)
(use gauche.process)
(use gauche.selector)
(use es.src.syslog)
(use es.dest.syslog)
(use text.html-lite)
(use text.tree)
(use srfi-1)

(debug-print-width #f)

(define (show-help prog n)
  (format #t "~a [--resolver=RESOLVER] [--limit-group=N] [--limit-list=N] [--url-format=http://...] [--format=es|html] DIST < /var/log/message\n" prog)
  (exit n))

(define (cmd->srpm cmd dist resolver)
  (let1 resolver resolver
    (let1 o (process-output->string-list 
	     `(,resolver
	       ,(format "/srv/sources/dists/~a/plugins/rpms2sqldb/rhel-i386-5.sqlite" dist)
	       ,cmd))
      ;; FIXME
      (when (member cmd o)
	(set! o (cons cmd (delete cmd o))))

      (if (null? o)
	  (values #f #f)
	  (apply values 
		 
		 (let loop ((candidates o))
		   (if (null? candidates)
		       (list #f #f)
		       (let1 p (car candidates)
			 (let1 v (guard (e
					 (else #f))
					(sys-readlink (format "/srv/sources/dists/~a/packages/~a/~a"
							      dist
							      (substring p 0 1)
							      p)))
			   (if v
			       (list p (sys-basename v))
			       (loop (cdr candidates)))))))
		 )))))

(define (package-version->xgettxt pkg ver)
  (if pkg
      (format "/srv/sources/sources/~a/~a/~a/plugins/xgettext/xgettext.out"
	      (substring pkg 0 1)
	      pkg
	      ver)
      #f))

(define-class <perg> ()
  ((package-version :init-keyword :package-version)
   (logs     :init-form    (list))
   (unsolved :init-form    (make-tree-map equal? 
					  (lambda (a b)
					    (>= (string-length a) 
						(string-length b)))))
   (in-process :init-form (make-hash-table 'equal?))
   (resolved :init-form    (make-hash-table 'equal?))
   ))

(define perg-cmd "perg")
(define (run-perg xgettext limit)
  (let ((limit-flag (format "--limit=~d" limit)))
    (run-process `(,perg-cmd "--format=es" ,limit-flag = ,xgettext) 
			      :input :pipe
			      :output :pipe)
    ))

(define-method estimate-mp ((perg <perg>) xgettext)
  (let1 pv (ref perg 'package-version)
    (cond
     ((list? pv)
      (if (equal? "kernel" (car pv))
	  XFORK
	  1))
     (else
      1))))

(define-method run ((perg <perg>) (limit <integer>))
  (let* ((xgettext (if (symbol? (ref perg 'package-version))
		       (ref perg 'package-version)
		       (apply package-version->xgettxt (ref perg 'package-version))))
	 (mp       (estimate-mp perg xgettext))
	 (run-perg$ (cute run-perg xgettext limit)))
    (cond
     ((and (string? xgettext)
	   (file-is-readable? xgettext))
      (let1 procs (map (lambda (_) (run-perg$)) (iota mp))
	(values procs
		(map process-input procs)
		(map process-output procs))))
     (else
      (values (list) (list) (list))))))

(define-method push-log! ((perg <perg>) log)
  ;;
  (push! (ref perg 'logs) log)
  (unless (string? (cadr (memq :msg log)))
    log)
  (tree-map-push! (ref perg 'unsolved) (cadr (memq :msg log)) log)
  )

(define-method pop-log! ((perg <perg>))
  (let1 r (tree-map-pop-min! (ref perg 'unsolved))
    (if r 
	(begin
	  (hash-table-put! (ref perg 'in-process) (car r) (cdr r))
	  (car (cdr r)))
	#f)))

(define-method empty! ((perg <perg>))
  (tree-map-clear! (ref perg 'unsolved)))

(define-method empty? ((perg <perg>))
  (not (tree-map-min (ref perg 'unsolved))))


(define-method resolved ((perg <perg>) resolved-data)
  (let1 logs (hash-table-get (ref perg 'in-process) (cadr resolved-data) #f)
    (map
     (lambda (log)
       (let1 resolved-data (list-copy resolved-data)
	 (set-car! (cdr (memq :date resolved-data))
		   (cadr (memq :date log)))
	 (set-car! (cdr (memq :host resolved-data))
		   (cadr (memq :host log)))
	 (set-car! (cdr (memq :cmd resolved-data))
		   (cadr (memq :cmd log)))
	 (set-car! (cdr (memq :pid resolved-data))
		   (cadr (memq :pid log)))
	 (set-car! (cdr (memq :line-number resolved-data))
		   (cadr (memq :line-number log)))
	 resolved-data
	 ))
     logs)))

(define-method resolved? ((perg <perg>) msg)
  (hash-table-get (ref perg 'resolved) msg #f)
  )

(define-method add-log! (pergs log linum dist resolver)
  (let1 cmd-k (memq :cmd log)
    (let* ((cmd (if cmd-k 
		   (or (cadr cmd-k) 'not-given)
		   'raw))
	   )
      (let1 perg (or (hash-table-get pergs cmd #f)
		     (let1 perg (make <perg> :package-version
				      (if (string? cmd)
					  (receive (pkg ver) (cmd->srpm cmd dist resolver)
			 		    (list pkg ver)
					    )
					  cmd))
		       (hash-table-put! pergs cmd perg)
		       perg))
	(push-log! perg (attach-line-number log linum))))))

(define (attach-line-number log n)
  (reverse (cons n (cons :line-number (reverse log)))))

;;
(define (prepare-pergs dist resolver)
  (let loop ((raw-log (read-line))
	     (n 0)
	     (pergs (make-hash-table 'equal?)))
      (if (eof-object? raw-log)
	  pergs
	  (let1 log (es<-syslog raw-log)
	    ;; FIXME: Just drop raw log.
	    (unless (memq :raw log)
	      (add-log! pergs log n dist resolver))
	    (loop (read-line) (+ n 1) pergs)))))

(define (writeln r oport)
  (write r oport)
  (newline oport))

;; (take-group '((:msg "a") (:msg "a") (:msg "a") (:msg "b") (:msg "b") (:msg "c") (:msg "c") (:msg "d") (:msg "d") ) 3)
;; => ((:msg "a") (:msg "a") (:msg "a") (:msg "b") (:msg "b") (:msg "c") (:msg "c"))
(define (take-group filelines limit)
  (if (null? filelines)
      filelines
      (let1 get-msg (lambda (xgettext) (cadr (memq :msg xgettext)))
	(let loop ((key          (get-msg (car filelines)))
		   (candidate    (car filelines))
		   (rest         (cdr filelines))
		   (result       (list))
		   (n            0))
	  (cond
	   ((eq? n limit)
	    (reverse result))
	   ((equal? (get-msg candidate) key)
	    (if (null? rest)
		(reverse (cons candidate result))
		(loop key (car rest) (cdr rest) (cons candidate result) n)))
	   (else
	    (loop (get-msg candidate) candidate rest result (+ n 1))))))))

(define-method run (pergs limit-group limit-list)
  (let ((selector (make <selector>))
	(n-procs 0)
	(result   (list)))
    (for-each
     (lambda (perg)
       (receive (procs write-targets read-targets) (run perg limit-list)
	 (if (null? procs)
	     (set! result (append (ref perg 'logs) result))
	     (for-each 
	      (lambda (proc write-target read-target)
		(set! n-procs (+ n-procs 1))
		(selector-add! selector write-target
			       (lambda (output flag)
				 (let1 log (pop-log! perg)
				   (when log
				     (guard (e
					     (else (begin (selector-delete! selector output #f #f)
							  (empty! perg))))
				       (writeln `(log ,(cadr (memq :msg log)) 
						      :date ,(cadr (memq :date log))
						      :host ,(cadr (memq :host log))
						      :cmd  ,(cadr (memq :cmd log))
						      :pid  ,(cadr (memq :pid log))
						      :line-number ,(cadr (memq :line-number log))
						      :package-version ,(ref perg 'package-version)) 
						output))))
				 (when (empty? perg)
				   (selector-delete! selector output #f #f)
				   (close-output-port output)))
			       '(w))
		(selector-add! selector read-target
			       (lambda (input flag)
				 (let1 log (read input)
				   (if (eof-object? log)
				       (begin (selector-delete! selector input #f #f)
					      (close-input-port input)
					      (process-wait proc)
					      (set! n-procs (- n-procs 1)))
				       (let1 filelines (cadr (memq :filelines log))
					 (set-car! (cdr (memq :filelines log)) 
						   (take-group filelines limit-group))
					 (set! result (append (resolved perg log) result))))))
			       '(r)))
	     procs write-targets read-targets))))
     (hash-table-values pergs))
    (let loop ()
      (when (< 0 n-procs)
	(let1 result (selector-select selector)
	  (unless (eq? result 0)
	    (loop)))))
    (sort result
	  (lambda (a b)
	    (< (cadr (memq :line-number a))
	       (cadr (memq :line-number b)))))))

(define url-format #f)
(define (make-href package version file line)
  #;(format "http://srpmix.org/api/browse.cgi?path=dists/centos5u2/packages/~a/~a/~a&display=font-lock#linum:~d"
	  (substring package 0 1)
	  package
	  file
	  line)
  (format url-format
	  (substring package 0 1)
	  package
	  version
	  file
	  line)
  )

(define (report-log-group groups package version log-line-len log-line-number)
  (map-with-index
   (lambda (index group)
     (let* ((head (car group))
	    (msg (cadr (memq :msg head)))
	    (score (cadr (memq :match-chars head))))
       (html:tr
	(html:th :valign "top" :align "left" 
		 (html:pre 
		  :id (format "msg-~d-~d" log-line-number index)
		  :onclick (format "toggle('~a');" (format "filelines-~d-~d" 
							   log-line-number
							   index))
		  :onmouseover (format "highlight('~a');" (format "msg-~d-~d" log-line-number index))
		  :onmouseout (format "unhighlight('~a');" (format "msg-~d-~d" log-line-number index))
		  (format "~,,,,5s/~d ~s" 
			  score
			  log-line-len
			  (html-escape-string msg))
		  )
		 (html:td :class "filelines"
			  :id (format "filelines-~d-~d" 
				      log-line-number
				      index)
			  :style "display: none;"
			  (map 
			   (lambda (xgettext)
			     (html:ul
			      (html:li (html:pre (html:a :href (make-href 
								package
								version
								(cadr (memq :file xgettext))
								(cadr (memq :line xgettext)))
							 (format "~a:~d" 
								 (cadr (memq :file xgettext))
								 (cadr (memq :line xgettext))
								 ))))))
			   group))))))
   groups))

(define (report-log r)
  (let* ((filelines (cadr (memq :filelines r)))
	 (n-filelines (length filelines))
	 (log-line-number (cadr (memq :line-number r)))
	 (log-line (syslog<-es (cons 'syslog (cons :msg (cdr r)))))

	 ;; http://forum.codecall.net/javascript/1931-javascript-analog-clock.html
	 (date (cadr (memq :date r)))

	 (log-line-len (string-length (cadr r)))
	 (package-version (cadr (memq :package-version r)))
	 (package (car package-version))
	 (version (cadr package-version)))
    (list
     (html:pre :class "log" 
	       :id (format "class-~d" log-line-number)
	       :onclick (format "toggle('~a')" 
				(format "xgettext-~d" log-line-number))
	       :onmouseover (let1 m (#/([0-9][0-9]):([0-9][0-9]):([0-9][0-9])/ date)
			      (format "highlight('~a'); clock(~d, ~d, ~d);" 
				    (format "class-~d" log-line-number)
				    (m 1)
				    (m 2)
				    (m 3)))
	       :onmouseout (format "unhighlight('~a');" (format "class-~d" log-line-number))
	       (string-append (format "[~a/~a]" package version)
			      " "
			      (html-escape-string log-line)))
     (html:table :border #f :class "xgettext" :id (format "xgettext-~d" log-line-number)
		 :style "display: none;"
		 (report-log-group 
		  ;;
		  (let1 get-msg (lambda (xgettext) 
				  (cadr (memq :msg xgettext)))
		    (let loop ((filelines filelines)
			       (result (list))
			       (current-group (list))
			       (msg #f))
		      (if (null? filelines)
			  (if (null? current-group)
			      (reverse result)
			      (reverse (cons (reverse current-group) result)))
			  (if msg
			      (let ((xgettext (car filelines))
				    (filelines (cdr filelines)))
				(if (equal? msg (get-msg xgettext))
				    (loop filelines 
					  result
					  (cons xgettext current-group)
					  msg)
				    (loop (cons xgettext filelines)
					  (cons (reverse current-group) result) 
					  (list)
					  (get-msg xgettext))))
			      (loop filelines result current-group (get-msg (car filelines)))))))
		  package
		  version
		  log-line-len
		  log-line-number)
		 )
     #;(html:hr)
     )))

(define (report-syslog r)
  (list (html:pre 
	 (string-append "[ ] "
			(html-escape-string 
			 (syslog<-es r))))
	#;(html:hr))
  )

;; Taken from http://www.kanaya440.com/contents/tips/javascript/012.html
(define toggle-script
  "function toggle(ch) {
    var obj=document.all && document.all(ch) || document.getElementById && document.getElementById(ch);
    if(obj && obj.style) obj.style.display=
    \"none\" == obj.style.display ?\"\" : \"none\";
}")

(define highlight-script
  "function highlight(ch) {
    var obj=document.all && document.all(ch) || document.getElementById && document.getElementById(ch);
    if(obj && obj.style) obj.style.backgroundColor= \"gold\";
}")

(define unhighlight-script
  "function unhighlight(ch) {
    var obj=document.all && document.all(ch) || document.getElementById && document.getElementById(ch);
    if(obj && obj.style) obj.style.backgroundColor= \"white\";
}")

(define clock-script
  "")


(define (report results fmt)
  (case fmt
    ('es
     (for-each
      writeln
      results))
    ('html
     (display
      (tree->string
       (html:html
	(html:head
	 (html:script :language "JavaScript"
		      :type "text/javascript"
		      (string-append
		       toggle-script
		       "\n"
		       highlight-script
		       "\n"
		       unhighlight-script
		       "\n"
		       clock-script
		       )))
	(html:body
	 (map
	  (lambda (r)
	    (case (car r)
	      ('log (report-log r))
	      ('syslog (report-syslog r))))
	  results)))
       )))))

(define XFORK 1)
(define (main args)
  (let-args (cdr args)
      ((help "h|help" => (cute show-help (car args) 0))
       (xfork "xfork=i" 1)
       (limit-list "limit-list=i" 100)
       (limit-group "limit-group=i" 10)
       (report-format "format=y" 'html)
       (url-fmt "url-format=s" #f)
       (resolver "resolver=s" "./list-srpmnames-by-file.sh")
       . rest)
    (set! XFORK xfork)
    (set! url-format url-fmt)
    (if (eq? (length rest) 1)
	(report (run (prepare-pergs (car rest)  resolver) limit-group limit-list)
		report-format
		)
	(with-output-to-port (current-error-port)
	  (lambda ()
	    (show-help (car args) 1))))))
