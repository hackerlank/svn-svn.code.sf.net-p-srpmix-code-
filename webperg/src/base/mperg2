#!/bin/sh
#| -*- scheme -*- |#
:; exec gosh -- $0 "$@"

;; Copyright (C) 2010 Masatake YAMATO

;; This library is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This library is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this library.  If not, see <http://www.gnu.org/licenses/>.
;;
;; Author: Masatake YAMATO <yamato@redhat.com>
;;
(use file.util)
(use gauche.sequence)
(use gauche.parseopt)
(use gauche.process)
(use gauche.selector)
(use es.src.syslog)
(use es.dest.syslog)
(use text.html-lite)
(use text.tree)
(use srfi-1)
(use util.queue)


(define kget
  (case-lambda
   ((klist key default)
    (cond
     ((null? klist) default)
     ((eq? (car klist) key) (cadr klist))
     (else (kget (cdr klist) key default))))
   ((klist key)
    (kget klist key #f))))

(define (kget-default$ default-klist)
  (lambda (klist key)
    (kget klist key (kget default-klist key))))

;; TODO: khave?
;; TODO: multiple
(define (kattach klist key value)
  ;; fold?
  (reverse (cons value (cons key (reverse klist)))))

(define (kreplace klist key value)
  (reverse (let loop ((input klist)
		      (result (list)))
	     (cond
	      ((null? input) result)
	      ((eq? (car input) key)
	       (loop (if (null? (cdr input))
			 (list)
			 (cddr input))
		     (cons value (cons key result)))
	       )
	      (else
	       (loop (cdr input) (cons (car input) result)))))))

(define (kupdate klist key proc)
  (reverse (let loop ((input klist)
		      (result (list)))
	     (cond
	      ((null? input) result)
	      ((eq? (car input) key)
	       (loop (if (null? (cdr input))
			 (list)
			 (cddr input))
		     (cons (proc (cadr input)) (cons key result)))
	       )
	      (else
	       (loop (cdr input) (cons (car input) result)))))))


(define (kdrop klist key)
  (reverse (let loop ((input klist)
		      (result (list)))
	     (cond
	      ((null? input) result)
	      ((eq? (car input) key)
	       (if (null? (cdr input))
		   ;; broken klist
		   result
		   (loop (cddr input) result)))
	      (else
	       (loop (cdr input) (cons (car input) result)))))))

(define kget&drop
  (case-lambda
   ((klist key default)
    (let loop ((klist        klist)
	       (result-klist (list))
	       (result-value default))
      (if (null? klist)
	  (values result-value (reverse! result-klist))
	  (if (eq? key (car klist))
	      (loop (cddr klist)
		    result-klist
		    (cadr klist))
	      (loop (cdr klist)
		    (cons (car klist) result-klist)
		    result-value)))))
   ((klist key)
    (kget&drop klist key #f))))

;; gosh> (ktranspose '(foo :a (bar 1 2 3) :b (fox "a" "b" "c")) :b)
;; (fox "a" "b" "c" :b! (foo :a (bar 1 2 3)))
;; gosh> (ktranspose '(foo :a (bar 1 2 3) :b (fox "a" "b" "c")) :b :enter)
;; (fox "a" "b" "c" :enter (foo :a (bar 1 2 3)))
;; gosh> (ktranspose (ktranspose '(foo :a (bar 1 2 3) :b (fox "a" "b" "c")) :b :enter) :enter :b)
;; (foo :a (bar 1 2 3) :b (fox "a" "b" "c"))
;; gosh> 
(define ktranspose 
  (case-lambda
   ((klist key-pull key-push)
    (receive (new old) (kget&drop klist key-pull)
	      (kattach new key-push old)))
   ((klist key-pull)
    (ktranspose klist 
		key-pull
		(make-keyword (string-append (x->string key-pull) "!"))))))


(define (basename->srpms basename dist resolver depth)
  (let1 pkgs (process-output->string-list 
	      `(,resolver
		,(format "/srv/sources/dists/~a/plugins/rpms2sqldb/rhel-i386-5.sqlite" dist)
		,basename))
    (if (null? pkgs)
	(list)
	(let loop ((pkgs pkgs)
		   (result (list)))
	  (if (null? pkgs)
	      result
	      (let1 pkg (car pkgs)
		(let1 verdir (guard (e (else #f))
				 (sys-readlink (format "/srv/sources/dists/~a/packages/~a/~a"
						       dist
						       (substring pkg 0 1)
						       pkg)))
		  (if verdir
		      (loop (cdr pkgs) (cons (list pkg (sys-basename verdir)) result))
		      (loop (cdr pkg ) result)))))))))

(define-class <director> ()
  ((dist :init-keyword :dist)
   (max-groups :init-keyword :max-groups)
   (basename->srpms :init-keyword :basename->srpms)
   (basenames :init-form (make-hash-table 'equal?))
   (packages  :init-form (make-hash-table 'equal?))
   (lines :init-form (list))
   (selector :init-form (make <selector>))
   ))

(define-class <basename> ()
  ((packages :init-keyword :packages)
   (uniq-logs :init-form (make-hash-table 'equal?))
   ))

(define-class <package> ()
  ((dist :init-keyword :dist)
   (pkgname :init-keyword :pkgname)
   (out-queue :init-form (make-queue))
   ))

(define-method boot ((package <package>))
  ;; loading xgettext
  pkg)

(define-method make-package ((director <director>) 
			     (pkgname <string>))
  (let1 pkg (make <package> 
	      :dist (ref director 'dist)
	      :pkgname pkgname)
    (set! (ref (ref director 'packages) pkgname) pkg)
    (receive (to-pergs from-pergs perg-procs) (boot pkg)
      ...				;selector add
      )
    pkg))

(define-method packages-for-basename ((director <director>) 
				      (basename <string>))
  (let loop ((candidates ((ref director 'basename->srpms) basename))
	     (exists (ref director 'packages))
	     (result (list)))
    (if (null? candidates)
	result
	(let* ((c (car candidates))
	       (pkg (or (ref exists (car candidates) #f)
			(make-package director c))))
	  (loop (cdr candidates) exists (cons pkg result))))))

(define-method make-basename ((director <director>)
			      (basename <string>))
  (let1 b (make <basename> 
	    :init-keyword (packages-for-basename director basename)
	    )
    (set! (ref director 'basenames) basename b)
    b))

(define-method prepare ((package  <package>)
			syslog)
  (enqueue! (ref package 'out-queue) syslog))

(define-method resolve ((basename <basename>)
			syslog)
  (let* ((log-line (kget syslog :msg))
	 (uniq-logs (ref basename 'uniq-logs)))
    (unless (ref uniq-logs log-line)
      (set! (ref uniq-logs log-line) 
	    (make-tree-map equal? 
			   (lambda () ...comparing score)))
      (for-each
       (cute prepare <> syslog)
       (ref basename 'packages)))))

(define-method prepare ((director <director>)
			log-line)
  (let1 syslog (kattach (es<-syslog line-string) :result (list))
    (push! director 'lines syslog)
    (unless (memq :raw syslog)
      (let1 basename (kget syslog :cmd)
	(when basename
	  (let1 b (or (ref (ref director 'basenames) basename #f)
		      (make-basename director basename))
	    (prepare basename syslog)))))))
	      
		    

(define (show-help prog n)
  (format #t "~a --help" prog)
  (format #t "~a [--basename--to-srpm=RESOLVER] [--max-groups=N] [--dist=DIST] [--depth=N] < /var/log/message\n" prog)
  (exit n))

(define-method resolve ((director <director>))
  ...
  director)

(define-method report ((director <director>))
  ...
  )

(define (main args)
  (let-args (cdr args)
      ((help "h|help" => (cute show-help (car args) 0))
       (dist "dist=s" "rhel5su4")
       (max-groups "max-groups=i" 10)
       (depth "depth=i" 1)
       (basename-to-srpms "basename-to-srpm=s" "./list-srpmnames-by-file.sh"))
    (report (resolve (let loop ((l (read-line))
				(director (make <director>
					    :dist dist
					    :max-groups max-groups
					    :basename->srpms (cute basename->srpms
								   <> 
								   dist
								   basename-to-srpm
								   depth))))
		       (unless (eof-object? l)
			 (prepare director l)
			 (loop (read-line))))))))


