#!/bin/sh
#| -*- scheme -*- |#
:; exec gosh -- $0 "$@"

;; Copyright (C) 2010 Masatake YAMATO

;; This library is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This library is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this library.  If not, see <http://www.gnu.org/licenses/>.
;;
;; Author: Masatake YAMATO <yamato@redhat.com>
;;
(use file.util)
(use gauche.sequence)
(use gauche.parseopt)
(use gauche.process)
(use gauche.selector)
(use es.src.syslog)
(use es.dest.syslog)
(use text.html-lite)
(use text.tree)
(use srfi-1)
(use srfi-13)
(use util.queue)

(debug-print-width #f)


(define perg-cmd "perg")
(define (package-version->xgettxt pkg ver)
  (format "/srv/sources/sources/~a/~a/~a/plugins/xgettext/xgettext.out"
	      (substring pkg 0 1)
	      pkg
	      ver))
(define (basename->srpms basename dist resolver depth)
  (let1 pkgs (process-output->string-list 
	      `(,resolver
		,(format "/srv/sources/dists/~a/plugins/rpms2sqldb/rhel-i386-5.sqlite" dist)
		,basename))
    (if (null? pkgs)
	(list)
	(let loop ((pkgs pkgs)
		   (result (list)))
	  (if (null? pkgs)
	      result
	      (let1 pkg (car pkgs)
		(let1 verdir (guard (e (else #f))
				 (sys-readlink (format "/srv/sources/dists/~a/packages/~a/~a"
						       dist
						       (substring pkg 0 1)
						       pkg)))
		  (if verdir
		      (loop (cdr pkgs) (cons (list pkg (sys-basename verdir)) result))
		      (loop (cdr pkg ) result)))))))))

(define kget
  (case-lambda
   ((klist key default)
    (cond
     ((null? klist) default)
     ((eq? (car klist) key) (cadr klist))
     (else (kget (cdr klist) key default))))
   ((klist key)
    (kget klist key #f))))

(define (kget-default$ default-klist)
  (lambda (klist key)
    (kget klist key (kget default-klist key))))

;; TODO: khave?
;; TODO: multiple
(define (kattach klist key value)
  ;; fold?
  (reverse (cons value (cons key (reverse klist)))))

(define (kreplace klist key value)
  (reverse (let loop ((input klist)
		      (result (list)))
	     (cond
	      ((null? input) result)
	      ((eq? (car input) key)
	       (loop (if (null? (cdr input))
			 (list)
			 (cddr input))
		     (cons value (cons key result)))
	       )
	      (else
	       (loop (cdr input) (cons (car input) result)))))))

(define (kupdate klist key proc)
  (reverse (let loop ((input klist)
		      (result (list)))
	     (cond
	      ((null? input) result)
	      ((eq? (car input) key)
	       (loop (if (null? (cdr input))
			 (list)
			 (cddr input))
		     (cons (proc (cadr input)) (cons key result)))
	       )
	      (else
	       (loop (cdr input) (cons (car input) result)))))))


(define (kdrop klist key)
  (reverse (let loop ((input klist)
		      (result (list)))
	     (cond
	      ((null? input) result)
	      ((eq? (car input) key)
	       (if (null? (cdr input))
		   ;; broken klist
		   result
		   (loop (cddr input) result)))
	      (else
	       (loop (cdr input) (cons (car input) result)))))))

(define kget&drop
  (case-lambda
   ((klist key default)
    (let loop ((klist        klist)
	       (result-klist (list))
	       (result-value default))
      (if (null? klist)
	  (values result-value (reverse! result-klist))
	  (if (eq? key (car klist))
	      (loop (cddr klist)
		    result-klist
		    (cadr klist))
	      (loop (cdr klist)
		    (cons (car klist) result-klist)
		    result-value)))))
   ((klist key)
    (kget&drop klist key #f))))

;; gosh> (ktranspose '(foo :a (bar 1 2 3) :b (fox "a" "b" "c")) :b)
;; (fox "a" "b" "c" :b! (foo :a (bar 1 2 3)))
;; gosh> (ktranspose '(foo :a (bar 1 2 3) :b (fox "a" "b" "c")) :b :enter)
;; (fox "a" "b" "c" :enter (foo :a (bar 1 2 3)))
;; gosh> (ktranspose (ktranspose '(foo :a (bar 1 2 3) :b (fox "a" "b" "c")) :b :enter) :enter :b)
;; (foo :a (bar 1 2 3) :b (fox "a" "b" "c"))
;; gosh> 
(define ktranspose 
  (case-lambda
   ((klist key-pull key-push)
    (receive (new old) (kget&drop klist key-pull)
	      (kattach new key-push old)))
   ((klist key-pull)
    (ktranspose klist 
		key-pull
		(make-keyword (string-append (x->string key-pull) "!"))))))

(define-class <director> ()
  ((dist :init-keyword :dist)
   (max-groups :init-keyword :max-groups)
   (basename->srpms :init-keyword :basename->srpms)
   (basenames :init-form (make-hash-table 'equal?))
   (packages  :init-form (make-hash-table 'equal?))
   (logs      :init-form (make-queue))
   (selector :init-form (make <selector>))
   ))

(define-class <basename> ()
  ((packages :init-keyword :packages)
   (uniq-logs :init-form (make-hash-table 'equal?))
   ))

(define-class <package> ()
  ((dist :init-keyword :dist)
   (pkgname :init-keyword :pkgname)
   (version :init-keyword :version)
   (to-perg-queue :init-form (make-queue))
   (pergs :init-form (list))
   (to-pergs-ports :init-form (list))
   (from-pergs-ports :init-form (list))
   ))

(define-method boot ((package <package>))
  (let ((xgettext (package-version->xgettxt (ref package 'pkgname)
					    (ref package 'version)))
	;; FIXME make parametric
	(limit 20))
    (let ((limit-flag (format "--limit=~d" limit)))
      (let1 proc (run-process `(,perg-cmd "--format=es" ,limit-flag = ,xgettext) 
			      :input :pipe
			      :output :pipe)
	(push! (ref package 'pergs) proc)
	(push! (ref package 'to-pergs-ports) (process-input proc))
	(push! (ref package 'from-pergs-ports) (process-output proc))))))
		

(define-method make-package ((director <director>) 
			     (pkgname <string>)
			     (version <string>))
  (let1 pkg (make <package> 
	      :dist (ref director 'dist)
	      :pkgname pkgname
	      :version version)
    ;; FIXME: This needs guard.
    (boot pkg)
    (set! (ref (ref director 'packages) pkgname) pkg)
    pkg))

(define-method packages-for-basename ((director <director>) 
				      (basename <string>))
  (let loop ((candidates ((ref director 'basename->srpms) basename))
	     (exists (ref director 'packages))
	     (result (list)))
    (if (null? candidates)
	result
	(let* ((c (car candidates))
	       (pkg (or (ref exists (car c) #f)
			(make-package director (car c) (cadr c)))))
	  (loop (cdr candidates) exists (cons pkg result))))))

(define-method make-basename ((director <director>)
			      (basename <string>))
  (let1 b (make <basename> 
	    :packages (packages-for-basename director basename)
	    )
    (set! (ref (ref director 'basenames)  basename)  b)
    b))

(define-method prepare ((package  <package>)
			syslog)
  (enqueue! (ref package 'to-perg-queue) syslog))

(define-method prepare ((basename <basename>)
			syslog)
  (let* ((log-line (kget syslog :msg))
	 (uniq-logs (ref basename 'uniq-logs)))
    (unless (ref uniq-logs log-line #f)
      (set! (ref uniq-logs log-line) 
	    (make-tree-map (lambda (k1 k2)
			     (and (eq? (car k1) (car k2))
				  (equal? (cadr k1) (cadr k2))))
			   (lambda (k1 k2)
			     (and (>= (car k1) (car k2))
				  (string< (cadr k1) (cadr k2))))
			     ))
      (for-each
       (cute prepare <> syslog)
       (ref basename 'packages)))))

(define-method prepare ((director <director>)
			log-line)
  (let1 syslog (es<-syslog log-line)
    (enqueue! (ref director 'logs) syslog)
    (unless (memq :raw syslog)
      (let1 basename (kget syslog :cmd)
	(when basename
	  (let1 b (or (ref (ref director 'basenames) basename #f)
		      (make-basename director basename))
	    (prepare b syslog)))))
    director))

(define (writeln r oport)
  (write r oport)
  (newline oport))

(define (take-group filelines limit)
  (if (null? filelines)
      filelines
      (let1 get-msg (lambda (xgettext) (kget xgettext :msg))
	(let loop ((key          (get-msg (car filelines)))
		   (candidate    (car filelines))
		   (rest         (cdr filelines))
		   (result       (list))
		   (n            0))
	  (cond
	   ((eq? n limit)
	    (reverse result))
	   ((equal? (get-msg candidate) key)
	    (if (null? rest)
		(reverse (cons candidate result))
		(loop key (car rest) (cdr rest) (cons candidate result) n)))
	   (else
	    (loop (get-msg candidate) candidate rest result (+ n 1))))))))

(define-method resolve ((basename <basename>)
			(uniq-log <string>)
			filelines
			max-groups
			pkgname
			version)
  ;; Pick higher rank upto MAX-GROUPS.
  ;; Put them to the tree-map.
  (let ((filelines (take-group filelines max-groups))
	(extra     (list :package pkgname :version version))
	(tree-map  (ref (ref basename 'uniq-logs) uniq-log)))
    (for-each
     (lambda (fileline)
       (let* ((match-chars (kget fileline :match-chars))
	      (msg (kget fileline :msg))
	      (key (list match-chars msg)))
	 (tree-map-push! tree-map key 
			 (append! fileline extra))
	 ))
     filelines)))


(define-method resolve ((director <director>))
  (let ((selector (ref director 'selector))
	(n-output-ports 0)
	(n-input-ports 0))
    (hash-table-for-each
     (ref director 'packages)
     (lambda (k package)
       (for-each
	(lambda (to-perg-port)
	  (set! n-output-ports (+ n-output-ports 1))
	  (selector-add! selector to-perg-port
			 (lambda (output-port flag)
			   (let* ((queue (ref package 'to-perg-queue))
				  (syslog (dequeue! queue)))
			     (when syslog
			       (guard (e
				       (else (dequeue-all! queue)))
				      (writeln `(log ,(kget syslog :msg)
						     :basename ,(kget syslog :cmd)
						     ;; :pkgname and :version can
						     ;; be attached here
						     )
					       output-port)))
			     (when (queue-empty? queue)
			       (selector-delete! selector output-port #f #f)
			       (close-output-port output-port)
			       (set! n-output-ports (- n-output-ports 1))
			       )))
			 '(w)))
	(ref package 'to-pergs-ports))
       (for-each
	(lambda (from-perg-port)
	  (set! n-input-ports (+ n-input-ports 1))
	  (selector-add! selector from-perg-port
			 (lambda (input-port flag)
			   (let1 log+filelines (read input-port)
			     (if (eof-object? log+filelines)
				 (begin (selector-delete! selector input-port #f #f)
					(close-input-port input-port)
					(set! n-input-ports (- n-input-ports 1)))
				 (resolve (ref (ref director 'basenames) 
					       (kget log+filelines :basename))
					  (cadr log+filelines)
					  (kget log+filelines :filelines)
					  (ref director 'max-groups)
					  (ref package 'pkgname)
					  (ref package 'version)
					  ))))

			 '(r)))
	(ref package 'from-pergs-ports))
       ))
    (let loop ()
      (when (or (< 0 n-output-ports)
		(< 0 n-input-ports))
	(let1 status (selector-select selector)
	  (unless (eq? status 0)
	    (loop)))))
    (hash-table-for-each
     (ref director 'packages)
     (lambda (k package)
       (for-each 
	process-wait
	(ref package 'pergs)))))
  director)

(define-method report-raw ((director <director>)
			   rawlog)
  (format #t "[_] ~a\n" (kget rawlog :raw)))
(define-method report-syslog ((director <director>)
			      syslog
			      tree-map)
  (format #t "[+] ~a\n" (kget syslog :msg)
	  
	  ))


(define (dequeue-safe! queue . default)
  (let1 default (if (null? default) #f  default)
    (if (queue-empty? queue)
	default
	(dequeue! queue))))
      
(define-method report ((director <director>))
  (let ((queue (ref director 'logs))
	(max-groups (ref director 'max-groups)))
    (let loop ((syslog (dequeue-safe! queue)))
      (when syslog
	(if (memq :raw syslog)
	    (report-raw director syslog)
	    (let1 tree-map (ref 
			    (ref 
			     (ref 
			      (ref director 'basenames)
			      (kget syslog :cmd))
			     'uniq-logs)
			    (kget syslog :msg))
	      (report-syslog director syslog tree-map)))
	(loop (dequeue-safe! queue))))))

(define (show-help prog n)
  (format #t "~a --help" prog)
  (format #t "~a [--basename--to-srpm=RESOLVER] [--max-groups=N] [--dist=DIST] [--depth=N] < /var/log/message\n" prog)
  (exit n))

(define (main args)
  (let-args (cdr args)
      ((help "h|help" => (cute show-help (car args) 0))
       (dist "dist=s" "rhel5su4")
       (max-groups "max-groups=i" 10)
       (depth "depth=i" 1)
       (basename-to-srpms "basename-to-srpm=s" "./list-srpmnames-by-file.sh"))
    (report (resolve (let loop ((l (read-line))
				(director (make <director>
					    :dist dist
					    :max-groups max-groups
					    :basename->srpms (cute basename->srpms
								   <> 
								   dist
								   basename-to-srpms
								   depth))))
		       (if (eof-object? l)
			   director
			   (loop (read-line) 
				 (prepare director l))))))))


