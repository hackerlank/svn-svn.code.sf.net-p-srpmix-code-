#!/bin/sh
#| -*- scheme -*- |#
:; exec gosh -- $0 "$@"

;; variable->function
;; type->function
;; functions->type
;; variable->type
;; type->variable
;; function->variable
;; member->struct

;; reachable?
;;
(use srfi-1)
(use srfi-13)
(use util.match)
(use util.list)
(use gauche.process)
(use gauche.parameter)
(use file.util)
(use gauche.parseopt)
(use gauche.sequence)
(use gauche.collection)
(use slib)
(require 'pretty-print)

(debug-print-width #f)

(define (kref es k)
  (if es
      (cadr (or (memq k es)
		(list k #f)))
      es))
  

(define objfiles (make-hash-table 'equal?))
(define (table? t) (and (list? t)
			(not (null? t))
			(eq? (car t) 'table)))

(define-class <libdwarves-table> ()
  ((current-compile-unit :init-value #f)
   (id->es :init-form (make-hash-table 'eq?))
   (compile-unit->es :init-form (make-hash-table 'equal?))
   (compile-unit->ids :init-form (make-hash-table 'equal?))
   (name->ids :init-form (make-hash-table 'equal?))
   (subprogram-name->ids :init-form (make-hash-table 'equal?))
   (variable-name->ids :init-form (make-hash-table 'equal?))
   (structure_type-name->ids :init-form (make-hash-table 'equal?))
   (union_type-name->ids :init-form (make-hash-table 'equal?))
   (typedef-name->ids :init-form (make-hash-table 'equal?))
   (base_type-name->ids :init-form (make-hash-table 'equal?))
   (enumeration_type-name->ids :init-form (make-hash-table 'equal?))
   (pointer_type-name->ids :init-form (make-hash-table 'equal?))
   ))

(define-method enter-compile-unit! ((dtable <libdwarves-table>)
				    compile-unit-es)
  (let1 name (kref compile-unit-es :name)
    (set! (~ dtable 'current-compile-unit) name)
    (set! (~ dtable 'compile-unit->es name) compile-unit-es)))

(define-syntax when-let1
  (syntax-rules ()
    [(when-let1 var exp . body)
     (let ((var exp)) (when var . body))]))


(define-method add ((dtable <libdwarves-table>)
		    es)
  (let1 id (kref es :id)
    (set! (~ dtable 'id->es id) es)
    (hash-table-push! (ref dtable 'compile-unit->ids)
		      (ref dtable 'current-compile-unit) id)
    (when-let1 name (kref es :name)
      (hash-table-push! (ref dtable 'name->ids) name id)
      (case (cadr es)
	('subprogram
	 (hash-table-push! (ref dtable 'subprogram-name->ids) name id))
	('variable
	 (hash-table-push! (ref dtable 'variable-name->ids) name id))
	('typedef
	 (hash-table-push! (ref dtable 'typedef-name->ids) name id))
	('structure_type
	 (hash-table-push! (ref dtable 'structure_type-name->ids) name id))
	('union_type
	 (hash-table-push! (ref dtable 'union_type-name->ids) name id))
	('base_type
	 (hash-table-push! (ref dtable 'base_type-name->ids) name id))
	('enumeration_type
	 (hash-table-push! (ref dtable 'enumeration_type-name->ids) name id))
	('pointer_type
	 (hash-table-push! (ref dtable 'pointer_type-name->ids) name id))
	)
      )))

(define-method all-ids ((dtable <libdwarves-table>))
  (hash-table-keys (ref dtable 'id->es)))

(define-method all-ids-in-compile-unit ((dtable <libdwarves-table>)
					(cu-name <string>))
  (ref (ref dtable 'compile-unit->ids) cu-name))
       
(define-method compile-unit-of ((dtable <libdwarves-table>)
				(id <symbol>))
  (let loop ((cu (compile-units dtable)))
    (if (null? cu)
	#f
	(if (memq id 
		  (all-ids-in-compile-unit dtable (car cu)))
	      (car cu)
	      (loop (cdr cu))))))
	      
(define-method compile-unit->es ((dtable <libdwarves-table>)
				 (compile-unit <string>))
  (~ dtable 'compile-unit->es compile-unit))

(define-method compile-units ((dtable <libdwarves-table>))
  (hash-table-keys (~ dtable 'compile-unit->es)))

(define-method id->es ((dtable <libdwarves-table>)
		       (id <symbol>))
  (ref (ref dtable 'id->es) id #f))

(define-method structure_type-name->ids ((dtable <libdwarves-table>)
					 (struct <string>))
  (ref (ref dtable 'structure_type-name->ids) struct (list)))
(define-method union_type-name->ids ((dtable <libdwarves-table>)
				     (union <string>))
  (ref (ref dtable 'union_type-name->ids) union (list)))
(define-method typedef-name->ids ((dtable <libdwarves-table>)
				  (typedef <string>))
  (ref (ref dtable 'typedef-name->ids) typedef (list)))
(define-method base_type-name->ids ((dtable <libdwarves-table>)
				    (base_type <string>))
  (ref (ref dtable 'base_type-name->ids) base_type (list)))
(define-method enumeration_type-name->ids ((dtable <libdwarves-table>)
					   (enum_type <string>))
  (ref (ref dtable 'enumeration_type-name->ids) enum_type (list)))
(define-method pointer_type-name->ids ((dtable <libdwarves-table>)
				       (pointer_type <string>))
  (ref (ref dtable 'pointer_type-name->ids) pointer_type (list)))

;; dtable: dwarf id and/or dwarf name -> libdwarves es.
(define (make-table ftable rtable dtable objpath)
  (list 'table ftable rtable dtable objpath))
(define (ref-ftable objfile)
  (ref objfile 1))
(define (ref-rtable objfile)
  (ref objfile 2))
(define (ref-dtable objfile)
  (ref objfile 3))
(define (ref-objpath objfile)
  (ref objfile 4))

(define (list-objfiles . args)
  (if (kref args :loaded-only)
      (hash-table-fold objfiles
		       (lambda (k v kdr)
			 (if (table? v)
			     (cons
			      `(objfile 
				,k ,(ref-objpath v))
			      kdr)
			     kdr))
		       (list))
      (hash-table-map objfiles
		      (lambda (k v)
			`(objfile 
			  ,k ,(if (table? v)
				  (ref-objpath v)
				  v))))))

(define current-file (make-parameter #f))
(define current-path (make-parameter #f))
(define current-ftable (make-parameter #f))
(define current-rtable (make-parameter #f))
(define current-dtable (make-parameter #f))
(define quiet (make-parameter #f))

(define (switch-objfile name)
  (let1 table (ref objfiles name #f)
    (cond
     ((table? table)
      (current-file name)
      (current-ftable (ref-ftable table))
      (current-rtable (ref-rtable table))
      (current-dtable (ref-dtable table))
      (current-path (ref-objpath table))
      (list))
     (else
      (error "Not loaded yet: " name)))))


(define (load-objfile0 file)
  (let* ((m (#/\/srv\/debugs\/dists\/([^\/]+)/ file))
	 (d (if m (m 1) #f))
	 (inventory (if d 
			(file->list 
			 read
			 #`"/srv/debugs/dists/,|d|/plugins/O0g3/INVENTORY.es")
			#f)))
    (call-with-input-process `(callp ,file)
      (lambda (input)
	(receive (ftable rtable dtable so)
	    (load-entries (read-line input))
	  (set! (ref objfiles (sys-basename file))
		(make-table ftable rtable dtable file))
	  (switch-objfile (sys-basename file))
	  (for-each
	   (lambda (s) 
	     (unless (ref objfiles s #f)
	       (set! (ref objfiles s) 
		     (or (and-let* (inventory (l (assoc-ref inventory s #f)))
			   `(LOADABLE ,#`"/srv/debugs/dists/,|d|/plugins/O0g3/root,|l|"))
			 'UNSOLVED))))
	   so))
	(list)))))

(define (load-objfile file)
  (if (equal? (sys-basename file) file)
      (load-objfile0 (let1 l (ref objfiles file #f)
		       (if (and (list? l)
				(not (null? l))
				(eq? (car l) 'LOADABLE))
			   (cadr l)
			   file)))
      
      (load-objfile0 file)
      ))

(define (load-objfile-all)
  (map load-objfile
       (hash-table-fold objfiles
			(lambda (k l kdr)
			  (if (and (list? l)
				   (not (null? l))
				   (eq? (car l) 'LOADABLE))
			      (cons (cadr l) kdr)
			      kdr))
			(list))))


(define (in-blacklist? name)
  (any (lambda (r) (r name))
       (list
	#/^__dso_handle.*/			;???
	#/^__FUNCTION__\..*/
	#/^__PRETTY_FUNCTION__\..*/
	#/^__libc_csu_init$/
	#/^__do_global_ctors_aux$/
	#/^_start$/
	#/^call_gmon_start$/
	#/^__do_global_dtors_aux$/
	#/^frame_dummy$/
	#/^_start$/
	)))

(define (load-entries file)
  (define (acceptable? entry)
    (not (in-blacklist? entry)))
  (define (wash! es)
    (let1 connections (fold-right 
		       (lambda (entry0 kdr)
			 (cond
			  ((memq (ref entry0 0) '(call ref 
						       ;; ???
						       lref
						       ))
			   (let1 entry (ref entry0 2)
			     (if (acceptable? entry)
				 (cons entry0 kdr)
				 kdr)))
			  ;; TODO: See objdump-dcall.scm.
			  ((memq (ref entry0 0) '(call-reg))
			   kdr
			   )
			  (else
			   #?=(ref entry0 0)
			   kdr)))
		       (list)
		       (delete-duplicates 
			(cadr (memq :connections es))))
      (set! (cadr (memq :connections es)) connections)))
  (with-input-from-file file
    (lambda ()
      (let loop ((es (read))
		 (ftable (make-hash-table 'equal?))
		 (rtable (make-hash-table 'equal?))
		 (dtable (make <libdwarves-table>))
		 (so (list)))
	;;(write es)(newline)
	(if (eof-object? es)
	    (values ftable rtable dtable so)
	    (cond
	     ((and (eq? (car es) 'objdump-dcall)
		   (eq? (cadr es) 'entry))
	      (wash! es)
	      (for-each
	       (lambda (entry)
		 (hash-table-push! rtable entry es))
	       (delete-duplicates
		(map
		 (cute ref <> 2)
		 (cadr (memq :connections es)))))
	      (when (acceptable? (ref es 3))
		(hash-table-push! ftable (ref es 3) es))
	      (loop (read) ftable rtable dtable so))
	     ((eq? (car es) 'readelf-so)
	      (loop (read) ftable rtable dtable (append (cdr es) so)))
	     ;;
	     ((eq? (car es) 'libdwarves)
	      (case (cadr es)
		('compile_unit
		 (enter-compile-unit! dtable es)
		 (loop (read) ftable rtable dtable so))
		(else
		 (add dtable es)
		 (loop (read) ftable rtable dtable so))))
	     ;;
	     (else
	      (loop (read) ftable rtable dtable so))))))))

(define (find-callers sym table)
  (define (build kar l)
    `(,(if kar 
	   kar
	   (if (cadr (memq :variable? l))
	       'v
	       'f))
      ,(ref l 3)
      :file ,(cadr (memq :file l)) 
      :line ,(cadr (memq :line l))
      ))
  (cond
   ((ref table sym #f) => (cute map (cute build #f <>) <>))
   (else
    (hash-table-fold 
     table 
     (lambda (k v kdr)
       (if (and (string-prefix? sym k)
		(memq (string-ref k (string-length sym))
		      '(#\@ #\.)))
	   (append (map (cute build 'x <>) v) kdr)
	   kdr))
     (list)))))

(define (drop-plt sym)
  (car (string-split sym #\@)))

(define (find-callees sym table)
  (if-let1 ess (or (ref table sym #f)
		   (ref table (drop-plt sym) #f))
    (append-map
     (lambda (es)
       (let1 connections (cadr (memq :connections es))
	 (map (lambda (name)
		(if-let1 callee-ess (ref table name #f)
		  (append-map
		   (lambda (callee-es)
		     `(,(if (cadr (memq :variable? callee-es))
			    'v
			    'f) 
		       ,(ref callee-es 3)
		       :file ,(cadr (memq :file callee-es))
		       :line ,(cadr (memq :line callee-es))
		       #;:caller #;(,(ref es 2) 
		       :file ,(cadr (memq :file es))
		       :line ,(cadr (memq :line es))))
		     )
		   callee-ess)
		  `(x ,name)))
	      (map (cute ref <> 2) connections))))
     ess)
    (list)))

(define (forward-chained? from to ftable)
  (list #f))
(define (backward-chained? from to ftable)
  (list #f))

(define (resolve-plt name table)
  (rxmatch-if (#/^(.*)@plt/ name)
      (#f first-name)
    (or (call/cc (lambda (return)
		   (for-each (lambda (objfile)
			       (let1 ftable (ref-ftable objfile)
				 (if-let1 es (ref ftable first-name #f)
					  (return #`",|first-name|@,(sys-basename (ref-objpath objfile))"))
			       (let1 dtable (ref-dtable objfile)
				 (if-let1 es (ref (~ dtable 'name->ids) first-name #f)
					  (return #`",|first-name|@,(sys-basename (ref-objpath objfile))")))))
			     (remove (lambda (objfile) 
				       (memq table objfile))
				     (map (cute ref objfiles <> #f) 
					  (map cadr 
					       (list-objfiles :loaded-only #t)))))
		   #f))
	name)
    name))

(define (decorate name table interactive?)
  (let1 resolved-name (resolve-plt name table)
    (if interactive?
	(if (equal? name resolved-name)
	    #`",(if (variable? name table) '= '|| ),|name|,(if (variable? name table) '|| '() )"
	    resolved-name)
	resolved-name)))
(define (undecorate name)
  (regexp-replace #/^=/ (regexp-replace #/\(\)$/ name "") ""))


(define (excludes? elt excludes)
  (any (lambda (ex)
	 (cond
	  ((equal? elt ex) #t)
	  ((string? ex) (or (equal? (undecorate ex) (undecorate elt))
			    (equal? (drop-plt ex) (drop-plt elt))))
	  ((regexp? ex) (ex elt))
	  (else #f)))
       excludes))

(define (callers* name rtable interactive? depth excludes)
  (hash-table-map
   (let loop ((current-callers (map
				(cute ref <> 1)
				(find-callers name rtable)))
	      (total-callers (make-hash-table 'equal?))
	      (path (list name))
	      (depth depth))
     (when (or (and (boolean? depth) depth)
	       (and (integer? depth) (< 0 depth)))
       (for-each
	(lambda (caller)
	  (unless (excludes? caller excludes)
	    (unless (member caller path)
	      (let* ((xpath (cons caller path))
		     (v (hash-table-get total-callers caller #f)))
		(unless (and v (member xpath v)) ; necessary
		  (hash-table-push! total-callers caller 
				    xpath)
		  (loop (map
			 (cute ref <> 1)
			 (find-callers caller rtable))
			total-callers
			xpath
			(if (integer? depth) (- depth 1) depth)
			))))))
	current-callers))
     total-callers)
   (lambda (a b)
     (cons (decorate a rtable interactive?)
	   (map
	    (lambda (x)
	      (map (cute decorate <> rtable interactive?) x))
	    b))
     )))

(define (callees* name ftable interactive? depth excludes)
  (hash-table-map
   (let loop ((current-callees (map
				(cute ref <> 1)
				(find-callees name ftable)))
	      (total-callees (make-hash-table 'equal?))
	      (path (list name))
	      (depth depth))
     (when (or (and (boolean? depth) depth)
	       (and (integer? depth) (< 0 depth)))
       (for-each
	(lambda (callee)
	  (unless (excludes? callee excludes)
	    (unless (member callee path)
	      (let* ((xpath (cons callee path))
		     (v (hash-table-get total-callees callee #f)))
		(unless (and v (member xpath v)) 
		  (hash-table-push! total-callees callee 
				    xpath)
		  (loop (map
			 (cute ref <> 1)
			 (find-callees callee ftable))
			total-callees
			xpath
			(if (integer? depth) (- depth 1) depth)))))))
	current-callees))
     total-callees)
   (lambda (a b)
     (cons (decorate a ftable interactive?) 
	   (map
	    (lambda (x)
	      (map (cute decorate <> ftable interactive?)
		   x))
	    (map reverse b))))))

(define (chained? from to rtable interactive? depth)
  (delete-duplicates 
   (or (let1 callers-from (callers* from rtable #f depth (list))
	 (if-let1 found (assoc-ref  callers-from to #f)
	   (map
	    (lambda (f)
	      (map (cute decorate <> rtable interactive?)
		   f))
	    found)
	   #f))
       (let1 callers-to (callers* to rtable #f depth (list))
	 (if-let1 found (assoc-ref  callers-to from #f)
	   (map
	    (lambda (f)
	      (map (cute decorate <> rtable interactive?)
		   f))
	    found)
	   #f))
       (list #f))))

(define (transit from to ftable rtable interactive? depth)
  (define (decorate* tree)
    (map (lambda (t) (map (cute decorate <> rtable interactive?) t)) 
	 tree))
  (delete-duplicates
   (let1 r (chained? from to rtable #f depth)
     (if (equal? r (list #f))
	 (let1 commons (append 
			(let* ((callers-from (callers* from rtable #f depth (list)))
			       (callers-to (callers* to rtable #f depth (list)))
			       (common-callers (lset-intersection equal? 
								  (map car callers-from)
								  (map car callers-to))))
			  (if (null? common-callers)
			      (list)
			      (map
			       (lambda (common-caller)
				 `(common-caller ,common-caller
						 :from ,(decorate*
							 (delete-duplicates 
							  (assoc-ref callers-from common-caller)))
						 :to ,(decorate*
						       (delete-duplicates
							(assoc-ref callers-to common-caller))))
				 )
			       common-callers)))
			(let* ((callees-from (callees* from ftable #f depth (list)))
			       (callees-to (callees* to ftable #f depth (list)))
			       (common-callees (lset-intersection equal? 
								  (map car callees-from)
								  (map car callees-to))))
			  (if (null? common-callees)
			      (list)
			      (map
			       (lambda (common-callee)
				 `(common-callee ,common-callee
						 :from ,(decorate*
							 (delete-duplicates
							  (assoc-ref callees-from common-callee)))
						 :to ,(decorate* 
						       (delete-duplicates
							(assoc-ref callees-to common-callee))))
				 )
			       common-callees))))
	   (if (null? commons)
	       (list #f)
	       commons))
	 r))))

(define (variable? name table)
  (let1 entry (ref table name #f)
    (if entry
	(cadr (memq :variable? (car entry)))
	#f)))

(define (desc name ftable)
  (ref ftable name (list #f)))

(define (file-line0 table file line)
  (define (file-line00 current-path table file line)
    (rxmatch-cond
      ((#/^\/srv\/debugs(\/sources\/[a-zA-Z0-9]\/[^\/]+\/[^\/]+).*/ 
	current-path)
       (#f m)
       `(,#`"/srv/sources,|m|/pre-build/,|file|" ,#`",|line|"))
      ((#/^\/srv\/debugs\/dists\/([^\/]+)\/plugins\/O0g3\/root\/.*/ 
	current-path)
       (#f d)
       (file-line00 (sys-readlink current-path) table file line)
       )))
  (let* ((debug-root-dir "/usr/src/debug/")
	 (debug-root-dir-len (string-length debug-root-dir)))
    (file-line00 (current-path) table (if (string-prefix? debug-root-dir  file)
					  (string-drop file debug-root-dir-len)
					  file) 
		 line)))

(define (file-line name ftable)
  (or (and-let* ((e (or (ref ftable name #f)
			(ref ftable (drop-plt name) #f)
			(list #f))
		    )
		 (e (car e))
		 (e (cdddr e))
		 (file (kref e :file))
		 (line (kref e :line)))
	(list (file-line0 ftable file line)))
      (list #f)))

(define (file-line-call caller callee ftable)
  (or (and-let* ((e (or (ref ftable caller #f)
			(ref ftable (drop-plt caller) #f)
			(list #f)
			))
		 (e (car e))
		 (conn (kref e :connections))
		 (ee (any (lambda (ee) 
			    (let1 ee-name (ref ee 2)
			      (if (or (equal? ee-name callee)
				      (equal? (car (string-split ee-name #/@|\./))
					      (car (string-split callee #/@|\./))))
				  ee
				  #f)))
			  conn))
		 (e (cdddr e))
		 (file (kref e :file))
		 (line (or (kref ee :line)
			   (kref e :line)
			   ))
		 (rel (car ee)))
	;; rel
	(list (file-line0 ftable file line)))
      (list)))

(define (preview generator viewer)
  (list 
   (if-let1 f (let1 r (generator) (if (null? r) #f (car r)))
     (if (null? f)
	 #f
	 (viewer  (car f) (cadr f)))
     #f)))
(define (firefox0 file line)
  (let ((b (regexp-replace #/^\/srv\/sources/ file "http://sources/ysh"))
	(l line))
    (run-process `(firefox ,(format "~a#L:~a" b l)))))
(define (emacs0 file line)
  (run-process `(emacsclient --no-wait ,#`"+,line" ,file)
	       :redirects '((> 2 :null))))
(define (inline0 file line range)
  (define (print/prefix prefix l)
    (display prefix)
    (print l))
  (let* ((range range)
	 (lines (file->string-list file))
	 (l (- (string->number line) range))
	 (l (if (< l 0) 0 l)))
    (for-each-with-index
     (lambda (index line)
       (print/prefix #`";,(+ l index):	" line))
  (take (drop lines l) range))
(list)))

(define (inline name ftable range)
  (preview (pa$ file-line name ftable) (cute inline0 <> <> range)))
(define (inline-call caller callee ftable range)
  (preview (pa$ file-line-call caller callee ftable) (cute inline0 <> <> range)))
(define (emacs name ftable)
  (preview (pa$ file-line name ftable) emacs0))
(define (emacs-call caller callee ftable)
  (preview (pa$ file-line-call caller callee ftable) emacs0))
(define (web name ftable)
  (preview (pa$ file-line name ftable) firefox0))
(define (web-call caller callee ftable)
  (preview (pa$ file-line-call caller callee ftable) firefox0))


(define-method search ((name <string>) ftable)
  (hash-table-fold ftable (lambda (k v kdr)
			    (if (string-scan k name)
				(cons k kdr)
				kdr))
		   (list)))

(define-method search ((regexp <regexp>) ftable)
  (hash-table-fold ftable (lambda (k v kdr)
			    (if (regexp k)
				(cons k kdr)
				kdr))
		   (list)))

(define (entry-points name ftable interactive?)
  (if name
      (map
       (cute decorate <> ftable interactive?)
       (hash-table-fold ftable (lambda (k v kdr)
				 (let1 file (any (lambda (x)
						   (and (kref x :entry-point)
							(kref x :file))
						   ) v)
				   (cond
				    ((not file) kdr)
				    ((or (equal? file name)
					 (equal? (sys-basename name) (sys-basename file)))
				     (cons k kdr))
				    (else
				     kdr))))
			(list)))
      (map
       (cute decorate <> ftable interactive?)
       (hash-table-fold ftable (lambda (k v kdr)
				 (if (any (cute kref <> :entry-point) v)
				     (cons k kdr)
				     kdr))
			(list)))
      ))
(define (list-source-files ftable)
  (sort (hash-table-fold ftable (lambda (k v kdr)
				  (let1 file (any (cute kref <> :file) v)
				    (cond
				     ((not file) kdr)
				     ((not (any (lambda (e) (equal? file (cdr e))) kdr))
				      (cons (cons (sys-basename file) file) kdr))
				     (else
				      kdr))))
			 (list))
	(lambda (a b) (string< (sys-basename (car a))
			       (sys-basename (car b))))))

(define (source file)
  (for-each
   (lambda (es)
     (unless (quiet)
       (display ";; context: ")
       (write (current-file))
       (newline)
       (display ";; expression: ")
       (write es)
       (newline))
     (writeln* (callq-eval es #f))
     )
   (file->sexp-list file))
  (list))

;;
;;
;;
(define (dwarf-raw id dtable interactive?)
  (let1 r (id->es dtable id)
    (if interactive?
	(list (cons 'tree r))
	r)))
	
(define (dwarf-name name dtable interactive?)
  (list (cons 'forest
	      (map (cute dwarf-raw <> dtable #f)
		   (~ dtable 'name->ids name)))))
  
;; list-vars, list-procs
(define-method list-dwarf-types (dtable interactive?)
  (apply 
    append-map (^ (category-name category-slot) 
		  (map (cute list category-name <>) 
		       (hash-table-keys (~ dtable category-slot))))
    (values->list (unzip2 '((typedef typedef-name->ids)
			    (struct  structure_type-name->ids)
			    (union   union_type-name->ids)
			    (enum    enumeration_type-name->ids)
			    ;;
			    (pointer pointer_type-name->ids)
			    )))))

(define (field-name-of field-name dtable interactive?)
  (fold (^ (kar kdr)
	   (let* ((struct-name (cadr kar))
		  (all-members (caddr kar))
		  (fitered-members (filter (^ (elt) 
					      (equal? (car elt) field-name)) 
					   all-members)))
	     (if (null? fitered-members)
		 kdr
		 (cons struct-name kdr))))
	(list)
	(append-map (^ (elt)
		       (cdar (dwarf-type elt dtable 1 #f)))
		    (map cadr (filter (^ (elt) (memq (car elt) '(struct union)))
				      (list-dwarf-types dtable #f))))))

(define (drop-file-name name)
  ((or (#/(.*)@.*/ name)
       (^ (_) name))
       1))

(define (field-type-of field-type dtable interactive?)
  (let1  field-type (drop-file-name field-type)
    (fold (^ (kar kdr)
	     (case (car kar)
	       ('pointer 
		(if (equal? (ref kar 2) field-type)
		    (let1 base-type (drop-file-name (ref kar 1))
		      (field-type-of base-type dtable #f))
		    kdr
		    ))
	       ((struct union)
		(let* ((struct-name (cadr kar))
		       (all-members (caddr kar))
		       (fitered-members (filter (^ (elt) 
						   (equal? (cadr elt) field-type)) 
						all-members)))
		  (cond
		   ((null? fitered-members) kdr)
		   ((member struct-name kdr) kdr)
		   (else
		    (cons struct-name kdr)))))))
	  (list)
	  (append-map (^ (elt)
			 (cdar (dwarf-type elt dtable 1 #f)))
		      (map cadr (filter (^ (elt) #t)
					(list-dwarf-types dtable #f)))))))

(define (type-connection name0 name1 dtable depth interactive?)
  ;; TODO
  )

(define-method dwarf-type ((name <string>) dtable depth interactive?)
  (list 
   (cons 'forest
	 (map (lambda (id)
		(let ((cu (compile-unit-of dtable id))
		      (type (dwarf-type id dtable depth (list) interactive?)))
		  (if (and (string? cu) 
			   (list? type)
			   (not (null? type))
			   (not (null? (cdr type)))
			   (string? (cadr type)))
		      (let1 k #`",(cadr type)@,|cu|"
			(cons* (car type)
			       k
			       (cddr type)))
		      type)))
	      (append-map (cute <> dtable name) `(,typedef-name->ids
						  ,structure_type-name->ids
						  ,union_type-name->ids
						  ,base_type-name->ids
						  ,enumeration_type-name->ids
						  ;;
						  ,pointer_type-name->ids
						  ))))))

(define-method dwarf-type ((id <symbol>) dtable depth handled interactive?)
  (let1 es (id->es dtable id)
    (if (memq id handled)
	(values (list id (and es (kref es :name)))
		handled)
	(if es
	    (case (cadr es)
	      ('typedef
	       (dwarf-typedef id dtable depth handled interactive?))
	      ('structure_type
	       (dwarf-struct id dtable depth handled interactive?))
	      ('union_type
	       (dwarf-union id dtable depth handled interactive?))
	      ('base_type
	       (dwarf-base-type id dtable depth handled interactive?))
	      ('enumeration_type
	       (dwarf-enum-type id dtable depth handled interactive?))
	      ('pointer_type
	       (dwarf-pointer-type id dtable depth handled interactive?))
	      ('array_type
	       (dwarf-array-type id dtable depth handled interactive?))
	      (else
	       #?=(cadr es)
	       (values
		(cadr es)
		handled))
	      )
	    (values es
		    handled)
	    ))))

(define-method dwarf-array-type ((id <symbol>) dtable depth handled interactive?)
  (dwarf-array-type (id->es dtable id) dtable depth (cons id handled) interactive?))
(define-method dwarf-array-type ((es <list>) dtable depth handled interactive?)
  (if (< 0 depth)
      (if-let1 bid (kref (kref es :base) :ref)
	(receive (r h) (dwarf-type bid dtable (- depth 1) handled interactive?)
	  (values
	   (list 'array (kref es :name) r)
	   h))
	(values (kref es :name) handled))
      (values (kref es :name) handled)))

(define-method dwarf-pointer-type ((id <symbol>) dtable depth handled interactive?)
  (dwarf-pointer-type (id->es dtable id) dtable depth (cons id handled) interactive?))
(define-method dwarf-pointer-type ((es <list>) dtable depth handled interactive?)
  (if (< 0 depth)
      (if-let1 id (kref (kref es :base) :ref)
	(receive (r h) (dwarf-type id dtable (- depth 1) handled interactive?)
	  (values 
	   (list 'pointer (kref es :name) r)
	   h))
	(values (kref es :name) handled))
      (values (kref es :name) handled)))

(define (zip/padding padding . all)
  (if (every null? all)
      (list)
      (cons
       (map (^ (lst)
	       (if (null? lst)
		   padding
		   (car lst)))
	    all)
       (apply zip/padding padding (map (^ (lst)
					  (if (null? lst)
					      lst
					      (cdr lst)))
				       all)))))

(define (same eq lst)
  (if (null? lst)
      #t
      (if (null? (cdr lst))
	  #t
	  (and (eq? (car lst) (cadr lst))
	       (same eq (cdr lst))))))

(define (common-prefix strlist)
  (list->string 
   (map car
	(reverse 
	 (fold
	  (^ (kar kdr)
	     (if (every char? kar)
		 (if (same eq? kar)
		     (cons kar kdr)
		     kdr)
		 kdr))
	  (list)
	  (apply zip/padding #f (map string->list strlist))
	  )))))

(define (drop-prefix len strlist)
  (map (cute string-drop <> len) strlist))

(define-method dwarf-enum-type ((id <symbol>) dtable depth handled interactive?)
  (dwarf-enum-type (id->es dtable id) dtable depth (cons id handled) interactive?))
(define-method dwarf-enum-type ((es <list>) dtable depth handled interactive?)
  (values
   (cons* 'enum (kref es :name)
	  (if (< 0 depth)
	      (if-let1 enumerators (map (^ (x) (kref x :ref))  (kref es :enumerators))
		(let1 name+value (map
				  (^ (enum)
				     (let1 es (id->es dtable enum)
				       (list (kref es :name)
					     (kref es :value))))
				  enumerators)
		  (let1 names (map car name+value)
		    (let1 prefix (common-prefix names)
		      (list (let1 short-names (drop-prefix (string-length prefix) names)
			      (zip short-names (values-ref (unzip2 name+value) 1)))
			    :prefix prefix))))
		(list))
	      (list)))
   handled))

(define-method dwarf-base-type ((id <symbol>) dtable depth handled interactive?)
  (dwarf-base-type (id->es dtable id) dtable depth (cons id handled) interactive?))
(define-method dwarf-base-type ((es <list>) dtable depth handled interactive?)
  (if (< 0 depth)
      (values 
       (list 'basetype (kref es :name) :size (kref es :size))
       handled)
      (values (kref es :name) handled)))

(define-method dwarf-typedef ((id <symbol>) dtable depth handled interactive?)
  (dwarf-typedef (id->es dtable id) dtable depth (cons id handled) interactive?))
(define-method dwarf-typedef ((es <list>) dtable depth handled interactive?)
  (if (< 0 depth)
      (receive (r h) (if-let1 id (kref (kref es :base) :ref)
		       (dwarf-type id dtable (- depth 1) handled interactive?)
		       (values #f handled))
	(values (list 'typedef (kref es :name) r)
		h))
      (values
       (kref es :name)
       handled)))

(define-method dwarf-struct ((id <symbol>) dtable depth handled interactive?)
  (dwarf-struct (id->es dtable id) dtable depth (cons id handled) interactive?))

(define-method dwarf-struct ((es <list>) dtable depth handled interactive?)
  (receive (r h)
      (fold2 (^ (m r h)
		(match m
		       (`(indirect member :ref ,mid) 
			(let1 mes (id->es dtable mid)
			  (let1 tid (kref (kref mes :type) :ref)
			    (receive (r0 h0) 
				(dwarf-type tid dtable (- depth 1) h interactive?)
			      (values
			       (cons (list (kref mes :name) r0) r)
			       h0)))))
		       (else
			(values (cons #f r) h))))
	     (list)
	     handled
	     (kref es :members))
    (values
     (if (< 0 depth)
	 (list 'struct (kref es :name) (reverse r))
	 (kref es :name))
     h)))
;;
(define-method dwarf-union ((id <symbol>) dtable depth handled interactive?)
  (dwarf-union (id->es dtable id) dtable depth (cons id handled) interactive?))

(define-method dwarf-union ((es <list>) dtable depth handled interactive?)
  (receive (r h)
      (fold2 (^ (m r h)
		(match m
		       (`(indirect member :ref ,mid) 
			(let1 mes (id->es dtable mid)
			  (let1 tid (kref (kref mes :type) :ref)
			    (receive (r0 h0) 
				(dwarf-type tid dtable (- depth 1) h interactive?)
			      (values
			       (cons (list (kref mes :name) r0) r)
			       h0)))))
		       (else
			(values (cons #f r) h))))
	     (list)
	     handled
	     (kref es :members))
    (values
     (if (< 0 depth)
	 (list 'union (kref es :name) (reverse r))
	 (kref es :name))
     h)))

;;
(define (dwarf-list-compile-units dtable interactive?)
  (compile-units dtable))
;;
(define (rtable-dump table)
  (apply append (hash-table-map table (^ (k v)
					 (map
					  (^ (v0) 
					     `(=> ,k ,(ref v0 3)))
					  (delete-duplicates v))
					 ))))

(define command-handlers (list))

(define-macro (define-command name pattern action . help)
  `(set! command-handlers (cons
			   (list ',name 
				 :pattern ',pattern
				 :handler (match-lambda 
					   (,pattern ,action)
					   (else 'next))
				 :help ,(if (null? help) #f (car help))
				 )
			   command-handlers)))

;; (handler es)
;; => next
;; => (...)
(define (callq-eval es env)
  (let loop ((command-handlers command-handlers))
    (if (null? command-handlers)
	(begin (print #`";; unknown command: ,(car es)")
	       (list #f))
	(let1 r ((kref (car command-handlers) :handler) es)
	  (if (eq? r 'next)
	      (loop (cdr command-handlers))
	      r)))))

(define (help cmd)
  (define (help-all)
    (map 
     (lambda (h) 
       `(help ,(car h) :pattern ,(kref h :pattern) :help ,(kref h :help)))
     command-handlers))
  (if cmd
      (filter (lambda (e) (eq? (cadr e) cmd)) (help-all))
      (sort (delete-duplicates (map cadr (help-all))) 
	    (lambda (a b) (string<? (symbol->string a) (symbol->string b))))
      ))

(define-command help ('help) (help #f) "List all commands")
(define-command help ('help (? symbol? s)) (help s) "Show syntax of commands")
(define-command source ('source (? string? file)) (source file))
(define-command load ('load (? string? file)) (load-objfile file))
(define-command load ('load 'all) (load-objfile-all))
(define-command switch ('switch (? string? file)) (switch-objfile file))
(define-command with ('with file code) (let1 old-file (current-file)
					 (switch-objfile file)
					 (begin0 (callq-eval code #f)
						 (switch-objfile old-file))))
(define-command list-objfiles ('list-objfiles) 
  (list-objfiles :loaded-only #f))
(define-command list-objfiles ('list-objfiles :loaded-only loaded-only) 
  (list-objfiles :loaded-only loaded-only))
(define-command source-files ('source-files) (list-source-files (current-ftable)))

(define-command desc ('desc (? string? name)) (desc (undecorate name) (current-ftable)))
(define-command desc ('? (? string? name)) (desc (undecorate name) (current-ftable)))

(define-command file-line ('file-line (? string? name)) (file-line (undecorate name) (current-ftable)))
(define-command file-line (': (? string? name)) (file-line (undecorate name) (current-ftable)))
(define-command file-line 
  ('file-line (? string? caller) (? string? callee)) 
  (file-line-call (undecorate caller)
		  (undecorate callee)
		  (current-ftable)))
(define-command file-line 
  (': (? string? caller) (? string? callee)) 
  (file-line-call (undecorate caller)
		  (undecorate callee)
		  (current-ftable)))


(define-command inline ('inline (? string? name))
  (inline (undecorate name) (current-ftable) 3))
(define-command inline ('l (? string? name)) 
  (inline (undecorate name) (current-ftable) 3))
(define-command inline ('inline (? string? name) (? integer? range))
  (inline (undecorate name) (current-ftable) range))
(define-command inline ('l (? string? name) (? integer? range)) 
  (inline (undecorate name) (current-ftable) range))

(define-command inline
  ('inline (? string? caller) (? string? callee)) 
  (inline-call (undecorate caller) (undecorate callee) (current-ftable) 3))
(define-command inline
  ('l (? string? caller) (? string? callee))
  (inline-call (undecorate caller) (undecorate callee) (current-ftable) 3))
(define-command inline
  ('inline (? string? caller) (? string? callee) (? integer? range)) 
  (inline-call caller (undecorate callee) (current-ftable) range))
(define-command inline
  ('l (? string? caller) (? string? callee) (? integer? range))
  (inline-call (undecorate caller) (undecorate callee) (current-ftable) range))


(define-command emacs ('emacs (? string? name)) (emacs (undecorate name) (current-ftable)))
(define-command emacs ('j (? string? name)) (emacs (undecorate name) (current-ftable)))
(define-command emacs 
  ('emacs (? string? caller) (? string? callee))
  (emacs-call (undecorate caller) (undecorate callee) (current-ftable)))
(define-command emacs
  ('j (? string? caller) (? string? callee))
  (emacs-call (undecorate caller) (undecorate callee) (current-ftable)))

(define-command web ('web (? string? name)) (web (undecorate name) (current-ftable)))
(define-command web ('u (? string? name)) (web (undecorate name) (current-ftable)))
(define-command web 
  ('web (? string? caller) (? string? callee)) 
  (web-call (undecorate caller) (undecorate callee) (current-ftable)))
(define-command web 
  ('u (? string? caller) (? string? callee)) 
  (web-call (undecorate caller) (undecorate callee) (current-ftable)))

(define-command search ('search (? string? name)) (search (undecorate name) (current-ftable)))
(define-command search ('search (? regexp? name)) (search name (current-ftable)))
(define-command search ('* (? string? name)) (search (undecorate name) (current-ftable)))
(define-command search ('* (? regexp? name)) (search name (current-ftable)))

(define-command dump ('dump) (rtable-dump (current-rtable)))


(define-command callers ('< (? string? name)) 
  (callers* (undecorate name) (current-rtable) #t 1 (list)))
(define-command callers ('callers (? string? name)) 
  (callers* (undecorate name) (current-rtable) #t 1 (list)))
(define-command callers ('< (? string? name) depth) 
  (callers* (undecorate name) (current-rtable) #t depth (list)))
(define-command callers ('callers (? string? name) depth) 
  (callers* (undecorate name) (current-rtable) #t depth (list)))

(define-command callers ('< (? string? name) '! (? list? excludes)) 
  (callers* (undecorate name) (current-rtable) #t 1 excludes))
(define-command callers ('callers (? string? name) '! (? list? excludes)) 
  (callers* (undecorate name) (current-rtable) #t 1 excludes))
(define-command callers ('< (? string? name) depth '! (? list? excludes))
  (callers* (undecorate name) (current-rtable) #t depth excludes))
(define-command callers ('callers (? string? name) depth '! (? list? excludes)) 
  (callers* (undecorate name) (current-rtable) #t depth excludes))


(define-command callees ('> (? string? name)) 
  (callees* (undecorate name) (current-ftable) #t 1 (list)))
(define-command callees ('callees (? string? name)) 
  (callees* (undecorate name) (current-ftable) #t 1 (list)))
(define-command callees ('> (? string? name) depth) 
  (callees* (undecorate name) (current-ftable) #t depth (list)))
(define-command callees ('callees (? string? name) depth) 
  (callees* (undecorate name) (current-ftable) #t depth (list)))

(define-command callees ('> (? string? name) '! (? list? excludes)) 
  (callees* (undecorate name) (current-ftable) #t 1 excludes))
(define-command callees ('callees (? string? name) '! (? list? excludes)) 
  (callees* (undecorate name) (current-ftable) #t 1 excludes))
(define-command callees ('> (? string? name) depth '! (? list? excludes)) 
  (callees* (undecorate name) (current-ftable) #t depth excludes))
(define-command callees ('callees (? string? name) depth '! (? list? excludes)) 
  (callees* (undecorate name) (current-ftable) #t depth excludes))


(define-command chained? ('chained? from to) (chained? (undecorate from)
						     (undecorate to)
						     (current-rtable) #t 1))
(define-command chained? ('chained? from to  depth) (chained? (undecorate from)
							    (undecorate to)
							    (current-rtable) #t depth))
(define-command chained? ('<> from to) (chained? (undecorate from)
					     (undecorate to)
					     (current-rtable) #t 1))
(define-command chained? ('<> from to  depth) (chained? (undecorate from)
						    (undecorate to)
						    (current-rtable) #t depth))

(define-command transit ('transit from to) 
  (transit (undecorate from) 
	   (undecorate to)
	   (current-ftable) (current-rtable) #t #t))
(define-command transit ('transit from to  depth) 
  (transit (undecorate from) 
	   (undecorate to)
	   (current-ftable) (current-rtable) #t depth))
(define-command transit ('<*> from to) (transit (undecorate from)
						(undecorate to)
						(current-ftable) (current-rtable) #t #t))
(define-command transit ('<*> from to  depth) (transit (undecorate from)
						       (undecorate to)
						       (current-ftable) (current-rtable) #t depth))

(define-command entry-points ('entry-points) (entry-points #f (current-ftable) #t))
(define-command entry-points ('$) (entry-points #f (current-ftable) #t))
(define-command externs ('externs (? string? name)) (entry-points name (current-ftable) #t))
(define-command externs ('$ (? string? name)) (entry-points name (current-ftable) #t))


(define-command dwarf ('dwarf (? symbol? id)) (dwarf-raw id (current-dtable) #t))
(define-command dwarf ('dwarf (? string? name)) (dwarf-name name (current-dtable) #t))

(define-command list-types ('list-types) (list-dwarf-types (current-dtable) #t))
(define-command type ('type #t) (list-dwarf-types (current-dtable) #t))
(define-command type ('type) (list-dwarf-types (current-dtable) #t))
(define-command type ('type (? string? name)) (dwarf-type name (current-dtable) 1 #t))
(define-command type ('type (? string? name) (? integer? depth)) (dwarf-type name (current-dtable) depth #t))
(define-command type ('type (? string? name0) (? string? name1) (? integer? depth)) 
  (type-connection name0 name1 (current-dtable) depth #t))

(define-command field-name-of ('field-name-of (? string? field-name))
  (field-name-of field-name (current-dtable) #t))
(define-command field-type-of ('field-type-of (? string? field-type))
  (field-type-of field-type (current-dtable) #t))

(define-command list-compile-units ('list-compile-units) (dwarf-list-compile-units (current-dtable) #t))
(define-command list-compile-units ('list-srcfiles) (dwarf-list-compile-units (current-dtable) #t))
;;(define-command freachable ('type name) (dwarf-type name (current-dtable) 1 #t))
;;(define-command treachable ('type name (? integer? depth)) (dwarf-type name (current-dtable) depth #t))

(define (set-quiet s) (quiet s) '())
(define-command quiet ('quiet) (set-quiet #t))
(define-command print  ('print str) `((message ,str)))

(define print-handlers (list))
(define-macro (define-printer name printer)
  `(set! print-handlers (cons
			 (cons ',name ,printer)
			 print-handlers)))

(define (callq-print0 interactive? es)
  (cond
   ((null? es)
    es					; do noething
    )
   ((list? es)
    (let* ((name (car es))
	   (handler (assq-ref print-handlers name #f)))
      (if handler
	  (handler interactive? (car es) (cdr es))
	  (write es))))
   (else
    (write es))))

(define (callq-print interactive? es . rest)
  (with-output-to-port (current-output-port)
    (lambda ()
      (cond
       ((not es) 
	es				; do nothing
	)
       ((integer? es) 
	(exit es))
       ((list? es)
	(for-each (lambda (es0) 
		    (callq-print0 interactive? es0)
		    (newline))
		  es))
       (else
	(write es)
	(newline)
	)))))

(define (writeln* ess)
  (callq-print #f ess))


(define-printer help 
  (lambda (interactive? kar kdr)
    (format #t #`",(kref kdr :pattern); ,(kref kdr :help)")
    ))

(define (callq-pretty-print obj . opt)
  (apply pretty-print 
	 (let loop ((obj obj))
	   (cond
	    ((keyword? obj)
	     (string->symbol (format "~s" obj)))
	    ((symbol? obj)
	     (let1 str (x->string obj)
	       (if (#/^0x.*/ str)
		   (string->symbol (format "~s" obj))
		   obj)))
	    ((pair? obj)
	     (cons (loop (car obj)) (loop (cdr obj))))
	    (else
	     obj)))
	 opt))


(define-printer forest
  (lambda (interactive? kar kdr)
    (let1 len (length kdr)
      (for-each-with-index 
       (^ (index tree)
	  (format #t #`";; ,(+ index 1)/,|len|\n")
	  (callq-pretty-print tree))
       kdr))))
(define-printer tree
  (lambda (interactive? kar kdr)
    (callq-pretty-print kdr)))

(define-printer objfile
  (lambda (interactive? kar kdr)
    (if (list? (cadr kdr))
	(format #t #`"	,(car kdr) => ,(caadr kdr)")
	(format #t #`"	,(car kdr) => ,(cadr kdr)"))))

(define-printer message
  (lambda (interactive? kar kdr)
    (display (car kdr))))

(define callq-read read)

;; timeout, plugin output routine, plugin input
(define (print-usage name status)
  (print "Usage: ")
  (print #`"	,|name| -h|--help")
  (print #`"	,|name| [--batch] [-s|--script|--source SCRIPT]...")
  (print #`"	,|name| [-s|--script|--source SCRIPT]... [-l|--load BINARY]...")
  (exit status))

(define (expected-length lst len)
  (if (null? lst)
      (if (< 0 len)
	  #f
	  #t)
      (expected-length (cdr lst) (- len 1))))

(define (repl batch)
  (read-eval-print-loop callq-read
			callq-eval
			(pa$ callq-print (not batch))
			(lambda () 
			  (with-output-to-port (current-error-port)
			    (lambda ()
			      (display (if batch "" #`"[,(current-file)]? "))
			      (flush))))))
(define (main args)
  (let-args (cdr args)
      ((help   "h|help" => (pa$ print-usage (car args) 0))
       (script "s|script|source=s" => (pa$ source))
       (load   "l|load=s" => (pa$ load-objfile))
       (batch  "b|batch")
       . rest)
    (when batch
      (exit 0))
    (for-each load-objfile rest)
    (repl batch)
    (newline)))
