#!/bin/sh
#| -*- scheme -*- |#
:; exec gosh -- $0 "$@"

(use srfi-1)
(use srfi-13)
(use util.match)
(use util.list)
(use gauche.process)
(use gauche.parameter)
(use file.util)
(use gauche.parseopt)

(debug-print-width #f)
(define blacklist 
  (list
   #/^__dso_handle.*/			;???
   #/^__FUNCTION__\..*/
   #/^__PRETTY_FUNCTION__\..*/
   #/^__libc_csu_init$/
   #/^__do_global_ctors_aux$/
   #/^_start$/
   #/^call_gmon_start$/
   #/^__do_global_dtors_aux$/
   #/^frame_dummy$/
   #/^_start$/
   ))

(define tables (make-hash-table 'equal?))
(define current-file (make-parameter #f))
(define current-ftable (make-parameter #f))
(define current-rtable (make-parameter #f))
(define (table? t) (list? t))

(define (list-files)
  (hash-table-map tables
		  (lambda (k v)
		    (list k (if (table? v)
				(ref v 2)
				v)))))

(define (select-file name)
  (let1 table (ref tables name #f)
    (cond
     ((table? table)
      (current-file name)
      (current-ftable (ref table 0))
      (current-rtable (ref table 1))
      (list #t))
     (else
      (error "Not loaded yet: " name)))))
	

(define (load-file file)
  (call-with-input-process `(callp ,file)
    (lambda (input)
      (receive (ftable rtable so)
	  (load-entries (read-line input))
	(set! (ref tables (sys-basename file))
	      (list ftable rtable file))
	(select-file (sys-basename file))
	(for-each
	 (lambda (s) 
	   (unless (ref tables s #f)
		   (set! (ref tables s) 'UNSOLVED)))
	 so))
      (list))))

(define (load-entries file)
  (define (acceptable? entry)
    (not (any (lambda (r) (r entry)) blacklist)))
  (define (wash! es)
    (let1 connections (fold-right 
		       (lambda (entry0 kdr)
			 (let1 entry (ref entry0 2)
			   (if (acceptable? entry)
			       (cons entry0 kdr)
			       kdr)))
		       (list)
		       (delete-duplicates 
			(cadr (memq :connections es))))
      (set! (cadr (memq :connections es)) connections)))
  (with-input-from-file file
    (lambda ()
      (let loop ((es (read))
		 (ftable (make-hash-table 'equal?))
		 (rtable (make-hash-table 'equal?))
		 (so (list)))
	  (if (eof-object? es)
	      (values ftable rtable so)
	      (cond
	       ((and (eq? (car es) 'objdump-dcall)
		     (eq? (cadr es) 'entry))
		(wash! es)
		  (for-each
		   (lambda (entry)
		     (hash-table-push! rtable entry es))
		   (delete-duplicates
		    (map
		     (cute ref <> 2)
		     (cadr (memq :connections es)))))
		  (when (acceptable? (ref es 3))
			(hash-table-push! ftable (ref es 3) es))
		  (loop (read) ftable rtable so))
	       ((eq? (car es) 'readelf-so)
		(loop (read) ftable rtable (append (cdr es) so)))
	       (else
		(loop (read) ftable rtable so))))))))

(define (find-callers sym table)
  (define (build kar l)
    `(,(if kar 
	   kar
	   (if (cadr (memq :variable? l))
	       'v
	       'f))
	   ,(ref l 3)
	   :file ,(cadr (memq :file l)) 
	   :line ,(cadr (memq :line l))
	   ))
  (cond
   ((ref table sym #f) => (cute map (cute build #f <>) <>))
   (else
    (let1 sym-len (string-length sym)
	  (hash-table-fold table (lambda (k v kdr)
				   (if (and (string-prefix? sym k)
					    (memq (string-ref k sym-len)
						  '(#\@ #\.)))
				       (append (map (cute build 'x <>) v) kdr)
				       kdr))
			   (list))))))

(define (find-callees sym table)
  (if-let1 ess (ref table sym #f)
	   (append-map
	    (lambda (es)
	      (let1 connections (cadr (memq :connections es))
		(map (lambda (name)
		       (if-let1 callee-ess (ref table name #f)
				(append-map
				 (lambda (callee-es)
				   `(,(if (cadr (memq :variable? callee-es))
					  'v
					  'f) 
				     ,(ref callee-es 3)
				     :file ,(cadr (memq :file callee-es))
				     :line ,(cadr (memq :line callee-es))
				     #;:caller #;(,(ref es 2) 
					      :file ,(cadr (memq :file es))
					      :line ,(cadr (memq :line es))))
				   )
				 callee-ess)
				`(x ,name)))
		     (map (cute ref <> 2) connections))))
	    ess)
	   (list)))

(define (writeln es)
  (write es)
  (newline)
  ;(print es)
  )
(define (writeln* ess)
  (for-each
   writeln
   ess))

(define (forward-reachable? from to ftable)
  (list #f))
(define (backward-reachable? from to ftable)
  (list #f))

(define (decorate name table interactive?)
  (if interactive?
      #`",(if (variable? name table) '= '|| ),|name|,(if (variable? name table) '|| '() )"
      name))

(define (callers* name rtable interactive? depth)
  (hash-table-map
   (let loop ((current-callers (map
				(cute ref <> 1)
				(find-callers name rtable)))
	      (total-callers (make-hash-table 'equal?))
	      (path (list name))
	      (depth depth))
     (when (or (and (boolean? depth) depth)
	       (and (integer? depth) (< 0 depth)))
       (for-each
	(lambda (caller)
	  (unless (member caller path)
	    (let* ((xpath (cons caller path))
		   (v (hash-table-get total-callers caller #f)))
	      (unless (and v (member xpath v)) ; necessary
                (hash-table-push! total-callers caller 
				  xpath)
		(loop (map
		       (cute ref <> 1)
		       (find-callers caller rtable))
		      total-callers
		      xpath
		      (if (integer? depth) (- depth 1) depth)
		    )))))
	current-callers))
     total-callers)
   (lambda (a b)
     (cons (decorate a rtable interactive?)
	   (map
	    (lambda (x)
	      (map (cute decorate <> rtable interactive?) x))
	    b))
     )))

(define (callees* name ftable interactive? depth)
  (hash-table-map
   (let loop ((current-callees (map
				(cute ref <> 1)
				(find-callees name ftable)))
	      (total-callees (make-hash-table 'equal?))
	      (path (list name))
	      (depth depth))
     (when (or (and (boolean? depth) depth)
	       (and (integer? depth) (< 0 depth)))
       (for-each
	(lambda (callee)
	  (unless (member callee path)
	    (let* ((xpath (cons callee path))
		   (v (hash-table-get total-callees callee #f)))
	      (unless (and v (member xpath v)) 
		(hash-table-push! total-callees callee 
				  xpath)
		(loop (map
		       (cute ref <> 1)
		       (find-callees callee ftable))
		      total-callees
		      xpath
		      (if (integer? depth) (- depth 1) depth))))))
	current-callees))
     total-callees)
   (lambda (a b)
     (cons (decorate a ftable interactive?) 
	   (map
	    (lambda (x)
	      (map (cute decorate <> ftable interactive?)
		   x))
	    (map reverse b))))))

(define (reachable? from to rtable interactive? depth)
  (delete-duplicates 
   (or (let1 callers-from (callers* from rtable #f depth)
	     (if-let1 found (assoc-ref  callers-from to #f)
		      (map
		       (lambda (f)
			 (map (cute decorate <> rtable interactive?)
			      f))
		       found)
		      #f))
       (let1 callers-to (callers* to rtable #f depth)
	     (if-let1 found (assoc-ref  callers-to from #f)
		      (map
		       (lambda (f)
			 (map (cute decorate <> rtable interactive?)
			      f))
		       found)
		      #f))
       (list #f))))

(define (transit from to ftable rtable interactive? depth)
  (define (decorate* tree)
    (map (lambda (t) (map (cute decorate <> rtable interactive?) t)) 
	 tree))
  (delete-duplicates
   (let1 r (reachable? from to rtable #f depth)
	 (if (equal? r (list #f))
	     (let1 commons (append (let* ((callers-from (callers* from rtable #f depth))
					  (callers-to (callers* to rtable #f depth))
					  (common-callers (lset-intersection equal? 
									     (map car callers-from)
									     (map car callers-to))))
				     (if (null? common-callers)
					 (list)
					 (map
					  (lambda (common-caller)
					    `(common-caller ,common-caller
							    :from ,(decorate*
								    (delete-duplicates 
								     (assoc-ref callers-from common-caller)))
							    :to ,(decorate*
								  (delete-duplicates
								   (assoc-ref callers-to common-caller))))
					    )
					  common-callers)))
				   (let* ((callees-from (callees* from ftable #f depth))
					  (callees-to (callees* to ftable #f depth))
					  (common-callees (lset-intersection equal? 
									     (map car callees-from)
									     (map car callees-to))))
				     (if (null? common-callees)
					 (list)
					 (map
					  (lambda (common-callee)
					    `(common-callee ,common-callee
							    :from ,(decorate*
								    (delete-duplicates
								     (assoc-ref callees-from common-callee)))
							    :to ,(decorate* 
								  (delete-duplicates
								   (assoc-ref callees-to common-callee))))
					    )
					  common-callees))))
		   (if (null? commons)
		       (list #f)
		       commons))
	     r))))

(define (variable? name table)
  (let1 entry (ref table name #f)
    (if entry
	(cadr (memq :variable? (car entry)))
	#f)))

(define (desc name ftable)
  (ref ftable name (list #f)))

(define (kref es k)
  (cadr (or (memq k es)
	    (list k #f))))

(define (fline name ftable)
  (or (and-let* ((e (car (ref ftable name (list #f))))
	     (e (cdddr e))
	     (file (kref e :file))
	     (line (kref e :line)))
	`(,#`",|file|:,|line|")))
  (list #f))

(define (search name ftable)
  (hash-table-fold ftable (lambda (k v kdr)
			    (if (string-scan k name)
				(cons k kdr)
				kdr))
		   (list)))

(define (path->dists path)
  (rxmatch-if (#/^\/srv\/debugs(\/sources\/[a-zA-Z0-9]\/[^\/]+)(\/[^\/]+).*/ path)
      (#f head rv)
    (fold
     (lambda (entry kdr)
       (let1 r (sys-readlink entry)
	 (if (equal? r #`".,|rv|")
	     (cons ((#/^\^alias-(.*)/ (sys-basename entry)) 1) kdr)
	     kdr)))
     (list)
     (glob #`"/srv/sources,|head|/^alias-*"))
    #f))

(define (list-loadable name)
  ;; c/p/vr
  (glob-fold "/srv/debugs/sources/*/*/*/plugins/O0g3/root"
	     (lambda (entry kdr)
	       (append 
		;; Handle goache's bug. May be fixed in F15.
		(directory-fold entry
				(lambda (path seed)
				  (if (equal? (sys-basename path) name)
				      (cons (list path 
						  (map string->symbol (path->dists path))
						  ) seed)
				      seed))
				(list)
				)
		kdr))
	       (list)))

(define (entry-points ftable interactive?)
  (map
   (cute decorate <> ftable interactive?)
   (hash-table-fold ftable (lambda (k v kdr)
			     (if (any (cute kref <> :entry-point) v)
				 (cons k kdr)
				 kdr))
		    (list))))


(define (source file)
  (for-each
   (lambda (es)
     (display ";; context: ")
     (write (current-file))
     (newline)
     (display ";; expression: ")
     (write es)
     (newline)
     (writeln* (callq-eval es #f))
     (newline)
     )
   (file->sexp-list file))
  (list))

(define handlers (list))

(define-macro (define-command pattern action)
  `(set! handlers (cons
		   (cons ',pattern
			 (match-lambda 
			     (,pattern ,action)
			    (else 'next)))
		   handlers)))
(define (callq-eval es env)
  (let loop ((handlers handlers))
    (if (null? handlers)
	(begin (print #`";; unknown command: ,(car es)")
	       (list #f))
	(let1 r ((cdr (car handlers)) es)
	  (if (eq? r 'next)
	      (loop (cdr handlers))
	      r)))))

(define-command ('help) (map car handlers))
(define-command ('source (? string? file)) (source file))
(define-command ('load (? string? file)) (load-file file))
(define-command ('select (? string? file)) (select-file file))
(define-command ('list-files) (list-files))
(define-command ('list-loadable (? string? name)) (list-loadable name))

(define-command ('desc (? string? name)) (desc name (current-ftable)))
(define-command ('? (? string? name)) (fline name (current-ftable)))
(define-command ('search (? string? name)) (search name (current-ftable)))
(define-command ('dump-table) (rtable-dump (current-rtable)))
(define-command ('< (? string? name)) (callers* name (current-rtable) #t 1))
(define-command ('callers (? string? name)) (callers* name (current-rtable) #t 1))
(define-command ('< (? string? name) depth) (callers* name (current-rtable) #t depth))
(define-command ('callers (? string? name) depth) (callers* name (current-rtable) #t depth))

(define-command ('> (? string? name)) (callees* name (current-ftable) #t 1))
(define-command ('callees (? string? name)) (callees* name (current-ftable) #t 1))
(define-command ('> (? string? name) depth) (callees* name (current-ftable) #t depth))
(define-command ('callees (? string? name) depth) (callees* name (current-ftable) #t depth))

(define-command ('reachable? from to) (reachable? from to (current-rtable) #t 1))
(define-command ('reachable? from to  depth) (reachable? from to (current-rtable) #t depth))
(define-command ('transit from to) (transit from to (current-ftable) (current-rtable) #t #t))
(define-command ('transit from to  depth) (transit from to (current-ftable) (current-rtable) #t depth))
(define-command ('entry-points) (entry-points (current-ftable) #t))

(define (rtable-dump table)
  (apply append (hash-table-map table (lambda (k v)
					(map
					 (lambda (v0) 
					   `(=> ,k ,(ref v0 3)))
					 (delete-duplicates v))
					))))

;; timeout, plugin output routine, plugin input
(define (print-usage name status)
  (print "Usage: ")
  (print #`"	,|name| -h|--help")
  (print #`"	,|name| [--batch] [-s|--script|--source SCRIPT]... [-l|--load BINARY]...")
  (exit status))

(define (main args)
  (let-args (cdr args)
      ((help   "h|help" => (pa$ print-usage (car args) 0))
       (script "s|script|source=s" => (pa$ source))
       (load   "l|load=s" => (pa$ load-file))
       (batch  "b|batch")
       . rest)
    (when batch
      (exit 0))
    (for-each load-file rest)
    (read-eval-print-loop read
			  (cute callq-eval <> <>)
			  writeln*
			  (lambda () 
			    (with-output-to-port (current-error-port)
			      (lambda ()
				(display (if batch "" #`"[,(current-file)]? "))
				(flush)))))
    (newline)))
