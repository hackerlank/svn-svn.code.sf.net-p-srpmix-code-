#!/bin/sh
#| -*- scheme -*- |#
:; exec gosh -- $0 "$@"

(use srfi-1)
(use srfi-13)
(use util.match)
(use util.list)
(use gauche.process)
(use gauche.parameter)
(use file.util)
(use gauche.parseopt)
(use gauche.sequence)

(debug-print-width #f)

(define (kref es k)
  (cadr (or (memq k es)
	    (list k #f))))

(define objfiles (make-hash-table 'equal?))
(define (table? t) (and (list? t)
			(not (null? t))
			(eq? (car t) 'table)))
(define (make-table ftable rtable dtable objpath)
  (list 'table ftable rtable dtable objpath))
(define (ref-ftable table)
  (ref table 1))
(define (ref-rtable table)
  (ref table 2))
(define (ref-dtable table)
  (ref table 3))
(define (ref-objpath table)
  (ref table 4))

(define (list-objfiles . args)
  (if (kref args :loaded-only)
      (hash-table-fold objfiles
		       (lambda (k v kdr)
			 (if (table? v)
			     (cons
			      `(objfile 
				,k ,(ref-objpath v))
			      kdr)
			     kdr))
		       (list))
      (hash-table-map objfiles
		      (lambda (k v)
			`(objfile 
			  ,k ,(if (table? v)
				  (ref-objpath v)
				  v))))))

(define current-file (make-parameter #f))
(define current-path (make-parameter #f))
(define current-ftable (make-parameter #f))
(define current-rtable (make-parameter #f))
(define current-dtable (make-parameter #f))

(define (switch-objfile name)
  (let1 table (ref objfiles name #f)
    (cond
     ((table? table)
      (current-file name)
      (current-ftable (ref-ftable table))
      (current-rtable (ref-rtable table))
      (current-dtable (ref-dtable table))
      (current-path (ref-objpath table))
      (list #t))
     (else
      (error "Not loaded yet: " name)))))
	

(define (load-objfile0 file)
	(let* ((m (#/\/srv\/debugs\/dists\/([^\/]+)/ file))
	       (d (if m (m 1) #f))
	       (inventory (if d 
			      (file->list 
			       read
			       #`"/srv/debugs/dists/,|d|/plugins/O0g3/INVENTORY.es")
			      #f)))
	  (call-with-input-process `(callp ,file)
	    (lambda (input)
	      (receive (ftable rtable dtable so)
		  (load-entries (read-line input))
		(set! (ref objfiles (sys-basename file))
		      (make-table ftable rtable dtable file))
		(switch-objfile (sys-basename file))
		(for-each
		 (lambda (s) 
		   (unless (ref objfiles s #f)
		     (set! (ref objfiles s) 
			   (or (and-let* (inventory (l (assoc-ref inventory s #f)))
				 `(LOADABLE ,#`"/srv/debugs/dists/,|d|/plugins/O0g3/root,l"))
			       'UNSOLVED))))
		 so))
	      (list)))))

(define (load-objfile file)
  (if (equal? (sys-basename file) file)
      (load-objfile0 (let1 l (ref objfiles file #f)
		       (if (and (list? l)
				(not (null? l))
				(eq? (car l) 'LOADABLE))
			   (cadr l)
			   file)))
		     
      (load-objfile0 file)
      ))


(define (in-blacklist? name)
  (any (lambda (r) (r name))
       (list
	#/^__dso_handle.*/			;???
	#/^__FUNCTION__\..*/
	#/^__PRETTY_FUNCTION__\..*/
	#/^__libc_csu_init$/
	#/^__do_global_ctors_aux$/
	#/^_start$/
	#/^call_gmon_start$/
	#/^__do_global_dtors_aux$/
	#/^frame_dummy$/
	#/^_start$/
	)))

(define (load-entries file)
  (define (acceptable? entry)
    (not (in-blacklist? entry)))
  (define (wash! es)
    (let1 connections (fold-right 
		       (lambda (entry0 kdr)
			 (let1 entry (ref entry0 2)
			   (if (acceptable? entry)
			       (cons entry0 kdr)
			       kdr)))
		       (list)
		       (delete-duplicates 
			(cadr (memq :connections es))))
      (set! (cadr (memq :connections es)) connections)))
  (with-input-from-file file
    (lambda ()
      (let loop ((es (read))
		 (ftable (make-hash-table 'equal?))
		 (rtable (make-hash-table 'equal?))
		 (dtable (make-hash-table 'equal?))
		 (so (list)))
	  (if (eof-object? es)
	      (values ftable rtable dtable so)
	      (cond
	       ((and (eq? (car es) 'objdump-dcall)
		     (eq? (cadr es) 'entry))
		(wash! es)
		  (for-each
		   (lambda (entry)
		     (hash-table-push! rtable entry es))
		   (delete-duplicates
		    (map
		     (cute ref <> 2)
		     (cadr (memq :connections es)))))
		  (when (acceptable? (ref es 3))
			(hash-table-push! ftable (ref es 3) es))
		  (loop (read) ftable rtable dtable so))
	       ((eq? (car es) 'readelf-so)
		(loop (read) ftable rtable dtable (append (cdr es) so)))
	       ;;
	       ((eq? (car es) 'libdwarves)
		(case (cadr es)
		  ('compile_unit
		   (loop (read) ftable rtable dtable so))
		  (else
		   (set! (ref dtable (kref es :id)) (list es))
		   (if-let1 name (kref es :name)
			    (begin
			      (unless (ref dtable name #f)
				(set! (ref dtable name) (list)))
			      (unless (member es (ref dtable name))
				(push! (ref dtable name) es))))
		   (loop (read) ftable rtable dtable so)
		   )))
	       ;;
	       (else
		(loop (read) ftable rtable dtable so))))))))

(define (find-callers sym table)
  (define (build kar l)
    `(,(if kar 
	   kar
	   (if (cadr (memq :variable? l))
	       'v
	       'f))
      ,(ref l 3)
      :file ,(cadr (memq :file l)) 
      :line ,(cadr (memq :line l))
      ))
  (cond
   ((ref table sym #f) => (cute map (cute build #f <>) <>))
   (else
    (hash-table-fold 
     table 
     (lambda (k v kdr)
       (if (and (string-prefix? sym k)
		(memq (string-ref k (string-length sym))
		      '(#\@ #\.)))
	   (append (map (cute build 'x <>) v) kdr)
	   kdr))
     (list)))))

(define (drop-plt sym)
  (car (string-split sym #\@)))

(define (find-callees sym table)
  (if-let1 ess (or (ref table sym #f)
		   (ref table (drop-plt sym) #f))
	   (append-map
	    (lambda (es)
	      (let1 connections (cadr (memq :connections es))
		(map (lambda (name)
		       (if-let1 callee-ess (ref table name #f)
				(append-map
				 (lambda (callee-es)
				   `(,(if (cadr (memq :variable? callee-es))
					  'v
					  'f) 
				     ,(ref callee-es 3)
				     :file ,(cadr (memq :file callee-es))
				     :line ,(cadr (memq :line callee-es))
				     #;:caller #;(,(ref es 2) 
					      :file ,(cadr (memq :file es))
					      :line ,(cadr (memq :line es))))
				   )
				 callee-ess)
				`(x ,name)))
		     (map (cute ref <> 2) connections))))
	    ess)
	   (list)))

(define (forward-reachable? from to ftable)
  (list #f))
(define (backward-reachable? from to ftable)
  (list #f))

(define (decorate name table interactive?)
  (if interactive?
      #`",(if (variable? name table) '= '|| ),|name|,(if (variable? name table) '|| '() )"
      name))
(define (undecorate name)
  (regexp-replace #/^=/ (regexp-replace #/\(\)$/ name "") ""))


(define (callers* name rtable interactive? depth)
  (hash-table-map
   (let loop ((current-callers (map
				(cute ref <> 1)
				(find-callers name rtable)))
	      (total-callers (make-hash-table 'equal?))
	      (path (list name))
	      (depth depth))
     (when (or (and (boolean? depth) depth)
	       (and (integer? depth) (< 0 depth)))
       (for-each
	(lambda (caller)
	  (unless (member caller path)
	    (let* ((xpath (cons caller path))
		   (v (hash-table-get total-callers caller #f)))
	      (unless (and v (member xpath v)) ; necessary
                (hash-table-push! total-callers caller 
				  xpath)
		(loop (map
		       (cute ref <> 1)
		       (find-callers caller rtable))
		      total-callers
		      xpath
		      (if (integer? depth) (- depth 1) depth)
		    )))))
	current-callers))
     total-callers)
   (lambda (a b)
     (cons (decorate a rtable interactive?)
	   (map
	    (lambda (x)
	      (map (cute decorate <> rtable interactive?) x))
	    b))
     )))

(define (callees* name ftable interactive? depth)
  (hash-table-map
   (let loop ((current-callees (map
				(cute ref <> 1)
				(find-callees name ftable)))
	      (total-callees (make-hash-table 'equal?))
	      (path (list name))
	      (depth depth))
     (when (or (and (boolean? depth) depth)
	       (and (integer? depth) (< 0 depth)))
       (for-each
	(lambda (callee)
	  (unless (member callee path)
	    (let* ((xpath (cons callee path))
		   (v (hash-table-get total-callees callee #f)))
	      (unless (and v (member xpath v)) 
		(hash-table-push! total-callees callee 
				  xpath)
		(loop (map
		       (cute ref <> 1)
		       (find-callees callee ftable))
		      total-callees
		      xpath
		      (if (integer? depth) (- depth 1) depth))))))
	current-callees))
     total-callees)
   (lambda (a b)
     (cons (decorate a ftable interactive?) 
	   (map
	    (lambda (x)
	      (map (cute decorate <> ftable interactive?)
		   x))
	    (map reverse b))))))

(define (reachable? from to rtable interactive? depth)
  (delete-duplicates 
   (or (let1 callers-from (callers* from rtable #f depth)
	     (if-let1 found (assoc-ref  callers-from to #f)
		      (map
		       (lambda (f)
			 (map (cute decorate <> rtable interactive?)
			      f))
		       found)
		      #f))
       (let1 callers-to (callers* to rtable #f depth)
	     (if-let1 found (assoc-ref  callers-to from #f)
		      (map
		       (lambda (f)
			 (map (cute decorate <> rtable interactive?)
			      f))
		       found)
		      #f))
       (list #f))))

(define (transit from to ftable rtable interactive? depth)
  (define (decorate* tree)
    (map (lambda (t) (map (cute decorate <> rtable interactive?) t)) 
	 tree))
  (delete-duplicates
   (let1 r (reachable? from to rtable #f depth)
	 (if (equal? r (list #f))
	     (let1 commons (append 
			    (let* ((callers-from (callers* from rtable #f depth))
				   (callers-to (callers* to rtable #f depth))
				   (common-callers (lset-intersection equal? 
								      (map car callers-from)
								      (map car callers-to))))
			      (if (null? common-callers)
				  (list)
				  (map
				   (lambda (common-caller)
				     `(common-caller ,common-caller
						     :from ,(decorate*
							     (delete-duplicates 
							      (assoc-ref callers-from common-caller)))
						     :to ,(decorate*
							   (delete-duplicates
							    (assoc-ref callers-to common-caller))))
				     )
				   common-callers)))
			    (let* ((callees-from (callees* from ftable #f depth))
				   (callees-to (callees* to ftable #f depth))
				   (common-callees (lset-intersection equal? 
								      (map car callees-from)
								      (map car callees-to))))
			      (if (null? common-callees)
				  (list)
				  (map
				   (lambda (common-callee)
				     `(common-callee ,common-callee
						     :from ,(decorate*
							     (delete-duplicates
							      (assoc-ref callees-from common-callee)))
						     :to ,(decorate* 
							   (delete-duplicates
							    (assoc-ref callees-to common-callee))))
				     )
				   common-callees))))
		   (if (null? commons)
		       (list #f)
		       commons))
	     r))))

(define (variable? name table)
  (let1 entry (ref table name #f)
    (if entry
	(cadr (memq :variable? (car entry)))
	#f)))

(define (desc name ftable)
  (ref ftable name (list #f)))

(define (file-line0 table file line)
  (define (file-line00 current-path table file line)
    (rxmatch-cond
      ((#/^\/srv\/debugs(\/sources\/[a-zA-Z0-9]\/[^\/]+\/[^\/]+).*/ 
			current-path)
       (#f m)
       `(,#`"/srv/sources,|m|/pre-build/,|file|" ,#`",|line|"))
      ((#/^\/srv\/debugs\/dists\/([^\/]+)\/plugins\/O0g3\/root\/.*/ 
				 current-path)
       (#f d)
       (file-line00 (sys-readlink current-path) table file line)
       )))
  (file-line00 (current-path) table file line))
    


(define (file-line name ftable)
  (or (and-let* ((e (or (ref ftable name #f)
			(ref ftable (drop-plt name) #f)
			(list #f))
		    )
		 (e (car e))
		 (e (cdddr e))
		 (file (kref e :file))
		 (line (kref e :line)))
	(list (file-line0 ftable file line)))
      (list #f)))

(define (file-line-call caller callee ftable)
  (or (and-let* ((e (or (ref ftable caller #f)
			(ref ftable (drop-plt caller) #f)
			(list #f)
			))
		 (e (car e))
		 (conn (kref e :connections))
		 (ee (any (lambda (ee) 
			     (let1 ee-name (ref ee 2)
			       (if (or (equal? ee-name callee)
				       (equal? (car (string-split ee-name #/@|\./))
					       (car (string-split callee #/@|\./))))
				   ee
				   #f)))
			   conn))
		 (e (cdddr e))
		 (file (kref e :file))
		 (line (or (kref ee :line)
			   (kref e :line)
			   ))
		 (rel (car ee)))
	;; rel
	(list (file-line0 ftable file line)))
      (list)))

(define (preview generator viewer)
  (list 
   (if-let1 f (let1 r (generator) (if (null? r) #f (car r)))
	    (if (null? f)
		#f
		(viewer  (car f) (cadr f)))
	    #f)))
(define (firefox0 file line)
  (let ((b (regexp-replace #/^\/srv\/sources/ file "http://sources/ysh"))
	(l line))
    (run-process `(firefox ,(format "~a#L:~a" b l)))))
(define (emacs0 file line)
  (run-process `(emacsclient --no-wait ,#`"+,line" ,file)))
(define (inline0 file line range)
  (define (print/prefix prefix l)
    (display prefix)
    (print l))
  (let* ((range range)
	 (lines (file->string-list file))
	 (l (- (string->number line) range))
	 (l (if (< l 0) 0 l)))
    (for-each-with-index
     (lambda (index line)
       (print/prefix #`";,(+ l index):	" line))
     (take (drop lines l) range))
    (list)))

(define (inline name ftable range)
  (preview (pa$ file-line name ftable) (cute inline0 <> <> range)))
(define (inline-call caller callee ftable range)
  (preview (pa$ file-line-call caller callee ftable) (cute inline0 <> <> range)))
(define (emacs name ftable)
  (preview (pa$ file-line name ftable) emacs0))
(define (emacs-call caller callee ftable)
  (preview (pa$ file-line-call caller callee ftable) emacs0))
(define (web name ftable)
  (preview (pa$ file-line name ftable) firefox0))
(define (web-call caller callee ftable)
  (preview (pa$ file-line-call caller callee ftable) firefox0))


(define-method search ((name <string>) ftable)
  (hash-table-fold ftable (lambda (k v kdr)
			    (if (string-scan k name)
				(cons k kdr)
				kdr))
		   (list)))

(define-method search ((regexp <regexp>) ftable)
  (hash-table-fold ftable (lambda (k v kdr)
			    (if (regexp k)
				(cons k kdr)
				kdr))
		   (list)))

(define (entry-points name ftable interactive?)
  (if name
      (map
       (cute decorate <> ftable interactive?)
       (hash-table-fold ftable (lambda (k v kdr)
				(let1 file (any (lambda (x)
						  (and (kref x :entry-point)
						       (kref x :file))
						  ) v)
				  (cond
				   ((not file) kdr)
				   ((or (equal? file name)
					(equal? (sys-basename name) (sys-basename file)))
				    (cons k kdr))
				   (else
				    kdr))))
			(list)))
      (map
       (cute decorate <> ftable interactive?)
       (hash-table-fold ftable (lambda (k v kdr)
				 (if (any (cute kref <> :entry-point) v)
				     (cons k kdr)
				     kdr))
			(list)))
      ))
(define (list-source-files ftable)
  (sort (hash-table-fold ftable (lambda (k v kdr)
				  (let1 file (any (cute kref <> :file) v)
				    (cond
				     ((not file) kdr)
				     ((not (any (lambda (e) (equal? file (cdr e))) kdr))
				      (cons (cons (sys-basename file) file) kdr))
				     (else
				      kdr))))
			 (list))
	(lambda (a b) (string< (sys-basename (car a))
			       (sys-basename (car b))))))

(define (source file)
  (for-each
   (lambda (es)
     (display ";; context: ")
     (write (current-file))
     (newline)
     (display ";; expression: ")
     (write es)
     (newline)
     (writeln* (callq-eval es #f))
     (newline)
     )
   (file->sexp-list file))
  (list))

(define (dwarf id dtable interactive?)
  (ref dtable id #f))
(define (rtable-dump table)
  (apply append (hash-table-map table (lambda (k v)
					(map
					 (lambda (v0) 
					   `(=> ,k ,(ref v0 3)))
					 (delete-duplicates v))
					))))

(define command-handlers (list))

(define-macro (define-command name pattern action . help)
  `(set! command-handlers (cons
		   (list ',name 
			 :pattern ',pattern
			 :handler (match-lambda 
				      (,pattern ,action)
				    (else 'next))
			 :help ,(if (null? help) #f (car help))
			 )
		   command-handlers)))

;; (handler es)
;; => next
;; => (...)
(define (callq-eval es env)
  (let loop ((command-handlers command-handlers))
    (if (null? command-handlers)
	(begin (print #`";; unknown command: ,(car es)")
	       (list #f))
	(let1 r ((kref (car command-handlers) :handler) es)
	  (if (eq? r 'next)
	      (loop (cdr command-handlers))
	      r)))))

(define (help cmd)
  (define (help-all)
    (map 
     (lambda (h) 
       `(help ,(car h) :pattern ,(kref h :pattern) :help ,(kref h :help)))
     command-handlers))
  (if cmd
      (filter (lambda (e) (eq? (cadr e) cmd)) (help-all))
      (sort (delete-duplicates (map cadr (help-all))) 
	    (lambda (a b) (string<? (symbol->string a) (symbol->string b))))
      ))

(define-command help ('help) (help #f) "List all commands")
(define-command help ('help (? symbol? s)) (help s) "Show syntax of commands")
(define-command source ('source (? string? file)) (source file))
(define-command load ('load (? string? file)) (load-objfile file))
(define-command switch ('switch (? string? file)) (switch-objfile file))
(define-command list-objfiles ('list-objfiles) 
  (list-objfiles :loaded-only #f))
(define-command list-objfiles ('list-objfiles :loaded-only loaded-only) 
  (list-objfiles :loaded-only loaded-only))
(define-command source-files ('source-files) (list-source-files (current-ftable)))

(define-command desc ('desc (? string? name)) (desc (undecorate name) (current-ftable)))
(define-command desc ('? (? string? name)) (desc (undecorate name) (current-ftable)))

(define-command file-line ('file-line (? string? name)) (file-line (undecorate name) (current-ftable)))
(define-command file-line (': (? string? name)) (file-line (undecorate name) (current-ftable)))
(define-command file-line 
  ('file-line (? string? caller) (? string? callee)) 
  (file-line-call (undecorate caller)
	      (undecorate callee)
	      (current-ftable)))
(define-command file-line 
  (': (? string? caller) (? string? callee)) 
  (file-line-call (undecorate caller)
	      (undecorate callee)
	      (current-ftable)))


(define-command inline ('inline (? string? name))
  (inline (undecorate name) (current-ftable) 3))
(define-command inline ('l (? string? name)) 
  (inline (undecorate name) (current-ftable) 3))
(define-command inline ('inline (? string? name) (? integer? range))
  (inline (undecorate name) (current-ftable) range))
(define-command inline ('l (? string? name) (? integer? range)) 
  (inline (undecorate name) (current-ftable) range))

(define-command inline
  ('inline (? string? caller) (? string? callee)) 
  (inline-call (undecorate caller) (undecorate callee) (current-ftable) 3))
(define-command inline
  ('l (? string? caller) (? string? callee))
  (inline-call (undecorate caller) (undecorate callee) (current-ftable) 3))
(define-command inline
  ('inline (? string? caller) (? string? callee) (? integer? range)) 
  (inline-call caller (undecorate callee) (current-ftable) range))
(define-command inline
  ('l (? string? caller) (? string? callee) (? integer? range))
  (inline-call (undecorate caller) (undecorate callee) (current-ftable) range))


(define-command emacs ('emacs (? string? name)) (emacs (undecorate name) (current-ftable)))
(define-command emacs ('j (? string? name)) (emacs (undecorate name) (current-ftable)))
(define-command emacs 
  ('emacs (? string? caller) (? string? callee))
  (emacs-call (undecorate caller) (undecorate callee) (current-ftable)))
(define-command emacs
  ('j (? string? caller) (? string? callee))
  (emacs-call (undecorate caller) (undecorate callee) (current-ftable)))

(define-command web ('web (? string? name)) (web (undecorate name) (current-ftable)))
(define-command web ('u (? string? name)) (web (undecorate name) (current-ftable)))
(define-command web 
  ('web (? string? caller) (? string? callee)) 
  (web-call (undecorate caller) (undecorate callee) (current-ftable)))
(define-command web 
  ('u (? string? caller) (? string? callee)) 
  (web-call (undecorate caller) (undecorate callee) (current-ftable)))

(define-command search ('search (? string? name)) (search (undecorate name) (current-ftable)))
(define-command search ('* (? regexp? name)) (search name (current-ftable)))
(define-command search ('* (? string? name)) (search (undecorate name) (current-ftable)))
(define-command search ('* (? regexp? name)) (search name (current-ftable)))

(define-command dump ('dump) (rtable-dump (current-rtable)))


(define-command callers ('< (? string? name)) (callers* (undecorate name) (current-rtable) #t 1))
(define-command callers ('callers (? string? name)) (callers* (undecorate name) (current-rtable) #t 1))
(define-command callers ('< (? string? name) depth) (callers* (undecorate name) (current-rtable) #t depth))
(define-command callers ('callers (? string? name) depth) (callers* (undecorate name) (current-rtable) #t depth))

(define-command callees ('> (? string? name)) (callees* (undecorate name) (current-ftable) #t 1))
(define-command callees ('callees (? string? name)) (callees* (undecorate name) (current-ftable) #t 1))
(define-command callees ('> (? string? name) depth) (callees* (undecorate name) (current-ftable) #t depth))
(define-command callees ('callees (? string? name) depth) (callees* (undecorate name) (current-ftable) #t depth))


(define-command reachable? ('reachable? from to) (reachable? (undecorate from)
						     (undecorate to)
						     (current-rtable) #t 1))
(define-command reachable? ('reachable? from to  depth) (reachable? (undecorate from)
							    (undecorate to)
							    (current-rtable) #t depth))
(define-command reachable? ('<> from to) (reachable? (undecorate from)
					     (undecorate to)
					     (current-rtable) #t 1))
(define-command reachable? ('<> from to  depth) (reachable? (undecorate from)
						    (undecorate to)
						    (current-rtable) #t depth))

(define-command transit ('transit from to) 
  (transit (undecorate from) 
	   (undecorate to)
	   (current-ftable) (current-rtable) #t #t))
(define-command transit ('transit from to  depth) 
  (transit (undecorate from) 
	   (undecorate to)
	   (current-ftable) (current-rtable) #t depth))
(define-command transit ('<*> from to) (transit (undecorate from)
					(undecorate to)
					(current-ftable) (current-rtable) #t #t))
(define-command transit ('<*> from to  depth) (transit (undecorate from)
					       (undecorate to)
					       (current-ftable) (current-rtable) #t depth))

(define-command entry-points ('entry-points) (entry-points #f (current-ftable) #t))
(define-command entry-points ('$) (entry-points #f (current-ftable) #t))
(define-command externs ('externs (? string? name)) (entry-points name (current-ftable) #t))
(define-command externs ('$ (? string? name)) (entry-points name (current-ftable) #t))


(define-command dwarf ('dwarf id) (dwarf id (current-dtable) #t))
(define-command dwarf ('d id) (dwarf id (current-dtable) #t))


(define print-handlers (list))
(define-macro (define-printer name printer)
  `(set! print-handlers (cons
			 (cons ',name ,printer)
			 print-handlers)))

(define (callq-print0 interactive? es)
  (cond
   ((null? es)
    es					; do noething
    )
   ((list? es)
    (let* ((name (car es))
	   (handler (assq-ref print-handlers name #f)))
      (if handler
	  (handler interactive? (car es) (cdr es))
	  (write es))))
   (else
    (write es))))

(define (callq-print interactive? es . rest)
  (with-output-to-port (current-output-port)
      (lambda ()
	(cond
	 ((not es) 
	  es				; do nothing
	  )
	 ((integer? es) 
	  (exit es))
	 ((list? es)
	  (for-each (lambda (es0) 
		      (callq-print0 interactive? es0)
		      (newline))
		    es))
	 (else
	  (write es)
	  (newline)
	  )))))

(define (writeln es)
  (write es)
  (newline)
  ;;(print es)
  )
(define (writeln* ess)
  (for-each
   writeln
   ess))


(define-printer help 
  (lambda (interactive? kar kdr)
    (format #t #`",(kref kdr :pattern); ,(kref kdr :help)")
    ))
(define-printer objfile
  (lambda (interactive? kar kdr)
    (if (list? (cadr kdr))
	(format #t #`"	,(car kdr) => ,(caadr kdr)")
	(format #t #`"	,(car kdr) => ,(cadr kdr)"))))

(define callq-read read)

;; timeout, plugin output routine, plugin input
(define (print-usage name status)
  (print "Usage: ")
  (print #`"	,|name| -h|--help")
  (print #`"	,|name| [--batch] [-s|--script|--source SCRIPT]...")
  (print #`"	,|name| [-s|--script|--source SCRIPT]... [-l|--load BINARY]...")
  (exit status))

(define (repl batch)
  (read-eval-print-loop callq-read
			callq-eval
			(pa$ callq-print (not batch))
			(lambda () 
			  (with-output-to-port (current-error-port)
			    (lambda ()
			      (display (if batch "" #`"[,(current-file)]? "))
			      (flush))))))
(define (main args)
  (let-args (cdr args)
      ((help   "h|help" => (pa$ print-usage (car args) 0))
       (script "s|script|source=s" => (pa$ source))
       (load   "l|load=s" => (pa$ load-objfile))
       (batch  "b|batch")
       . rest)
    (when batch
      (exit 0))
    (for-each load-objfile rest)
    (repl batch)
    (newline)))
