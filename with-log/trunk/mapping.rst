3. ソースコード行への対応付け
************************************************************************

ログが入手できれば、それに対応するソースコード行を特定することができる
はずです。必要なのは文字列検索だけなので簡単に思われますが、この作業で
もいくつか準備と知識が必要です。


ソースコードの準備
========================================================================

まずログを出力したソフトウェアのソースコードが必要です。ログを顧客から
受けとってからソースコードを準備するのではなく、サポートの対象となる
ソフトウェアのソースコードを全て手元に準備しておくことをお勧めします [SRPMIX]_
。



ソースコード上での文字列と変数展開
========================================================================

ログメッセージはソースコード中では、プログラミング言語の意味での文字列
として表現されていると期待されます。従ってそのプログラミング言語の文法
において文字列がどのように表現されるか知っておく必要があります。C言語を
含む多くの言語でダブルクォート ``"`` が使われます::

 "文字列"

しかし、例えばPostscriptでれば ``(`` と ``)`` が使われ::

 (文字列)

となります。

また文字列中に変数を置くと変数の保持する値が展開して文字列を作成する
機能を有するプログラミング言語も存在します。例えばログメッセージ::

   Cannot find interface: eth1

について、対応するlogging関数呼び出しを捜す場合を考えます。対象
となるソフトウェアはbashスクリプトだと想定します。まず::


   "Cannot find interface: eth1"

と記載されている可能性があります。しかしeth1という固有名詞が
ハードコードされていることは稀で、::

   interface=eth1
   ...
   "Cannot find interface: ${interface}"

と変数展開を利用しているコードを良く目にします。この場合変数展開
を考慮して、ログメッセージを一度分解して、検索文字列を組み立てる
必要があります。



フォーマット文字列
========================================================================

変数展開と良く似ている文字列構築機能にフォーマットがあります。有名なものに標準C
ライブラリに含まれるprintf関数があります。::

  int interface;
  ...  
  interface = 1;
  ..
  printf("Cannot find interface: eth%d\n", interface);

printf関数は、第一引数に与えられた「フォーマット文字列」を調べて ``%d`` がプレイスホルダー
であると知ります。そして第二引数に与えた整数でその部分を埋めて::

   "Cannot find interface: eth1"

を出力します。整数のかわりに文字列を使っている場合もありえます。::

  char* interface;
  ...  
  interface = "eth1";
  ..
  printf("Cannot find interface:%s\n", interface);

この場合 ``%d`` のかわりに ``%s`` を使います。

「フォーマット文字列」内の文法は、多くの場合printfの ``%`` を用いた形式を採用していますが、
プログラミング言語、logging関数によっては異なるものがあります。例えばscheme言語
であば、 ``%`` のかわりに ``~`` を用います。::

  (print (let ((interface "eth1"))
            (format "Cannot find interface:~s\n" interface)))

TODO: perl. python, sh, Cなどの主要な言語の「フォーマット文字列」の文法に
ついて解説すること。

