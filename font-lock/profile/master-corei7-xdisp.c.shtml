(*TOP* (*PI* xml "version=\"1.0\" encoding=\"UTF-8\"") "\n" (*DECL* DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd") "\n" (*COMMENT* " Created by xhtmlize-1.34.1 in external-css mode. ") "\n" (html (|@| (xmlns "http://www.w3.org/1999/xhtml") (xml:lang "en") (lang "en")) "\n" (head "\n" "    " (title "xdisp.c") "\n" "    " (meta (|@| (name "major-mode") (content "c-mode"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/default--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/default--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-comment-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-comment-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-comment-delimiter-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-comment-delimiter-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-constant-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-constant-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-function-name-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-function-name-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-keyword-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-keyword-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-negation-char-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-negation-char-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-preprocessor-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-preprocessor-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-string-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-string-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-type-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-type-face--Invert.css") (title "Invert"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-variable-name-face--Default.css") (title "Default"))) "\n" "    " (link (|@| (rel "stylesheet") (type "text/css") (href "file:///tmp/font-lock-variable-name-face--Invert.css") (title "Invert"))) "\n") "\n" "    " (body "\n" "    " (pre "\n" (span (|@| (class "comment-delimiter") (id "F:1")) "/* ") (span (|@| (class "comment") (id "F:4")) "Display generation from window structure and buffer text.\n   Copyright (C) 1985, 1986, 1987, 1988, 1993, 1994, 1995,\n                 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n                 2004, 2005, 2006, 2007, 2008, 2009, 2010\n                 Free Software Foundation, Inc.\n\nThis file is part of GNU Emacs.\n\nGNU Emacs is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nGNU Emacs is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.  ") (span (|@| (class "comment-delimiter") (id "F:924")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:928")) "/* ") (span (|@| (class "comment") (id "F:931")) "New redisplay written by Gerd Moellmann <gerd@gnu.org>.\n\n   Redisplay.\n\n   Emacs separates the task of updating the display from code\n   modifying global state, e.g. buffer text.  This way functions\n   operating on buffers don't also have to be concerned with updating\n   the display.\n\n   Updating the display is triggered by the Lisp interpreter when it\n   decides it's time to do it.  This is done either automatically for\n   you as part of the interpreter's command loop or as the result of\n   calling Lisp functions like `sit-for'.  The C function `redisplay'\n   in xdisp.c is the only entry into the inner redisplay code.\n\n   The following diagram shows how redisplay code is invoked.  As you\n   can see, Lisp calls redisplay and vice versa.  Under window systems\n   like X, some portions of the redisplay code are also called\n   asynchronously during mouse movement or expose events.  It is very\n   important that these code parts do NOT use the C library (malloc,\n   free) because many C libraries under Unix are not reentrant.  They\n   may also NOT call functions of the Lisp interpreter which could\n   change the interpreter's state.  If you don't follow these rules,\n   you will encounter bugs which are very hard to explain.\n\n   +--------------+   redisplay     +----------------+\n   | Lisp machine |---------------->| Redisplay code |<--+\n   +--------------+   (xdisp.c)     +----------------+   |\n          ^                                  |           |\n          +----------------------------------+           |\n            Don't use this path when called              |\n            asynchronously!                              |\n                                                         |\n                           expose_window (asynchronous)  |\n                                                         |\n                                   X expose events  -----+\n\n   What does redisplay do?  Obviously, it has to figure out somehow what\n   has been changed since the last time the display has been updated,\n   and to make these changes visible.  Preferably it would do that in\n   a moderately intelligent way, i.e. fast.\n\n   Changes in buffer text can be deduced from window and buffer\n   structures, and from some global variables like `beg_unchanged' and\n   `end_unchanged'.  The contents of the display are additionally\n   recorded in a `glyph matrix', a two-dimensional matrix of glyph\n   structures.  Each row in such a matrix corresponds to a line on the\n   display, and each glyph in a row corresponds to a column displaying\n   a character, an image, or what else.  This matrix is called the\n   `current glyph matrix' or `current matrix' in redisplay\n   terminology.\n\n   For buffer parts that have been changed since the last update, a\n   second glyph matrix is constructed, the so called `desired glyph\n   matrix' or short `desired matrix'.  Current and desired matrix are\n   then compared to find a cheap way to update the display, e.g. by\n   reusing part of the display by scrolling lines.\n\n   You will find a lot of redisplay optimizations when you start\n   looking at the innards of redisplay.  The overall goal of all these\n   optimizations is to make redisplay fast because it is done\n   frequently.  Some of these optimizations are implemented by the\n   following functions:\n\n    . try_cursor_movement\n\n      This function tries to update the display if the text in the\n      window did not change and did not scroll, only point moved, and\n      it did not move off the displayed portion of the text.\n\n    . try_window_reusing_current_matrix\n\n      This function reuses the current matrix of a window when text\n      has not changed, but the window start changed (e.g., due to\n      scrolling).\n\n    . try_window_id\n\n      This function attempts to redisplay a window by reusing parts of\n      its existing display.  It finds and reuses the part that was not\n      changed, and redraws the rest.\n\n    . try_window\n\n      This function performs the full redisplay of a single window\n      assuming that its fonts were not changed and that the cursor\n      will not end up in the scroll margins.  (Loading fonts requires\n      re-adjustment of dimensions of glyph matrices, which makes this\n      method impossible to use.)\n\n   These optimizations are tried in sequence (some can be skipped if\n   it is known that they are not applicable).  If none of the\n   optimizations were successful, redisplay calls redisplay_windows,\n   which performs a full redisplay of all windows.\n\n   Desired matrices.\n\n   Desired matrices are always built per Emacs window.  The function\n   `display_line' is the central function to look at if you are\n   interested.  It constructs one row in a desired matrix given an\n   iterator structure containing both a buffer position and a\n   description of the environment in which the text is to be\n   displayed.  But this is too early, read on.\n\n   Characters and pixmaps displayed for a range of buffer text depend\n   on various settings of buffers and windows, on overlays and text\n   properties, on display tables, on selective display.  The good news\n   is that all this hairy stuff is hidden behind a small set of\n   interface functions taking an iterator structure (struct it)\n   argument.\n\n   Iteration over things to be displayed is then simple.  It is\n   started by initializing an iterator with a call to init_iterator.\n   Calls to get_next_display_element fill the iterator structure with\n   relevant information about the next thing to display.  Calls to\n   set_iterator_to_next move the iterator to the next thing.\n\n   Besides this, an iterator also contains information about the\n   display environment in which glyphs for display elements are to be\n   produced.  It has fields for the width and height of the display,\n   the information whether long lines are truncated or continued, a\n   current X and Y position, and lots of other stuff you can better\n   see in dispextern.h.\n\n   Glyphs in a desired matrix are normally constructed in a loop\n   calling get_next_display_element and then PRODUCE_GLYPHS.  The call\n   to PRODUCE_GLYPHS will fill the iterator structure with pixel\n   information about the element being displayed and at the same time\n   produce glyphs for it.  If the display element fits on the line\n   being displayed, set_iterator_to_next is called next, otherwise the\n   glyphs produced are discarded.  The function display_line is the\n   workhorse of filling glyph rows in the desired matrix with glyphs.\n   In addition to producing glyphs, it also handles line truncation\n   and continuation, word wrap, and cursor positioning (for the\n   latter, see also set_cursor_from_row).\n\n   Frame matrices.\n\n   That just couldn't be all, could it?  What about terminal types not\n   supporting operations on sub-windows of the screen?  To update the\n   display on such a terminal, window-based glyph matrices are not\n   well suited.  To be able to reuse part of the display (scrolling\n   lines up and down), we must instead have a view of the whole\n   screen.  This is what `frame matrices' are for.  They are a trick.\n\n   Frames on terminals like above have a glyph pool.  Windows on such\n   a frame sub-allocate their glyph memory from their frame's glyph\n   pool.  The frame itself is given its own glyph matrices.  By\n   coincidence---or maybe something else---rows in window glyph\n   matrices are slices of corresponding rows in frame matrices.  Thus\n   writing to window matrices implicitly updates a frame matrix which\n   provides us with the view of the whole screen that we originally\n   wanted to have without having to move many bytes around.  To be\n   honest, there is a little bit more done, but not much more.  If you\n   plan to extend that code, take a look at dispnew.c.  The function\n   build_frame_matrix is a good starting point.\n\n   Bidirectional display.\n\n   Bidirectional display adds quite some hair to this already complex\n   design.  The good news are that a large portion of that hairy stuff\n   is hidden in bidi.c behind only 3 interfaces.  bidi.c implements a\n   reordering engine which is called by set_iterator_to_next and\n   returns the next character to display in the visual order.  See\n   commentary on bidi.c for more details.  As far as redisplay is\n   concerned, the effect of calling bidi_move_to_visually_next, the\n   main interface of the reordering engine, is that the iterator gets\n   magically placed on the buffer or string position that is to be\n   displayed next.  In other words, a linear iteration through the\n   buffer/string is replaced with a non-linear one.  All the rest of\n   the redisplay is oblivious to the bidi reordering.\n\n   Well, almost oblivious---there are still complications, most of\n   them due to the fact that buffer and string positions no longer\n   change monotonously with glyph indices in a glyph row.  Moreover,\n   for continued lines, the buffer positions may not even be\n   monotonously changing with vertical positions.  Also, accounting\n   for face changes, overlays, etc. becomes more complex because\n   non-linear iteration could potentially skip many positions with\n   changes, and then cross them again on the way back...\n\n   One other prominent effect of bidirectional display is that some\n   paragraphs of text need to be displayed starting at the right\n   margin of the window---the so-called right-to-left, or R2L\n   paragraphs.  R2L paragraphs are displayed with R2L glyph rows,\n   which have their reversed_p flag set.  The bidi reordering engine\n   produces characters in such rows starting from the character which\n   should be the rightmost on display.  PRODUCE_GLYPHS then reverses\n   the order, when it fills up the glyph row whose reversed_p flag is\n   set, by prepending each new glyph to what is already there, instead\n   of appending it.  When the glyph row is complete, the function\n   extend_face_to_end_of_line fills the empty space to the left of the\n   leftmost character with special glyphs, which will display as,\n   well, empty.  On text terminals, these special glyphs are simply\n   blank characters.  On graphics terminals, there's a single stretch\n   glyph with suitably computed width.  Both the blanks and the\n   stretch glyph are given the face of the background of the line.\n   This way, the terminal-specific back-end can still draw the glyphs\n   left to right, even for R2L lines.  ") (span (|@| (class "comment-delimiter") (id "F:11191")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:11195")) "#include") " " (span (|@| (class "string") (id "F:11204")) "<config.h>") "\n" (span (|@| (class "preprocessor") (id "F:11215")) "#include") " " (span (|@| (class "string") (id "F:11224")) "<stdio.h>") "\n" (span (|@| (class "preprocessor") (id "F:11234")) "#include") " " (span (|@| (class "string") (id "F:11243")) "<limits.h>") "\n" (span (|@| (class "preprocessor") (id "F:11254")) "#include") " " (span (|@| (class "string") (id "F:11263")) "<setjmp.h>") "\n\n" (span (|@| (class "preprocessor") (id "F:11275")) "#include") " " (span (|@| (class "string") (id "F:11284")) "\"lisp.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11293")) "#include") " " (span (|@| (class "string") (id "F:11302")) "\"keyboard.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11315")) "#include") " " (span (|@| (class "string") (id "F:11324")) "\"frame.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11334")) "#include") " " (span (|@| (class "string") (id "F:11343")) "\"window.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11354")) "#include") " " (span (|@| (class "string") (id "F:11363")) "\"termchar.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11376")) "#include") " " (span (|@| (class "string") (id "F:11385")) "\"dispextern.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11400")) "#include") " " (span (|@| (class "string") (id "F:11409")) "\"buffer.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11420")) "#include") " " (span (|@| (class "string") (id "F:11429")) "\"character.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11443")) "#include") " " (span (|@| (class "string") (id "F:11452")) "\"charset.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11464")) "#include") " " (span (|@| (class "string") (id "F:11473")) "\"indent.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11484")) "#include") " " (span (|@| (class "string") (id "F:11493")) "\"commands.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11506")) "#include") " " (span (|@| (class "string") (id "F:11515")) "\"keymap.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11526")) "#include") " " (span (|@| (class "string") (id "F:11535")) "\"macros.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11546")) "#include") " " (span (|@| (class "string") (id "F:11555")) "\"disptab.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11567")) "#include") " " (span (|@| (class "string") (id "F:11576")) "\"termhooks.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11590")) "#include") " " (span (|@| (class "string") (id "F:11599")) "\"intervals.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11613")) "#include") " " (span (|@| (class "string") (id "F:11622")) "\"coding.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11633")) "#include") " " (span (|@| (class "string") (id "F:11642")) "\"process.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11654")) "#include") " " (span (|@| (class "string") (id "F:11663")) "\"region-cache.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11680")) "#include") " " (span (|@| (class "string") (id "F:11689")) "\"font.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11698")) "#include") " " (span (|@| (class "string") (id "F:11707")) "\"fontset.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11719")) "#include") " " (span (|@| (class "string") (id "F:11728")) "\"blockinput.h\"") "\n\n" (span (|@| (class "preprocessor") (id "F:11744")) "#ifdef") " HAVE_X_WINDOWS\n" (span (|@| (class "preprocessor") (id "F:11766")) "#include") " " (span (|@| (class "string") (id "F:11775")) "\"xterm.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11785")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:11792")) "#ifdef") " WINDOWSNT\n" (span (|@| (class "preprocessor") (id "F:11809")) "#include") " " (span (|@| (class "string") (id "F:11818")) "\"w32term.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11830")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:11837")) "#ifdef") " HAVE_NS\n" (span (|@| (class "preprocessor") (id "F:11852")) "#include") " " (span (|@| (class "string") (id "F:11861")) "\"nsterm.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11872")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:11879")) "#ifdef") " USE_GTK\n" (span (|@| (class "preprocessor") (id "F:11894")) "#include") " " (span (|@| (class "string") (id "F:11903")) "\"gtkutil.h\"") "\n" (span (|@| (class "preprocessor") (id "F:11915")) "#endif") "\n\n" (span (|@| (class "preprocessor") (id "F:11923")) "#include") " " (span (|@| (class "string") (id "F:11932")) "\"font.h\"") "\n\n" (span (|@| (class "preprocessor") (id "F:11942")) "#if") (span (|@| (class "negation-char") (id "F:11945")) (span (|@| (class "preprocessor") (id "F:11945")) "n")) (span (|@| (class "preprocessor") (id "F:11946")) "def") " FRAME_X_OUTPUT\n" (span (|@| (class "preprocessor") (id "F:11965")) "#define") " " (span (|@| (class "function-name") (id "F:11973")) "FRAME_X_OUTPUT") "(" (span (|@| (class "variable-name") (id "F:11988")) "f") ") ((f)->output_data.x)\n" (span (|@| (class "preprocessor") (id "F:12012")) "#endif") "\n\n" (span (|@| (class "preprocessor") (id "F:12020")) "#define") " " (span (|@| (class "variable-name") (id "F:12028")) "INFINITY") " 10000000\n\n" (span (|@| (class "preprocessor") (id "F:12047")) "#if") " " (span (|@| (class "preprocessor") (id "F:12051")) "defined") " (USE_X_TOOLKIT) || " (span (|@| (class "preprocessor") (id "F:12078")) "defined") " (HAVE_NTGUI) \\\n    || " (span (|@| (class "preprocessor") (id "F:12108")) "defined") "(HAVE_NS) || " (span (|@| (class "preprocessor") (id "F:12128")) "defined") " (USE_GTK)\n" (span (|@| (class "keyword") (id "F:12146")) "extern") " " (span (|@| (class "type") (id "F:12153")) "void") " " (span (|@| (class "function-name") (id "F:12158")) "set_frame_menubar") " P_ ((" (span (|@| (class "keyword") (id "F:12181")) "struct") " " (span (|@| (class "type") (id "F:12188")) "frame") " *" (span (|@| (class "variable-name") (id "F:12195")) "f") ", " (span (|@| (class "type") (id "F:12198")) "int") ", " (span (|@| (class "type") (id "F:12203")) "int") "));\n" (span (|@| (class "keyword") (id "F:12210")) "extern") " " (span (|@| (class "type") (id "F:12217")) "int") " " (span (|@| (class "variable-name") (id "F:12221")) "pending_menu_activation") ";\n" (span (|@| (class "preprocessor") (id "F:12246")) "#endif") "\n\n" (span (|@| (class "keyword") (id "F:12254")) "extern") " " (span (|@| (class "type") (id "F:12261")) "int") " " (span (|@| (class "variable-name") (id "F:12265")) "interrupt_input") ";\n" (span (|@| (class "keyword") (id "F:12282")) "extern") " " (span (|@| (class "type") (id "F:12289")) "int") " " (span (|@| (class "variable-name") (id "F:12293")) "command_loop_level") ";\n\n" (span (|@| (class "keyword") (id "F:12314")) "extern") " " (span (|@| (class "type") (id "F:12321")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12333")) "do_mouse_tracking") ";\n\n" (span (|@| (class "keyword") (id "F:12353")) "extern") " " (span (|@| (class "type") (id "F:12360")) "int") " " (span (|@| (class "variable-name") (id "F:12364")) "minibuffer_auto_raise") ";\n" (span (|@| (class "keyword") (id "F:12387")) "extern") " " (span (|@| (class "type") (id "F:12394")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12406")) "Vminibuffer_list") ";\n\n" (span (|@| (class "keyword") (id "F:12425")) "extern") " " (span (|@| (class "type") (id "F:12432")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12444")) "Qface") ";\n" (span (|@| (class "keyword") (id "F:12451")) "extern") " " (span (|@| (class "type") (id "F:12458")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12470")) "Qmode_line") ", " (span (|@| (class "variable-name") (id "F:12482")) "Qmode_line_inactive") ", " (span (|@| (class "variable-name") (id "F:12503")) "Qheader_line") ";\n\n" (span (|@| (class "keyword") (id "F:12518")) "extern") " " (span (|@| (class "type") (id "F:12525")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12537")) "Voverriding_local_map") ";\n" (span (|@| (class "keyword") (id "F:12560")) "extern") " " (span (|@| (class "type") (id "F:12567")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12579")) "Voverriding_local_map_menu_flag") ";\n" (span (|@| (class "keyword") (id "F:12612")) "extern") " " (span (|@| (class "type") (id "F:12619")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12631")) "Qmenu_item") ";\n" (span (|@| (class "keyword") (id "F:12643")) "extern") " " (span (|@| (class "type") (id "F:12650")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12662")) "Qwhen") ";\n" (span (|@| (class "keyword") (id "F:12669")) "extern") " " (span (|@| (class "type") (id "F:12676")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12688")) "Qhelp_echo") ";\n" (span (|@| (class "keyword") (id "F:12700")) "extern") " " (span (|@| (class "type") (id "F:12707")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12719")) "Qbefore_string") ", " (span (|@| (class "variable-name") (id "F:12735")) "Qafter_string") ";\n\n" (span (|@| (class "type") (id "F:12751")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12763")) "Qoverriding_local_map") ", " (span (|@| (class "variable-name") (id "F:12786")) "Qoverriding_terminal_local_map") ";\n" (span (|@| (class "type") (id "F:12818")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12830")) "Qwindow_scroll_functions") ", " (span (|@| (class "variable-name") (id "F:12856")) "Vwindow_scroll_functions") ";\n" (span (|@| (class "type") (id "F:12882")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12894")) "Qwindow_text_change_functions") ", " (span (|@| (class "variable-name") (id "F:12925")) "Vwindow_text_change_functions") ";\n" (span (|@| (class "type") (id "F:12956")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:12968")) "Qredisplay_end_trigger_functions") ", " (span (|@| (class "variable-name") (id "F:13002")) "Vredisplay_end_trigger_functions") ";\n" (span (|@| (class "type") (id "F:13036")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13048")) "Qinhibit_point_motion_hooks") ";\n" (span (|@| (class "type") (id "F:13077")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13089")) "QCeval") ", " (span (|@| (class "variable-name") (id "F:13097")) "QCfile") ", " (span (|@| (class "variable-name") (id "F:13105")) "QCdata") ", " (span (|@| (class "variable-name") (id "F:13113")) "QCpropertize") ";\n" (span (|@| (class "type") (id "F:13127")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13139")) "Qfontified") ";\n" (span (|@| (class "type") (id "F:13151")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13163")) "Qgrow_only") ";\n" (span (|@| (class "type") (id "F:13175")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13187")) "Qinhibit_eval_during_redisplay") ";\n" (span (|@| (class "type") (id "F:13219")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13231")) "Qbuffer_position") ", " (span (|@| (class "variable-name") (id "F:13249")) "Qposition") ", " (span (|@| (class "variable-name") (id "F:13260")) "Qobject") ";\n" (span (|@| (class "type") (id "F:13269")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13281")) "Qright_to_left") ", " (span (|@| (class "variable-name") (id "F:13297")) "Qleft_to_right") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:13314")) "/* ") (span (|@| (class "comment") (id "F:13317")) "Cursor shapes ") (span (|@| (class "comment-delimiter") (id "F:13331")) "*/") "\n" (span (|@| (class "type") (id "F:13334")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13346")) "Qbar") ", " (span (|@| (class "variable-name") (id "F:13352")) "Qhbar") ", " (span (|@| (class "variable-name") (id "F:13359")) "Qbox") ", " (span (|@| (class "variable-name") (id "F:13365")) "Qhollow") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:13375")) "/* ") (span (|@| (class "comment") (id "F:13378")) "Pointer shapes ") (span (|@| (class "comment-delimiter") (id "F:13393")) "*/") "\n" (span (|@| (class "type") (id "F:13396")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13408")) "Qarrow") ", " (span (|@| (class "variable-name") (id "F:13416")) "Qhand") ", " (span (|@| (class "variable-name") (id "F:13423")) "Qtext") ";\n\n" (span (|@| (class "type") (id "F:13431")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13443")) "Qrisky_local_variable") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:13467")) "/* ") (span (|@| (class "comment") (id "F:13470")) "Holds the list (error).  ") (span (|@| (class "comment-delimiter") (id "F:13495")) "*/") "\n" (span (|@| (class "type") (id "F:13498")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13510")) "list_of_error") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:13526")) "/* ") (span (|@| (class "comment") (id "F:13529")) "Functions called to fontify regions of text.  ") (span (|@| (class "comment-delimiter") (id "F:13575")) "*/") "\n\n" (span (|@| (class "type") (id "F:13579")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13591")) "Vfontification_functions") ";\n" (span (|@| (class "type") (id "F:13617")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13629")) "Qfontification_functions") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:13656")) "/* ") (span (|@| (class "comment") (id "F:13659")) "Non-nil means automatically select any window when the mouse\n   cursor moves into it.  ") (span (|@| (class "comment-delimiter") (id "F:13746")) "*/") "\n" (span (|@| (class "type") (id "F:13749")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13761")) "Vmouse_autoselect_window") ";\n\n" (span (|@| (class "type") (id "F:13788")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13800")) "Vwrap_prefix") ", " (span (|@| (class "variable-name") (id "F:13814")) "Qwrap_prefix") ";\n" (span (|@| (class "type") (id "F:13828")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:13840")) "Vline_prefix") ", " (span (|@| (class "variable-name") (id "F:13854")) "Qline_prefix") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:13869")) "/* ") (span (|@| (class "comment") (id "F:13872")) "Non-zero means draw tool bar buttons raised when the mouse moves\n   over them.  ") (span (|@| (class "comment-delimiter") (id "F:13952")) "*/") "\n\n" (span (|@| (class "type") (id "F:13956")) "int") " " (span (|@| (class "variable-name") (id "F:13960")) "auto_raise_tool_bar_buttons_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:13992")) "/* ") (span (|@| (class "comment") (id "F:13995")) "Non-zero means to reposition window if cursor line is only partially visible.  ") (span (|@| (class "comment-delimiter") (id "F:14074")) "*/") "\n\n" (span (|@| (class "type") (id "F:14078")) "int") " " (span (|@| (class "variable-name") (id "F:14082")) "make_cursor_line_fully_visible_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:14117")) "/* ") (span (|@| (class "comment") (id "F:14120")) "Margin below tool bar in pixels.  0 or nil means no margin.\n   If value is `internal-border-width' or `border-width',\n   the corresponding frame parameter is used.  ") (span (|@| (class "comment-delimiter") (id "F:14285")) "*/") "\n\n" (span (|@| (class "type") (id "F:14289")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:14301")) "Vtool_bar_border") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:14320")) "/* ") (span (|@| (class "comment") (id "F:14323")) "Margin around tool bar buttons in pixels.  ") (span (|@| (class "comment-delimiter") (id "F:14366")) "*/") "\n\n" (span (|@| (class "type") (id "F:14370")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:14382")) "Vtool_bar_button_margin") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:14408")) "/* ") (span (|@| (class "comment") (id "F:14411")) "Thickness of shadow to draw around tool bar buttons.  ") (span (|@| (class "comment-delimiter") (id "F:14465")) "*/") "\n\n" (span (|@| (class "type") (id "F:14469")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:14479")) "tool_bar_button_relief") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:14504")) "/* ") (span (|@| (class "comment") (id "F:14507")) "Non-nil means automatically resize tool-bars so that all tool-bar\n   items are visible, and no blank lines remain.\n\n   If value is `grow-only', only make tool-bar bigger.  ") (span (|@| (class "comment-delimiter") (id "F:14679")) "*/") "\n\n" (span (|@| (class "type") (id "F:14683")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:14695")) "Vauto_resize_tool_bars") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:14720")) "/* ") (span (|@| (class "comment") (id "F:14723")) "Type of tool bar.  Can be symbols image, text, both or both-hroiz.  ") (span (|@| (class "comment-delimiter") (id "F:14791")) "*/") "\n\n" (span (|@| (class "type") (id "F:14795")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:14807")) "Vtool_bar_style") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:14825")) "/* ") (span (|@| (class "comment") (id "F:14828")) "Maximum number of characters a label can have to be shown.  ") (span (|@| (class "comment-delimiter") (id "F:14888")) "*/") "\n\n" (span (|@| (class "type") (id "F:14892")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:14902")) "tool_bar_max_label_size") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:14928")) "/* ") (span (|@| (class "comment") (id "F:14931")) "Non-zero means draw block and hollow cursor as wide as the glyph\n   under it.  For example, if a block cursor is over a tab, it will be\n   drawn as wide as that tab on the display.  ") (span (|@| (class "comment-delimiter") (id "F:15113")) "*/") "\n\n" (span (|@| (class "type") (id "F:15117")) "int") " " (span (|@| (class "variable-name") (id "F:15121")) "x_stretch_cursor_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:15142")) "/* ") (span (|@| (class "comment") (id "F:15145")) "Non-nil means don't actually do any redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:15193")) "*/") "\n\n" (span (|@| (class "type") (id "F:15197")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15209")) "Vinhibit_redisplay") ", " (span (|@| (class "variable-name") (id "F:15229")) "Qinhibit_redisplay") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:15250")) "/* ") (span (|@| (class "comment") (id "F:15253")) "Non-zero means Lisp evaluation during redisplay is inhibited.  ") (span (|@| (class "comment-delimiter") (id "F:15316")) "*/") "\n\n" (span (|@| (class "type") (id "F:15320")) "int") " " (span (|@| (class "variable-name") (id "F:15324")) "inhibit_eval_during_redisplay") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:15356")) "/* ") (span (|@| (class "comment") (id "F:15359")) "Names of text properties relevant for redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:15409")) "*/") "\n\n" (span (|@| (class "type") (id "F:15413")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15425")) "Qdisplay") ";\n" (span (|@| (class "keyword") (id "F:15435")) "extern") " " (span (|@| (class "type") (id "F:15442")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15454")) "Qface") ", " (span (|@| (class "variable-name") (id "F:15461")) "Qinvisible") ", " (span (|@| (class "variable-name") (id "F:15473")) "Qwidth") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:15482")) "/* ") (span (|@| (class "comment") (id "F:15485")) "Symbols used in text property values.  ") (span (|@| (class "comment-delimiter") (id "F:15524")) "*/") "\n\n" (span (|@| (class "type") (id "F:15528")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15540")) "Vdisplay_pixels_per_inch") ";\n" (span (|@| (class "type") (id "F:15566")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15578")) "Qspace") ", " (span (|@| (class "variable-name") (id "F:15586")) "QCalign_to") ", " (span (|@| (class "variable-name") (id "F:15598")) "QCrelative_width") ", " (span (|@| (class "variable-name") (id "F:15616")) "QCrelative_height") ";\n" (span (|@| (class "type") (id "F:15635")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15647")) "Qleft_margin") ", " (span (|@| (class "variable-name") (id "F:15661")) "Qright_margin") ", " (span (|@| (class "variable-name") (id "F:15676")) "Qspace_width") ", " (span (|@| (class "variable-name") (id "F:15690")) "Qraise") ";\n" (span (|@| (class "type") (id "F:15698")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15710")) "Qslice") ";\n" (span (|@| (class "type") (id "F:15718")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15730")) "Qcenter") ";\n" (span (|@| (class "type") (id "F:15739")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15751")) "Qmargin") ", " (span (|@| (class "variable-name") (id "F:15760")) "Qpointer") ";\n" (span (|@| (class "type") (id "F:15770")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15782")) "Qline_height") ";\n" (span (|@| (class "keyword") (id "F:15796")) "extern") " " (span (|@| (class "type") (id "F:15803")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15815")) "Qheight") ";\n" (span (|@| (class "keyword") (id "F:15824")) "extern") " " (span (|@| (class "type") (id "F:15831")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15843")) "QCwidth") ", " (span (|@| (class "variable-name") (id "F:15852")) "QCheight") ", " (span (|@| (class "variable-name") (id "F:15862")) "QCascent") ";\n" (span (|@| (class "keyword") (id "F:15872")) "extern") " " (span (|@| (class "type") (id "F:15879")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15891")) "Qscroll_bar") ";\n" (span (|@| (class "keyword") (id "F:15904")) "extern") " " (span (|@| (class "type") (id "F:15911")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15923")) "Qcursor") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:15933")) "/* ") (span (|@| (class "comment") (id "F:15936")) "Non-nil means highlight trailing whitespace.  ") (span (|@| (class "comment-delimiter") (id "F:15982")) "*/") "\n\n" (span (|@| (class "type") (id "F:15986")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:15998")) "Vshow_trailing_whitespace") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:16026")) "/* ") (span (|@| (class "comment") (id "F:16029")) "Non-nil means escape non-break space and hyphens.  ") (span (|@| (class "comment-delimiter") (id "F:16080")) "*/") "\n\n" (span (|@| (class "type") (id "F:16084")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:16096")) "Vnobreak_char_display") ";\n\n" (span (|@| (class "preprocessor") (id "F:16120")) "#ifdef") " HAVE_WINDOW_SYSTEM\n" (span (|@| (class "keyword") (id "F:16146")) "extern") " " (span (|@| (class "type") (id "F:16153")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:16165")) "Voverflow_newline_into_fringe") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:16197")) "/* ") (span (|@| (class "comment") (id "F:16200")) "Test if overflow newline into fringe.  Called with iterator IT\n   at or past right window margin, and with IT->current_x set.  ") (span (|@| (class "comment-delimiter") (id "F:16327")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:16331")) "#define") " " (span (|@| (class "function-name") (id "F:16339")) "IT_OVERFLOW_NEWLINE_INTO_FRINGE") "(" (span (|@| (class "variable-name") (id "F:16371")) "IT") ")             \\\n  (" (span (|@| (class "negation-char") (id "F:16381")) "!") "NILP (Voverflow_newline_into_fringe)                \\\n   && FRAME_WINDOW_P ((IT)->f)                          \\\n   && ((IT)->bidi_it.paragraph_dir == R2L               \\\n       ? (WINDOW_LEFT_FRINGE_WIDTH ((IT)->w) > 0)       \\\n       : (WINDOW_RIGHT_FRINGE_WIDTH ((IT)->w) > 0))     \\\n   && (IT)->current_x == (IT)->last_visible_x           \\\n   && (IT)->line_wrap != WORD_WRAP)\n\n" (span (|@| (class "preprocessor") (id "F:16695")) "#else") " " (span (|@| (class "comment-delimiter") (id "F:16701")) "/* ") (span (|@| (class "comment") (id "F:16704")) "!HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:16724")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:16727")) "#define") " " (span (|@| (class "function-name") (id "F:16735")) "IT_OVERFLOW_NEWLINE_INTO_FRINGE") "(" (span (|@| (class "variable-name") (id "F:16767")) "it") ") 0\n" (span (|@| (class "preprocessor") (id "F:16773")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:16780")) "/* ") (span (|@| (class "comment") (id "F:16783")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:16802")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:16806")) "/* ") (span (|@| (class "comment") (id "F:16809")) "Test if the display element loaded in IT is a space or tab\n   character.  This is used to determine word wrapping.  ") (span (|@| (class "comment-delimiter") (id "F:16925")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:16929")) "#define") " " (span (|@| (class "function-name") (id "F:16937")) "IT_DISPLAYING_WHITESPACE") "(" (span (|@| (class "variable-name") (id "F:16962")) "it") ")                            \\\n  (it->what == IT_CHARACTER && (it->c == " (span (|@| (class "string") (id "F:17012")) "' '") " || it->c == " (span (|@| (class "string") (id "F:17028")) "'\\t'") "))\n\n" (span (|@| (class "comment-delimiter") (id "F:17036")) "/* ") (span (|@| (class "comment") (id "F:17039")) "Non-nil means show the text cursor in void text areas\n   i.e. in blank areas after eol and eob.  This used to be\n   the default in 21.3.  ") (span (|@| (class "comment-delimiter") (id "F:17177")) "*/") "\n\n" (span (|@| (class "type") (id "F:17181")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:17193")) "Vvoid_text_area_pointer") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:17219")) "/* ") (span (|@| (class "comment") (id "F:17222")) "Name of the face used to highlight trailing whitespace.  ") (span (|@| (class "comment-delimiter") (id "F:17279")) "*/") "\n\n" (span (|@| (class "type") (id "F:17283")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:17295")) "Qtrailing_whitespace") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:17318")) "/* ") (span (|@| (class "comment") (id "F:17321")) "Name and number of the face used to highlight escape glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:17383")) "*/") "\n\n" (span (|@| (class "type") (id "F:17387")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:17399")) "Qescape_glyph") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:17415")) "/* ") (span (|@| (class "comment") (id "F:17418")) "Name and number of the face used to highlight non-breaking spaces.  ") (span (|@| (class "comment-delimiter") (id "F:17486")) "*/") "\n\n" (span (|@| (class "type") (id "F:17490")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:17502")) "Qnobreak_space") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:17519")) "/* ") (span (|@| (class "comment") (id "F:17522")) "The symbol `image' which is the car of the lists used to represent\n   images in Lisp.  Also a tool bar style.  ") (span (|@| (class "comment-delimiter") (id "F:17633")) "*/") "\n\n" (span (|@| (class "type") (id "F:17637")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:17649")) "Qimage") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:17658")) "/* ") (span (|@| (class "comment") (id "F:17661")) "The image map types.  ") (span (|@| (class "comment-delimiter") (id "F:17683")) "*/") "\n" (span (|@| (class "type") (id "F:17686")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:17698")) "QCmap") ", " (span (|@| (class "variable-name") (id "F:17705")) "QCpointer") ";\n" (span (|@| (class "type") (id "F:17716")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:17728")) "Qrect") ", " (span (|@| (class "variable-name") (id "F:17735")) "Qcircle") ", " (span (|@| (class "variable-name") (id "F:17744")) "Qpoly") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:17752")) "/* ") (span (|@| (class "comment") (id "F:17755")) "Tool bar styles ") (span (|@| (class "comment-delimiter") (id "F:17771")) "*/") "\n" (span (|@| (class "type") (id "F:17774")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:17786")) "Qtext") ", " (span (|@| (class "variable-name") (id "F:17793")) "Qboth") ", " (span (|@| (class "variable-name") (id "F:17800")) "Qboth_horiz") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:17814")) "/* ") (span (|@| (class "comment") (id "F:17817")) "Non-zero means print newline to stdout before next mini-buffer\n   message.  ") (span (|@| (class "comment-delimiter") (id "F:17893")) "*/") "\n\n" (span (|@| (class "type") (id "F:17897")) "int") " " (span (|@| (class "variable-name") (id "F:17901")) "noninteractive_need_newline") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:17931")) "/* ") (span (|@| (class "comment") (id "F:17934")) "Non-zero means print newline to message log before next message.  ") (span (|@| (class "comment-delimiter") (id "F:18000")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:18004")) "static") " " (span (|@| (class "type") (id "F:18011")) "int") " " (span (|@| (class "variable-name") (id "F:18015")) "message_log_need_newline") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:18042")) "/* ") (span (|@| (class "comment") (id "F:18045")) "Three markers that message_dolog uses.\n   It could allocate them itself, but that causes trouble\n   in handling memory-full errors.  ") (span (|@| (class "comment-delimiter") (id "F:18178")) "*/") "\n" (span (|@| (class "keyword") (id "F:18181")) "static") " " (span (|@| (class "type") (id "F:18188")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:18200")) "message_dolog_marker1") ";\n" (span (|@| (class "keyword") (id "F:18223")) "static") " " (span (|@| (class "type") (id "F:18230")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:18242")) "message_dolog_marker2") ";\n" (span (|@| (class "keyword") (id "F:18265")) "static") " " (span (|@| (class "type") (id "F:18272")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:18284")) "message_dolog_marker3") ";\n\f\n" (span (|@| (class "comment-delimiter") (id "F:18309")) "/* ") (span (|@| (class "comment") (id "F:18312")) "The buffer position of the first character appearing entirely or\n   partially on the line of the selected window which contains the\n   cursor; <= 0 if not known.  Set by set_cursor_from_row, used for\n   redisplay optimization in redisplay_internal.  ") (span (|@| (class "comment-delimiter") (id "F:18562")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:18566")) "static") " " (span (|@| (class "keyword") (id "F:18573")) "struct") " " (span (|@| (class "type") (id "F:18580")) "text_pos") " " (span (|@| (class "variable-name") (id "F:18589")) "this_line_start_pos") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:18611")) "/* ") (span (|@| (class "comment") (id "F:18614")) "Number of characters past the end of the line above, including the\n   terminating newline.  ") (span (|@| (class "comment-delimiter") (id "F:18706")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:18710")) "static") " " (span (|@| (class "keyword") (id "F:18717")) "struct") " " (span (|@| (class "type") (id "F:18724")) "text_pos") " " (span (|@| (class "variable-name") (id "F:18733")) "this_line_end_pos") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:18753")) "/* ") (span (|@| (class "comment") (id "F:18756")) "The vertical positions and the height of this line.  ") (span (|@| (class "comment-delimiter") (id "F:18809")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:18813")) "static") " " (span (|@| (class "type") (id "F:18820")) "int") " " (span (|@| (class "variable-name") (id "F:18824")) "this_line_vpos") ";\n" (span (|@| (class "keyword") (id "F:18840")) "static") " " (span (|@| (class "type") (id "F:18847")) "int") " " (span (|@| (class "variable-name") (id "F:18851")) "this_line_y") ";\n" (span (|@| (class "keyword") (id "F:18864")) "static") " " (span (|@| (class "type") (id "F:18871")) "int") " " (span (|@| (class "variable-name") (id "F:18875")) "this_line_pixel_height") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:18900")) "/* ") (span (|@| (class "comment") (id "F:18903")) "X position at which this display line starts.  Usually zero;\n   negative if first character is partially visible.  ") (span (|@| (class "comment-delimiter") (id "F:19018")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:19022")) "static") " " (span (|@| (class "type") (id "F:19029")) "int") " " (span (|@| (class "variable-name") (id "F:19033")) "this_line_start_x") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:19053")) "/* ") (span (|@| (class "comment") (id "F:19056")) "Buffer that this_line_.* variables are referring to.  ") (span (|@| (class "comment-delimiter") (id "F:19110")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:19114")) "static") " " (span (|@| (class "keyword") (id "F:19121")) "struct") " " (span (|@| (class "type") (id "F:19128")) "buffer") " *" (span (|@| (class "variable-name") (id "F:19136")) "this_line_buffer") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:19155")) "/* ") (span (|@| (class "comment") (id "F:19158")) "Nonzero means truncate lines in all windows less wide than the\n   frame.  ") (span (|@| (class "comment-delimiter") (id "F:19232")) "*/") "\n\n" (span (|@| (class "type") (id "F:19236")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:19248")) "Vtruncate_partial_width_windows") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:19282")) "/* ") (span (|@| (class "comment") (id "F:19285")) "A flag to control how to display unibyte 8-bit character.  ") (span (|@| (class "comment-delimiter") (id "F:19344")) "*/") "\n\n" (span (|@| (class "type") (id "F:19348")) "int") " " (span (|@| (class "variable-name") (id "F:19352")) "unibyte_display_via_language_environment") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:19395")) "/* ") (span (|@| (class "comment") (id "F:19398")) "Nonzero means we have more than one non-mini-buffer-only frame.\n   Not guaranteed to be accurate except while parsing\n   frame-title-format.  ") (span (|@| (class "comment-delimiter") (id "F:19540")) "*/") "\n\n" (span (|@| (class "type") (id "F:19544")) "int") " " (span (|@| (class "variable-name") (id "F:19548")) "multiple_frames") ";\n\n" (span (|@| (class "type") (id "F:19566")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:19578")) "Vglobal_mode_string") ";\n\n\n" (span (|@| (class "comment-delimiter") (id "F:19601")) "/* ") (span (|@| (class "comment") (id "F:19604")) "List of variables (symbols) which hold markers for overlay arrows.\n   The symbols on this list are examined during redisplay to determine\n   where to display overlay arrows.  ") (span (|@| (class "comment-delimiter") (id "F:19779")) "*/") "\n\n" (span (|@| (class "type") (id "F:19783")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:19795")) "Voverlay_arrow_variable_list") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:19826")) "/* ") (span (|@| (class "comment") (id "F:19829")) "Marker for where to display an arrow on top of the buffer text.  ") (span (|@| (class "comment-delimiter") (id "F:19894")) "*/") "\n\n" (span (|@| (class "type") (id "F:19898")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:19910")) "Voverlay_arrow_position") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:19936")) "/* ") (span (|@| (class "comment") (id "F:19939")) "String to display for the arrow.  Only used on terminal frames.  ") (span (|@| (class "comment-delimiter") (id "F:20004")) "*/") "\n\n" (span (|@| (class "type") (id "F:20008")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:20020")) "Voverlay_arrow_string") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:20044")) "/* ") (span (|@| (class "comment") (id "F:20047")) "Values of those variables at last redisplay are stored as\n   properties on `overlay-arrow-position' symbol.  However, if\n   Voverlay_arrow_position is a marker, last-arrow-position is its\n   numerical position.  ") (span (|@| (class "comment-delimiter") (id "F:20259")) "*/") "\n\n" (span (|@| (class "type") (id "F:20263")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:20275")) "Qlast_arrow_position") ", " (span (|@| (class "variable-name") (id "F:20297")) "Qlast_arrow_string") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:20318")) "/* ") (span (|@| (class "comment") (id "F:20321")) "Alternative overlay-arrow-string and overlay-arrow-bitmap\n   properties on a symbol in overlay-arrow-variable-list.  ") (span (|@| (class "comment-delimiter") (id "F:20438")) "*/") "\n\n" (span (|@| (class "type") (id "F:20442")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:20454")) "Qoverlay_arrow_string") ", " (span (|@| (class "variable-name") (id "F:20477")) "Qoverlay_arrow_bitmap") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:20501")) "/* ") (span (|@| (class "comment") (id "F:20504")) "Like mode-line-format, but for the title bar on a visible frame.  ") (span (|@| (class "comment-delimiter") (id "F:20570")) "*/") "\n\n" (span (|@| (class "type") (id "F:20574")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:20586")) "Vframe_title_format") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:20608")) "/* ") (span (|@| (class "comment") (id "F:20611")) "Like mode-line-format, but for the title bar on an iconified frame.  ") (span (|@| (class "comment-delimiter") (id "F:20680")) "*/") "\n\n" (span (|@| (class "type") (id "F:20684")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:20696")) "Vicon_title_format") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:20717")) "/* ") (span (|@| (class "comment") (id "F:20720")) "List of functions to call when a window's size changes.  These\n   functions get one arg, a frame on which one or more windows' sizes\n   have changed.  ") (span (|@| (class "comment-delimiter") (id "F:20871")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:20875")) "static") " " (span (|@| (class "type") (id "F:20882")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:20894")) "Vwindow_size_change_functions") ";\n\n" (span (|@| (class "type") (id "F:20926")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:20938")) "Qmenu_bar_update_hook") ", " (span (|@| (class "variable-name") (id "F:20961")) "Vmenu_bar_update_hook") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:20985")) "/* ") (span (|@| (class "comment") (id "F:20988")) "Nonzero if an overlay arrow has been displayed in this window.  ") (span (|@| (class "comment-delimiter") (id "F:21052")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:21056")) "static") " " (span (|@| (class "type") (id "F:21063")) "int") " " (span (|@| (class "variable-name") (id "F:21067")) "overlay_arrow_seen") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:21088")) "/* ") (span (|@| (class "comment") (id "F:21091")) "Nonzero means highlight the region even in nonselected windows.  ") (span (|@| (class "comment-delimiter") (id "F:21156")) "*/") "\n\n" (span (|@| (class "type") (id "F:21160")) "int") " " (span (|@| (class "variable-name") (id "F:21164")) "highlight_nonselected_windows") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:21196")) "/* ") (span (|@| (class "comment") (id "F:21199")) "If cursor motion alone moves point off frame, try scrolling this\n   many lines up or down if that will bring it back.  ") (span (|@| (class "comment-delimiter") (id "F:21318")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:21322")) "static") " " (span (|@| (class "type") (id "F:21329")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:21339")) "scroll_step") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:21353")) "/* ") (span (|@| (class "comment") (id "F:21356")) "Nonzero means scroll just far enough to bring point back on the\n   screen, when appropriate.  ") (span (|@| (class "comment-delimiter") (id "F:21450")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:21454")) "static") " " (span (|@| (class "type") (id "F:21461")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:21471")) "scroll_conservatively") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:21495")) "/* ") (span (|@| (class "comment") (id "F:21498")) "Recenter the window whenever point gets within this many lines of\n   the top or bottom of the window.  This value is translated into a\n   pixel value by multiplying it with FRAME_LINE_HEIGHT, which means\n   that there is really a fixed pixel height scroll margin.  ") (span (|@| (class "comment-delimiter") (id "F:21763")) "*/") "\n\n" (span (|@| (class "type") (id "F:21767")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:21777")) "scroll_margin") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:21793")) "/* ") (span (|@| (class "comment") (id "F:21796")) "Number of windows showing the buffer of the selected window (or\n   another buffer with the same base buffer).  keyboard.c refers to\n   this.  ") (span (|@| (class "comment-delimiter") (id "F:21938")) "*/") "\n\n" (span (|@| (class "type") (id "F:21942")) "int") " " (span (|@| (class "variable-name") (id "F:21946")) "buffer_shared") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:21962")) "/* ") (span (|@| (class "comment") (id "F:21965")) "Vector containing glyphs for an ellipsis `...'.  ") (span (|@| (class "comment-delimiter") (id "F:22014")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:22018")) "static") " " (span (|@| (class "type") (id "F:22025")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:22037")) "default_invis_vector") "[3];\n\n" (span (|@| (class "comment-delimiter") (id "F:22063")) "/* ") (span (|@| (class "comment") (id "F:22066")) "Zero means display the mode-line/header-line/menu-bar in the default face\n   (this slightly odd definition is for compatibility with previous versions\n   of emacs), non-zero means display them using their respective faces.\n\n   This variable is deprecated.  ") (span (|@| (class "comment-delimiter") (id "F:22323")) "*/") "\n\n" (span (|@| (class "type") (id "F:22327")) "int") " " (span (|@| (class "variable-name") (id "F:22331")) "mode_line_inverse_video") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:22357")) "/* ") (span (|@| (class "comment") (id "F:22360")) "Prompt to display in front of the mini-buffer contents.  ") (span (|@| (class "comment-delimiter") (id "F:22417")) "*/") "\n\n" (span (|@| (class "type") (id "F:22421")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:22433")) "minibuf_prompt") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:22450")) "/* ") (span (|@| (class "comment") (id "F:22453")) "Width of current mini-buffer prompt.  Only set after display_line\n   of the line that contains the prompt.  ") (span (|@| (class "comment-delimiter") (id "F:22561")) "*/") "\n\n" (span (|@| (class "type") (id "F:22565")) "int") " " (span (|@| (class "variable-name") (id "F:22569")) "minibuf_prompt_width") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:22592")) "/* ") (span (|@| (class "comment") (id "F:22595")) "This is the window where the echo area message was displayed.  It\n   is always a mini-buffer window, but it may not be the same window\n   currently active as a mini-buffer.  ") (span (|@| (class "comment-delimiter") (id "F:22769")) "*/") "\n\n" (span (|@| (class "type") (id "F:22773")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:22785")) "echo_area_window") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:22804")) "/* ") (span (|@| (class "comment") (id "F:22807")) "List of pairs (MESSAGE . MULTIBYTE).  The function save_message\n   pushes the current message and the value of\n   message_enable_multibyte on the stack, the function restore_message\n   pops the stack and displays MESSAGE again.  ") (span (|@| (class "comment-delimiter") (id "F:23036")) "*/") "\n\n" (span (|@| (class "type") (id "F:23040")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:23052")) "Vmessage_stack") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:23069")) "/* ") (span (|@| (class "comment") (id "F:23072")) "Nonzero means multibyte characters were enabled when the echo area\n   message was specified.  ") (span (|@| (class "comment-delimiter") (id "F:23166")) "*/") "\n\n" (span (|@| (class "type") (id "F:23170")) "int") " " (span (|@| (class "variable-name") (id "F:23174")) "message_enable_multibyte") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:23201")) "/* ") (span (|@| (class "comment") (id "F:23204")) "Nonzero if we should redraw the mode lines on the next redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:23271")) "*/") "\n\n" (span (|@| (class "type") (id "F:23275")) "int") " " (span (|@| (class "variable-name") (id "F:23279")) "update_mode_lines") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:23299")) "/* ") (span (|@| (class "comment") (id "F:23302")) "Nonzero if window sizes or contents have changed since last\n   redisplay that finished.  ") (span (|@| (class "comment-delimiter") (id "F:23391")) "*/") "\n\n" (span (|@| (class "type") (id "F:23395")) "int") " " (span (|@| (class "variable-name") (id "F:23399")) "windows_or_buffers_changed") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:23428")) "/* ") (span (|@| (class "comment") (id "F:23431")) "Nonzero means a frame's cursor type has been changed.  ") (span (|@| (class "comment-delimiter") (id "F:23486")) "*/") "\n\n" (span (|@| (class "type") (id "F:23490")) "int") " " (span (|@| (class "variable-name") (id "F:23494")) "cursor_type_changed") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:23516")) "/* ") (span (|@| (class "comment") (id "F:23519")) "Nonzero after display_mode_line if %l was used and it displayed a\n   line number.  ") (span (|@| (class "comment-delimiter") (id "F:23602")) "*/") "\n\n" (span (|@| (class "type") (id "F:23606")) "int") " " (span (|@| (class "variable-name") (id "F:23610")) "line_number_displayed") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:23634")) "/* ") (span (|@| (class "comment") (id "F:23637")) "Maximum buffer size for which to display line numbers.  ") (span (|@| (class "comment-delimiter") (id "F:23693")) "*/") "\n\n" (span (|@| (class "type") (id "F:23697")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:23709")) "Vline_number_display_limit") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:23738")) "/* ") (span (|@| (class "comment") (id "F:23741")) "Line width to consider when repositioning for line number display.  ") (span (|@| (class "comment-delimiter") (id "F:23809")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:23813")) "static") " " (span (|@| (class "type") (id "F:23820")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:23830")) "line_number_display_limit_width") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:23864")) "/* ") (span (|@| (class "comment") (id "F:23867")) "Number of lines to keep in the message log buffer.  t means\n   infinite.  nil means don't log at all.  ") (span (|@| (class "comment-delimiter") (id "F:23970")) "*/") "\n\n" (span (|@| (class "type") (id "F:23974")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:23986")) "Vmessage_log_max") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:24005")) "/* ") (span (|@| (class "comment") (id "F:24008")) "The name of the *Messages* buffer, a string.  ") (span (|@| (class "comment-delimiter") (id "F:24054")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:24058")) "static") " " (span (|@| (class "type") (id "F:24065")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:24077")) "Vmessages_buffer_name") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:24101")) "/* ") (span (|@| (class "comment") (id "F:24104")) "Current, index 0, and last displayed echo area message.  Either\n   buffers from echo_buffers, or nil to indicate no message.  ") (span (|@| (class "comment-delimiter") (id "F:24230")) "*/") "\n\n" (span (|@| (class "type") (id "F:24234")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:24246")) "echo_area_buffer") "[2];\n\n" (span (|@| (class "comment-delimiter") (id "F:24268")) "/* ") (span (|@| (class "comment") (id "F:24271")) "The buffers referenced from echo_area_buffer.  ") (span (|@| (class "comment-delimiter") (id "F:24318")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:24322")) "static") " " (span (|@| (class "type") (id "F:24329")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:24341")) "echo_buffer") "[2];\n\n" (span (|@| (class "comment-delimiter") (id "F:24358")) "/* ") (span (|@| (class "comment") (id "F:24361")) "A vector saved used in with_area_buffer to reduce consing.  ") (span (|@| (class "comment-delimiter") (id "F:24421")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:24425")) "static") " " (span (|@| (class "type") (id "F:24432")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:24444")) "Vwith_echo_area_save_vector") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:24474")) "/* ") (span (|@| (class "comment") (id "F:24477")) "Non-zero means display_echo_area should display the last echo area\n   message again.  Set by redisplay_preserve_echo_area.  ") (span (|@| (class "comment-delimiter") (id "F:24601")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:24605")) "static") " " (span (|@| (class "type") (id "F:24612")) "int") " " (span (|@| (class "variable-name") (id "F:24616")) "display_last_displayed_message_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:24651")) "/* ") (span (|@| (class "comment") (id "F:24654")) "Nonzero if echo area is being used by print; zero if being used by\n   message.  ") (span (|@| (class "comment-delimiter") (id "F:24734")) "*/") "\n\n" (span (|@| (class "type") (id "F:24738")) "int") " " (span (|@| (class "variable-name") (id "F:24742")) "message_buf_print") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:24762")) "/* ") (span (|@| (class "comment") (id "F:24765")) "The symbol `inhibit-menubar-update' and its DEFVAR_BOOL variable.  ") (span (|@| (class "comment-delimiter") (id "F:24832")) "*/") "\n\n" (span (|@| (class "type") (id "F:24836")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:24848")) "Qinhibit_menubar_update") ";\n" (span (|@| (class "type") (id "F:24873")) "int") " " (span (|@| (class "variable-name") (id "F:24877")) "inhibit_menubar_update") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:24902")) "/* ") (span (|@| (class "comment") (id "F:24905")) "When evaluating expressions from menu bar items (enable conditions,\n   for instance), this is the frame they are being processed for.  ") (span (|@| (class "comment-delimiter") (id "F:25040")) "*/") "\n\n" (span (|@| (class "type") (id "F:25044")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:25056")) "Vmenu_updating_frame") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:25079")) "/* ") (span (|@| (class "comment") (id "F:25082")) "Maximum height for resizing mini-windows.  Either a float\n   specifying a fraction of the available height, or an integer\n   specifying a number of lines.  ") (span (|@| (class "comment-delimiter") (id "F:25238")) "*/") "\n\n" (span (|@| (class "type") (id "F:25242")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:25254")) "Vmax_mini_window_height") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:25280")) "/* ") (span (|@| (class "comment") (id "F:25283")) "Non-zero means messages should be displayed with truncated\n   lines instead of being continued.  ") (span (|@| (class "comment-delimiter") (id "F:25380")) "*/") "\n\n" (span (|@| (class "type") (id "F:25384")) "int") " " (span (|@| (class "variable-name") (id "F:25388")) "message_truncate_lines") ";\n" (span (|@| (class "type") (id "F:25412")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:25424")) "Qmessage_truncate_lines") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:25450")) "/* ") (span (|@| (class "comment") (id "F:25453")) "Set to 1 in clear_message to make redisplay_internal aware\n   of an emptied echo area.  ") (span (|@| (class "comment-delimiter") (id "F:25541")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:25545")) "static") " " (span (|@| (class "type") (id "F:25552")) "int") " " (span (|@| (class "variable-name") (id "F:25556")) "message_cleared_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:25576")) "/* ") (span (|@| (class "comment") (id "F:25579")) "How to blink the default frame cursor off.  ") (span (|@| (class "comment-delimiter") (id "F:25623")) "*/") "\n" (span (|@| (class "type") (id "F:25626")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:25638")) "Vblink_cursor_alist") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:25660")) "/* ") (span (|@| (class "comment") (id "F:25663")) "A scratch glyph row with contents used for generating truncation\n   glyphs.  Also used in direct_output_for_insert.  ") (span (|@| (class "comment-delimiter") (id "F:25780")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:25784")) "#define") " " (span (|@| (class "variable-name") (id "F:25792")) "MAX_SCRATCH_GLYPHS") " 100\n" (span (|@| (class "keyword") (id "F:25815")) "struct") " " (span (|@| (class "type") (id "F:25822")) "glyph_row") " " (span (|@| (class "variable-name") (id "F:25832")) "scratch_glyph_row") ";\n" (span (|@| (class "keyword") (id "F:25851")) "static") " " (span (|@| (class "keyword") (id "F:25858")) "struct") " " (span (|@| (class "type") (id "F:25865")) "glyph") " " (span (|@| (class "variable-name") (id "F:25871")) "scratch_glyphs") "[MAX_SCRATCH_GLYPHS];\n\n" (span (|@| (class "comment-delimiter") (id "F:25908")) "/* ") (span (|@| (class "comment") (id "F:25911")) "Ascent and height of the last line processed by move_it_to.  ") (span (|@| (class "comment-delimiter") (id "F:25972")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:25976")) "static") " " (span (|@| (class "type") (id "F:25983")) "int") " " (span (|@| (class "variable-name") (id "F:25987")) "last_max_ascent") ", " (span (|@| (class "variable-name") (id "F:26004")) "last_height") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:26018")) "/* ") (span (|@| (class "comment") (id "F:26021")) "Non-zero if there's a help-echo in the echo area.  ") (span (|@| (class "comment-delimiter") (id "F:26072")) "*/") "\n\n" (span (|@| (class "type") (id "F:26076")) "int") " " (span (|@| (class "variable-name") (id "F:26080")) "help_echo_showing_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:26102")) "/* ") (span (|@| (class "comment") (id "F:26105")) "If >= 0, computed, exact values of mode-line and header-line height\n   to use in the macros CURRENT_MODE_LINE_HEIGHT and\n   CURRENT_HEADER_LINE_HEIGHT.  ") (span (|@| (class "comment-delimiter") (id "F:26258")) "*/") "\n\n" (span (|@| (class "type") (id "F:26262")) "int") " " (span (|@| (class "variable-name") (id "F:26266")) "current_mode_line_height") ", " (span (|@| (class "variable-name") (id "F:26292")) "current_header_line_height") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:26321")) "/* ") (span (|@| (class "comment") (id "F:26324")) "The maximum distance to look ahead for text properties.  Values\n   that are too small let us call compute_char_face and similar\n   functions too often which is expensive.  Values that are too large\n   let us call compute_char_face and alike too often because we\n   might not be interested in text properties that far away.  ") (span (|@| (class "comment-delimiter") (id "F:26648")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:26652")) "#define") " " (span (|@| (class "variable-name") (id "F:26660")) "TEXT_PROP_DISTANCE_LIMIT") " 100\n\n" (span (|@| (class "preprocessor") (id "F:26690")) "#if") " GLYPH_DEBUG\n\n" (span (|@| (class "comment-delimiter") (id "F:26707")) "/* ") (span (|@| (class "comment") (id "F:26710")) "Variables to turn off display optimizations from Lisp.  ") (span (|@| (class "comment-delimiter") (id "F:26766")) "*/") "\n\n" (span (|@| (class "type") (id "F:26770")) "int") " " (span (|@| (class "variable-name") (id "F:26774")) "inhibit_try_window_id") ", " (span (|@| (class "variable-name") (id "F:26797")) "inhibit_try_window_reusing") ";\n" (span (|@| (class "type") (id "F:26825")) "int") " " (span (|@| (class "variable-name") (id "F:26829")) "inhibit_try_cursor_movement") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:26859")) "/* ") (span (|@| (class "comment") (id "F:26862")) "Non-zero means print traces of redisplay if compiled with\n   GLYPH_DEBUG != 0.  ") (span (|@| (class "comment-delimiter") (id "F:26942")) "*/") "\n\n" (span (|@| (class "type") (id "F:26946")) "int") " " (span (|@| (class "variable-name") (id "F:26950")) "trace_redisplay_p") ";\n\n" (span (|@| (class "preprocessor") (id "F:26970")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:26977")) "/* ") (span (|@| (class "comment") (id "F:26980")) "GLYPH_DEBUG ") (span (|@| (class "comment-delimiter") (id "F:26992")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:26996")) "#ifdef") " DEBUG_TRACE_MOVE\n" (span (|@| (class "comment-delimiter") (id "F:27020")) "/* ") (span (|@| (class "comment") (id "F:27023")) "Non-zero means trace with TRACE_MOVE to stderr.  ") (span (|@| (class "comment-delimiter") (id "F:27072")) "*/") "\n" (span (|@| (class "type") (id "F:27075")) "int") " " (span (|@| (class "variable-name") (id "F:27079")) "trace_move") ";\n\n" (span (|@| (class "preprocessor") (id "F:27092")) "#define") " " (span (|@| (class "function-name") (id "F:27100")) "TRACE_MOVE") "(" (span (|@| (class "variable-name") (id "F:27111")) "x") ")   " (span (|@| (class "keyword") (id "F:27114")) "if") " (trace_move) " (span (|@| (class "type") (id "F:27130")) "fprintf") " " (span (|@| (class "variable-name") (id "F:27138")) "x") "; " (span (|@| (class "keyword") (id "F:27141")) "else") " (" (span (|@| (class "type") (id "F:27147")) "void") ") 0\n" (span (|@| (class "preprocessor") (id "F:27155")) "#else") "\n" (span (|@| (class "preprocessor") (id "F:27161")) "#define") " " (span (|@| (class "function-name") (id "F:27169")) "TRACE_MOVE") "(" (span (|@| (class "variable-name") (id "F:27180")) "x") ")   (" (span (|@| (class "type") (id "F:27184")) "void") ") 0\n" (span (|@| (class "preprocessor") (id "F:27192")) "#endif") "\n\n" (span (|@| (class "comment-delimiter") (id "F:27200")) "/* ") (span (|@| (class "comment") (id "F:27203")) "Non-zero means automatically scroll windows horizontally to make\n   point visible.  ") (span (|@| (class "comment-delimiter") (id "F:27287")) "*/") "\n\n" (span (|@| (class "type") (id "F:27291")) "int") " " (span (|@| (class "variable-name") (id "F:27295")) "automatic_hscrolling_p") ";\n" (span (|@| (class "type") (id "F:27319")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:27331")) "Qauto_hscroll_mode") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:27352")) "/* ") (span (|@| (class "comment") (id "F:27355")) "How close to the margin can point get before the window is scrolled\n   horizontally.  ") (span (|@| (class "comment-delimiter") (id "F:27441")) "*/") "\n" (span (|@| (class "type") (id "F:27444")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:27454")) "hscroll_margin") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:27471")) "/* ") (span (|@| (class "comment") (id "F:27474")) "How much to scroll horizontally when point is inside the above margin.  ") (span (|@| (class "comment-delimiter") (id "F:27546")) "*/") "\n" (span (|@| (class "type") (id "F:27549")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:27561")) "Vhscroll_step") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:27577")) "/* ") (span (|@| (class "comment") (id "F:27580")) "The variable `resize-mini-windows'.  If nil, don't resize\n   mini-windows.  If t, always resize them to fit the text they\n   display.  If `grow-only', let mini-windows grow only until they\n   become empty.  ") (span (|@| (class "comment-delimiter") (id "F:27787")) "*/") "\n\n" (span (|@| (class "type") (id "F:27791")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:27803")) "Vresize_mini_windows") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:27826")) "/* ") (span (|@| (class "comment") (id "F:27829")) "Buffer being redisplayed -- for redisplay_window_error.  ") (span (|@| (class "comment-delimiter") (id "F:27886")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:27890")) "struct") " " (span (|@| (class "type") (id "F:27897")) "buffer") " *" (span (|@| (class "variable-name") (id "F:27905")) "displayed_buffer") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:27924")) "/* ") (span (|@| (class "comment") (id "F:27927")) "Space between overline and text. ") (span (|@| (class "comment-delimiter") (id "F:27960")) "*/") "\n\n" (span (|@| (class "type") (id "F:27964")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:27974")) "overline_margin") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:27992")) "/* ") (span (|@| (class "comment") (id "F:27995")) "Require underline to be at least this many screen pixels below baseline\n   This to avoid underline \"merging\" with the base of letters at small\n   font sizes, particularly when x_use_underline_position_properties is on. ") (span (|@| (class "comment-delimiter") (id "F:28214")) "*/") "\n\n" (span (|@| (class "type") (id "F:28218")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:28228")) "underline_minimum_offset") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:28255")) "/* ") (span (|@| (class "comment") (id "F:28258")) "Value returned from text property handlers (see below).  ") (span (|@| (class "comment-delimiter") (id "F:28315")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:28319")) "enum") " " (span (|@| (class "type") (id "F:28324")) "prop_handled") "\n{\n  " (span (|@| (class "variable-name") (id "F:28341")) "HANDLED_NORMALLY") ",\n  " (span (|@| (class "variable-name") (id "F:28361")) "HANDLED_RECOMPUTE_PROPS") ",\n  " (span (|@| (class "variable-name") (id "F:28388")) "HANDLED_OVERLAY_STRING_CONSUMED") ",\n  " (span (|@| (class "variable-name") (id "F:28423")) "HANDLED_RETURN") "\n};\n\n" (span (|@| (class "comment-delimiter") (id "F:28442")) "/* ") (span (|@| (class "comment") (id "F:28445")) "A description of text properties that redisplay is interested\n   in.  ") (span (|@| (class "comment-delimiter") (id "F:28515")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:28519")) "struct") " " (span (|@| (class "type") (id "F:28526")) "props") "\n{\n  " (span (|@| (class "comment-delimiter") (id "F:28536")) "/* ") (span (|@| (class "comment") (id "F:28539")) "The name of the property.  ") (span (|@| (class "comment-delimiter") (id "F:28566")) "*/") "\n  " (span (|@| (class "type") (id "F:28571")) "Lisp_Object") " *" (span (|@| (class "variable-name") (id "F:28584")) "name") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:28593")) "/* ") (span (|@| (class "comment") (id "F:28596")) "A unique index for the property.  ") (span (|@| (class "comment-delimiter") (id "F:28630")) "*/") "\n  " (span (|@| (class "keyword") (id "F:28635")) "enum") " " (span (|@| (class "type") (id "F:28640")) "prop_idx") " " (span (|@| (class "variable-name") (id "F:28649")) "idx") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:28657")) "/* ") (span (|@| (class "comment") (id "F:28660")) "A handler function called to set up iterator IT from the property\n     at IT's current position.  Value is used to steer handle_stop.  ") (span (|@| (class "comment-delimiter") (id "F:28795")) "*/") "\n  " (span (|@| (class "keyword") (id "F:28800")) "enum") " " (span (|@| (class "type") (id "F:28805")) "prop_handled") " (*" (span (|@| (class "function-name") (id "F:28820")) "handler") ") P_ ((" (span (|@| (class "keyword") (id "F:28834")) "struct") " " (span (|@| (class "type") (id "F:28841")) "it") " *" (span (|@| (class "variable-name") (id "F:28845")) "it") "));\n};\n\n" (span (|@| (class "keyword") (id "F:28855")) "static") " " (span (|@| (class "keyword") (id "F:28862")) "enum") " " (span (|@| (class "type") (id "F:28867")) "prop_handled") " handle_face_prop P_ ((" (span (|@| (class "keyword") (id "F:28902")) "struct") " " (span (|@| (class "type") (id "F:28909")) "it") " *));\n" (span (|@| (class "keyword") (id "F:28917")) "static") " " (span (|@| (class "keyword") (id "F:28924")) "enum") " " (span (|@| (class "type") (id "F:28929")) "prop_handled") " handle_invisible_prop P_ ((" (span (|@| (class "keyword") (id "F:28969")) "struct") " " (span (|@| (class "type") (id "F:28976")) "it") " *));\n" (span (|@| (class "keyword") (id "F:28984")) "static") " " (span (|@| (class "keyword") (id "F:28991")) "enum") " " (span (|@| (class "type") (id "F:28996")) "prop_handled") " handle_display_prop P_ ((" (span (|@| (class "keyword") (id "F:29034")) "struct") " " (span (|@| (class "type") (id "F:29041")) "it") " *));\n" (span (|@| (class "keyword") (id "F:29049")) "static") " " (span (|@| (class "keyword") (id "F:29056")) "enum") " " (span (|@| (class "type") (id "F:29061")) "prop_handled") " handle_composition_prop P_ ((" (span (|@| (class "keyword") (id "F:29103")) "struct") " " (span (|@| (class "type") (id "F:29110")) "it") " *));\n" (span (|@| (class "keyword") (id "F:29118")) "static") " " (span (|@| (class "keyword") (id "F:29125")) "enum") " " (span (|@| (class "type") (id "F:29130")) "prop_handled") " handle_overlay_change P_ ((" (span (|@| (class "keyword") (id "F:29170")) "struct") " " (span (|@| (class "type") (id "F:29177")) "it") " *));\n" (span (|@| (class "keyword") (id "F:29185")) "static") " " (span (|@| (class "keyword") (id "F:29192")) "enum") " " (span (|@| (class "type") (id "F:29197")) "prop_handled") " handle_fontified_prop P_ ((" (span (|@| (class "keyword") (id "F:29237")) "struct") " " (span (|@| (class "type") (id "F:29244")) "it") " *));\n\n" (span (|@| (class "comment-delimiter") (id "F:29253")) "/* ") (span (|@| (class "comment") (id "F:29256")) "Properties handled by iterators.  ") (span (|@| (class "comment-delimiter") (id "F:29290")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:29294")) "static") " " (span (|@| (class "keyword") (id "F:29301")) "struct") " " (span (|@| (class "type") (id "F:29308")) "props") " " (span (|@| (class "variable-name") (id "F:29314")) "it_props") "[] =\n{\n  {&Qfontified,         FONTIFIED_PROP_IDX,     handle_fontified_prop},\n  " (span (|@| (class "comment-delimiter") (id "F:29392")) "/* ") (span (|@| (class "comment") (id "F:29395")) "Handle `face' before `display' because some sub-properties of\n     `display' need to know the face.  ") (span (|@| (class "comment-delimiter") (id "F:29496")) "*/") "\n  {&Qface,              FACE_PROP_IDX,          handle_face_prop},\n  {&Qdisplay,           DISPLAY_PROP_IDX,       handle_display_prop},\n  {&Qinvisible,         INVISIBLE_PROP_IDX,     handle_invisible_prop},\n  {&Qcomposition,       COMPOSITION_PROP_IDX,   handle_composition_prop},\n  {" (span (|@| (class "constant") (id "F:29731")) "NULL") ",                0,                      " (span (|@| (class "constant") (id "F:29743")) "NULL") "}\n};\n\n" (span (|@| (class "comment-delimiter") (id "F:29753")) "/* ") (span (|@| (class "comment") (id "F:29756")) "Value is the position described by X.  If X is a marker, value is\n   the marker_position of X.  Otherwise, value is X.  ") (span (|@| (class "comment-delimiter") (id "F:29876")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:29880")) "#define") " " (span (|@| (class "function-name") (id "F:29888")) "COERCE_MARKER") "(" (span (|@| (class "variable-name") (id "F:29902")) "X") ") (MARKERP ((X)) ? Fmarker_position (X) : (X))\n\n" (span (|@| (class "comment-delimiter") (id "F:29951")) "/* ") (span (|@| (class "comment") (id "F:29954")) "Enumeration returned by some move_it_.* functions internally.  ") (span (|@| (class "comment-delimiter") (id "F:30017")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:30021")) "enum") " " (span (|@| (class "type") (id "F:30026")) "move_it_result") "\n{\n  " (span (|@| (class "comment-delimiter") (id "F:30045")) "/* ") (span (|@| (class "comment") (id "F:30048")) "Not used.  Undefined value.  ") (span (|@| (class "comment-delimiter") (id "F:30077")) "*/") "\n  " (span (|@| (class "variable-name") (id "F:30082")) "MOVE_UNDEFINED") ",\n\n  " (span (|@| (class "comment-delimiter") (id "F:30101")) "/* ") (span (|@| (class "comment") (id "F:30104")) "Move ended at the requested buffer position or ZV.  ") (span (|@| (class "comment-delimiter") (id "F:30156")) "*/") "\n  " (span (|@| (class "variable-name") (id "F:30161")) "MOVE_POS_MATCH_OR_ZV") ",\n\n  " (span (|@| (class "comment-delimiter") (id "F:30186")) "/* ") (span (|@| (class "comment") (id "F:30189")) "Move ended at the requested X pixel position.  ") (span (|@| (class "comment-delimiter") (id "F:30236")) "*/") "\n  " (span (|@| (class "variable-name") (id "F:30241")) "MOVE_X_REACHED") ",\n\n  " (span (|@| (class "comment-delimiter") (id "F:30260")) "/* ") (span (|@| (class "comment") (id "F:30263")) "Move within a line ended at the end of a line that must be\n     continued.  ") (span (|@| (class "comment-delimiter") (id "F:30339")) "*/") "\n  " (span (|@| (class "variable-name") (id "F:30344")) "MOVE_LINE_CONTINUED") ",\n\n  " (span (|@| (class "comment-delimiter") (id "F:30368")) "/* ") (span (|@| (class "comment") (id "F:30371")) "Move within a line ended at the end of a line that would\n     be displayed truncated.  ") (span (|@| (class "comment-delimiter") (id "F:30458")) "*/") "\n  " (span (|@| (class "variable-name") (id "F:30463")) "MOVE_LINE_TRUNCATED") ",\n\n  " (span (|@| (class "comment-delimiter") (id "F:30487")) "/* ") (span (|@| (class "comment") (id "F:30490")) "Move within a line ended at a line end.  ") (span (|@| (class "comment-delimiter") (id "F:30531")) "*/") "\n  " (span (|@| (class "variable-name") (id "F:30536")) "MOVE_NEWLINE_OR_CR") "\n};\n\n" (span (|@| (class "comment-delimiter") (id "F:30559")) "/* ") (span (|@| (class "comment") (id "F:30562")) "This counter is used to clear the face cache every once in a while\n   in redisplay_internal.  It is incremented for each redisplay.\n   Every CLEAR_FACE_CACHE_COUNT full redisplays, the face cache is\n   cleared.  ") (span (|@| (class "comment-delimiter") (id "F:30774")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:30778")) "#define") " " (span (|@| (class "variable-name") (id "F:30786")) "CLEAR_FACE_CACHE_COUNT") "  500\n" (span (|@| (class "keyword") (id "F:30813")) "static") " " (span (|@| (class "type") (id "F:30820")) "int") " " (span (|@| (class "variable-name") (id "F:30824")) "clear_face_cache_count") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:30849")) "/* ") (span (|@| (class "comment") (id "F:30852")) "Similarly for the image cache.  ") (span (|@| (class "comment-delimiter") (id "F:30884")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:30888")) "#ifdef") " HAVE_WINDOW_SYSTEM\n" (span (|@| (class "preprocessor") (id "F:30914")) "#define") " " (span (|@| (class "variable-name") (id "F:30922")) "CLEAR_IMAGE_CACHE_COUNT") " 101\n" (span (|@| (class "keyword") (id "F:30950")) "static") " " (span (|@| (class "type") (id "F:30957")) "int") " " (span (|@| (class "variable-name") (id "F:30961")) "clear_image_cache_count") ";\n" (span (|@| (class "preprocessor") (id "F:30986")) "#endif") "\n\n" (span (|@| (class "comment-delimiter") (id "F:30994")) "/* ") (span (|@| (class "comment") (id "F:30997")) "Non-zero while redisplay_internal is in progress.  ") (span (|@| (class "comment-delimiter") (id "F:31048")) "*/") "\n\n" (span (|@| (class "type") (id "F:31052")) "int") " " (span (|@| (class "variable-name") (id "F:31056")) "redisplaying_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:31073")) "/* ") (span (|@| (class "comment") (id "F:31076")) "Non-zero means don't free realized faces.  Bound while freeing\n   realized faces is dangerous because glyph matrices might still\n   reference them.  ") (span (|@| (class "comment-delimiter") (id "F:31225")) "*/") "\n\n" (span (|@| (class "type") (id "F:31229")) "int") " " (span (|@| (class "variable-name") (id "F:31233")) "inhibit_free_realized_faces") ";\n" (span (|@| (class "type") (id "F:31262")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:31274")) "Qinhibit_free_realized_faces") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:31305")) "/* ") (span (|@| (class "comment") (id "F:31308")) "If a string, XTread_socket generates an event to display that string.\n   (The display is done in read_char.)  ") (span (|@| (class "comment-delimiter") (id "F:31418")) "*/") "\n\n" (span (|@| (class "type") (id "F:31422")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:31434")) "help_echo_string") ";\n" (span (|@| (class "type") (id "F:31452")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:31464")) "help_echo_window") ";\n" (span (|@| (class "type") (id "F:31482")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:31494")) "help_echo_object") ";\n" (span (|@| (class "type") (id "F:31512")) "int") " " (span (|@| (class "variable-name") (id "F:31516")) "help_echo_pos") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:31532")) "/* ") (span (|@| (class "comment") (id "F:31535")) "Temporary variable for XTread_socket.  ") (span (|@| (class "comment-delimiter") (id "F:31574")) "*/") "\n\n" (span (|@| (class "type") (id "F:31578")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:31590")) "previous_help_echo_string") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:31618")) "/* ") (span (|@| (class "comment") (id "F:31621")) "Null glyph slice ") (span (|@| (class "comment-delimiter") (id "F:31638")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:31642")) "static") " " (span (|@| (class "keyword") (id "F:31649")) "struct") " " (span (|@| (class "type") (id "F:31656")) "glyph_slice") " " (span (|@| (class "variable-name") (id "F:31668")) "null_glyph_slice") " = { 0, 0, 0, 0 };\n\n" (span (|@| (class "comment-delimiter") (id "F:31704")) "/* ") (span (|@| (class "comment") (id "F:31707")) "Platform-independent portion of hourglass implementation. ") (span (|@| (class "comment-delimiter") (id "F:31765")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:31769")) "/* ") (span (|@| (class "comment") (id "F:31772")) "Non-zero means we're allowed to display a hourglass pointer.  ") (span (|@| (class "comment-delimiter") (id "F:31834")) "*/") "\n" (span (|@| (class "type") (id "F:31837")) "int") " " (span (|@| (class "variable-name") (id "F:31841")) "display_hourglass_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:31863")) "/* ") (span (|@| (class "comment") (id "F:31866")) "Non-zero means an hourglass cursor is currently shown.  ") (span (|@| (class "comment-delimiter") (id "F:31922")) "*/") "\n" (span (|@| (class "type") (id "F:31925")) "int") " " (span (|@| (class "variable-name") (id "F:31929")) "hourglass_shown_p") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:31949")) "/* ") (span (|@| (class "comment") (id "F:31952")) "If non-null, an asynchronous timer that, when it expires, displays\n   an hourglass cursor on all frames.  ") (span (|@| (class "comment-delimiter") (id "F:32058")) "*/") "\n" (span (|@| (class "keyword") (id "F:32061")) "struct") " " (span (|@| (class "type") (id "F:32068")) "atimer") " *" (span (|@| (class "variable-name") (id "F:32076")) "hourglass_atimer") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:32095")) "/* ") (span (|@| (class "comment") (id "F:32098")) "Number of seconds to wait before displaying an hourglass cursor.  ") (span (|@| (class "comment-delimiter") (id "F:32164")) "*/") "\n" (span (|@| (class "type") (id "F:32167")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:32179")) "Vhourglass_delay") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:32198")) "/* ") (span (|@| (class "comment") (id "F:32201")) "Default number of seconds to wait before displaying an hourglass\n   cursor.  ") (span (|@| (class "comment-delimiter") (id "F:32278")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:32281")) "#define") " " (span (|@| (class "variable-name") (id "F:32289")) "DEFAULT_HOURGLASS_DELAY") " 1\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:32318")) "/* ") (span (|@| (class "comment") (id "F:32321")) "Function prototypes.  ") (span (|@| (class "comment-delimiter") (id "F:32343")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:32347")) "static") " " (span (|@| (class "type") (id "F:32354")) "void") " " (span (|@| (class "function-name") (id "F:32359")) "setup_for_ellipsis") " P_ ((" (span (|@| (class "keyword") (id "F:32383")) "struct") " " (span (|@| (class "type") (id "F:32390")) "it") " *, " (span (|@| (class "type") (id "F:32396")) "int") "));\n" (span (|@| (class "keyword") (id "F:32403")) "static") " " (span (|@| (class "type") (id "F:32410")) "void") " " (span (|@| (class "function-name") (id "F:32415")) "mark_window_display_accurate_1") " P_ ((" (span (|@| (class "keyword") (id "F:32451")) "struct") " " (span (|@| (class "type") (id "F:32458")) "window") " *, " (span (|@| (class "type") (id "F:32468")) "int") "));\n" (span (|@| (class "keyword") (id "F:32475")) "static") " " (span (|@| (class "type") (id "F:32482")) "int") " " (span (|@| (class "function-name") (id "F:32486")) "single_display_spec_string_p") " P_ ((Lisp_Object, Lisp_Object));\n" (span (|@| (class "keyword") (id "F:32548")) "static") " " (span (|@| (class "type") (id "F:32555")) "int") " " (span (|@| (class "function-name") (id "F:32559")) "display_prop_string_p") " P_ ((Lisp_Object, Lisp_Object));\n" (span (|@| (class "keyword") (id "F:32614")) "static") " " (span (|@| (class "type") (id "F:32621")) "int") " " (span (|@| (class "function-name") (id "F:32625")) "cursor_row_p") " P_ ((" (span (|@| (class "keyword") (id "F:32643")) "struct") " " (span (|@| (class "type") (id "F:32650")) "window") " *, " (span (|@| (class "keyword") (id "F:32660")) "struct") " " (span (|@| (class "type") (id "F:32667")) "glyph_row") " *));\n" (span (|@| (class "keyword") (id "F:32682")) "static") " " (span (|@| (class "type") (id "F:32689")) "int") " " (span (|@| (class "function-name") (id "F:32693")) "redisplay_mode_lines") " P_ ((Lisp_Object, " (span (|@| (class "type") (id "F:32732")) "int") "));\n" (span (|@| (class "keyword") (id "F:32739")) "static") " " (span (|@| (class "type") (id "F:32746")) "char") " *" (span (|@| (class "function-name") (id "F:32752")) "decode_mode_spec_coding") " P_ ((Lisp_Object, " (span (|@| (class "type") (id "F:32794")) "char") " *, " (span (|@| (class "type") (id "F:32802")) "int") "));\n\n" (span (|@| (class "keyword") (id "F:32810")) "static") " Lisp_Object get_it_property P_ ((" (span (|@| (class "keyword") (id "F:32850")) "struct") " " (span (|@| (class "type") (id "F:32857")) "it") " *" (span (|@| (class "variable-name") (id "F:32861")) "it") ", " (span (|@| (class "type") (id "F:32865")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:32877")) "prop") "));\n\n" (span (|@| (class "keyword") (id "F:32886")) "static") " " (span (|@| (class "type") (id "F:32893")) "void") " " (span (|@| (class "function-name") (id "F:32898")) "handle_line_prefix") " P_ ((" (span (|@| (class "keyword") (id "F:32922")) "struct") " " (span (|@| (class "type") (id "F:32929")) "it") " *));\n\n" (span (|@| (class "keyword") (id "F:32938")) "static") " " (span (|@| (class "type") (id "F:32945")) "void") " " (span (|@| (class "function-name") (id "F:32950")) "pint2str") " P_ ((" (span (|@| (class "type") (id "F:32964")) "char") " *, " (span (|@| (class "type") (id "F:32972")) "int") ", " (span (|@| (class "type") (id "F:32977")) "int") "));\n" (span (|@| (class "keyword") (id "F:32984")) "static") " " (span (|@| (class "type") (id "F:32991")) "void") " " (span (|@| (class "function-name") (id "F:32996")) "pint2hrstr") " P_ ((" (span (|@| (class "type") (id "F:33012")) "char") " *, " (span (|@| (class "type") (id "F:33020")) "int") ", " (span (|@| (class "type") (id "F:33025")) "int") "));\n" (span (|@| (class "keyword") (id "F:33032")) "static") " " (span (|@| (class "keyword") (id "F:33039")) "struct") " " (span (|@| (class "type") (id "F:33046")) "text_pos") " run_window_scroll_functions P_ ((Lisp_Object,\n                                                        " (span (|@| (class "keyword") (id "F:33108")) "struct") " " (span (|@| (class "type") (id "F:33115")) "text_pos") "));\n" (span (|@| (class "keyword") (id "F:33127")) "static") " " (span (|@| (class "type") (id "F:33134")) "void") " " (span (|@| (class "function-name") (id "F:33139")) "reconsider_clip_changes") " P_ ((" (span (|@| (class "keyword") (id "F:33168")) "struct") " " (span (|@| (class "type") (id "F:33175")) "window") " *, " (span (|@| (class "keyword") (id "F:33185")) "struct") " " (span (|@| (class "type") (id "F:33192")) "buffer") " *));\n" (span (|@| (class "keyword") (id "F:33204")) "static") " " (span (|@| (class "type") (id "F:33211")) "int") " " (span (|@| (class "function-name") (id "F:33215")) "text_outside_line_unchanged_p") " P_ ((" (span (|@| (class "keyword") (id "F:33250")) "struct") " " (span (|@| (class "type") (id "F:33257")) "window") " *, " (span (|@| (class "type") (id "F:33267")) "int") ", " (span (|@| (class "type") (id "F:33272")) "int") "));\n" (span (|@| (class "keyword") (id "F:33279")) "static") " " (span (|@| (class "type") (id "F:33286")) "void") " " (span (|@| (class "function-name") (id "F:33291")) "store_mode_line_noprop_char") " P_ ((" (span (|@| (class "type") (id "F:33324")) "char") "));\n" (span (|@| (class "keyword") (id "F:33332")) "static") " " (span (|@| (class "type") (id "F:33339")) "int") " " (span (|@| (class "function-name") (id "F:33343")) "store_mode_line_noprop") " P_ ((" (span (|@| (class "keyword") (id "F:33371")) "const") " " (span (|@| (class "type") (id "F:33377")) "unsigned") " " (span (|@| (class "type") (id "F:33386")) "char") " *, " (span (|@| (class "type") (id "F:33394")) "int") ", " (span (|@| (class "type") (id "F:33399")) "int") "));\n" (span (|@| (class "keyword") (id "F:33406")) "static") " " (span (|@| (class "type") (id "F:33413")) "void") " " (span (|@| (class "function-name") (id "F:33418")) "x_consider_frame_title") " P_ ((Lisp_Object));\n" (span (|@| (class "keyword") (id "F:33461")) "static") " " (span (|@| (class "type") (id "F:33468")) "void") " " (span (|@| (class "function-name") (id "F:33473")) "handle_stop") " P_ ((" (span (|@| (class "keyword") (id "F:33490")) "struct") " " (span (|@| (class "type") (id "F:33497")) "it") " *));\n" (span (|@| (class "keyword") (id "F:33505")) "static") " " (span (|@| (class "type") (id "F:33512")) "void") " " (span (|@| (class "function-name") (id "F:33517")) "handle_stop_backwards") " P_ ((" (span (|@| (class "keyword") (id "F:33544")) "struct") " " (span (|@| (class "type") (id "F:33551")) "it") " *, EMACS_INT));\n" (span (|@| (class "keyword") (id "F:33570")) "static") " " (span (|@| (class "type") (id "F:33577")) "int") " " (span (|@| (class "function-name") (id "F:33581")) "tool_bar_lines_needed") " P_ ((" (span (|@| (class "keyword") (id "F:33608")) "struct") " " (span (|@| (class "type") (id "F:33615")) "frame") " *, " (span (|@| (class "type") (id "F:33624")) "int") " *));\n" (span (|@| (class "keyword") (id "F:33633")) "static") " " (span (|@| (class "type") (id "F:33640")) "int") " " (span (|@| (class "function-name") (id "F:33644")) "single_display_spec_intangible_p") " P_ ((Lisp_Object));\n" (span (|@| (class "keyword") (id "F:33697")) "static") " " (span (|@| (class "type") (id "F:33704")) "void") " " (span (|@| (class "function-name") (id "F:33709")) "ensure_echo_area_buffers") " P_ ((" (span (|@| (class "type") (id "F:33739")) "void") "));\n" (span (|@| (class "keyword") (id "F:33747")) "static") " Lisp_Object " (span (|@| (class "type") (id "F:33766")) "unwind_with_echo_area_buffer") " " (span (|@| (class "function-name") (id "F:33795")) "P_") " ((" (span (|@| (class "type") (id "F:33800")) "Lisp_Object") "));\n" (span (|@| (class "keyword") (id "F:33815")) "static") " Lisp_Object with_echo_area_buffer_unwind_data P_ ((" (span (|@| (class "keyword") (id "F:33873")) "struct") " " (span (|@| (class "type") (id "F:33880")) "window") " *));\n" (span (|@| (class "keyword") (id "F:33892")) "static") " " (span (|@| (class "type") (id "F:33899")) "int") " " (span (|@| (class "function-name") (id "F:33903")) "with_echo_area_buffer") " P_ ((" (span (|@| (class "keyword") (id "F:33930")) "struct") " " (span (|@| (class "type") (id "F:33937")) "window") " *, " (span (|@| (class "type") (id "F:33947")) "int") ",\n                                      " (span (|@| (class "type") (id "F:33962")) "int") " (*) (" (span (|@| (class "type") (id "F:33971")) "EMACS_INT") ", " (span (|@| (class "type") (id "F:33982")) "Lisp_Object") ", " (span (|@| (class "type") (id "F:33995")) "EMACS_INT") ", " (span (|@| (class "type") (id "F:34006")) "EMACS_INT") "),\n                                      EMACS_INT, Lisp_Object, EMACS_INT, EMACS_INT));\n" (span (|@| (class "keyword") (id "F:34076")) "static") " " (span (|@| (class "type") (id "F:34083")) "void") " " (span (|@| (class "function-name") (id "F:34088")) "clear_garbaged_frames") " P_ ((" (span (|@| (class "type") (id "F:34115")) "void") "));\n" (span (|@| (class "keyword") (id "F:34123")) "static") " " (span (|@| (class "type") (id "F:34130")) "int") " " (span (|@| (class "function-name") (id "F:34134")) "current_message_1") " P_ ((EMACS_INT, Lisp_Object, EMACS_INT, EMACS_INT));\n" (span (|@| (class "keyword") (id "F:34205")) "static") " " (span (|@| (class "type") (id "F:34212")) "int") " " (span (|@| (class "function-name") (id "F:34216")) "truncate_message_1") " P_ ((EMACS_INT, Lisp_Object, EMACS_INT, EMACS_INT));\n" (span (|@| (class "keyword") (id "F:34288")) "static") " " (span (|@| (class "type") (id "F:34295")) "int") " " (span (|@| (class "function-name") (id "F:34299")) "set_message_1") " P_ ((EMACS_INT, Lisp_Object, EMACS_INT, EMACS_INT));\n" (span (|@| (class "keyword") (id "F:34366")) "static") " " (span (|@| (class "type") (id "F:34373")) "int") " " (span (|@| (class "function-name") (id "F:34377")) "display_echo_area") " P_ ((" (span (|@| (class "keyword") (id "F:34400")) "struct") " " (span (|@| (class "type") (id "F:34407")) "window") " *));\n" (span (|@| (class "keyword") (id "F:34419")) "static") " " (span (|@| (class "type") (id "F:34426")) "int") " " (span (|@| (class "function-name") (id "F:34430")) "display_echo_area_1") " P_ ((EMACS_INT, Lisp_Object, EMACS_INT, EMACS_INT));\n" (span (|@| (class "keyword") (id "F:34503")) "static") " " (span (|@| (class "type") (id "F:34510")) "int") " " (span (|@| (class "function-name") (id "F:34514")) "resize_mini_window_1") " P_ ((EMACS_INT, Lisp_Object, EMACS_INT, EMACS_INT));\n" (span (|@| (class "keyword") (id "F:34588")) "static") " Lisp_Object " (span (|@| (class "type") (id "F:34607")) "unwind_redisplay") " " (span (|@| (class "function-name") (id "F:34624")) "P_") " ((" (span (|@| (class "type") (id "F:34629")) "Lisp_Object") "));\n" (span (|@| (class "keyword") (id "F:34644")) "static") " " (span (|@| (class "type") (id "F:34651")) "int") " " (span (|@| (class "function-name") (id "F:34655")) "string_char_and_length") " P_ ((" (span (|@| (class "keyword") (id "F:34683")) "const") " " (span (|@| (class "type") (id "F:34689")) "unsigned") " " (span (|@| (class "type") (id "F:34698")) "char") " *, " (span (|@| (class "type") (id "F:34706")) "int") " *));\n" (span (|@| (class "keyword") (id "F:34715")) "static") " " (span (|@| (class "keyword") (id "F:34722")) "struct") " " (span (|@| (class "type") (id "F:34729")) "text_pos") " display_prop_end P_ ((" (span (|@| (class "keyword") (id "F:34760")) "struct") " " (span (|@| (class "type") (id "F:34767")) "it") " *, Lisp_Object,\n                                             " (span (|@| (class "keyword") (id "F:34796")) "struct") " " (span (|@| (class "type") (id "F:34803")) "text_pos") "));\n" (span (|@| (class "keyword") (id "F:34815")) "static") " " (span (|@| (class "type") (id "F:34822")) "int") " " (span (|@| (class "function-name") (id "F:34826")) "compute_window_start_on_continuation_line") " P_ ((" (span (|@| (class "keyword") (id "F:34873")) "struct") " " (span (|@| (class "type") (id "F:34880")) "window") " *));\n" (span (|@| (class "keyword") (id "F:34892")) "static") " Lisp_Object " (span (|@| (class "type") (id "F:34911")) "safe_eval_handler") " " (span (|@| (class "function-name") (id "F:34929")) "P_") " ((" (span (|@| (class "type") (id "F:34934")) "Lisp_Object") "));\n" (span (|@| (class "keyword") (id "F:34949")) "static") " " (span (|@| (class "type") (id "F:34956")) "void") " " (span (|@| (class "function-name") (id "F:34961")) "insert_left_trunc_glyphs") " P_ ((" (span (|@| (class "keyword") (id "F:34991")) "struct") " " (span (|@| (class "type") (id "F:34998")) "it") " *));\n" (span (|@| (class "keyword") (id "F:35006")) "static") " " (span (|@| (class "keyword") (id "F:35013")) "struct") " " (span (|@| (class "type") (id "F:35020")) "glyph_row") " *" (span (|@| (class "function-name") (id "F:35031")) "get_overlay_arrow_glyph_row") " P_ ((" (span (|@| (class "keyword") (id "F:35064")) "struct") " " (span (|@| (class "type") (id "F:35071")) "window") " *,\n                                                          Lisp_Object));\n" (span (|@| (class "keyword") (id "F:35105")) "static") " " (span (|@| (class "type") (id "F:35112")) "void") " " (span (|@| (class "function-name") (id "F:35117")) "extend_face_to_end_of_line") " P_ ((" (span (|@| (class "keyword") (id "F:35149")) "struct") " " (span (|@| (class "type") (id "F:35156")) "it") " *));\n" (span (|@| (class "keyword") (id "F:35164")) "static") " " (span (|@| (class "type") (id "F:35171")) "int") " " (span (|@| (class "function-name") (id "F:35175")) "append_space_for_newline") " P_ ((" (span (|@| (class "keyword") (id "F:35205")) "struct") " " (span (|@| (class "type") (id "F:35212")) "it") " *, " (span (|@| (class "type") (id "F:35218")) "int") "));\n" (span (|@| (class "keyword") (id "F:35225")) "static") " " (span (|@| (class "type") (id "F:35232")) "int") " " (span (|@| (class "function-name") (id "F:35236")) "cursor_row_fully_visible_p") " P_ ((" (span (|@| (class "keyword") (id "F:35268")) "struct") " " (span (|@| (class "type") (id "F:35275")) "window") " *, " (span (|@| (class "type") (id "F:35285")) "int") ", " (span (|@| (class "type") (id "F:35290")) "int") "));\n" (span (|@| (class "keyword") (id "F:35297")) "static") " " (span (|@| (class "type") (id "F:35304")) "int") " " (span (|@| (class "function-name") (id "F:35308")) "try_scrolling") " P_ ((Lisp_Object, " (span (|@| (class "type") (id "F:35340")) "int") ", EMACS_INT, EMACS_INT, " (span (|@| (class "type") (id "F:35367")) "int") ", " (span (|@| (class "type") (id "F:35372")) "int") "));\n" (span (|@| (class "keyword") (id "F:35379")) "static") " " (span (|@| (class "type") (id "F:35386")) "int") " " (span (|@| (class "function-name") (id "F:35390")) "try_cursor_movement") " P_ ((Lisp_Object, " (span (|@| (class "keyword") (id "F:35428")) "struct") " " (span (|@| (class "type") (id "F:35435")) "text_pos") ", " (span (|@| (class "type") (id "F:35445")) "int") " *));\n" (span (|@| (class "keyword") (id "F:35454")) "static") " " (span (|@| (class "type") (id "F:35461")) "int") " " (span (|@| (class "function-name") (id "F:35465")) "trailing_whitespace_p") " P_ ((" (span (|@| (class "type") (id "F:35492")) "int") "));\n" (span (|@| (class "keyword") (id "F:35499")) "static") " " (span (|@| (class "type") (id "F:35506")) "int") " " (span (|@| (class "function-name") (id "F:35510")) "message_log_check_duplicate") " P_ ((" (span (|@| (class "type") (id "F:35543")) "int") ", " (span (|@| (class "type") (id "F:35548")) "int") ", " (span (|@| (class "type") (id "F:35553")) "int") ", " (span (|@| (class "type") (id "F:35558")) "int") "));\n" (span (|@| (class "keyword") (id "F:35565")) "static") " " (span (|@| (class "type") (id "F:35572")) "void") " " (span (|@| (class "function-name") (id "F:35577")) "push_it") " P_ ((" (span (|@| (class "keyword") (id "F:35590")) "struct") " " (span (|@| (class "type") (id "F:35597")) "it") " *));\n" (span (|@| (class "keyword") (id "F:35605")) "static") " " (span (|@| (class "type") (id "F:35612")) "void") " " (span (|@| (class "function-name") (id "F:35617")) "pop_it") " P_ ((" (span (|@| (class "keyword") (id "F:35629")) "struct") " " (span (|@| (class "type") (id "F:35636")) "it") " *));\n" (span (|@| (class "keyword") (id "F:35644")) "static") " " (span (|@| (class "type") (id "F:35651")) "void") " " (span (|@| (class "function-name") (id "F:35656")) "sync_frame_with_window_matrix_rows") " P_ ((" (span (|@| (class "keyword") (id "F:35696")) "struct") " " (span (|@| (class "type") (id "F:35703")) "window") " *));\n" (span (|@| (class "keyword") (id "F:35715")) "static") " " (span (|@| (class "type") (id "F:35722")) "void") " " (span (|@| (class "function-name") (id "F:35727")) "select_frame_for_redisplay") " P_ ((Lisp_Object));\n" (span (|@| (class "keyword") (id "F:35774")) "static") " " (span (|@| (class "type") (id "F:35781")) "void") " " (span (|@| (class "function-name") (id "F:35786")) "redisplay_internal") " P_ ((" (span (|@| (class "type") (id "F:35810")) "int") "));\n" (span (|@| (class "keyword") (id "F:35817")) "static") " " (span (|@| (class "type") (id "F:35824")) "int") " " (span (|@| (class "function-name") (id "F:35828")) "echo_area_display") " P_ ((" (span (|@| (class "type") (id "F:35851")) "int") "));\n" (span (|@| (class "keyword") (id "F:35858")) "static") " " (span (|@| (class "type") (id "F:35865")) "void") " " (span (|@| (class "function-name") (id "F:35870")) "redisplay_windows") " P_ ((Lisp_Object));\n" (span (|@| (class "keyword") (id "F:35908")) "static") " " (span (|@| (class "type") (id "F:35915")) "void") " " (span (|@| (class "function-name") (id "F:35920")) "redisplay_window") " P_ ((Lisp_Object, " (span (|@| (class "type") (id "F:35955")) "int") "));\n" (span (|@| (class "keyword") (id "F:35962")) "static") " " (span (|@| (class "type") (id "F:35969")) "Lisp_Object") " " (span (|@| (class "function-name") (id "F:35981")) "redisplay_window_error") " ();\n" (span (|@| (class "keyword") (id "F:36008")) "static") " Lisp_Object " (span (|@| (class "type") (id "F:36027")) "redisplay_window_0") " " (span (|@| (class "function-name") (id "F:36046")) "P_") " ((" (span (|@| (class "type") (id "F:36051")) "Lisp_Object") "));\n" (span (|@| (class "keyword") (id "F:36066")) "static") " Lisp_Object " (span (|@| (class "type") (id "F:36085")) "redisplay_window_1") " " (span (|@| (class "function-name") (id "F:36104")) "P_") " ((" (span (|@| (class "type") (id "F:36109")) "Lisp_Object") "));\n" (span (|@| (class "keyword") (id "F:36124")) "static") " " (span (|@| (class "type") (id "F:36131")) "int") " " (span (|@| (class "function-name") (id "F:36135")) "update_menu_bar") " P_ ((" (span (|@| (class "keyword") (id "F:36156")) "struct") " " (span (|@| (class "type") (id "F:36163")) "frame") " *, " (span (|@| (class "type") (id "F:36172")) "int") ", " (span (|@| (class "type") (id "F:36177")) "int") "));\n" (span (|@| (class "keyword") (id "F:36184")) "static") " " (span (|@| (class "type") (id "F:36191")) "int") " " (span (|@| (class "function-name") (id "F:36195")) "try_window_reusing_current_matrix") " P_ ((" (span (|@| (class "keyword") (id "F:36234")) "struct") " " (span (|@| (class "type") (id "F:36241")) "window") " *));\n" (span (|@| (class "keyword") (id "F:36253")) "static") " " (span (|@| (class "type") (id "F:36260")) "int") " " (span (|@| (class "function-name") (id "F:36264")) "try_window_id") " P_ ((" (span (|@| (class "keyword") (id "F:36283")) "struct") " " (span (|@| (class "type") (id "F:36290")) "window") " *));\n" (span (|@| (class "keyword") (id "F:36302")) "static") " " (span (|@| (class "type") (id "F:36309")) "int") " " (span (|@| (class "function-name") (id "F:36313")) "display_line") " P_ ((" (span (|@| (class "keyword") (id "F:36331")) "struct") " " (span (|@| (class "type") (id "F:36338")) "it") " *));\n" (span (|@| (class "keyword") (id "F:36346")) "static") " " (span (|@| (class "type") (id "F:36353")) "int") " " (span (|@| (class "function-name") (id "F:36357")) "display_mode_lines") " P_ ((" (span (|@| (class "keyword") (id "F:36381")) "struct") " " (span (|@| (class "type") (id "F:36388")) "window") " *));\n" (span (|@| (class "keyword") (id "F:36400")) "static") " " (span (|@| (class "type") (id "F:36407")) "int") " " (span (|@| (class "function-name") (id "F:36411")) "display_mode_line") " P_ ((" (span (|@| (class "keyword") (id "F:36434")) "struct") " " (span (|@| (class "type") (id "F:36441")) "window") " *, " (span (|@| (class "keyword") (id "F:36451")) "enum") " " (span (|@| (class "type") (id "F:36456")) "face_id") ", Lisp_Object));\n" (span (|@| (class "keyword") (id "F:36480")) "static") " " (span (|@| (class "type") (id "F:36487")) "int") " " (span (|@| (class "function-name") (id "F:36491")) "display_mode_element") " P_ ((" (span (|@| (class "keyword") (id "F:36517")) "struct") " " (span (|@| (class "type") (id "F:36524")) "it") " *, " (span (|@| (class "type") (id "F:36530")) "int") ", " (span (|@| (class "type") (id "F:36535")) "int") ", " (span (|@| (class "type") (id "F:36540")) "int") ", Lisp_Object, Lisp_Object, " (span (|@| (class "type") (id "F:36571")) "int") "));\n" (span (|@| (class "keyword") (id "F:36578")) "static") " " (span (|@| (class "type") (id "F:36585")) "int") " " (span (|@| (class "function-name") (id "F:36589")) "store_mode_line_string") " P_ ((" (span (|@| (class "type") (id "F:36617")) "char") " *, Lisp_Object, " (span (|@| (class "type") (id "F:36638")) "int") ", " (span (|@| (class "type") (id "F:36643")) "int") ", " (span (|@| (class "type") (id "F:36648")) "int") ", Lisp_Object));\n" (span (|@| (class "keyword") (id "F:36668")) "static") " " (span (|@| (class "type") (id "F:36675")) "char") " *" (span (|@| (class "function-name") (id "F:36681")) "decode_mode_spec") " P_ ((" (span (|@| (class "keyword") (id "F:36703")) "struct") " " (span (|@| (class "type") (id "F:36710")) "window") " *, " (span (|@| (class "type") (id "F:36720")) "int") ", " (span (|@| (class "type") (id "F:36725")) "int") ", " (span (|@| (class "type") (id "F:36730")) "int") ",\n                                   " (span (|@| (class "type") (id "F:36742")) "Lisp_Object") " *));\n" (span (|@| (class "keyword") (id "F:36759")) "static") " " (span (|@| (class "type") (id "F:36766")) "void") " " (span (|@| (class "function-name") (id "F:36771")) "display_menu_bar") " P_ ((" (span (|@| (class "keyword") (id "F:36793")) "struct") " " (span (|@| (class "type") (id "F:36800")) "window") " *));\n" (span (|@| (class "keyword") (id "F:36812")) "static") " " (span (|@| (class "type") (id "F:36819")) "int") " " (span (|@| (class "function-name") (id "F:36823")) "display_count_lines") " P_ ((" (span (|@| (class "type") (id "F:36848")) "int") ", " (span (|@| (class "type") (id "F:36853")) "int") ", " (span (|@| (class "type") (id "F:36858")) "int") ", " (span (|@| (class "type") (id "F:36863")) "int") ", " (span (|@| (class "type") (id "F:36868")) "int") " *));\n" (span (|@| (class "keyword") (id "F:36877")) "static") " " (span (|@| (class "type") (id "F:36884")) "int") " " (span (|@| (class "function-name") (id "F:36888")) "display_string") " P_ ((" (span (|@| (class "type") (id "F:36908")) "unsigned") " " (span (|@| (class "type") (id "F:36917")) "char") " *, Lisp_Object, Lisp_Object,\n                               EMACS_INT, EMACS_INT, " (span (|@| (class "keyword") (id "F:36983")) "struct") " " (span (|@| (class "type") (id "F:36990")) "it") " *, " (span (|@| (class "type") (id "F:36996")) "int") ", " (span (|@| (class "type") (id "F:37001")) "int") ", " (span (|@| (class "type") (id "F:37006")) "int") ", " (span (|@| (class "type") (id "F:37011")) "int") "));\n" (span (|@| (class "keyword") (id "F:37018")) "static") " " (span (|@| (class "type") (id "F:37025")) "void") " " (span (|@| (class "function-name") (id "F:37030")) "compute_line_metrics") " P_ ((" (span (|@| (class "keyword") (id "F:37056")) "struct") " " (span (|@| (class "type") (id "F:37063")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37071")) "static") " " (span (|@| (class "type") (id "F:37078")) "void") " " (span (|@| (class "function-name") (id "F:37083")) "run_redisplay_end_trigger_hook") " P_ ((" (span (|@| (class "keyword") (id "F:37119")) "struct") " " (span (|@| (class "type") (id "F:37126")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37134")) "static") " " (span (|@| (class "type") (id "F:37141")) "int") " " (span (|@| (class "function-name") (id "F:37145")) "get_overlay_strings") " P_ ((" (span (|@| (class "keyword") (id "F:37170")) "struct") " " (span (|@| (class "type") (id "F:37177")) "it") " *, " (span (|@| (class "type") (id "F:37183")) "int") "));\n" (span (|@| (class "keyword") (id "F:37190")) "static") " " (span (|@| (class "type") (id "F:37197")) "int") " " (span (|@| (class "function-name") (id "F:37201")) "get_overlay_strings_1") " P_ ((" (span (|@| (class "keyword") (id "F:37228")) "struct") " " (span (|@| (class "type") (id "F:37235")) "it") " *, " (span (|@| (class "type") (id "F:37241")) "int") ", " (span (|@| (class "type") (id "F:37246")) "int") "));\n" (span (|@| (class "keyword") (id "F:37253")) "static") " " (span (|@| (class "type") (id "F:37260")) "void") " " (span (|@| (class "function-name") (id "F:37265")) "next_overlay_string") " P_ ((" (span (|@| (class "keyword") (id "F:37290")) "struct") " " (span (|@| (class "type") (id "F:37297")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37305")) "static") " " (span (|@| (class "type") (id "F:37312")) "void") " " (span (|@| (class "function-name") (id "F:37317")) "reseat") " P_ ((" (span (|@| (class "keyword") (id "F:37329")) "struct") " " (span (|@| (class "type") (id "F:37336")) "it") " *, " (span (|@| (class "keyword") (id "F:37342")) "struct") " " (span (|@| (class "type") (id "F:37349")) "text_pos") ", " (span (|@| (class "type") (id "F:37359")) "int") "));\n" (span (|@| (class "keyword") (id "F:37366")) "static") " " (span (|@| (class "type") (id "F:37373")) "void") " " (span (|@| (class "function-name") (id "F:37378")) "reseat_1") " P_ ((" (span (|@| (class "keyword") (id "F:37392")) "struct") " " (span (|@| (class "type") (id "F:37399")) "it") " *, " (span (|@| (class "keyword") (id "F:37405")) "struct") " " (span (|@| (class "type") (id "F:37412")) "text_pos") ", " (span (|@| (class "type") (id "F:37422")) "int") "));\n" (span (|@| (class "keyword") (id "F:37429")) "static") " " (span (|@| (class "type") (id "F:37436")) "void") " " (span (|@| (class "function-name") (id "F:37441")) "back_to_previous_visible_line_start") " P_ ((" (span (|@| (class "keyword") (id "F:37482")) "struct") " " (span (|@| (class "type") (id "F:37489")) "it") " *));\n" (span (|@| (class "type") (id "F:37497")) "void") " " (span (|@| (class "function-name") (id "F:37502")) "reseat_at_previous_visible_line_start") " P_ ((" (span (|@| (class "keyword") (id "F:37545")) "struct") " " (span (|@| (class "type") (id "F:37552")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37560")) "static") " " (span (|@| (class "type") (id "F:37567")) "void") " " (span (|@| (class "function-name") (id "F:37572")) "reseat_at_next_visible_line_start") " P_ ((" (span (|@| (class "keyword") (id "F:37611")) "struct") " " (span (|@| (class "type") (id "F:37618")) "it") " *, " (span (|@| (class "type") (id "F:37624")) "int") "));\n" (span (|@| (class "keyword") (id "F:37631")) "static") " " (span (|@| (class "type") (id "F:37638")) "int") " " (span (|@| (class "function-name") (id "F:37642")) "next_element_from_ellipsis") " P_ ((" (span (|@| (class "keyword") (id "F:37674")) "struct") " " (span (|@| (class "type") (id "F:37681")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37689")) "static") " " (span (|@| (class "type") (id "F:37696")) "int") " " (span (|@| (class "function-name") (id "F:37700")) "next_element_from_display_vector") " P_ ((" (span (|@| (class "keyword") (id "F:37738")) "struct") " " (span (|@| (class "type") (id "F:37745")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37753")) "static") " " (span (|@| (class "type") (id "F:37760")) "int") " " (span (|@| (class "function-name") (id "F:37764")) "next_element_from_string") " P_ ((" (span (|@| (class "keyword") (id "F:37794")) "struct") " " (span (|@| (class "type") (id "F:37801")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37809")) "static") " " (span (|@| (class "type") (id "F:37816")) "int") " " (span (|@| (class "function-name") (id "F:37820")) "next_element_from_c_string") " P_ ((" (span (|@| (class "keyword") (id "F:37852")) "struct") " " (span (|@| (class "type") (id "F:37859")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37867")) "static") " " (span (|@| (class "type") (id "F:37874")) "int") " " (span (|@| (class "function-name") (id "F:37878")) "next_element_from_buffer") " P_ ((" (span (|@| (class "keyword") (id "F:37908")) "struct") " " (span (|@| (class "type") (id "F:37915")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37923")) "static") " " (span (|@| (class "type") (id "F:37930")) "int") " " (span (|@| (class "function-name") (id "F:37934")) "next_element_from_composition") " P_ ((" (span (|@| (class "keyword") (id "F:37969")) "struct") " " (span (|@| (class "type") (id "F:37976")) "it") " *));\n" (span (|@| (class "keyword") (id "F:37984")) "static") " " (span (|@| (class "type") (id "F:37991")) "int") " " (span (|@| (class "function-name") (id "F:37995")) "next_element_from_image") " P_ ((" (span (|@| (class "keyword") (id "F:38024")) "struct") " " (span (|@| (class "type") (id "F:38031")) "it") " *));\n" (span (|@| (class "keyword") (id "F:38039")) "static") " " (span (|@| (class "type") (id "F:38046")) "int") " " (span (|@| (class "function-name") (id "F:38050")) "next_element_from_stretch") " P_ ((" (span (|@| (class "keyword") (id "F:38081")) "struct") " " (span (|@| (class "type") (id "F:38088")) "it") " *));\n" (span (|@| (class "keyword") (id "F:38096")) "static") " " (span (|@| (class "type") (id "F:38103")) "void") " " (span (|@| (class "function-name") (id "F:38108")) "load_overlay_strings") " P_ ((" (span (|@| (class "keyword") (id "F:38134")) "struct") " " (span (|@| (class "type") (id "F:38141")) "it") " *, " (span (|@| (class "type") (id "F:38147")) "int") "));\n" (span (|@| (class "keyword") (id "F:38154")) "static") " " (span (|@| (class "type") (id "F:38161")) "int") " " (span (|@| (class "function-name") (id "F:38165")) "init_from_display_pos") " P_ ((" (span (|@| (class "keyword") (id "F:38192")) "struct") " " (span (|@| (class "type") (id "F:38199")) "it") " *, " (span (|@| (class "keyword") (id "F:38205")) "struct") " " (span (|@| (class "type") (id "F:38212")) "window") " *,\n                                      " (span (|@| (class "keyword") (id "F:38232")) "struct") " " (span (|@| (class "type") (id "F:38239")) "display_pos") " *));\n" (span (|@| (class "keyword") (id "F:38256")) "static") " " (span (|@| (class "type") (id "F:38263")) "void") " " (span (|@| (class "function-name") (id "F:38268")) "reseat_to_string") " P_ ((" (span (|@| (class "keyword") (id "F:38290")) "struct") " " (span (|@| (class "type") (id "F:38297")) "it") " *, " (span (|@| (class "type") (id "F:38303")) "unsigned") " " (span (|@| (class "type") (id "F:38312")) "char") " *,\n                                  Lisp_Object, " (span (|@| (class "type") (id "F:38339")) "int") ", " (span (|@| (class "type") (id "F:38344")) "int") ", " (span (|@| (class "type") (id "F:38349")) "int") ", " (span (|@| (class "type") (id "F:38354")) "int") "));\n" (span (|@| (class "keyword") (id "F:38361")) "static") " " (span (|@| (class "keyword") (id "F:38368")) "enum") " " (span (|@| (class "type") (id "F:38373")) "move_it_result") "\n       " (span (|@| (class "function-name") (id "F:38395")) "move_it_in_display_line_to") " (" (span (|@| (class "keyword") (id "F:38423")) "struct") " " (span (|@| (class "type") (id "F:38430")) "it") " *, " (span (|@| (class "type") (id "F:38436")) "EMACS_INT") ", " (span (|@| (class "type") (id "F:38447")) "int") ",\n                                   " (span (|@| (class "keyword") (id "F:38459")) "enum") " " (span (|@| (class "type") (id "F:38464")) "move_operation_enum") ");\n" (span (|@| (class "type") (id "F:38486")) "void") " " (span (|@| (class "function-name") (id "F:38491")) "move_it_vertically_backward") " P_ ((" (span (|@| (class "keyword") (id "F:38524")) "struct") " " (span (|@| (class "type") (id "F:38531")) "it") " *, " (span (|@| (class "type") (id "F:38537")) "int") "));\n" (span (|@| (class "keyword") (id "F:38544")) "static") " " (span (|@| (class "type") (id "F:38551")) "void") " " (span (|@| (class "function-name") (id "F:38556")) "init_to_row_start") " P_ ((" (span (|@| (class "keyword") (id "F:38579")) "struct") " " (span (|@| (class "type") (id "F:38586")) "it") " *, " (span (|@| (class "keyword") (id "F:38592")) "struct") " " (span (|@| (class "type") (id "F:38599")) "window") " *,\n                                   " (span (|@| (class "keyword") (id "F:38616")) "struct") " " (span (|@| (class "type") (id "F:38623")) "glyph_row") " *));\n" (span (|@| (class "keyword") (id "F:38638")) "static") " " (span (|@| (class "type") (id "F:38645")) "int") " " (span (|@| (class "function-name") (id "F:38649")) "init_to_row_end") " P_ ((" (span (|@| (class "keyword") (id "F:38670")) "struct") " " (span (|@| (class "type") (id "F:38677")) "it") " *, " (span (|@| (class "keyword") (id "F:38683")) "struct") " " (span (|@| (class "type") (id "F:38690")) "window") " *,\n                                " (span (|@| (class "keyword") (id "F:38704")) "struct") " " (span (|@| (class "type") (id "F:38711")) "glyph_row") " *));\n" (span (|@| (class "keyword") (id "F:38726")) "static") " " (span (|@| (class "type") (id "F:38733")) "void") " " (span (|@| (class "function-name") (id "F:38738")) "back_to_previous_line_start") " P_ ((" (span (|@| (class "keyword") (id "F:38771")) "struct") " " (span (|@| (class "type") (id "F:38778")) "it") " *));\n" (span (|@| (class "keyword") (id "F:38786")) "static") " " (span (|@| (class "type") (id "F:38793")) "int") " " (span (|@| (class "function-name") (id "F:38797")) "forward_to_next_line_start") " P_ ((" (span (|@| (class "keyword") (id "F:38829")) "struct") " " (span (|@| (class "type") (id "F:38836")) "it") " *, " (span (|@| (class "type") (id "F:38842")) "int") " *));\n" (span (|@| (class "keyword") (id "F:38851")) "static") " " (span (|@| (class "keyword") (id "F:38858")) "struct") " " (span (|@| (class "type") (id "F:38865")) "text_pos") " string_pos_nchars_ahead P_ ((" (span (|@| (class "keyword") (id "F:38903")) "struct") " " (span (|@| (class "type") (id "F:38910")) "text_pos") ",\n                                                    Lisp_Object, " (span (|@| (class "type") (id "F:38943")) "int") "));\n" (span (|@| (class "keyword") (id "F:38950")) "static") " " (span (|@| (class "keyword") (id "F:38957")) "struct") " " (span (|@| (class "type") (id "F:38964")) "text_pos") " string_pos P_ ((" (span (|@| (class "type") (id "F:38989")) "int") ", Lisp_Object));\n" (span (|@| (class "keyword") (id "F:39009")) "static") " " (span (|@| (class "keyword") (id "F:39016")) "struct") " " (span (|@| (class "type") (id "F:39023")) "text_pos") " c_string_pos P_ ((" (span (|@| (class "type") (id "F:39050")) "int") ", " (span (|@| (class "type") (id "F:39055")) "unsigned") " " (span (|@| (class "type") (id "F:39064")) "char") " *, " (span (|@| (class "type") (id "F:39072")) "int") "));\n" (span (|@| (class "keyword") (id "F:39079")) "static") " " (span (|@| (class "type") (id "F:39086")) "int") " " (span (|@| (class "function-name") (id "F:39090")) "number_of_chars") " P_ ((" (span (|@| (class "type") (id "F:39111")) "unsigned") " " (span (|@| (class "type") (id "F:39120")) "char") " *, " (span (|@| (class "type") (id "F:39128")) "int") "));\n" (span (|@| (class "keyword") (id "F:39135")) "static") " " (span (|@| (class "type") (id "F:39142")) "void") " " (span (|@| (class "function-name") (id "F:39147")) "compute_stop_pos") " P_ ((" (span (|@| (class "keyword") (id "F:39169")) "struct") " " (span (|@| (class "type") (id "F:39176")) "it") " *));\n" (span (|@| (class "keyword") (id "F:39184")) "static") " " (span (|@| (class "type") (id "F:39191")) "void") " " (span (|@| (class "function-name") (id "F:39196")) "compute_string_pos") " P_ ((" (span (|@| (class "keyword") (id "F:39220")) "struct") " " (span (|@| (class "type") (id "F:39227")) "text_pos") " *, " (span (|@| (class "keyword") (id "F:39239")) "struct") " " (span (|@| (class "type") (id "F:39246")) "text_pos") ",\n                                    Lisp_Object));\n" (span (|@| (class "keyword") (id "F:39279")) "static") " " (span (|@| (class "type") (id "F:39286")) "int") " " (span (|@| (class "function-name") (id "F:39290")) "face_before_or_after_it_pos") " P_ ((" (span (|@| (class "keyword") (id "F:39323")) "struct") " " (span (|@| (class "type") (id "F:39330")) "it") " *, " (span (|@| (class "type") (id "F:39336")) "int") "));\n" (span (|@| (class "keyword") (id "F:39343")) "static") " " (span (|@| (class "type") (id "F:39350")) "EMACS_INT") " " (span (|@| (class "type") (id "F:39360")) "next_overlay_change") " " (span (|@| (class "function-name") (id "F:39380")) "P_") " ((" (span (|@| (class "type") (id "F:39385")) "EMACS_INT") "));\n" (span (|@| (class "keyword") (id "F:39398")) "static") " " (span (|@| (class "type") (id "F:39405")) "int") " " (span (|@| (class "function-name") (id "F:39409")) "handle_single_display_spec") " P_ ((" (span (|@| (class "keyword") (id "F:39441")) "struct") " " (span (|@| (class "type") (id "F:39448")) "it") " *, Lisp_Object,\n                                           Lisp_Object, Lisp_Object,\n                                           " (span (|@| (class "keyword") (id "F:39509")) "struct") " " (span (|@| (class "type") (id "F:39516")) "text_pos") " *, " (span (|@| (class "type") (id "F:39528")) "int") "));\n" (span (|@| (class "keyword") (id "F:39535")) "static") " " (span (|@| (class "type") (id "F:39542")) "int") " " (span (|@| (class "function-name") (id "F:39546")) "underlying_face_id") " P_ ((" (span (|@| (class "keyword") (id "F:39570")) "struct") " " (span (|@| (class "type") (id "F:39577")) "it") " *));\n" (span (|@| (class "keyword") (id "F:39585")) "static") " " (span (|@| (class "type") (id "F:39592")) "int") " " (span (|@| (class "function-name") (id "F:39596")) "in_ellipses_for_invisible_text_p") " P_ ((" (span (|@| (class "keyword") (id "F:39634")) "struct") " " (span (|@| (class "type") (id "F:39641")) "display_pos") " *,\n                                                 " (span (|@| (class "keyword") (id "F:39663")) "struct") " " (span (|@| (class "type") (id "F:39670")) "window") " *));\n\n" (span (|@| (class "preprocessor") (id "F:39683")) "#define") " " (span (|@| (class "function-name") (id "F:39691")) "face_before_it_pos") "(" (span (|@| (class "variable-name") (id "F:39710")) "IT") ") face_before_or_after_it_pos ((IT), 1)\n" (span (|@| (class "preprocessor") (id "F:39752")) "#define") " " (span (|@| (class "function-name") (id "F:39760")) "face_after_it_pos") "(" (span (|@| (class "variable-name") (id "F:39778")) "IT") ")  face_before_or_after_it_pos ((IT), 0)\n\n" (span (|@| (class "preprocessor") (id "F:39822")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "keyword") (id "F:39849")) "static") " " (span (|@| (class "type") (id "F:39856")) "void") " " (span (|@| (class "function-name") (id "F:39861")) "update_tool_bar") " P_ ((" (span (|@| (class "keyword") (id "F:39882")) "struct") " " (span (|@| (class "type") (id "F:39889")) "frame") " *, " (span (|@| (class "type") (id "F:39898")) "int") "));\n" (span (|@| (class "keyword") (id "F:39905")) "static") " " (span (|@| (class "type") (id "F:39912")) "void") " " (span (|@| (class "function-name") (id "F:39917")) "build_desired_tool_bar_string") " P_ ((" (span (|@| (class "keyword") (id "F:39952")) "struct") " " (span (|@| (class "type") (id "F:39959")) "frame") " *" (span (|@| (class "variable-name") (id "F:39966")) "f") "));\n" (span (|@| (class "keyword") (id "F:39971")) "static") " " (span (|@| (class "type") (id "F:39978")) "int") " " (span (|@| (class "function-name") (id "F:39982")) "redisplay_tool_bar") " P_ ((" (span (|@| (class "keyword") (id "F:40006")) "struct") " " (span (|@| (class "type") (id "F:40013")) "frame") " *));\n" (span (|@| (class "keyword") (id "F:40024")) "static") " " (span (|@| (class "type") (id "F:40031")) "void") " " (span (|@| (class "function-name") (id "F:40036")) "display_tool_bar_line") " P_ ((" (span (|@| (class "keyword") (id "F:40063")) "struct") " " (span (|@| (class "type") (id "F:40070")) "it") " *, " (span (|@| (class "type") (id "F:40076")) "int") "));\n" (span (|@| (class "keyword") (id "F:40083")) "static") " " (span (|@| (class "type") (id "F:40090")) "void") " " (span (|@| (class "function-name") (id "F:40095")) "notice_overwritten_cursor") " P_ ((" (span (|@| (class "keyword") (id "F:40126")) "struct") " " (span (|@| (class "type") (id "F:40133")) "window") " *,\n                                           " (span (|@| (class "keyword") (id "F:40151")) "enum") " " (span (|@| (class "type") (id "F:40156")) "glyph_row_area") ",\n                                           " (span (|@| (class "type") (id "F:40180")) "int") ", " (span (|@| (class "type") (id "F:40185")) "int") ", " (span (|@| (class "type") (id "F:40190")) "int") ", " (span (|@| (class "type") (id "F:40195")) "int") "));\n" (span (|@| (class "keyword") (id "F:40202")) "static") " " (span (|@| (class "type") (id "F:40209")) "void") " " (span (|@| (class "function-name") (id "F:40214")) "append_stretch_glyph") " P_ ((" (span (|@| (class "keyword") (id "F:40240")) "struct") " " (span (|@| (class "type") (id "F:40247")) "it") " *, Lisp_Object,\n                                      " (span (|@| (class "type") (id "F:40276")) "int") ", " (span (|@| (class "type") (id "F:40281")) "int") ", " (span (|@| (class "type") (id "F:40286")) "int") "));\n\n\n\n" (span (|@| (class "preprocessor") (id "F:40296")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:40303")) "/* ") (span (|@| (class "comment") (id "F:40306")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:40325")) "*/") "\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:40331")) "/***********************************************************************") (span (|@| (class "comment") (id "F:40403")) "\n                      Window display dimensions\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:40509")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:40513")) "/* ") (span (|@| (class "comment") (id "F:40516")) "Return the bottom boundary y-position for text lines in window W.\n   This is the first y position at which a line cannot start.\n   It is relative to the top of the window.\n\n   This is the height of W minus the height of a mode line, if any.  ") (span (|@| (class "comment-delimiter") (id "F:40758")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:40769")) "int") "\n" (span (|@| (class "function-name") (id "F:40773")) "window_text_bottom_y") " (w)\n     " (span (|@| (class "keyword") (id "F:40803")) "struct") " " (span (|@| (class "type") (id "F:40810")) "window") " *" (span (|@| (class "variable-name") (id "F:40818")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:40825")) "int") " " (span (|@| (class "variable-name") (id "F:40829")) "height") " = WINDOW_TOTAL_HEIGHT (w);\n\n  " (span (|@| (class "keyword") (id "F:40866")) "if") " (WINDOW_WANTS_MODELINE_P (w))\n    height -= CURRENT_MODE_LINE_HEIGHT (w);\n  " (span (|@| (class "keyword") (id "F:40945")) "return") " height;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:40963")) "/* ") (span (|@| (class "comment") (id "F:40966")) "Return the pixel width of display area AREA of window W.  AREA < 0\n   means return the total width of W, not including fringes to\n   the left and right of the window.  ") (span (|@| (class "comment-delimiter") (id "F:41134")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:41145")) "int") "\n" (span (|@| (class "function-name") (id "F:41149")) "window_box_width") " (w, area)\n     " (span (|@| (class "keyword") (id "F:41181")) "struct") " " (span (|@| (class "type") (id "F:41188")) "window") " *" (span (|@| (class "variable-name") (id "F:41196")) "w") ";\n     " (span (|@| (class "type") (id "F:41204")) "int") " " (span (|@| (class "variable-name") (id "F:41208")) "area") ";\n{\n  " (span (|@| (class "type") (id "F:41218")) "int") " " (span (|@| (class "variable-name") (id "F:41222")) "cols") " = XFASTINT (w->total_cols);\n  " (span (|@| (class "type") (id "F:41257")) "int") " " (span (|@| (class "variable-name") (id "F:41261")) "pixels") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:41276")) "if") " (" (span (|@| (class "negation-char") (id "F:41280")) "!") "w->pseudo_window_p)\n    {\n      cols -= WINDOW_SCROLL_BAR_COLS (w);\n\n      " (span (|@| (class "keyword") (id "F:41356")) "if") " (area == TEXT_AREA)\n        {\n          " (span (|@| (class "keyword") (id "F:41385")) "if") " (INTEGERP (w->left_margin_cols))\n            cols -= XFASTINT (w->left_margin_cols);\n          " (span (|@| (class "keyword") (id "F:41469")) "if") " (INTEGERP (w->right_margin_cols))\n            cols -= XFASTINT (w->right_margin_cols);\n          pixels = -WINDOW_TOTAL_FRINGE_WIDTH (w);\n        }\n      " (span (|@| (class "keyword") (id "F:41605")) "else") " " (span (|@| (class "keyword") (id "F:41610")) "if") " (area == LEFT_MARGIN_AREA)\n        {\n          cols = (INTEGERP (w->left_margin_cols)\n                   ? XFASTINT (w->left_margin_cols) : 0);\n          pixels = 0;\n        }\n      " (span (|@| (class "keyword") (id "F:41753")) "else") " " (span (|@| (class "keyword") (id "F:41758")) "if") " (area == RIGHT_MARGIN_AREA)\n        {\n          cols = (INTEGERP (w->right_margin_cols)\n                   ? XFASTINT (w->right_margin_cols) : 0);\n          pixels = 0;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:41907")) "return") " cols * WINDOW_FRAME_COLUMN_WIDTH (w) + pixels;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:41965")) "/* ") (span (|@| (class "comment") (id "F:41968")) "Return the pixel height of the display area of window W, not\n   including mode lines of W, if any.  ") (span (|@| (class "comment-delimiter") (id "F:42068")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:42079")) "int") "\n" (span (|@| (class "function-name") (id "F:42083")) "window_box_height") " (w)\n     " (span (|@| (class "keyword") (id "F:42110")) "struct") " " (span (|@| (class "type") (id "F:42117")) "window") " *" (span (|@| (class "variable-name") (id "F:42125")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:42132")) "struct") " " (span (|@| (class "type") (id "F:42139")) "frame") " *" (span (|@| (class "variable-name") (id "F:42146")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:42171")) "int") " " (span (|@| (class "variable-name") (id "F:42175")) "height") " = WINDOW_TOTAL_HEIGHT (w);\n\n  xassert (height >= 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:42238")) "/* ") (span (|@| (class "comment") (id "F:42241")) "Note: the code below that determines the mode-line/header-line\n     height is essentially the same as that contained in the macro\n     CURRENT_{MODE,HEADER}_LINE_HEIGHT, except that it checks whether\n     the appropriate glyph row has its `mode_line_p' flag set,\n     and if it doesn't, uses estimate_mode_line_height instead.  ") (span (|@| (class "comment-delimiter") (id "F:42569")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:42575")) "if") " (WINDOW_WANTS_MODELINE_P (w))\n    {\n      " (span (|@| (class "keyword") (id "F:42620")) "struct") " " (span (|@| (class "type") (id "F:42627")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:42638")) "ml_row") "\n        = (w->current_matrix && w->current_matrix->rows\n           ? MATRIX_MODE_LINE_ROW (w->current_matrix)\n           : 0);\n      " (span (|@| (class "keyword") (id "F:42757")) "if") " (ml_row && ml_row->mode_line_p)\n        height -= ml_row->height;\n      " (span (|@| (class "keyword") (id "F:42825")) "else") "\n        height -= estimate_mode_line_height (f, CURRENT_MODE_LINE_FACE_ID (w));\n    }\n\n  " (span (|@| (class "keyword") (id "F:42912")) "if") " (WINDOW_WANTS_HEADER_LINE_P (w))\n    {\n      " (span (|@| (class "keyword") (id "F:42960")) "struct") " " (span (|@| (class "type") (id "F:42967")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:42978")) "hl_row") "\n        = (w->current_matrix && w->current_matrix->rows\n           ? MATRIX_HEADER_LINE_ROW (w->current_matrix)\n           : 0);\n      " (span (|@| (class "keyword") (id "F:43099")) "if") " (hl_row && hl_row->mode_line_p)\n        height -= hl_row->height;\n      " (span (|@| (class "keyword") (id "F:43167")) "else") "\n        height -= estimate_mode_line_height (f, HEADER_LINE_FACE_ID);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:43244")) "/* ") (span (|@| (class "comment") (id "F:43247")) "With a very small font and a mode-line that's taller than\n     default, we might end up with a negative height.  ") (span (|@| (class "comment-delimiter") (id "F:43360")) "*/") "\n  " (span (|@| (class "keyword") (id "F:43365")) "return") " max (0, height);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:43392")) "/* ") (span (|@| (class "comment") (id "F:43395")) "Return the window-relative coordinate of the left edge of display\n   area AREA of window W.  AREA < 0 means return the left edge of the\n   whole window, to the right of the left fringe of W.  ") (span (|@| (class "comment-delimiter") (id "F:43587")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:43598")) "int") "\n" (span (|@| (class "function-name") (id "F:43602")) "window_box_left_offset") " (w, area)\n     " (span (|@| (class "keyword") (id "F:43640")) "struct") " " (span (|@| (class "type") (id "F:43647")) "window") " *" (span (|@| (class "variable-name") (id "F:43655")) "w") ";\n     " (span (|@| (class "type") (id "F:43663")) "int") " " (span (|@| (class "variable-name") (id "F:43667")) "area") ";\n{\n  " (span (|@| (class "type") (id "F:43677")) "int") " " (span (|@| (class "variable-name") (id "F:43681")) "x") ";\n\n  " (span (|@| (class "keyword") (id "F:43687")) "if") " (w->pseudo_window_p)\n    " (span (|@| (class "keyword") (id "F:43715")) "return") " 0;\n\n  x = WINDOW_LEFT_SCROLL_BAR_AREA_WIDTH (w);\n\n  " (span (|@| (class "keyword") (id "F:43774")) "if") " (area == TEXT_AREA)\n    x += (WINDOW_LEFT_FRINGE_WIDTH (w)\n          + window_box_width (w, LEFT_MARGIN_AREA));\n  " (span (|@| (class "keyword") (id "F:43884")) "else") " " (span (|@| (class "keyword") (id "F:43889")) "if") " (area == RIGHT_MARGIN_AREA)\n    x += (WINDOW_LEFT_FRINGE_WIDTH (w)\n          + window_box_width (w, LEFT_MARGIN_AREA)\n          + window_box_width (w, TEXT_AREA)\n          + (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)\n             ? 0\n             : WINDOW_RIGHT_FRINGE_WIDTH (w)));\n  " (span (|@| (class "keyword") (id "F:44138")) "else") " " (span (|@| (class "keyword") (id "F:44143")) "if") " (area == LEFT_MARGIN_AREA\n           && WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w))\n    x += WINDOW_LEFT_FRINGE_WIDTH (w);\n\n  " (span (|@| (class "keyword") (id "F:44261")) "return") " x;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:44275")) "/* ") (span (|@| (class "comment") (id "F:44278")) "Return the window-relative coordinate of the right edge of display\n   area AREA of window W.  AREA < 0 means return the left edge of the\n   whole window, to the left of the right fringe of W.  ") (span (|@| (class "comment-delimiter") (id "F:44471")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:44482")) "int") "\n" (span (|@| (class "function-name") (id "F:44486")) "window_box_right_offset") " (w, area)\n     " (span (|@| (class "keyword") (id "F:44525")) "struct") " " (span (|@| (class "type") (id "F:44532")) "window") " *" (span (|@| (class "variable-name") (id "F:44540")) "w") ";\n     " (span (|@| (class "type") (id "F:44548")) "int") " " (span (|@| (class "variable-name") (id "F:44552")) "area") ";\n{\n  " (span (|@| (class "keyword") (id "F:44562")) "return") " window_box_left_offset (w, area) + window_box_width (w, area);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:44635")) "/* ") (span (|@| (class "comment") (id "F:44638")) "Return the frame-relative coordinate of the left edge of display\n   area AREA of window W.  AREA < 0 means return the left edge of the\n   whole window, to the right of the left fringe of W.  ") (span (|@| (class "comment-delimiter") (id "F:44829")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:44840")) "int") "\n" (span (|@| (class "function-name") (id "F:44844")) "window_box_left") " (w, area)\n     " (span (|@| (class "keyword") (id "F:44875")) "struct") " " (span (|@| (class "type") (id "F:44882")) "window") " *" (span (|@| (class "variable-name") (id "F:44890")) "w") ";\n     " (span (|@| (class "type") (id "F:44898")) "int") " " (span (|@| (class "variable-name") (id "F:44902")) "area") ";\n{\n  " (span (|@| (class "keyword") (id "F:44912")) "struct") " " (span (|@| (class "type") (id "F:44919")) "frame") " *" (span (|@| (class "variable-name") (id "F:44926")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:44951")) "int") " " (span (|@| (class "variable-name") (id "F:44955")) "x") ";\n\n  " (span (|@| (class "keyword") (id "F:44961")) "if") " (w->pseudo_window_p)\n    " (span (|@| (class "keyword") (id "F:44989")) "return") " FRAME_INTERNAL_BORDER_WIDTH (f);\n\n  x = (WINDOW_LEFT_EDGE_X (w)\n       + window_box_left_offset (w, area));\n\n  " (span (|@| (class "keyword") (id "F:45107")) "return") " x;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:45121")) "/* ") (span (|@| (class "comment") (id "F:45124")) "Return the frame-relative coordinate of the right edge of display\n   area AREA of window W.  AREA < 0 means return the left edge of the\n   whole window, to the left of the right fringe of W.  ") (span (|@| (class "comment-delimiter") (id "F:45316")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:45327")) "int") "\n" (span (|@| (class "function-name") (id "F:45331")) "window_box_right") " (w, area)\n     " (span (|@| (class "keyword") (id "F:45363")) "struct") " " (span (|@| (class "type") (id "F:45370")) "window") " *" (span (|@| (class "variable-name") (id "F:45378")) "w") ";\n     " (span (|@| (class "type") (id "F:45386")) "int") " " (span (|@| (class "variable-name") (id "F:45390")) "area") ";\n{\n  " (span (|@| (class "keyword") (id "F:45400")) "return") " window_box_left (w, area) + window_box_width (w, area);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:45466")) "/* ") (span (|@| (class "comment") (id "F:45469")) "Get the bounding box of the display area AREA of window W, without\n   mode lines, in frame-relative coordinates.  AREA < 0 means the\n   whole window, not including the left and right fringes of\n   the window.  Return in *BOX_X and *BOX_Y the frame-relative pixel\n   coordinates of the upper-left corner of the box.  Return in\n   *BOX_WIDTH, and *BOX_HEIGHT the pixel width and height of the box.  ") (span (|@| (class "comment-delimiter") (id "F:45866")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:45877")) "void") "\n" (span (|@| (class "function-name") (id "F:45882")) "window_box") " (w, area, box_x, box_y, box_width, box_height)\n     " (span (|@| (class "keyword") (id "F:45945")) "struct") " " (span (|@| (class "type") (id "F:45952")) "window") " *" (span (|@| (class "variable-name") (id "F:45960")) "w") ";\n     " (span (|@| (class "type") (id "F:45968")) "int") " " (span (|@| (class "variable-name") (id "F:45972")) "area") ";\n     " (span (|@| (class "type") (id "F:45983")) "int") " *" (span (|@| (class "variable-name") (id "F:45988")) "box_x") ", *" (span (|@| (class "variable-name") (id "F:45996")) "box_y") ", *" (span (|@| (class "variable-name") (id "F:46004")) "box_width") ", *" (span (|@| (class "variable-name") (id "F:46016")) "box_height") ";\n{\n  " (span (|@| (class "keyword") (id "F:46032")) "if") " (box_width)\n    *box_width = window_box_width (w, area);\n  " (span (|@| (class "keyword") (id "F:46094")) "if") " (box_height)\n    *box_height = window_box_height (w);\n  " (span (|@| (class "keyword") (id "F:46153")) "if") " (box_x)\n    *box_x = window_box_left (w, area);\n  " (span (|@| (class "keyword") (id "F:46206")) "if") " (box_y)\n    {\n      *box_y = WINDOW_TOP_EDGE_Y (w);\n      " (span (|@| (class "keyword") (id "F:46267")) "if") " (WINDOW_WANTS_HEADER_LINE_P (w))\n        *box_y += CURRENT_HEADER_LINE_HEIGHT (w);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:46356")) "/* ") (span (|@| (class "comment") (id "F:46359")) "Get the bounding box of the display area AREA of window W, without\n   mode lines.  AREA < 0 means the whole window, not including the\n   left and right fringe of the window.  Return in *TOP_LEFT_X\n   and TOP_LEFT_Y the frame-relative pixel coordinates of the\n   upper-left corner of the box.  Return in *BOTTOM_RIGHT_X, and\n   *BOTTOM_RIGHT_Y the coordinates of the bottom-right corner of the\n   box.  ") (span (|@| (class "comment-delimiter") (id "F:46761")) "*/") "\n\nINLINE " (span (|@| (class "type") (id "F:46772")) "void") "\n" (span (|@| (class "function-name") (id "F:46777")) "window_box_edges") " (w, area, top_left_x, top_left_y,\n                  bottom_right_x, bottom_right_y)\n     " (span (|@| (class "keyword") (id "F:46869")) "struct") " " (span (|@| (class "type") (id "F:46876")) "window") " *" (span (|@| (class "variable-name") (id "F:46884")) "w") ";\n     " (span (|@| (class "type") (id "F:46892")) "int") " " (span (|@| (class "variable-name") (id "F:46896")) "area") ";\n     " (span (|@| (class "type") (id "F:46907")) "int") " *" (span (|@| (class "variable-name") (id "F:46912")) "top_left_x") ", *" (span (|@| (class "variable-name") (id "F:46925")) "top_left_y") ", *" (span (|@| (class "variable-name") (id "F:46938")) "bottom_right_x") ", *" (span (|@| (class "variable-name") (id "F:46955")) "bottom_right_y") ";\n{\n  window_box (w, area, top_left_x, top_left_y, bottom_right_x,\n              bottom_right_y);\n  *bottom_right_x += *top_left_x;\n  *bottom_right_y += *top_left_y;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:47134")) "/***********************************************************************") (span (|@| (class "comment") (id "F:47206")) "\n                              Utilities\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:47297")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:47301")) "/* ") (span (|@| (class "comment") (id "F:47304")) "Return the bottom y-position of the line the iterator IT is in.\n   This can modify IT's settings.  ") (span (|@| (class "comment-delimiter") (id "F:47403")) "*/") "\n\n" (span (|@| (class "type") (id "F:47407")) "int") "\n" (span (|@| (class "function-name") (id "F:47411")) "line_bottom_y") " (" (span (|@| (class "type") (id "F:47426")) "it") ")\n     " (span (|@| (class "keyword") (id "F:47435")) "struct") " " (span (|@| (class "type") (id "F:47442")) "it") " *" (span (|@| (class "variable-name") (id "F:47446")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:47454")) "int") " " (span (|@| (class "variable-name") (id "F:47458")) "line_height") " = it->max_ascent + it->max_descent;\n  " (span (|@| (class "type") (id "F:47508")) "int") " " (span (|@| (class "variable-name") (id "F:47512")) "line_top_y") " = it->current_y;\n\n  " (span (|@| (class "keyword") (id "F:47543")) "if") " (line_height == 0)\n    {\n      " (span (|@| (class "keyword") (id "F:47577")) "if") " (last_height)\n        line_height = last_height;\n      " (span (|@| (class "keyword") (id "F:47628")) "else") " " (span (|@| (class "keyword") (id "F:47633")) "if") " (IT_CHARPOS (*it) < ZV)\n        {\n          move_it_by_lines (it, 1, 1);\n          line_height = (it->max_ascent || it->max_descent\n                         ? it->max_ascent + it->max_descent\n                         : last_height);\n        }\n      " (span (|@| (class "keyword") (id "F:47815")) "else") "\n        {\n          " (span (|@| (class "keyword") (id "F:47826")) "struct") " " (span (|@| (class "type") (id "F:47833")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:47844")) "row") " = it->glyph_row;\n\n          " (span (|@| (class "comment-delimiter") (id "F:47869")) "/* ") (span (|@| (class "comment") (id "F:47872")) "Use the default character height.  ") (span (|@| (class "comment-delimiter") (id "F:47907")) "*/") "\n          it->glyph_row = " (span (|@| (class "constant") (id "F:47929")) "NULL") ";\n          it->what = IT_CHARACTER;\n          it->c = " (span (|@| (class "string") (id "F:47974")) "' '") ";\n          it->len = 1;\n          PRODUCE_GLYPHS (it);\n          line_height = it->ascent + it->descent;\n          it->glyph_row = row;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:48098")) "return") " line_top_y + line_height;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:48135")) "/* ") (span (|@| (class "comment") (id "F:48138")) "Return 1 if position CHARPOS is visible in window W.\n   CHARPOS < 0 means return info about WINDOW_END position.\n   If visible, set *X and *Y to pixel coordinates of top left corner.\n   Set *RTOP and *RBOT to pixel height of an invisible area of glyph at POS.\n   Set *ROWH and *VPOS to row's visible height and VPOS (row number).  ") (span (|@| (class "comment-delimiter") (id "F:48469")) "*/") "\n\n" (span (|@| (class "type") (id "F:48473")) "int") "\n" (span (|@| (class "function-name") (id "F:48477")) "pos_visible_p") " (w, charpos, x, y, rtop, rbot, rowh, vpos)\n     " (span (|@| (class "keyword") (id "F:48539")) "struct") " " (span (|@| (class "type") (id "F:48546")) "window") " *" (span (|@| (class "variable-name") (id "F:48554")) "w") ";\n     " (span (|@| (class "type") (id "F:48562")) "int") " " (span (|@| (class "variable-name") (id "F:48566")) "charpos") ", *" (span (|@| (class "variable-name") (id "F:48576")) "x") ", *" (span (|@| (class "variable-name") (id "F:48580")) "y") ", *" (span (|@| (class "variable-name") (id "F:48584")) "rtop") ", *" (span (|@| (class "variable-name") (id "F:48591")) "rbot") ", *" (span (|@| (class "variable-name") (id "F:48598")) "rowh") ", *" (span (|@| (class "variable-name") (id "F:48605")) "vpos") ";\n{\n  " (span (|@| (class "keyword") (id "F:48615")) "struct") " " (span (|@| (class "type") (id "F:48622")) "it") " " (span (|@| (class "variable-name") (id "F:48625")) "it") ";\n  " (span (|@| (class "keyword") (id "F:48631")) "struct") " " (span (|@| (class "type") (id "F:48638")) "text_pos") " " (span (|@| (class "variable-name") (id "F:48647")) "top") ";\n  " (span (|@| (class "type") (id "F:48654")) "int") " " (span (|@| (class "variable-name") (id "F:48658")) "visible_p") " = 0;\n  " (span (|@| (class "keyword") (id "F:48675")) "struct") " " (span (|@| (class "type") (id "F:48682")) "buffer") " *" (span (|@| (class "variable-name") (id "F:48690")) "old_buffer") " = " (span (|@| (class "constant") (id "F:48703")) "NULL") ";\n\n  " (span (|@| (class "keyword") (id "F:48712")) "if") " (FRAME_INITIAL_P (XFRAME (WINDOW_FRAME (w))))\n    " (span (|@| (class "keyword") (id "F:48765")) "return") " visible_p;\n\n  " (span (|@| (class "keyword") (id "F:48786")) "if") " (XBUFFER (w->buffer) != current_buffer)\n    {\n      old_buffer = current_buffer;\n      set_buffer_internal_1 (XBUFFER (w->buffer));\n    }\n\n  SET_TEXT_POS_FROM_MARKER (top, w->start);\n\n  " (span (|@| (class "comment-delimiter") (id "F:48975")) "/* ") (span (|@| (class "comment") (id "F:48978")) "Compute exact mode line heights.  ") (span (|@| (class "comment-delimiter") (id "F:49012")) "*/") "\n  " (span (|@| (class "keyword") (id "F:49017")) "if") " (WINDOW_WANTS_MODELINE_P (w))\n    current_mode_line_height\n      = display_mode_line (w, CURRENT_MODE_LINE_FACE_ID (w),\n                           current_buffer->mode_line_format);\n\n  " (span (|@| (class "keyword") (id "F:49184")) "if") " (WINDOW_WANTS_HEADER_LINE_P (w))\n    current_header_line_height\n      = display_mode_line (w, HEADER_LINE_FACE_ID,\n                               current_buffer->header_line_format);\n\n  start_display (&it, w, top);\n  move_it_to (&it, charpos, -1, it.last_visible_y-1, -1,\n              (charpos >= 0 ? MOVE_TO_POS : 0) | MOVE_TO_Y);\n\n  " (span (|@| (class "keyword") (id "F:49495")) "if") " (charpos >= 0 && IT_CHARPOS (it) >= charpos)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:49555")) "/* ") (span (|@| (class "comment") (id "F:49558")) "We have reached CHARPOS, or passed it.  How the call to\n         move_it_to can overshoot: (i) If CHARPOS is on invisible\n         text, move_it_to stops at the end of the invisible text,\n         after CHARPOS.  (ii) If CHARPOS is in a display vector,\n         move_it_to stops on its last glyph.  ") (span (|@| (class "comment-delimiter") (id "F:49829")) "*/") "\n      " (span (|@| (class "type") (id "F:49838")) "int") " " (span (|@| (class "variable-name") (id "F:49842")) "top_x") " = it.current_x;\n      " (span (|@| (class "type") (id "F:49870")) "int") " " (span (|@| (class "variable-name") (id "F:49874")) "top_y") " = it.current_y;\n      " (span (|@| (class "keyword") (id "F:49902")) "enum") " " (span (|@| (class "type") (id "F:49907")) "it_method") " " (span (|@| (class "variable-name") (id "F:49917")) "it_method") " = it.method;\n      " (span (|@| (class "comment-delimiter") (id "F:49946")) "/* ") (span (|@| (class "comment") (id "F:49949")) "Calling line_bottom_y may change it.method, it.position, etc.  ") (span (|@| (class "comment-delimiter") (id "F:50012")) "*/") "\n      " (span (|@| (class "type") (id "F:50021")) "int") " " (span (|@| (class "variable-name") (id "F:50025")) "bottom_y") " = (last_height = 0, line_bottom_y (&it));\n      " (span (|@| (class "type") (id "F:50082")) "int") " " (span (|@| (class "variable-name") (id "F:50086")) "window_top_y") " = WINDOW_HEADER_LINE_HEIGHT (w);\n\n      " (span (|@| (class "keyword") (id "F:50139")) "if") " (top_y < window_top_y)\n        visible_p = bottom_y > window_top_y;\n      " (span (|@| (class "keyword") (id "F:50209")) "else") " " (span (|@| (class "keyword") (id "F:50214")) "if") " (top_y < it.last_visible_y)\n        visible_p = 1;\n      " (span (|@| (class "keyword") (id "F:50267")) "if") " (visible_p)\n        {\n          " (span (|@| (class "keyword") (id "F:50288")) "if") " (it_method == GET_FROM_DISPLAY_VECTOR)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:50344")) "/* ") (span (|@| (class "comment") (id "F:50347")) "We stopped on the last glyph of a display vector.\n                 Try and recompute.  Hack alert!  ") (span (|@| (class "comment-delimiter") (id "F:50433")) "*/") "\n              " (span (|@| (class "keyword") (id "F:50443")) "if") " (charpos < 2 || top.charpos >= charpos)\n                top_x = it.glyph_row->x;\n              " (span (|@| (class "keyword") (id "F:50520")) "else") "\n                {\n                  " (span (|@| (class "keyword") (id "F:50533")) "struct") " " (span (|@| (class "type") (id "F:50540")) "it") " " (span (|@| (class "variable-name") (id "F:50543")) "it2") ";\n                  start_display (&it2, w, top);\n                  move_it_to (&it2, charpos - 1, -1, -1, -1, MOVE_TO_POS);\n                  get_next_display_element (&it2);\n                  PRODUCE_GLYPHS (&it2);\n                  " (span (|@| (class "keyword") (id "F:50711")) "if") " (ITERATOR_AT_END_OF_LINE_P (&it2)\n                      || it2.current_x > it2.last_visible_x)\n                    top_x = it.glyph_row->x;\n                  " (span (|@| (class "keyword") (id "F:50830")) "else") "\n                    {\n                      top_x = it2.current_x;\n                      top_y = it2.current_y;\n                    }\n                }\n            }\n\n          *x = top_x;\n          *y = max (top_y + max (0, it.max_ascent - it.ascent), window_top_y);\n          *rtop = max (0, window_top_y - top_y);\n          *rbot = max (0, bottom_y - it.last_visible_y);\n          *rowh = max (0, (min (bottom_y, it.last_visible_y)\n                           - max (top_y, window_top_y)));\n          *vpos = it.vpos;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:51226")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:51243")) "struct") " " (span (|@| (class "type") (id "F:51250")) "it") " " (span (|@| (class "variable-name") (id "F:51253")) "it2") ";\n\n      it2 = it;\n      " (span (|@| (class "keyword") (id "F:51281")) "if") " (IT_CHARPOS (it) < ZV && FETCH_BYTE (IT_BYTEPOS (it)) != " (span (|@| (class "string") (id "F:51341")) "'\\n'") ")\n        move_it_by_lines (&it, 1, 0);\n      " (span (|@| (class "keyword") (id "F:51384")) "if") " (charpos < IT_CHARPOS (it)\n          || (it.what == IT_EOB && charpos == IT_CHARPOS (it)))\n        {\n          visible_p = 1;\n          move_it_to (&it2, charpos, -1, -1, -1, MOVE_TO_POS);\n          *x = it2.current_x;\n          *y = it2.current_y + it2.max_ascent - it2.ascent;\n          *rtop = max (0, -it2.current_y);\n          *rbot = max (0, ((it2.current_y + it2.max_ascent + it2.max_descent)\n                           - it.last_visible_y));\n          *rowh = max (0, (min (it2.current_y + it2.max_ascent + it2.max_descent,\n                                it.last_visible_y)\n                           - max (it2.current_y,\n                                  WINDOW_HEADER_LINE_HEIGHT (w))));\n          *vpos = it2.vpos;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:51959")) "if") " (old_buffer)\n    set_buffer_internal_1 (old_buffer);\n\n  current_header_line_height = current_mode_line_height = -1;\n\n  " (span (|@| (class "keyword") (id "F:52081")) "if") " (visible_p && XFASTINT (w->hscroll) > 0)\n    *x -= XFASTINT (w->hscroll) * WINDOW_FRAME_COLUMN_WIDTH (w);\n\n" (span (|@| (class "preprocessor") (id "F:52191")) "#if") " 0\n  " (span (|@| (class "comment-delimiter") (id "F:52199")) "/* ") (span (|@| (class "comment") (id "F:52202")) "Debugging code.  ") (span (|@| (class "comment-delimiter") (id "F:52219")) "*/") "\n  " (span (|@| (class "keyword") (id "F:52224")) "if") " (visible_p)\n    fprintf (stderr, " (span (|@| (class "string") (id "F:52260")) "\"+pv pt=%d vs=%d --> x=%d y=%d rt=%d rb=%d rh=%d vp=%d\\n\"") ",\n             charpos, w->vscroll, *x, *y, *rtop, *rbot, *rowh, *vpos);\n  " (span (|@| (class "keyword") (id "F:52385")) "else") "\n    fprintf (stderr, " (span (|@| (class "string") (id "F:52411")) "\"-pv pt=%d vs=%d\\n\"") ", charpos, w->vscroll);\n" (span (|@| (class "preprocessor") (id "F:52454")) "#endif") "\n\n  " (span (|@| (class "keyword") (id "F:52464")) "return") " visible_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:52486")) "/* ") (span (|@| (class "comment") (id "F:52489")) "Return the next character from STR which is MAXLEN bytes long.\n   Return in *LEN the length of the character.  This is like\n   STRING_CHAR_AND_LENGTH but never returns an invalid character.  If\n   we find one, we return a `?', but with the length of the invalid\n   character.  ") (span (|@| (class "comment-delimiter") (id "F:52766")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:52770")) "static") " INLINE " (span (|@| (class "type") (id "F:52784")) "int") "\n" (span (|@| (class "function-name") (id "F:52788")) "string_char_and_length") " (str, len)\n     " (span (|@| (class "keyword") (id "F:52827")) "const") " " (span (|@| (class "type") (id "F:52833")) "unsigned") " " (span (|@| (class "type") (id "F:52842")) "char") " *" (span (|@| (class "variable-name") (id "F:52848")) "str") ";\n     " (span (|@| (class "type") (id "F:52858")) "int") " *" (span (|@| (class "variable-name") (id "F:52863")) "len") ";\n{\n  " (span (|@| (class "type") (id "F:52872")) "int") " " (span (|@| (class "variable-name") (id "F:52876")) "c") ";\n\n  c = STRING_CHAR_AND_LENGTH (str, *len);\n  " (span (|@| (class "keyword") (id "F:52924")) "if") " (" (span (|@| (class "negation-char") (id "F:52928")) "!") "CHAR_VALID_P (c, 1))\n    " (span (|@| (class "comment-delimiter") (id "F:52954")) "/* ") (span (|@| (class "comment") (id "F:52957")) "We may not change the length here because other places in Emacs\n       don't use this function, i.e. they silently accept invalid\n       characters.  ") (span (|@| (class "comment-delimiter") (id "F:53107")) "*/") "\n    c = " (span (|@| (class "string") (id "F:53118")) "'?'") ";\n\n  " (span (|@| (class "keyword") (id "F:53126")) "return") " c;\n}\n\n\n\n" (span (|@| (class "comment-delimiter") (id "F:53141")) "/* ") (span (|@| (class "comment") (id "F:53144")) "Given a position POS containing a valid character and byte position\n   in STRING, return the position NCHARS ahead (NCHARS >= 0).  ") (span (|@| (class "comment-delimiter") (id "F:53275")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:53279")) "static") " " (span (|@| (class "keyword") (id "F:53286")) "struct") " " (span (|@| (class "type") (id "F:53293")) "text_pos") "\n" (span (|@| (class "function-name") (id "F:53302")) "string_pos_nchars_ahead") " (pos, string, nchars)\n     " (span (|@| (class "keyword") (id "F:53353")) "struct") " " (span (|@| (class "type") (id "F:53360")) "text_pos") " " (span (|@| (class "variable-name") (id "F:53369")) "pos") ";\n     " (span (|@| (class "type") (id "F:53379")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:53391")) "string") ";\n     " (span (|@| (class "type") (id "F:53404")) "int") " " (span (|@| (class "variable-name") (id "F:53408")) "nchars") ";\n{\n  xassert (STRINGP (string) && nchars >= 0);\n\n  " (span (|@| (class "keyword") (id "F:53466")) "if") " (STRING_MULTIBYTE (string))\n    {\n      " (span (|@| (class "type") (id "F:53509")) "int") " " (span (|@| (class "variable-name") (id "F:53513")) "rest") " = SBYTES (string) - BYTEPOS (pos);\n      " (span (|@| (class "keyword") (id "F:53559")) "const") " " (span (|@| (class "type") (id "F:53565")) "unsigned") " " (span (|@| (class "type") (id "F:53574")) "char") " *" (span (|@| (class "variable-name") (id "F:53580")) "p") " = SDATA (string) + BYTEPOS (pos);\n      " (span (|@| (class "type") (id "F:53622")) "int") " " (span (|@| (class "variable-name") (id "F:53626")) "len") ";\n\n      " (span (|@| (class "keyword") (id "F:53638")) "while") " (nchars--)\n        {\n          string_char_and_length (p, &len);\n          p += len, rest -= len;\n          xassert (rest >= 0);\n          CHARPOS (pos) += 1;\n          BYTEPOS (pos) += len;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:53804")) "else") "\n    SET_TEXT_POS (pos, CHARPOS (pos) + nchars, BYTEPOS (pos) + nchars);\n\n  " (span (|@| (class "keyword") (id "F:53884")) "return") " pos;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:53900")) "/* ") (span (|@| (class "comment") (id "F:53903")) "Value is the text position, i.e. character and byte position,\n   for character position CHARPOS in STRING.  ") (span (|@| (class "comment-delimiter") (id "F:54011")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:54015")) "static") " INLINE " (span (|@| (class "keyword") (id "F:54029")) "struct") " " (span (|@| (class "type") (id "F:54036")) "text_pos") "\n" (span (|@| (class "function-name") (id "F:54045")) "string_pos") " (charpos, string)\n     " (span (|@| (class "type") (id "F:54079")) "int") " " (span (|@| (class "variable-name") (id "F:54083")) "charpos") ";\n     " (span (|@| (class "type") (id "F:54097")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:54109")) "string") ";\n{\n  " (span (|@| (class "keyword") (id "F:54121")) "struct") " " (span (|@| (class "type") (id "F:54128")) "text_pos") " " (span (|@| (class "variable-name") (id "F:54137")) "pos") ";\n  xassert (STRINGP (string));\n  xassert (charpos >= 0);\n  SET_TEXT_POS (pos, charpos, string_char_to_byte (string, charpos));\n  " (span (|@| (class "keyword") (id "F:54270")) "return") " pos;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:54286")) "/* ") (span (|@| (class "comment") (id "F:54289")) "Value is a text position, i.e. character and byte position, for\n   character position CHARPOS in C string S.  MULTIBYTE_P non-zero\n   means recognize multibyte characters.  ") (span (|@| (class "comment-delimiter") (id "F:54462")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:54466")) "static") " " (span (|@| (class "keyword") (id "F:54473")) "struct") " " (span (|@| (class "type") (id "F:54480")) "text_pos") "\n" (span (|@| (class "function-name") (id "F:54489")) "c_string_pos") " (charpos, s, multibyte_p)\n     " (span (|@| (class "type") (id "F:54533")) "int") " " (span (|@| (class "variable-name") (id "F:54537")) "charpos") ";\n     " (span (|@| (class "type") (id "F:54551")) "unsigned") " " (span (|@| (class "type") (id "F:54560")) "char") " *" (span (|@| (class "variable-name") (id "F:54566")) "s") ";\n     " (span (|@| (class "type") (id "F:54574")) "int") " " (span (|@| (class "variable-name") (id "F:54578")) "multibyte_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:54595")) "struct") " " (span (|@| (class "type") (id "F:54602")) "text_pos") " " (span (|@| (class "variable-name") (id "F:54611")) "pos") ";\n\n  xassert (s != " (span (|@| (class "constant") (id "F:54633")) "NULL") ");\n  xassert (charpos >= 0);\n\n  " (span (|@| (class "keyword") (id "F:54669")) "if") " (multibyte_p)\n    {\n      " (span (|@| (class "type") (id "F:54698")) "int") " " (span (|@| (class "variable-name") (id "F:54702")) "rest") " = strlen (s), " (span (|@| (class "variable-name") (id "F:54721")) "len") ";\n\n      SET_TEXT_POS (pos, 0, 0);\n      " (span (|@| (class "keyword") (id "F:54765")) "while") " (charpos--)\n        {\n          string_char_and_length (s, &len);\n          s += len, rest -= len;\n          xassert (rest >= 0);\n          CHARPOS (pos) += 1;\n          BYTEPOS (pos) += len;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:54932")) "else") "\n    SET_TEXT_POS (pos, charpos, charpos);\n\n  " (span (|@| (class "keyword") (id "F:54982")) "return") " pos;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:54998")) "/* ") (span (|@| (class "comment") (id "F:55001")) "Value is the number of characters in C string S.  MULTIBYTE_P\n   non-zero means recognize multibyte characters.  ") (span (|@| (class "comment-delimiter") (id "F:55114")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:55118")) "static") " " (span (|@| (class "type") (id "F:55125")) "int") "\n" (span (|@| (class "function-name") (id "F:55129")) "number_of_chars") " (s, multibyte_p)\n     " (span (|@| (class "type") (id "F:55167")) "unsigned") " " (span (|@| (class "type") (id "F:55176")) "char") " *" (span (|@| (class "variable-name") (id "F:55182")) "s") ";\n     " (span (|@| (class "type") (id "F:55190")) "int") " " (span (|@| (class "variable-name") (id "F:55194")) "multibyte_p") ";\n{\n  " (span (|@| (class "type") (id "F:55211")) "int") " " (span (|@| (class "variable-name") (id "F:55215")) "nchars") ";\n\n  " (span (|@| (class "keyword") (id "F:55226")) "if") " (multibyte_p)\n    {\n      " (span (|@| (class "type") (id "F:55255")) "int") " " (span (|@| (class "variable-name") (id "F:55259")) "rest") " = strlen (s), " (span (|@| (class "variable-name") (id "F:55278")) "len") ";\n      " (span (|@| (class "type") (id "F:55289")) "unsigned") " " (span (|@| (class "type") (id "F:55298")) "char") " *" (span (|@| (class "variable-name") (id "F:55304")) "p") " = (" (span (|@| (class "type") (id "F:55309")) "unsigned") " " (span (|@| (class "type") (id "F:55318")) "char") " *) s;\n\n      " (span (|@| (class "keyword") (id "F:55336")) "for") " (nchars = 0; rest > 0; ++nchars)\n        {\n          string_char_and_length (p, &len);\n          rest -= len, p += len;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:55450")) "else") "\n    nchars = strlen (s);\n\n  " (span (|@| (class "keyword") (id "F:55483")) "return") " nchars;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:55502")) "/* ") (span (|@| (class "comment") (id "F:55505")) "Compute byte position NEWPOS->bytepos corresponding to\n   NEWPOS->charpos.  POS is a known position in string STRING.\n   NEWPOS->charpos must be >= POS.charpos.  ") (span (|@| (class "comment-delimiter") (id "F:55667")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:55671")) "static") " " (span (|@| (class "type") (id "F:55678")) "void") "\n" (span (|@| (class "function-name") (id "F:55683")) "compute_string_pos") " (newpos, pos, string)\n     " (span (|@| (class "keyword") (id "F:55729")) "struct") " " (span (|@| (class "type") (id "F:55736")) "text_pos") " *" (span (|@| (class "variable-name") (id "F:55746")) "newpos") ", " (span (|@| (class "variable-name") (id "F:55754")) "pos") ";\n     " (span (|@| (class "type") (id "F:55764")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:55776")) "string") ";\n{\n  xassert (STRINGP (string));\n  xassert (CHARPOS (*newpos) >= CHARPOS (pos));\n\n  " (span (|@| (class "keyword") (id "F:55867")) "if") " (STRING_MULTIBYTE (string))\n    *newpos = string_pos_nchars_ahead (pos, string,\n                                       CHARPOS (*newpos) - CHARPOS (pos));\n  " (span (|@| (class "keyword") (id "F:55999")) "else") "\n    BYTEPOS (*newpos) = CHARPOS (*newpos);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:56050")) "/* ") (span (|@| (class "comment") (id "F:56053")) "EXPORT:\n   Return an estimation of the pixel height of mode or header lines on\n   frame F.  FACE_ID specifies what line's height to estimate.  ") (span (|@| (class "comment-delimiter") (id "F:56196")) "*/") "\n\n" (span (|@| (class "type") (id "F:56200")) "int") "\n" (span (|@| (class "function-name") (id "F:56204")) "estimate_mode_line_height") " (f, " (span (|@| (class "type") (id "F:56234")) "face_id") ")\n     " (span (|@| (class "keyword") (id "F:56248")) "struct") " " (span (|@| (class "type") (id "F:56255")) "frame") " *" (span (|@| (class "variable-name") (id "F:56262")) "f") ";\n     " (span (|@| (class "keyword") (id "F:56270")) "enum") " " (span (|@| (class "type") (id "F:56275")) "face_id") " " (span (|@| (class "variable-name") (id "F:56283")) "face_id") ";\n{\n" (span (|@| (class "preprocessor") (id "F:56294")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "keyword") (id "F:56322")) "if") " (FRAME_WINDOW_P (f))\n    {\n      " (span (|@| (class "type") (id "F:56358")) "int") " " (span (|@| (class "variable-name") (id "F:56362")) "height") " = FONT_HEIGHT (FRAME_FONT (f));\n\n      " (span (|@| (class "comment-delimiter") (id "F:56408")) "/* ") (span (|@| (class "comment") (id "F:56411")) "This function is called so early when Emacs starts that the face\n         cache and mode line face are not yet initialized.  ") (span (|@| (class "comment-delimiter") (id "F:56529")) "*/") "\n      " (span (|@| (class "keyword") (id "F:56538")) "if") " (FRAME_FACE_CACHE (f))\n        {\n          " (span (|@| (class "keyword") (id "F:56570")) "struct") " " (span (|@| (class "type") (id "F:56577")) "face") " *" (span (|@| (class "variable-name") (id "F:56583")) "face") " = FACE_FROM_ID (f, face_id);\n          " (span (|@| (class "keyword") (id "F:56620")) "if") " (face)\n            {\n              " (span (|@| (class "keyword") (id "F:56644")) "if") " (face->font)\n                height = FONT_HEIGHT (face->font);\n              " (span (|@| (class "keyword") (id "F:56704")) "if") " (face->box_line_width > 0)\n                height += 2 * face->box_line_width;\n            }\n        }\n\n      " (span (|@| (class "keyword") (id "F:56789")) "return") " height;\n    }\n" (span (|@| (class "preprocessor") (id "F:56810")) "#endif") "\n\n  " (span (|@| (class "keyword") (id "F:56820")) "return") " 1;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:56833")) "/* ") (span (|@| (class "comment") (id "F:56836")) "Given a pixel position (PIX_X, PIX_Y) on frame F, return glyph\n   co-ordinates in (*X, *Y).  Set *BOUNDS to the rectangle that the\n   glyph at X, Y occupies, if BOUNDS != 0.  If NOCLIP is non-zero, do\n   not force the value into range.  ") (span (|@| (class "comment-delimiter") (id "F:57073")) "*/") "\n\n" (span (|@| (class "type") (id "F:57077")) "void") "\n" (span (|@| (class "function-name") (id "F:57082")) "pixel_to_glyph_coords") " (f, pix_x, pix_y, x, y, bounds, noclip)\n     " (span (|@| (class "type") (id "F:57149")) "FRAME_PTR") " " (span (|@| (class "variable-name") (id "F:57159")) "f") ";\n     " (span (|@| (class "keyword") (id "F:57167")) "register") " " (span (|@| (class "type") (id "F:57176")) "int") " " (span (|@| (class "variable-name") (id "F:57180")) "pix_x") ", " (span (|@| (class "variable-name") (id "F:57187")) "pix_y") ";\n     " (span (|@| (class "type") (id "F:57199")) "int") " *" (span (|@| (class "variable-name") (id "F:57204")) "x") ", *" (span (|@| (class "variable-name") (id "F:57208")) "y") ";\n     " (span (|@| (class "type") (id "F:57216")) "NativeRectangle") " *" (span (|@| (class "variable-name") (id "F:57233")) "bounds") ";\n     " (span (|@| (class "type") (id "F:57246")) "int") " " (span (|@| (class "variable-name") (id "F:57250")) "noclip") ";\n{\n\n" (span (|@| (class "preprocessor") (id "F:57261")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "keyword") (id "F:57289")) "if") " (FRAME_WINDOW_P (f))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:57325")) "/* ") (span (|@| (class "comment") (id "F:57328")) "Arrange for the division in FRAME_PIXEL_X_TO_COL etc. to round down\n         even for negative values.  ") (span (|@| (class "comment-delimiter") (id "F:57425")) "*/") "\n      " (span (|@| (class "keyword") (id "F:57434")) "if") " (pix_x < 0)\n        pix_x -= FRAME_COLUMN_WIDTH (f) - 1;\n      " (span (|@| (class "keyword") (id "F:57493")) "if") " (pix_y < 0)\n        pix_y -= FRAME_LINE_HEIGHT (f) - 1;\n\n      pix_x = FRAME_PIXEL_X_TO_COL (f, pix_x);\n      pix_y = FRAME_PIXEL_Y_TO_LINE (f, pix_y);\n\n      " (span (|@| (class "keyword") (id "F:57648")) "if") " (bounds)\n        STORE_NATIVE_RECT (*bounds,\n                           FRAME_COL_TO_PIXEL_X (f, pix_x),\n                           FRAME_LINE_TO_PIXEL_Y (f, pix_y),\n                           FRAME_COLUMN_WIDTH (f) - 1,\n                           FRAME_LINE_HEIGHT (f) - 1);\n\n      " (span (|@| (class "keyword") (id "F:57843")) "if") " (" (span (|@| (class "negation-char") (id "F:57847")) "!") "noclip)\n        {\n          " (span (|@| (class "keyword") (id "F:57862")) "if") " (pix_x < 0)\n            pix_x = 0;\n          " (span (|@| (class "keyword") (id "F:57896")) "else") " " (span (|@| (class "keyword") (id "F:57901")) "if") " (pix_x > FRAME_TOTAL_COLS (f))\n            pix_x = FRAME_TOTAL_COLS (f);\n\n          " (span (|@| (class "keyword") (id "F:57974")) "if") " (pix_y < 0)\n            pix_y = 0;\n          " (span (|@| (class "keyword") (id "F:58008")) "else") " " (span (|@| (class "keyword") (id "F:58013")) "if") " (pix_y > FRAME_LINES (f))\n            pix_y = FRAME_LINES (f);\n        }\n    }\n" (span (|@| (class "preprocessor") (id "F:58081")) "#endif") "\n\n  *x = pix_x;\n  *y = pix_y;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:58121")) "/* ") (span (|@| (class "comment") (id "F:58124")) "Given HPOS/VPOS in the current matrix of W, return corresponding\n   frame-relative pixel positions in *FRAME_X and *FRAME_Y.  If we\n   can't tell the positions because W's display is not up to date,\n   return 0.  ") (span (|@| (class "comment-delimiter") (id "F:58337")) "*/") "\n\n" (span (|@| (class "type") (id "F:58341")) "int") "\n" (span (|@| (class "function-name") (id "F:58345")) "glyph_to_pixel_coords") " (w, hpos, vpos, frame_x, frame_y)\n     " (span (|@| (class "keyword") (id "F:58406")) "struct") " " (span (|@| (class "type") (id "F:58413")) "window") " *" (span (|@| (class "variable-name") (id "F:58421")) "w") ";\n     " (span (|@| (class "type") (id "F:58429")) "int") " " (span (|@| (class "variable-name") (id "F:58433")) "hpos") ", " (span (|@| (class "variable-name") (id "F:58439")) "vpos") ";\n     " (span (|@| (class "type") (id "F:58450")) "int") " *" (span (|@| (class "variable-name") (id "F:58455")) "frame_x") ", *" (span (|@| (class "variable-name") (id "F:58465")) "frame_y") ";\n{\n" (span (|@| (class "preprocessor") (id "F:58476")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "keyword") (id "F:58504")) "if") " (FRAME_WINDOW_P (XFRAME (WINDOW_FRAME (w))))\n    {\n      " (span (|@| (class "type") (id "F:58564")) "int") " " (span (|@| (class "variable-name") (id "F:58568")) "success_p") ";\n\n      xassert (hpos >= 0 && hpos < w->current_matrix->matrix_w);\n      xassert (vpos >= 0 && vpos < w->current_matrix->matrix_h);\n\n      " (span (|@| (class "keyword") (id "F:58717")) "if") " (display_completed)\n        {\n          " (span (|@| (class "keyword") (id "F:58746")) "struct") " " (span (|@| (class "type") (id "F:58753")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:58764")) "row") " = MATRIX_ROW (w->current_matrix, vpos);\n          " (span (|@| (class "keyword") (id "F:58811")) "struct") " " (span (|@| (class "type") (id "F:58818")) "glyph") " *" (span (|@| (class "variable-name") (id "F:58825")) "glyph") " = row->glyphs[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:58860")) "struct") " " (span (|@| (class "type") (id "F:58867")) "glyph") " *" (span (|@| (class "variable-name") (id "F:58874")) "end") " = glyph + min (hpos, row->used[TEXT_AREA]);\n\n          hpos = row->x;\n          vpos = row->y;\n          " (span (|@| (class "keyword") (id "F:58962")) "while") " (glyph < end)\n            {\n              hpos += glyph->pixel_width;\n              ++glyph;\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:59051")) "/* ") (span (|@| (class "comment") (id "F:59054")) "If first glyph is partially visible, its first visible position is still 0.  ") (span (|@| (class "comment-delimiter") (id "F:59131")) "*/") "\n          " (span (|@| (class "keyword") (id "F:59137")) "if") " (hpos < 0)\n            hpos = 0;\n\n          success_p = 1;\n        }\n      " (span (|@| (class "keyword") (id "F:59194")) "else") "\n        {\n          hpos = vpos = 0;\n          success_p = 0;\n        }\n\n      *frame_x = WINDOW_TO_FRAME_PIXEL_X (w, hpos);\n      *frame_y = WINDOW_TO_FRAME_PIXEL_Y (w, vpos);\n      " (span (|@| (class "keyword") (id "F:59354")) "return") " success_p;\n    }\n" (span (|@| (class "preprocessor") (id "F:59378")) "#endif") "\n\n  *frame_x = hpos;\n  *frame_y = vpos;\n  " (span (|@| (class "keyword") (id "F:59426")) "return") " 1;\n}\n\n\n" (span (|@| (class "preprocessor") (id "F:59440")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "comment-delimiter") (id "F:59467")) "/* ") (span (|@| (class "comment") (id "F:59470")) "Find the glyph under window-relative coordinates X/Y in window W.\n   Consider only glyphs from buffer text, i.e. no glyphs from overlay\n   strings.  Return in *HPOS and *VPOS the row and column number of\n   the glyph found.  Return in *AREA the glyph area containing X.\n   Value is a pointer to the glyph found or null if X/Y is not on\n   text, or we can't tell because W's current matrix is not up to\n   date.  ") (span (|@| (class "comment-delimiter") (id "F:59882")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:59886")) "static") "\n" (span (|@| (class "keyword") (id "F:59893")) "struct") " " (span (|@| (class "type") (id "F:59900")) "glyph") " *\n" (span (|@| (class "function-name") (id "F:59908")) "x_y_to_hpos_vpos") " (w, x, y, hpos, vpos, dx, dy, area)\n     " (span (|@| (class "keyword") (id "F:59966")) "struct") " " (span (|@| (class "type") (id "F:59973")) "window") " *" (span (|@| (class "variable-name") (id "F:59981")) "w") ";\n     " (span (|@| (class "type") (id "F:59989")) "int") " " (span (|@| (class "variable-name") (id "F:59993")) "x") ", " (span (|@| (class "variable-name") (id "F:59996")) "y") ";\n     " (span (|@| (class "type") (id "F:60004")) "int") " *" (span (|@| (class "variable-name") (id "F:60009")) "hpos") ", *" (span (|@| (class "variable-name") (id "F:60016")) "vpos") ", *" (span (|@| (class "variable-name") (id "F:60023")) "dx") ", *" (span (|@| (class "variable-name") (id "F:60028")) "dy") ", *" (span (|@| (class "variable-name") (id "F:60033")) "area") ";\n{\n  " (span (|@| (class "keyword") (id "F:60043")) "struct") " " (span (|@| (class "type") (id "F:60050")) "glyph") " *" (span (|@| (class "variable-name") (id "F:60057")) "glyph") ", *" (span (|@| (class "variable-name") (id "F:60065")) "end") ";\n  " (span (|@| (class "keyword") (id "F:60072")) "struct") " " (span (|@| (class "type") (id "F:60079")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:60090")) "row") " = " (span (|@| (class "constant") (id "F:60096")) "NULL") ";\n  " (span (|@| (class "type") (id "F:60104")) "int") " " (span (|@| (class "variable-name") (id "F:60108")) "x0") ", " (span (|@| (class "variable-name") (id "F:60112")) "i") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:60118")) "/* ") (span (|@| (class "comment") (id "F:60121")) "Find row containing Y.  Give up if some row is not enabled.  ") (span (|@| (class "comment-delimiter") (id "F:60182")) "*/") "\n  " (span (|@| (class "keyword") (id "F:60187")) "for") " (i = 0; i < w->current_matrix->nrows; ++i)\n    {\n      row = MATRIX_ROW (w->current_matrix, i);\n      " (span (|@| (class "keyword") (id "F:60293")) "if") " (" (span (|@| (class "negation-char") (id "F:60297")) "!") "row->enabled_p)\n        " (span (|@| (class "keyword") (id "F:60315")) "return") " " (span (|@| (class "constant") (id "F:60322")) "NULL") ";\n      " (span (|@| (class "keyword") (id "F:60334")) "if") " (y >= row->y && y < MATRIX_ROW_BOTTOM_Y (row))\n        " (span (|@| (class "keyword") (id "F:60385")) "break") ";\n    }\n\n  *vpos = i;\n  *hpos = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:60428")) "/* ") (span (|@| (class "comment") (id "F:60431")) "Give up if Y is not in the window.  ") (span (|@| (class "comment-delimiter") (id "F:60467")) "*/") "\n  " (span (|@| (class "keyword") (id "F:60472")) "if") " (i == w->current_matrix->nrows)\n    " (span (|@| (class "keyword") (id "F:60511")) "return") " " (span (|@| (class "constant") (id "F:60518")) "NULL") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:60527")) "/* ") (span (|@| (class "comment") (id "F:60530")) "Get the glyph area containing X.  ") (span (|@| (class "comment-delimiter") (id "F:60564")) "*/") "\n  " (span (|@| (class "keyword") (id "F:60569")) "if") " (w->pseudo_window_p)\n    {\n      *area = TEXT_AREA;\n      x0 = 0;\n    }\n  " (span (|@| (class "keyword") (id "F:60646")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:60663")) "if") " (x < window_box_left_offset (w, TEXT_AREA))\n        {\n          *area = LEFT_MARGIN_AREA;\n          x0 = window_box_left_offset (w, LEFT_MARGIN_AREA);\n        }\n      " (span (|@| (class "keyword") (id "F:60805")) "else") " " (span (|@| (class "keyword") (id "F:60810")) "if") " (x < window_box_right_offset (w, TEXT_AREA))\n        {\n          *area = TEXT_AREA;\n          x0 = window_box_left_offset (w, TEXT_AREA) + min (row->x, 0);\n        }\n      " (span (|@| (class "keyword") (id "F:60957")) "else") "\n        {\n          *area = RIGHT_MARGIN_AREA;\n          x0 = window_box_left_offset (w, RIGHT_MARGIN_AREA);\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:61062")) "/* ") (span (|@| (class "comment") (id "F:61065")) "Find glyph containing X.  ") (span (|@| (class "comment-delimiter") (id "F:61091")) "*/") "\n  glyph = row->glyphs[*area];\n  end = glyph + row->used[*area];\n  x -= x0;\n  " (span (|@| (class "keyword") (id "F:61171")) "while") " (glyph < end && x >= glyph->pixel_width)\n    {\n      x -= glyph->pixel_width;\n      ++glyph;\n    }\n\n  " (span (|@| (class "keyword") (id "F:61279")) "if") " (glyph == end)\n    " (span (|@| (class "keyword") (id "F:61301")) "return") " " (span (|@| (class "constant") (id "F:61308")) "NULL") ";\n\n  " (span (|@| (class "keyword") (id "F:61317")) "if") " (dx)\n    {\n      *dx = x;\n      *dy = y - (row->y + row->ascent - glyph->ascent);\n    }\n\n  *hpos = glyph - row->glyphs[*area];\n  " (span (|@| (class "keyword") (id "F:61449")) "return") " glyph;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:61467")) "/* ") (span (|@| (class "comment") (id "F:61470")) "EXPORT:\n   Convert frame-relative x/y to coordinates relative to window W.\n   Takes pseudo-windows into account.  ") (span (|@| (class "comment-delimiter") (id "F:61584")) "*/") "\n\n" (span (|@| (class "type") (id "F:61588")) "void") "\n" (span (|@| (class "function-name") (id "F:61593")) "frame_to_window_pixel_xy") " (w, x, y)\n     " (span (|@| (class "keyword") (id "F:61633")) "struct") " " (span (|@| (class "type") (id "F:61640")) "window") " *" (span (|@| (class "variable-name") (id "F:61648")) "w") ";\n     " (span (|@| (class "type") (id "F:61656")) "int") " *" (span (|@| (class "variable-name") (id "F:61661")) "x") ", *" (span (|@| (class "variable-name") (id "F:61665")) "y") ";\n{\n  " (span (|@| (class "keyword") (id "F:61672")) "if") " (w->pseudo_window_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:61708")) "/* ") (span (|@| (class "comment") (id "F:61711")) "A pseudo-window is always full-width, and starts at the\n         left edge of the frame, plus a frame border.  ") (span (|@| (class "comment-delimiter") (id "F:61815")) "*/") "\n      " (span (|@| (class "keyword") (id "F:61824")) "struct") " " (span (|@| (class "type") (id "F:61831")) "frame") " *" (span (|@| (class "variable-name") (id "F:61838")) "f") " = XFRAME (w->frame);\n      *x -= FRAME_INTERNAL_BORDER_WIDTH (f);\n      *y = FRAME_TO_WINDOW_PIXEL_Y (w, *y);\n    }\n  " (span (|@| (class "keyword") (id "F:61958")) "else") "\n    {\n      *x -= WINDOW_LEFT_EDGE_X (w);\n      *y = FRAME_TO_WINDOW_PIXEL_Y (w, *y);\n    }\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:62058")) "/* ") (span (|@| (class "comment") (id "F:62061")) "EXPORT:\n   Return in RECTS[] at most N clipping rectangles for glyph string S.\n   Return the number of stored rectangles.  ") (span (|@| (class "comment-delimiter") (id "F:62184")) "*/") "\n\n" (span (|@| (class "type") (id "F:62188")) "int") "\n" (span (|@| (class "function-name") (id "F:62192")) "get_glyph_string_clip_rects") " (s, rects, n)\n     " (span (|@| (class "keyword") (id "F:62239")) "struct") " " (span (|@| (class "type") (id "F:62246")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:62260")) "s") ";\n     " (span (|@| (class "type") (id "F:62268")) "NativeRectangle") " *" (span (|@| (class "variable-name") (id "F:62285")) "rects") ";\n     " (span (|@| (class "type") (id "F:62297")) "int") " " (span (|@| (class "variable-name") (id "F:62301")) "n") ";\n{\n  " (span (|@| (class "type") (id "F:62308")) "XRectangle") " " (span (|@| (class "variable-name") (id "F:62319")) "r") ";\n\n  " (span (|@| (class "keyword") (id "F:62325")) "if") " (n <= 0)\n    " (span (|@| (class "keyword") (id "F:62341")) "return") " 0;\n\n  " (span (|@| (class "keyword") (id "F:62354")) "if") " (s->row->full_width_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:62392")) "/* ") (span (|@| (class "comment") (id "F:62395")) "Draw full-width.  X coordinates are relative to S->w->left_col.  ") (span (|@| (class "comment-delimiter") (id "F:62460")) "*/") "\n      r.x = WINDOW_LEFT_EDGE_X (s->w);\n      r.width = WINDOW_TOTAL_WIDTH (s->w);\n\n      " (span (|@| (class "comment-delimiter") (id "F:62552")) "/* ") (span (|@| (class "comment") (id "F:62555")) "Unless displaying a mode or menu bar line, which are always\n         fully visible, clip to the visible part of the row.  ") (span (|@| (class "comment-delimiter") (id "F:62670")) "*/") "\n      " (span (|@| (class "keyword") (id "F:62679")) "if") " (s->w->pseudo_window_p)\n        r.height = s->row->visible_height;\n      " (span (|@| (class "keyword") (id "F:62748")) "else") "\n        r.height = s->height;\n    }\n  " (span (|@| (class "keyword") (id "F:62784")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:62801")) "/* ") (span (|@| (class "comment") (id "F:62804")) "This is a text line that may be partially visible.  ") (span (|@| (class "comment-delimiter") (id "F:62856")) "*/") "\n      r.x = window_box_left (s->w, s->area);\n      r.width = window_box_width (s->w, s->area);\n      r.height = s->row->visible_height;\n    }\n\n  " (span (|@| (class "keyword") (id "F:63004")) "if") " (s->clip_head)\n    " (span (|@| (class "keyword") (id "F:63026")) "if") " (r.x < s->clip_head->x)\n      {\n        " (span (|@| (class "keyword") (id "F:63062")) "if") " (r.width >= s->clip_head->x - r.x)\n          r.width -= s->clip_head->x - r.x;\n        " (span (|@| (class "keyword") (id "F:63138")) "else") "\n          r.width = 0;\n        r.x = s->clip_head->x;\n      }\n  " (span (|@| (class "keyword") (id "F:63193")) "if") " (s->clip_tail)\n    " (span (|@| (class "keyword") (id "F:63215")) "if") " (r.x + r.width > s->clip_tail->x + s->clip_tail->background_width)\n      {\n        " (span (|@| (class "keyword") (id "F:63294")) "if") " (s->clip_tail->x + s->clip_tail->background_width >= r.x)\n          r.width = s->clip_tail->x + s->clip_tail->background_width - r.x;\n        " (span (|@| (class "keyword") (id "F:63425")) "else") "\n          r.width = 0;\n      }\n\n  " (span (|@| (class "comment-delimiter") (id "F:63457")) "/* ") (span (|@| (class "comment") (id "F:63460")) "If S draws overlapping rows, it's sufficient to use the top and\n     bottom of the window for clipping because this glyph string\n     intentionally draws over other lines.  ") (span (|@| (class "comment-delimiter") (id "F:63633")) "*/") "\n  " (span (|@| (class "keyword") (id "F:63638")) "if") " (s->for_overlaps)\n    {\n      r.y = WINDOW_HEADER_LINE_HEIGHT (s->w);\n      r.height = window_text_bottom_y (s->w) - r.y;\n\n      " (span (|@| (class "comment-delimiter") (id "F:63770")) "/* ") (span (|@| (class "comment") (id "F:63773")) "Alas, the above simple strategy does not work for the\n         environments with anti-aliased text: if the same text is\n         drawn onto the same place multiple times, it gets thicker.\n         If the overlap we are processing is for the erased cursor, we\n         take the intersection with the rectagle of the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:64069")) "*/") "\n      " (span (|@| (class "keyword") (id "F:64078")) "if") " (s->for_overlaps & OVERLAPS_ERASED_CURSOR)\n        {\n          " (span (|@| (class "type") (id "F:64130")) "XRectangle") " " (span (|@| (class "variable-name") (id "F:64141")) "rc") ", " (span (|@| (class "variable-name") (id "F:64145")) "r_save") " = r;\n\n          rc.x = WINDOW_TEXT_TO_FRAME_PIXEL_X (s->w, s->w->phys_cursor.x);\n          rc.y = s->w->phys_cursor.y;\n          rc.width = s->w->phys_cursor_width;\n          rc.height = s->w->phys_cursor_height;\n\n          x_intersect_rectangles (&r_save, &rc, &r);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:64395")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:64412")) "/* ") (span (|@| (class "comment") (id "F:64415")) "Don't use S->y for clipping because it doesn't take partially\n         visible lines into account.  For example, it can be negative for\n         partially visible lines at the top of a window.  ") (span (|@| (class "comment-delimiter") (id "F:64595")) "*/") "\n      " (span (|@| (class "keyword") (id "F:64604")) "if") " (" (span (|@| (class "negation-char") (id "F:64608")) "!") "s->row->full_width_p\n          && MATRIX_ROW_PARTIALLY_VISIBLE_AT_TOP_P (s->w, s->row))\n        r.y = WINDOW_HEADER_LINE_HEIGHT (s->w);\n      " (span (|@| (class "keyword") (id "F:64737")) "else") "\n        r.y = max (0, s->row->y);\n    }\n\n  r.y = WINDOW_TO_FRAME_PIXEL_Y (s->w, r.y);\n\n  " (span (|@| (class "comment-delimiter") (id "F:64824")) "/* ") (span (|@| (class "comment") (id "F:64827")) "If drawing the cursor, don't let glyph draw outside its\n     advertised boundaries. Cleartype does this under some circumstances.  ") (span (|@| (class "comment-delimiter") (id "F:64958")) "*/") "\n  " (span (|@| (class "keyword") (id "F:64963")) "if") " (s->hl == DRAW_CURSOR)\n    {\n      " (span (|@| (class "keyword") (id "F:65001")) "struct") " " (span (|@| (class "type") (id "F:65008")) "glyph") " *" (span (|@| (class "variable-name") (id "F:65015")) "glyph") " = s->first_glyph;\n      " (span (|@| (class "type") (id "F:65045")) "int") " " (span (|@| (class "variable-name") (id "F:65049")) "height") ", " (span (|@| (class "variable-name") (id "F:65057")) "max_y") ";\n\n      " (span (|@| (class "keyword") (id "F:65071")) "if") " (s->x > r.x)\n        {\n          r.width -= s->x - r.x;\n          r.x = s->x;\n        }\n      r.width = min (r.width, glyph->pixel_width);\n\n      " (span (|@| (class "comment-delimiter") (id "F:65192")) "/* ") (span (|@| (class "comment") (id "F:65195")) "If r.y is below window bottom, ensure that we still see a cursor.  ") (span (|@| (class "comment-delimiter") (id "F:65262")) "*/") "\n      height = min (glyph->ascent + glyph->descent,\n                    min (FRAME_LINE_HEIGHT (s->f), s->row->visible_height));\n      max_y = window_text_bottom_y (s->w) - height;\n      max_y = WINDOW_TO_FRAME_PIXEL_Y (s->w, max_y);\n      " (span (|@| (class "keyword") (id "F:65491")) "if") " (s->ybase - glyph->ascent > max_y)\n        {\n          r.y = max_y;\n          r.height = height;\n        }\n      " (span (|@| (class "keyword") (id "F:65579")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:65590")) "/* ") (span (|@| (class "comment") (id "F:65593")) "Don't draw cursor glyph taller than our actual glyph.  ") (span (|@| (class "comment-delimiter") (id "F:65648")) "*/") "\n          height = max (FRAME_LINE_HEIGHT (s->f), glyph->ascent + glyph->descent);\n          " (span (|@| (class "keyword") (id "F:65730")) "if") " (height < r.height)\n            {\n              max_y = r.y + r.height;\n              r.y = min (max_y, max (r.y, s->ybase + glyph->descent - height));\n              r.height = min (max_y - r.y, height);\n            }\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:65928")) "if") " (s->row->clip)\n    {\n      " (span (|@| (class "type") (id "F:65958")) "XRectangle") " " (span (|@| (class "variable-name") (id "F:65969")) "r_save") " = r;\n\n      " (span (|@| (class "keyword") (id "F:65988")) "if") " (" (span (|@| (class "negation-char") (id "F:65992")) "!") " x_intersect_rectangles (&r_save, s->row->clip, &r))\n        r.width = 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:66069")) "if") " ((s->for_overlaps & OVERLAPS_BOTH) == 0\n      || ((s->for_overlaps & OVERLAPS_BOTH) == OVERLAPS_BOTH && n == 1))\n    {\n" (span (|@| (class "preprocessor") (id "F:66191")) "#ifdef") " CONVERT_FROM_XRECT\n      CONVERT_FROM_XRECT (r, *rects);\n" (span (|@| (class "preprocessor") (id "F:66255")) "#else") "\n      *rects = r;\n" (span (|@| (class "preprocessor") (id "F:66279")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:66292")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:66310")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:66327")) "/* ") (span (|@| (class "comment") (id "F:66330")) "If we are processing overlapping and allowed to return\n         multiple clipping rectangles, we exclude the row of the glyph\n         string from the clipping rectangle.  This is to avoid drawing\n         the same text on the environment with anti-aliasing.  ") (span (|@| (class "comment-delimiter") (id "F:66569")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:66572")) "#ifdef") " CONVERT_FROM_XRECT\n      " (span (|@| (class "type") (id "F:66604")) "XRectangle") " " (span (|@| (class "variable-name") (id "F:66615")) "rs") "[2];\n" (span (|@| (class "preprocessor") (id "F:66622")) "#else") "\n      " (span (|@| (class "type") (id "F:66634")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:66646")) "rs") " = rects;\n" (span (|@| (class "preprocessor") (id "F:66658")) "#endif") "\n      " (span (|@| (class "type") (id "F:66671")) "int") " " (span (|@| (class "variable-name") (id "F:66675")) "i") " = 0, " (span (|@| (class "variable-name") (id "F:66682")) "row_y") " = WINDOW_TO_FRAME_PIXEL_Y (s->w, s->row->y);\n\n      " (span (|@| (class "keyword") (id "F:66740")) "if") " (s->for_overlaps & OVERLAPS_PRED)\n        {\n          rs[i] = r;\n          " (span (|@| (class "keyword") (id "F:66797")) "if") " (r.y + r.height > row_y)\n            {\n              " (span (|@| (class "keyword") (id "F:66839")) "if") " (r.y < row_y)\n                rs[i].height = row_y - r.y;\n              " (span (|@| (class "keyword") (id "F:66893")) "else") "\n                rs[i].height = 0;\n            }\n          i++;\n        }\n      " (span (|@| (class "keyword") (id "F:66942")) "if") " (s->for_overlaps & OVERLAPS_SUCC)\n        {\n          rs[i] = r;\n          " (span (|@| (class "keyword") (id "F:66999")) "if") " (r.y < row_y + s->row->visible_height)\n            {\n              " (span (|@| (class "keyword") (id "F:67055")) "if") " (r.y + r.height > row_y + s->row->visible_height)\n                {\n                  rs[i].y = row_y + s->row->visible_height;\n                  rs[i].height = r.y + r.height - rs[i].y;\n                }\n              " (span (|@| (class "keyword") (id "F:67214")) "else") "\n                rs[i].height = 0;\n            }\n          i++;\n        }\n\n      n = i;\n" (span (|@| (class "preprocessor") (id "F:67271")) "#ifdef") " CONVERT_FROM_XRECT\n      " (span (|@| (class "keyword") (id "F:67303")) "for") " (i = 0; i < n; i++)\n        CONVERT_FROM_XRECT (rs[i], rects[i]);\n" (span (|@| (class "preprocessor") (id "F:67366")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:67379")) "return") " n;\n    }\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:67398")) "/* ") (span (|@| (class "comment") (id "F:67401")) "EXPORT:\n   Return in *NR the clipping rectangle for glyph string S.  ") (span (|@| (class "comment-delimiter") (id "F:67470")) "*/") "\n\n" (span (|@| (class "type") (id "F:67474")) "void") "\n" (span (|@| (class "function-name") (id "F:67479")) "get_glyph_string_clip_rect") " (s, nr)\n     " (span (|@| (class "keyword") (id "F:67519")) "struct") " " (span (|@| (class "type") (id "F:67526")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:67540")) "s") ";\n     " (span (|@| (class "type") (id "F:67548")) "NativeRectangle") " *" (span (|@| (class "variable-name") (id "F:67565")) "nr") ";\n{\n  get_glyph_string_clip_rects (s, nr, 1);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:67617")) "/* ") (span (|@| (class "comment") (id "F:67620")) "EXPORT:\n   Return the position and height of the phys cursor in window W.\n   Set w->phys_cursor_width to width of phys cursor.\n") (span (|@| (class "comment-delimiter") (id "F:67747")) "*/") "\n\n" (span (|@| (class "type") (id "F:67751")) "void") "\n" (span (|@| (class "function-name") (id "F:67756")) "get_phys_cursor_geometry") " (w, row, " (span (|@| (class "type") (id "F:67790")) "glyph") ", xp, yp, heightp)\n     " (span (|@| (class "keyword") (id "F:67819")) "struct") " " (span (|@| (class "type") (id "F:67826")) "window") " *" (span (|@| (class "variable-name") (id "F:67834")) "w") ";\n     " (span (|@| (class "keyword") (id "F:67842")) "struct") " " (span (|@| (class "type") (id "F:67849")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:67860")) "row") ";\n     " (span (|@| (class "keyword") (id "F:67870")) "struct") " " (span (|@| (class "type") (id "F:67877")) "glyph") " *" (span (|@| (class "variable-name") (id "F:67884")) "glyph") ";\n     " (span (|@| (class "type") (id "F:67896")) "int") " *" (span (|@| (class "variable-name") (id "F:67901")) "xp") ", *" (span (|@| (class "variable-name") (id "F:67906")) "yp") ", *" (span (|@| (class "variable-name") (id "F:67911")) "heightp") ";\n{\n  " (span (|@| (class "keyword") (id "F:67924")) "struct") " " (span (|@| (class "type") (id "F:67931")) "frame") " *" (span (|@| (class "variable-name") (id "F:67938")) "f") " = XFRAME (WINDOW_FRAME (w));\n  " (span (|@| (class "type") (id "F:67971")) "int") " " (span (|@| (class "variable-name") (id "F:67975")) "x") ", " (span (|@| (class "variable-name") (id "F:67978")) "y") ", " (span (|@| (class "variable-name") (id "F:67981")) "wd") ", " (span (|@| (class "variable-name") (id "F:67985")) "h") ", " (span (|@| (class "variable-name") (id "F:67988")) "h0") ", " (span (|@| (class "variable-name") (id "F:67992")) "y0") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:67999")) "/* ") (span (|@| (class "comment") (id "F:68002")) "Compute the width of the rectangle to draw.  If on a stretch\n     glyph, and `x-stretch-block-cursor' is nil, don't draw a\n     rectangle as wide as the glyph, but use a canonical character\n     width instead.  ") (span (|@| (class "comment-delimiter") (id "F:68213")) "*/") "\n  wd = glyph->pixel_width - 1;\n" (span (|@| (class "preprocessor") (id "F:68247")) "#if") " " (span (|@| (class "preprocessor") (id "F:68251")) "defined") "(HAVE_NTGUI) || " (span (|@| (class "preprocessor") (id "F:68274")) "defined") "(HAVE_NS)\n  wd++; " (span (|@| (class "comment-delimiter") (id "F:68299")) "/* ") (span (|@| (class "comment") (id "F:68302")) "Why? ") (span (|@| (class "comment-delimiter") (id "F:68307")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:68310")) "#endif") "\n\n  x = w->phys_cursor.x;\n  " (span (|@| (class "keyword") (id "F:68344")) "if") " (x < 0)\n    {\n      wd += x;\n      x = 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:68398")) "if") " (glyph->type == STRETCH_GLYPH\n      && " (span (|@| (class "negation-char") (id "F:68440")) "!") "x_stretch_cursor_p)\n    wd = min (FRAME_COLUMN_WIDTH (f), wd);\n  w->phys_cursor_width = wd;\n\n  y = w->phys_cursor.y + row->ascent - glyph->ascent;\n\n  " (span (|@| (class "comment-delimiter") (id "F:68591")) "/* ") (span (|@| (class "comment") (id "F:68594")) "If y is below window bottom, ensure that we still see a cursor.  ") (span (|@| (class "comment-delimiter") (id "F:68659")) "*/") "\n  h0 = min (FRAME_LINE_HEIGHT (f), row->visible_height);\n\n  h = max (h0, glyph->ascent + glyph->descent);\n  h0 = min (h0, glyph->ascent + glyph->descent);\n\n  y0 = WINDOW_HEADER_LINE_HEIGHT (w);\n  " (span (|@| (class "keyword") (id "F:68858")) "if") " (y < y0)\n    {\n      h = max (h - (y0 - y) + 1, h0);\n      y = y0 - 1;\n    }\n  " (span (|@| (class "keyword") (id "F:68940")) "else") "\n    {\n      y0 = window_text_bottom_y (w) - h0;\n      " (span (|@| (class "keyword") (id "F:68999")) "if") " (y > y0)\n        {\n          h += y - y0;\n          y = y0;\n        }\n    }\n\n  *xp = WINDOW_TEXT_TO_FRAME_PIXEL_X (w, x);\n  *yp = WINDOW_TO_FRAME_PIXEL_Y (w, y);\n  *heightp = h;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:69155")) "/*") (span (|@| (class "comment") (id "F:69157")) "\n * Remember which glyph the mouse is over.\n ") (span (|@| (class "comment-delimiter") (id "F:69202")) "*/") "\n\n" (span (|@| (class "type") (id "F:69206")) "void") "\n" (span (|@| (class "function-name") (id "F:69211")) "remember_mouse_glyph") " (f, gx, gy, rect)\n     " (span (|@| (class "keyword") (id "F:69255")) "struct") " " (span (|@| (class "type") (id "F:69262")) "frame") " *" (span (|@| (class "variable-name") (id "F:69269")) "f") ";\n     " (span (|@| (class "type") (id "F:69277")) "int") " " (span (|@| (class "variable-name") (id "F:69281")) "gx") ", " (span (|@| (class "variable-name") (id "F:69285")) "gy") ";\n     " (span (|@| (class "type") (id "F:69294")) "NativeRectangle") " *" (span (|@| (class "variable-name") (id "F:69311")) "rect") ";\n{\n  " (span (|@| (class "type") (id "F:69321")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:69333")) "window") ";\n  " (span (|@| (class "keyword") (id "F:69343")) "struct") " " (span (|@| (class "type") (id "F:69350")) "window") " *" (span (|@| (class "variable-name") (id "F:69358")) "w") ";\n  " (span (|@| (class "keyword") (id "F:69363")) "struct") " " (span (|@| (class "type") (id "F:69370")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:69381")) "r") ", *" (span (|@| (class "variable-name") (id "F:69385")) "gr") ", *" (span (|@| (class "variable-name") (id "F:69390")) "end_row") ";\n  " (span (|@| (class "keyword") (id "F:69401")) "enum") " " (span (|@| (class "type") (id "F:69406")) "window_part") " " (span (|@| (class "variable-name") (id "F:69418")) "part") ";\n  " (span (|@| (class "keyword") (id "F:69426")) "enum") " " (span (|@| (class "type") (id "F:69431")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:69446")) "area") ";\n  " (span (|@| (class "type") (id "F:69454")) "int") " " (span (|@| (class "variable-name") (id "F:69458")) "x") ", " (span (|@| (class "variable-name") (id "F:69461")) "y") ", " (span (|@| (class "variable-name") (id "F:69464")) "width") ", " (span (|@| (class "variable-name") (id "F:69471")) "height") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:69482")) "/* ") (span (|@| (class "comment") (id "F:69485")) "Try to determine frame pixel position and size of the glyph under\n     frame pixel coordinates X/Y on frame F.  ") (span (|@| (class "comment-delimiter") (id "F:69597")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:69603")) "if") " (" (span (|@| (class "negation-char") (id "F:69607")) "!") "f->glyphs_initialized_p\n      || (window = window_from_coordinates (f, gx, gy, &part, &x, &y, 0),\n          NILP (window)))\n    {\n      width = FRAME_SMALLEST_CHAR_WIDTH (f);\n      height = FRAME_SMALLEST_FONT_HEIGHT (f);\n      " (span (|@| (class "keyword") (id "F:69829")) "goto") " " (span (|@| (class "constant") (id "F:69834")) "virtual_glyph") ";\n    }\n\n  w = XWINDOW (window);\n  width = WINDOW_FRAME_COLUMN_WIDTH (w);\n  height = WINDOW_FRAME_LINE_HEIGHT (w);\n\n  r = MATRIX_FIRST_TEXT_ROW (w->current_matrix);\n  end_row = MATRIX_BOTTOM_TEXT_ROW (w->current_matrix, w);\n\n  " (span (|@| (class "keyword") (id "F:70074")) "if") " (w->pseudo_window_p)\n    {\n      area = TEXT_AREA;\n      part = ON_MODE_LINE; " (span (|@| (class "comment-delimiter") (id "F:70155")) "/* ") (span (|@| (class "comment") (id "F:70158")) "Don't adjust margin. ") (span (|@| (class "comment-delimiter") (id "F:70179")) "*/") "\n      " (span (|@| (class "keyword") (id "F:70188")) "goto") " " (span (|@| (class "constant") (id "F:70193")) "text_glyph") ";\n    }\n\n  " (span (|@| (class "keyword") (id "F:70214")) "switch") " (part)\n    {\n    " (span (|@| (class "keyword") (id "F:70238")) "case") " ON_LEFT_MARGIN:\n      area = LEFT_MARGIN_AREA;\n      " (span (|@| (class "keyword") (id "F:70296")) "goto") " " (span (|@| (class "constant") (id "F:70301")) "text_glyph") ";\n\n    " (span (|@| (class "keyword") (id "F:70318")) "case") " ON_RIGHT_MARGIN:\n      area = RIGHT_MARGIN_AREA;\n      " (span (|@| (class "keyword") (id "F:70378")) "goto") " " (span (|@| (class "constant") (id "F:70383")) "text_glyph") ";\n\n    " (span (|@| (class "keyword") (id "F:70400")) "case") " ON_HEADER_LINE:\n    " (span (|@| (class "keyword") (id "F:70425")) "case") " ON_MODE_LINE:\n      gr = (part == ON_HEADER_LINE\n            ? MATRIX_HEADER_LINE_ROW (w->current_matrix)\n            : MATRIX_MODE_LINE_ROW (w->current_matrix));\n      gy = gr->y;\n      area = TEXT_AREA;\n      " (span (|@| (class "keyword") (id "F:70627")) "goto") " " (span (|@| (class "constant") (id "F:70632")) "text_glyph_row_found") ";\n\n    " (span (|@| (class "keyword") (id "F:70659")) "case") " ON_TEXT:\n      area = TEXT_AREA;\n\n    " (span (|@| (class "constant") (id "F:70702")) "text_glyph") ":\n      gr = 0; gy = 0;\n      " (span (|@| (class "keyword") (id "F:70742")) "for") " (; r <= end_row && r->enabled_p; ++r)\n        " (span (|@| (class "keyword") (id "F:70785")) "if") " (r->y + r->height > y)\n          {\n            gr = r; gy = r->y;\n            " (span (|@| (class "keyword") (id "F:70845")) "break") ";\n          }\n\n    " (span (|@| (class "constant") (id "F:70862")) "text_glyph_row_found") ":\n      " (span (|@| (class "keyword") (id "F:70890")) "if") " (gr && gy <= y)\n        {\n          " (span (|@| (class "keyword") (id "F:70915")) "struct") " " (span (|@| (class "type") (id "F:70922")) "glyph") " *" (span (|@| (class "variable-name") (id "F:70929")) "g") " = gr->glyphs[area];\n          " (span (|@| (class "keyword") (id "F:70954")) "struct") " " (span (|@| (class "type") (id "F:70961")) "glyph") " *" (span (|@| (class "variable-name") (id "F:70968")) "end") " = g + gr->used[area];\n\n          height = gr->height;\n          " (span (|@| (class "keyword") (id "F:71022")) "for") " (gx = gr->x; g < end; gx += g->pixel_width, ++g)\n            " (span (|@| (class "keyword") (id "F:71080")) "if") " (gx + g->pixel_width > x)\n              " (span (|@| (class "keyword") (id "F:71116")) "break") ";\n\n          " (span (|@| (class "keyword") (id "F:71127")) "if") " (g < end)\n            {\n              " (span (|@| (class "keyword") (id "F:71154")) "if") " (g->type == IMAGE_GLYPH)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:71190")) "/* ") (span (|@| (class "comment") (id "F:71193")) "Don't remember when mouse is over image, as\n                     image may have hot-spots.  ") (span (|@| (class "comment-delimiter") (id "F:71271")) "*/") "\n                  STORE_NATIVE_RECT (*rect, 0, 0, 0, 0);\n                  " (span (|@| (class "keyword") (id "F:71321")) "return") ";\n                }\n              width = g->pixel_width;\n            }\n          " (span (|@| (class "keyword") (id "F:71374")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:71393")) "/* ") (span (|@| (class "comment") (id "F:71396")) "Use nominal char spacing at end of line.  ") (span (|@| (class "comment-delimiter") (id "F:71438")) "*/") "\n              x -= gx;\n              gx += (x / width) * width;\n            }\n\n          " (span (|@| (class "keyword") (id "F:71502")) "if") " (part != ON_MODE_LINE && part != ON_HEADER_LINE)\n            gx += window_box_left_offset (w, area);\n        }\n      " (span (|@| (class "keyword") (id "F:71608")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:71619")) "/* ") (span (|@| (class "comment") (id "F:71622")) "Use nominal line height at end of window.  ") (span (|@| (class "comment-delimiter") (id "F:71665")) "*/") "\n          gx = (x / width) * width;\n          y -= gy;\n          gy += (y / height) * height;\n        }\n      " (span (|@| (class "keyword") (id "F:71750")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:71762")) "case") " ON_LEFT_FRINGE:\n      gx = (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)\n            ? WINDOW_LEFT_SCROLL_BAR_AREA_WIDTH (w)\n            : window_box_right_offset (w, LEFT_MARGIN_AREA));\n      width = WINDOW_LEFT_FRINGE_WIDTH (w);\n      " (span (|@| (class "keyword") (id "F:71984")) "goto") " " (span (|@| (class "constant") (id "F:71989")) "row_glyph") ";\n\n    " (span (|@| (class "keyword") (id "F:72005")) "case") " ON_RIGHT_FRINGE:\n      gx = (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)\n            ? window_box_right_offset (w, RIGHT_MARGIN_AREA)\n            : window_box_right_offset (w, TEXT_AREA));\n      width = WINDOW_RIGHT_FRINGE_WIDTH (w);\n      " (span (|@| (class "keyword") (id "F:72231")) "goto") " " (span (|@| (class "constant") (id "F:72236")) "row_glyph") ";\n\n    " (span (|@| (class "keyword") (id "F:72252")) "case") " ON_SCROLL_BAR:\n      gx = (WINDOW_HAS_VERTICAL_SCROLL_BAR_ON_LEFT (w)\n            ? 0\n            : (window_box_right_offset (w, RIGHT_MARGIN_AREA)\n               + (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)\n                  ? WINDOW_RIGHT_FRINGE_WIDTH (w)\n                  : 0)));\n      width = WINDOW_SCROLL_BAR_AREA_WIDTH (w);\n\n    " (span (|@| (class "constant") (id "F:72542")) "row_glyph") ":\n      gr = 0, gy = 0;\n      " (span (|@| (class "keyword") (id "F:72581")) "for") " (; r <= end_row && r->enabled_p; ++r)\n        " (span (|@| (class "keyword") (id "F:72624")) "if") " (r->y + r->height > y)\n          {\n            gr = r; gy = r->y;\n            " (span (|@| (class "keyword") (id "F:72684")) "break") ";\n          }\n\n      " (span (|@| (class "keyword") (id "F:72703")) "if") " (gr && gy <= y)\n        height = gr->height;\n      " (span (|@| (class "keyword") (id "F:72750")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:72761")) "/* ") (span (|@| (class "comment") (id "F:72764")) "Use nominal line height at end of window.  ") (span (|@| (class "comment-delimiter") (id "F:72807")) "*/") "\n          y -= gy;\n          gy += (y / height) * height;\n        }\n      " (span (|@| (class "keyword") (id "F:72863")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:72875")) "default") ":\n      ;\n    " (span (|@| (class "constant") (id "F:72896")) "virtual_glyph") ":\n      " (span (|@| (class "comment-delimiter") (id "F:72917")) "/* ") (span (|@| (class "comment") (id "F:72920")) "If there is no glyph under the mouse, then we divide the screen\n         into a grid of the smallest glyph in the frame, and use that\n         as our \"glyph\".  ") (span (|@| (class "comment-delimiter") (id "F:73066")) "*/") "\n\n      " (span (|@| (class "comment-delimiter") (id "F:73076")) "/* ") (span (|@| (class "comment") (id "F:73079")) "Arrange for the division in FRAME_PIXEL_X_TO_COL etc. to\n         round down even for negative values.  ") (span (|@| (class "comment-delimiter") (id "F:73176")) "*/") "\n      " (span (|@| (class "keyword") (id "F:73185")) "if") " (gx < 0)\n        gx -= width - 1;\n      " (span (|@| (class "keyword") (id "F:73221")) "if") " (gy < 0)\n        gy -= height - 1;\n\n      gx = (gx / width) * width;\n      gy = (gy / height) * height;\n\n      " (span (|@| (class "keyword") (id "F:73328")) "goto") " " (span (|@| (class "constant") (id "F:73333")) "store_rect") ";\n    }\n\n  gx += WINDOW_LEFT_EDGE_X (w);\n  gy += WINDOW_TOP_EDGE_Y (w);\n\n " (span (|@| (class "constant") (id "F:73417")) "store_rect") ":\n  STORE_NATIVE_RECT (*rect, gx, gy, width, height);\n\n  " (span (|@| (class "comment-delimiter") (id "F:73484")) "/* ") (span (|@| (class "comment") (id "F:73487")) "Visible feedback for debugging.  ") (span (|@| (class "comment-delimiter") (id "F:73520")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:73523")) "#if") " 0\n" (span (|@| (class "preprocessor") (id "F:73529")) "#if") " HAVE_X_WINDOWS\n  XDrawRectangle (FRAME_X_DISPLAY (f), FRAME_X_WINDOW (f),\n                  f->output_data.x->normal_gc,\n                  gx, gy, width, height);\n" (span (|@| (class "preprocessor") (id "F:73668")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:73675")) "#endif") "\n}\n\n\n" (span (|@| (class "preprocessor") (id "F:73686")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:73693")) "/* ") (span (|@| (class "comment") (id "F:73696")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:73715")) "*/") "\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:73721")) "/***********************************************************************") (span (|@| (class "comment") (id "F:73793")) "\n                        Lisp form evaluation\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:73889")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:73893")) "/* ") (span (|@| (class "comment") (id "F:73896")) "Error handler for safe_eval and safe_call.  ") (span (|@| (class "comment-delimiter") (id "F:73940")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:73944")) "static") " " (span (|@| (class "type") (id "F:73951")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:73963")) "safe_eval_handler") " (arg)\n     " (span (|@| (class "type") (id "F:73992")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:74004")) "arg") ";\n{\n  add_to_log (" (span (|@| (class "string") (id "F:74025")) "\"Error during redisplay: %s\"") ", arg, Qnil);\n  " (span (|@| (class "keyword") (id "F:74069")) "return") " Qnil;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:74086")) "/* ") (span (|@| (class "comment") (id "F:74089")) "Evaluate SEXPR and return the result, or nil if something went\n   wrong.  Prevent redisplay during the evaluation.  ") (span (|@| (class "comment-delimiter") (id "F:74205")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:74209")) "/* ") (span (|@| (class "comment") (id "F:74212")) "Call function ARGS[0] with arguments ARGS[1] to ARGS[NARGS - 1].\n   Return the result, or nil if something went wrong.  Prevent\n   redisplay during the evaluation.  ") (span (|@| (class "comment-delimiter") (id "F:74377")) "*/") "\n\n" (span (|@| (class "type") (id "F:74381")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:74393")) "safe_call") " (nargs, args)\n     " (span (|@| (class "type") (id "F:74422")) "int") " " (span (|@| (class "variable-name") (id "F:74426")) "nargs") ";\n     " (span (|@| (class "type") (id "F:74438")) "Lisp_Object") " *" (span (|@| (class "variable-name") (id "F:74451")) "args") ";\n{\n  " (span (|@| (class "type") (id "F:74461")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:74473")) "val") ";\n\n  " (span (|@| (class "keyword") (id "F:74481")) "if") " (inhibit_eval_during_redisplay)\n    val = Qnil;\n  " (span (|@| (class "keyword") (id "F:74534")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:74551")) "int") " " (span (|@| (class "variable-name") (id "F:74555")) "count") " = SPECPDL_INDEX ();\n      " (span (|@| (class "keyword") (id "F:74587")) "struct") " " (span (|@| (class "type") (id "F:74594")) "gcpro") " " (span (|@| (class "variable-name") (id "F:74600")) "gcpro1") ";\n\n      GCPRO1 (args[0]);\n      gcpro1.nvars = nargs;\n      specbind (Qinhibit_redisplay, Qt);\n      " (span (|@| (class "comment-delimiter") (id "F:74708")) "/* ") (span (|@| (class "comment") (id "F:74711")) "Use Qt to ensure debugger does not run,\n         so there is no possibility of wanting to redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:74806")) "*/") "\n      val = internal_condition_case_n (Ffuncall, nargs, args, Qt,\n                                       safe_eval_handler);\n      UNGCPRO;\n      val = unbind_to (count, val);\n    }\n\n  " (span (|@| (class "keyword") (id "F:74966")) "return") " val;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:74982")) "/* ") (span (|@| (class "comment") (id "F:74985")) "Call function FN with one argument ARG.\n   Return the result, or nil if something went wrong.  ") (span (|@| (class "comment-delimiter") (id "F:75080")) "*/") "\n\n" (span (|@| (class "type") (id "F:75084")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:75096")) "safe_call1") " (fn, arg)\n     " (span (|@| (class "type") (id "F:75122")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:75134")) "fn") ", " (span (|@| (class "variable-name") (id "F:75138")) "arg") ";\n{\n  " (span (|@| (class "type") (id "F:75147")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:75159")) "args") "[2];\n  args[0] = fn;\n  args[1] = arg;\n  " (span (|@| (class "keyword") (id "F:75203")) "return") " safe_call (2, args);\n}\n\n" (span (|@| (class "keyword") (id "F:75234")) "static") " " (span (|@| (class "type") (id "F:75241")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:75253")) "Qeval") ";\n\n" (span (|@| (class "type") (id "F:75261")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:75273")) "safe_eval") " (" (span (|@| (class "type") (id "F:75284")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:75296")) "sexpr") ")\n{\n  " (span (|@| (class "keyword") (id "F:75307")) "return") " safe_call1 (Qeval, sexpr);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:75344")) "/* ") (span (|@| (class "comment") (id "F:75347")) "Call function FN with one argument ARG.\n   Return the result, or nil if something went wrong.  ") (span (|@| (class "comment-delimiter") (id "F:75442")) "*/") "\n\n" (span (|@| (class "type") (id "F:75446")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:75458")) "safe_call2") " (" (span (|@| (class "type") (id "F:75470")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:75482")) "fn") ", " (span (|@| (class "type") (id "F:75486")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:75498")) "arg1") ", " (span (|@| (class "type") (id "F:75504")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:75516")) "arg2") ")\n{\n  " (span (|@| (class "type") (id "F:75526")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:75538")) "args") "[3];\n  args[0] = fn;\n  args[1] = arg1;\n  args[2] = arg2;\n  " (span (|@| (class "keyword") (id "F:75601")) "return") " safe_call (3, args);\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:75635")) "/***********************************************************************") (span (|@| (class "comment") (id "F:75707")) "\n                              Debugging\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:75798")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:75802")) "#if") " 0\n\n" (span (|@| (class "comment-delimiter") (id "F:75809")) "/* ") (span (|@| (class "comment") (id "F:75812")) "Define CHECK_IT to perform sanity checks on iterators.\n   This is for debugging.  It is too slow to do unconditionally.  ") (span (|@| (class "comment-delimiter") (id "F:75933")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:75937")) "static") " " (span (|@| (class "type") (id "F:75944")) "void") "\n" (span (|@| (class "function-name") (id "F:75949")) "check_it") " (" (span (|@| (class "type") (id "F:75959")) "it") ")\n     " (span (|@| (class "keyword") (id "F:75968")) "struct") " " (span (|@| (class "type") (id "F:75975")) "it") " *" (span (|@| (class "variable-name") (id "F:75979")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:75987")) "if") " (it->method == GET_FROM_STRING)\n    {\n      xassert (STRINGP (it->string));\n      xassert (IT_STRING_CHARPOS (*it) >= 0);\n    }\n  " (span (|@| (class "keyword") (id "F:76120")) "else") "\n    {\n      xassert (IT_STRING_CHARPOS (*it) < 0);\n      " (span (|@| (class "keyword") (id "F:76182")) "if") " (it->method == GET_FROM_BUFFER)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:76223")) "/* ") (span (|@| (class "comment") (id "F:76226")) "Check that character and byte positions agree.  ") (span (|@| (class "comment-delimiter") (id "F:76274")) "*/") "\n          xassert (IT_CHARPOS (*it) == BYTE_TO_CHAR (IT_BYTEPOS (*it)));\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:76355")) "if") " (it->dpvec)\n    xassert (it->current.dpvec_index >= 0);\n  " (span (|@| (class "keyword") (id "F:76416")) "else") "\n    xassert (it->current.dpvec_index < 0);\n}\n\n" (span (|@| (class "preprocessor") (id "F:76467")) "#define") " " (span (|@| (class "function-name") (id "F:76475")) "CHECK_IT") "(" (span (|@| (class "variable-name") (id "F:76484")) "IT") ")    check_it ((IT))\n\n" (span (|@| (class "preprocessor") (id "F:76505")) "#else") " " (span (|@| (class "comment-delimiter") (id "F:76511")) "/* ") (span (|@| (class "comment") (id "F:76514")) "not 0 ") (span (|@| (class "comment-delimiter") (id "F:76520")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:76524")) "#define") " " (span (|@| (class "function-name") (id "F:76532")) "CHECK_IT") "(" (span (|@| (class "variable-name") (id "F:76541")) "IT") ")    (" (span (|@| (class "type") (id "F:76546")) "void") ") 0\n\n" (span (|@| (class "preprocessor") (id "F:76555")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:76562")) "/* ") (span (|@| (class "comment") (id "F:76565")) "not 0 ") (span (|@| (class "comment-delimiter") (id "F:76571")) "*/") "\n\n\n" (span (|@| (class "preprocessor") (id "F:76576")) "#if") " GLYPH_DEBUG\n\n" (span (|@| (class "comment-delimiter") (id "F:76593")) "/* ") (span (|@| (class "comment") (id "F:76596")) "Check that the window end of window W is what we expect it\n   to be---the last row in the current matrix displaying text.  ") (span (|@| (class "comment-delimiter") (id "F:76719")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:76723")) "static") " " (span (|@| (class "type") (id "F:76730")) "void") "\n" (span (|@| (class "function-name") (id "F:76735")) "check_window_end") " (w)\n     " (span (|@| (class "keyword") (id "F:76761")) "struct") " " (span (|@| (class "type") (id "F:76768")) "window") " *" (span (|@| (class "variable-name") (id "F:76776")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:76783")) "if") " (" (span (|@| (class "negation-char") (id "F:76787")) "!") "MINI_WINDOW_P (w)\n      && " (span (|@| (class "negation-char") (id "F:76815")) "!") "NILP (w->window_end_valid))\n    {\n      " (span (|@| (class "keyword") (id "F:76856")) "struct") " " (span (|@| (class "type") (id "F:76863")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:76874")) "row") ";\n      xassert ((row = MATRIX_ROW (w->current_matrix,\n                                  XFASTINT (w->window_end_vpos)),\n                " (span (|@| (class "negation-char") (id "F:76972")) "!") "row->enabled_p\n                || MATRIX_ROW_DISPLAYS_TEXT_P (row)\n                || MATRIX_ROW_VPOS (row, w->current_matrix) == 0));\n    }\n}\n\n" (span (|@| (class "preprocessor") (id "F:77089")) "#define") " " (span (|@| (class "function-name") (id "F:77097")) "CHECK_WINDOW_END") "(" (span (|@| (class "variable-name") (id "F:77114")) "W") ")     check_window_end ((W))\n\n" (span (|@| (class "preprocessor") (id "F:77141")) "#else") " " (span (|@| (class "comment-delimiter") (id "F:77147")) "/* ") (span (|@| (class "comment") (id "F:77150")) "not GLYPH_DEBUG ") (span (|@| (class "comment-delimiter") (id "F:77166")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:77170")) "#define") " " (span (|@| (class "function-name") (id "F:77178")) "CHECK_WINDOW_END") "(" (span (|@| (class "variable-name") (id "F:77195")) "W") ")     (" (span (|@| (class "type") (id "F:77199")) "void") ") 0\n\n" (span (|@| (class "preprocessor") (id "F:77208")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:77215")) "/* ") (span (|@| (class "comment") (id "F:77218")) "not GLYPH_DEBUG ") (span (|@| (class "comment-delimiter") (id "F:77234")) "*/") "\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:77241")) "/***********************************************************************") (span (|@| (class "comment") (id "F:77313")) "\n                       Iterator initialization\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:77418")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:77422")) "/* ") (span (|@| (class "comment") (id "F:77425")) "Initialize IT for displaying current_buffer in window W, starting\n   at character position CHARPOS.  CHARPOS < 0 means that no buffer\n   position is specified which is useful when the iterator is assigned\n   a position later.  BYTEPOS is the byte position corresponding to\n   CHARPOS.  BYTEPOS < 0 means compute it from CHARPOS.\n\n   If ROW is not null, calls to produce_glyphs with IT as parameter\n   will produce glyphs in that row.\n\n   BASE_FACE_ID is the id of a base face to use.  It must be one of\n   DEFAULT_FACE_ID for normal text, MODE_LINE_FACE_ID,\n   MODE_LINE_INACTIVE_FACE_ID, or HEADER_LINE_FACE_ID for displaying\n   mode lines, or TOOL_BAR_FACE_ID for displaying the tool-bar.\n\n   If ROW is null and BASE_FACE_ID is equal to MODE_LINE_FACE_ID,\n   MODE_LINE_INACTIVE_FACE_ID, or HEADER_LINE_FACE_ID, the iterator\n   will be initialized to use the corresponding mode line glyph row of\n   the desired matrix of W.  ") (span (|@| (class "comment-delimiter") (id "F:78351")) "*/") "\n\n" (span (|@| (class "type") (id "F:78355")) "void") "\n" (span (|@| (class "function-name") (id "F:78360")) "init_iterator") " (" (span (|@| (class "type") (id "F:78375")) "it") ", w, charpos, bytepos, row, base_face_id)\n     " (span (|@| (class "keyword") (id "F:78424")) "struct") " " (span (|@| (class "type") (id "F:78431")) "it") " *" (span (|@| (class "variable-name") (id "F:78435")) "it") ";\n     " (span (|@| (class "keyword") (id "F:78444")) "struct") " " (span (|@| (class "type") (id "F:78451")) "window") " *" (span (|@| (class "variable-name") (id "F:78459")) "w") ";\n     " (span (|@| (class "type") (id "F:78467")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:78477")) "charpos") ", " (span (|@| (class "variable-name") (id "F:78486")) "bytepos") ";\n     " (span (|@| (class "keyword") (id "F:78500")) "struct") " " (span (|@| (class "type") (id "F:78507")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:78518")) "row") ";\n     " (span (|@| (class "keyword") (id "F:78528")) "enum") " " (span (|@| (class "type") (id "F:78533")) "face_id") " " (span (|@| (class "variable-name") (id "F:78541")) "base_face_id") ";\n{\n  " (span (|@| (class "type") (id "F:78559")) "int") " " (span (|@| (class "variable-name") (id "F:78563")) "highlight_region_p") ";\n  " (span (|@| (class "keyword") (id "F:78585")) "enum") " " (span (|@| (class "type") (id "F:78590")) "face_id") " " (span (|@| (class "variable-name") (id "F:78598")) "remapped_base_face_id") " = base_face_id;\n\n  " (span (|@| (class "comment-delimiter") (id "F:78639")) "/* ") (span (|@| (class "comment") (id "F:78642")) "Some precondition checks.  ") (span (|@| (class "comment-delimiter") (id "F:78669")) "*/") "\n  xassert (w != " (span (|@| (class "constant") (id "F:78688")) "NULL") " && it != " (span (|@| (class "constant") (id "F:78702")) "NULL") ");\n  xassert (charpos < 0 || (charpos >= BUF_BEG (current_buffer)\n                           && charpos <= ZV));\n\n  " (span (|@| (class "comment-delimiter") (id "F:78801")) "/* ") (span (|@| (class "comment") (id "F:78804")) "If face attributes have been changed since the last redisplay,\n     free realized faces now because they depend on face definitions\n     that might have changed.  Don't free faces while there might be\n     desired matrices pending which reference these faces.  ") (span (|@| (class "comment-delimiter") (id "F:79065")) "*/") "\n  " (span (|@| (class "keyword") (id "F:79070")) "if") " (face_change_count && " (span (|@| (class "negation-char") (id "F:79095")) "!") "inhibit_free_realized_faces)\n    {\n      face_change_count = 0;\n      free_all_realized_faces (Qnil);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:79207")) "/* ") (span (|@| (class "comment") (id "F:79210")) "Perhaps remap BASE_FACE_ID to a user-specified alternative.  ") (span (|@| (class "comment-delimiter") (id "F:79271")) "*/") "\n  " (span (|@| (class "keyword") (id "F:79276")) "if") " (" (span (|@| (class "negation-char") (id "F:79280")) "!") " NILP (Vface_remapping_alist))\n    remapped_base_face_id = lookup_basic_face (XFRAME (w->frame), base_face_id);\n\n  " (span (|@| (class "comment-delimiter") (id "F:79396")) "/* ") (span (|@| (class "comment") (id "F:79399")) "Use one of the mode line rows of W's desired matrix if\n     appropriate.  ") (span (|@| (class "comment-delimiter") (id "F:79473")) "*/") "\n  " (span (|@| (class "keyword") (id "F:79478")) "if") " (row == " (span (|@| (class "constant") (id "F:79489")) "NULL") ")\n    {\n      " (span (|@| (class "keyword") (id "F:79507")) "if") " (base_face_id == MODE_LINE_FACE_ID\n          || base_face_id == MODE_LINE_INACTIVE_FACE_ID)\n        row = MATRIX_MODE_LINE_ROW (w->desired_matrix);\n      " (span (|@| (class "keyword") (id "F:79650")) "else") " " (span (|@| (class "keyword") (id "F:79655")) "if") " (base_face_id == HEADER_LINE_FACE_ID)\n        row = MATRIX_HEADER_LINE_ROW (w->desired_matrix);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:79756")) "/* ") (span (|@| (class "comment") (id "F:79759")) "Clear IT.  ") (span (|@| (class "comment-delimiter") (id "F:79770")) "*/") "\n  bzero (it, " (span (|@| (class "keyword") (id "F:79786")) "sizeof") " *it);\n  it->current.overlay_string_index = -1;\n  it->current.dpvec_index = -1;\n  it->base_face_id = remapped_base_face_id;\n  it->string = Qnil;\n  IT_STRING_CHARPOS (*it) = IT_STRING_BYTEPOS (*it) = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:79998")) "/* ") (span (|@| (class "comment") (id "F:80001")) "The window in which we iterate over current_buffer:  ") (span (|@| (class "comment-delimiter") (id "F:80054")) "*/") "\n  XSETWINDOW (it->window, w);\n  it->w = w;\n  it->f = XFRAME (w->frame);\n\n  it->cmp_it.id = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:80155")) "/* ") (span (|@| (class "comment") (id "F:80158")) "Extra space between lines (on window systems only).  ") (span (|@| (class "comment-delimiter") (id "F:80211")) "*/") "\n  " (span (|@| (class "keyword") (id "F:80216")) "if") " (base_face_id == DEFAULT_FACE_ID\n      && FRAME_WINDOW_P (it->f))\n    {\n      " (span (|@| (class "keyword") (id "F:80297")) "if") " (NATNUMP (current_buffer->extra_line_spacing))\n        it->extra_line_spacing = XFASTINT (current_buffer->extra_line_spacing);\n      " (span (|@| (class "keyword") (id "F:80426")) "else") " " (span (|@| (class "keyword") (id "F:80431")) "if") " (FLOATP (current_buffer->extra_line_spacing))\n        it->extra_line_spacing = (XFLOAT_DATA (current_buffer->extra_line_spacing)\n                                  * FRAME_LINE_HEIGHT (it->f));\n      " (span (|@| (class "keyword") (id "F:80598")) "else") " " (span (|@| (class "keyword") (id "F:80603")) "if") " (it->f->extra_line_spacing > 0)\n        it->extra_line_spacing = it->f->extra_line_spacing;\n      it->max_extra_line_spacing = 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:80738")) "/* ") (span (|@| (class "comment") (id "F:80741")) "If realized faces have been removed, e.g. because of face\n     attribute changes of named faces, recompute them.  When running\n     in batch mode, the face cache of the initial frame is null.  If\n     we happen to get called, make a dummy face cache.  ") (span (|@| (class "comment-delimiter") (id "F:80993")) "*/") "\n  " (span (|@| (class "keyword") (id "F:80998")) "if") " (FRAME_FACE_CACHE (it->f) == " (span (|@| (class "constant") (id "F:81030")) "NULL") ")\n    init_frame_faces (it->f);\n  " (span (|@| (class "keyword") (id "F:81068")) "if") " (FRAME_FACE_CACHE (it->f)->used == 0)\n    recompute_basic_faces (it->f);\n\n  " (span (|@| (class "comment-delimiter") (id "F:81147")) "/* ") (span (|@| (class "comment") (id "F:81150")) "Current value of the `slice', `space-width', and 'height' properties.  ") (span (|@| (class "comment-delimiter") (id "F:81221")) "*/") "\n  it->slice.x = it->slice.y = it->slice.width = it->slice.height = Qnil;\n  it->space_width = Qnil;\n  it->font_height = Qnil;\n  it->override_ascent = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:81380")) "/* ") (span (|@| (class "comment") (id "F:81383")) "Are control characters displayed as `^C'?  ") (span (|@| (class "comment-delimiter") (id "F:81426")) "*/") "\n  it->ctl_arrow_p = " (span (|@| (class "negation-char") (id "F:81449")) "!") "NILP (current_buffer->ctl_arrow);\n\n  " (span (|@| (class "comment-delimiter") (id "F:81487")) "/* ") (span (|@| (class "comment") (id "F:81490")) "-1 means everything between a CR and the following line end\n     is invisible.  >0 means lines indented more than this value are\n     invisible.  ") (span (|@| (class "comment-delimiter") (id "F:81636")) "*/") "\n  it->selective = (INTEGERP (current_buffer->selective_display)\n                   ? XFASTINT (current_buffer->selective_display)\n                   : (" (span (|@| (class "negation-char") (id "F:81763")) "!") "NILP (current_buffer->selective_display)\n                      ? -1 : 0));\n  it->selective_display_ellipsis_p\n    = " (span (|@| (class "negation-char") (id "F:81866")) "!") "NILP (current_buffer->selective_display_ellipses);\n\n  " (span (|@| (class "comment-delimiter") (id "F:81921")) "/* ") (span (|@| (class "comment") (id "F:81924")) "Display table to use.  ") (span (|@| (class "comment-delimiter") (id "F:81947")) "*/") "\n  it->dp = window_display_table (w);\n\n  " (span (|@| (class "comment-delimiter") (id "F:81990")) "/* ") (span (|@| (class "comment") (id "F:81993")) "Are multibyte characters enabled in current_buffer?  ") (span (|@| (class "comment-delimiter") (id "F:82046")) "*/") "\n  it->multibyte_p = " (span (|@| (class "negation-char") (id "F:82069")) "!") "NILP (current_buffer->enable_multibyte_characters);\n\n  " (span (|@| (class "comment-delimiter") (id "F:82125")) "/* ") (span (|@| (class "comment") (id "F:82128")) "Do we need to reorder bidirectional text?  Not if this is a\n     unibyte buffer: by definition, none of the single-byte characters\n     are strong R2L, so no reordering is needed.  And bidi.c doesn't\n     support unibyte buffers anyway.  ") (span (|@| (class "comment-delimiter") (id "F:82366")) "*/") "\n  it->bidi_p\n    = " (span (|@| (class "negation-char") (id "F:82388")) "!") "NILP (current_buffer->bidi_display_reordering) && it->multibyte_p;\n\n  " (span (|@| (class "comment-delimiter") (id "F:82459")) "/* ") (span (|@| (class "comment") (id "F:82462")) "Non-zero if we should highlight the region.  ") (span (|@| (class "comment-delimiter") (id "F:82507")) "*/") "\n  highlight_region_p\n    = (" (span (|@| (class "negation-char") (id "F:82538")) "!") "NILP (Vtransient_mark_mode)\n       && " (span (|@| (class "negation-char") (id "F:82577")) "!") "NILP (current_buffer->mark_active)\n       && XMARKER (current_buffer->mark)->buffer != 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:82672")) "/* ") (span (|@| (class "comment") (id "F:82675")) "Set IT->region_beg_charpos and IT->region_end_charpos to the\n     start and end of a visible region in window IT->w.  Set both to\n     -1 to indicate no region.  ") (span (|@| (class "comment-delimiter") (id "F:82837")) "*/") "\n  " (span (|@| (class "keyword") (id "F:82842")) "if") " (highlight_region_p\n      " (span (|@| (class "comment-delimiter") (id "F:82871")) "/* ") (span (|@| (class "comment") (id "F:82874")) "Maybe highlight only in selected window.  ") (span (|@| (class "comment-delimiter") (id "F:82916")) "*/") "\n      && (" (span (|@| (class "comment-delimiter") (id "F:82929")) "/* ") (span (|@| (class "comment") (id "F:82932")) "Either show region everywhere.  ") (span (|@| (class "comment-delimiter") (id "F:82964")) "*/") "\n          highlight_nonselected_windows\n          " (span (|@| (class "comment-delimiter") (id "F:83003")) "/* ") (span (|@| (class "comment") (id "F:83006")) "Or show region in the selected window.  ") (span (|@| (class "comment-delimiter") (id "F:83046")) "*/") "\n          || w == XWINDOW (selected_window)\n          " (span (|@| (class "comment-delimiter") (id "F:83089")) "/* ") (span (|@| (class "comment") (id "F:83092")) "Or show the region if we are in the mini-buffer and W is\n             the window the mini-buffer refers to.  ") (span (|@| (class "comment-delimiter") (id "F:83194")) "*/") "\n          || (MINI_WINDOW_P (XWINDOW (selected_window))\n              && WINDOWP (minibuf_selected_window)\n              && w == XWINDOW (minibuf_selected_window))))\n    {\n      " (span (|@| (class "type") (id "F:83354")) "int") " " (span (|@| (class "variable-name") (id "F:83358")) "charpos") " = marker_position (current_buffer->mark);\n      it->region_beg_charpos = min (PT, charpos);\n      it->region_end_charpos = max (PT, charpos);\n    }\n  " (span (|@| (class "keyword") (id "F:83516")) "else") "\n    it->region_beg_charpos = it->region_end_charpos = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:83582")) "/* ") (span (|@| (class "comment") (id "F:83585")) "Get the position at which the redisplay_end_trigger hook should\n     be run, if it is to be run at all.  ") (span (|@| (class "comment-delimiter") (id "F:83690")) "*/") "\n  " (span (|@| (class "keyword") (id "F:83695")) "if") " (MARKERP (w->redisplay_end_trigger)\n      && XMARKER (w->redisplay_end_trigger)->buffer != 0)\n    it->redisplay_end_trigger_charpos\n      = marker_position (w->redisplay_end_trigger);\n  " (span (|@| (class "keyword") (id "F:83884")) "else") " " (span (|@| (class "keyword") (id "F:83889")) "if") " (INTEGERP (w->redisplay_end_trigger))\n    it->redisplay_end_trigger_charpos = XINT (w->redisplay_end_trigger);\n\n  " (span (|@| (class "comment-delimiter") (id "F:84006")) "/* ") (span (|@| (class "comment") (id "F:84009")) "Correct bogus values of tab_width.  ") (span (|@| (class "comment-delimiter") (id "F:84045")) "*/") "\n  it->tab_width = XINT (current_buffer->tab_width);\n  " (span (|@| (class "keyword") (id "F:84102")) "if") " (it->tab_width <= 0 || it->tab_width > 1000)\n    it->tab_width = 8;\n\n  " (span (|@| (class "comment-delimiter") (id "F:84176")) "/* ") (span (|@| (class "comment") (id "F:84179")) "Are lines in the display truncated?  ") (span (|@| (class "comment-delimiter") (id "F:84216")) "*/") "\n  " (span (|@| (class "keyword") (id "F:84221")) "if") " (base_face_id != DEFAULT_FACE_ID\n      || XINT (it->w->hscroll)\n      || (" (span (|@| (class "negation-char") (id "F:84298")) "!") " WINDOW_FULL_WIDTH_P (it->w)\n          && ((" (span (|@| (class "negation-char") (id "F:84336")) "!") "NILP (Vtruncate_partial_width_windows)\n               && " (span (|@| (class "negation-char") (id "F:84387")) "!") "INTEGERP (Vtruncate_partial_width_windows))\n              || (INTEGERP (Vtruncate_partial_width_windows)\n                  && (WINDOW_TOTAL_COLS (it->w)\n                      < XINT (Vtruncate_partial_width_windows))))))\n    it->line_wrap = TRUNCATE;\n  " (span (|@| (class "keyword") (id "F:84606")) "else") " " (span (|@| (class "keyword") (id "F:84611")) "if") " (NILP (current_buffer->truncate_lines))\n    it->line_wrap = NILP (current_buffer->word_wrap)\n      ? WINDOW_WRAP : WORD_WRAP;\n  " (span (|@| (class "keyword") (id "F:84742")) "else") "\n    it->line_wrap = TRUNCATE;\n\n  " (span (|@| (class "comment-delimiter") (id "F:84780")) "/* ") (span (|@| (class "comment") (id "F:84783")) "Get dimensions of truncation and continuation glyphs.  These are\n     displayed as fringe bitmaps under X, so we don't need them for such\n     frames.  ") (span (|@| (class "comment-delimiter") (id "F:84935")) "*/") "\n  " (span (|@| (class "keyword") (id "F:84940")) "if") " (" (span (|@| (class "negation-char") (id "F:84944")) "!") "FRAME_WINDOW_P (it->f))\n    {\n      " (span (|@| (class "keyword") (id "F:84981")) "if") " (it->line_wrap == TRUNCATE)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:85018")) "/* ") (span (|@| (class "comment") (id "F:85021")) "We will need the truncation glyph.  ") (span (|@| (class "comment-delimiter") (id "F:85057")) "*/") "\n          xassert (it->glyph_row == " (span (|@| (class "constant") (id "F:85089")) "NULL") ");\n          produce_special_glyphs (it, IT_TRUNCATION);\n          it->truncation_pixel_width = it->pixel_width;\n        }\n      " (span (|@| (class "keyword") (id "F:85201")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:85212")) "/* ") (span (|@| (class "comment") (id "F:85215")) "We will need the continuation glyph.  ") (span (|@| (class "comment-delimiter") (id "F:85253")) "*/") "\n          xassert (it->glyph_row == " (span (|@| (class "constant") (id "F:85285")) "NULL") ");\n          produce_special_glyphs (it, IT_CONTINUATION);\n          it->continuation_pixel_width = it->pixel_width;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:85402")) "/* ") (span (|@| (class "comment") (id "F:85405")) "Reset these values to zero because the produce_special_glyphs\n         above has changed them.  ") (span (|@| (class "comment-delimiter") (id "F:85494")) "*/") "\n      it->pixel_width = it->ascent = it->descent = 0;\n      it->phys_ascent = it->phys_descent = 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:85606")) "/* ") (span (|@| (class "comment") (id "F:85609")) "Set this after getting the dimensions of truncation and\n     continuation glyphs, so that we don't produce glyphs when calling\n     produce_special_glyphs, above.  ") (span (|@| (class "comment-delimiter") (id "F:85773")) "*/") "\n  it->glyph_row = row;\n  it->area = TEXT_AREA;\n\n  " (span (|@| (class "comment-delimiter") (id "F:85826")) "/* ") (span (|@| (class "comment") (id "F:85829")) "Forget any previous info about this row being reversed.  ") (span (|@| (class "comment-delimiter") (id "F:85886")) "*/") "\n  " (span (|@| (class "keyword") (id "F:85891")) "if") " (it->glyph_row)\n    it->glyph_row->reversed_p = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:85948")) "/* ") (span (|@| (class "comment") (id "F:85951")) "Get the dimensions of the display area.  The display area\n     consists of the visible window area plus a horizontally scrolled\n     part to the left of the window.  All x-values are relative to the\n     start of this total display area.  ") (span (|@| (class "comment-delimiter") (id "F:86190")) "*/") "\n  " (span (|@| (class "keyword") (id "F:86195")) "if") " (base_face_id != DEFAULT_FACE_ID)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:86244")) "/* ") (span (|@| (class "comment") (id "F:86247")) "Mode lines, menu bar in terminal frames.  ") (span (|@| (class "comment-delimiter") (id "F:86289")) "*/") "\n      it->first_visible_x = 0;\n      it->last_visible_x = WINDOW_TOTAL_WIDTH (w);\n    }\n  " (span (|@| (class "keyword") (id "F:86382")) "else") "\n    {\n      it->first_visible_x\n        = XFASTINT (it->w->hscroll) * FRAME_COLUMN_WIDTH (it->f);\n      it->last_visible_x = (it->first_visible_x\n                            + window_box_width (w, TEXT_AREA));\n\n      " (span (|@| (class "comment-delimiter") (id "F:86576")) "/* ") (span (|@| (class "comment") (id "F:86579")) "If we truncate lines, leave room for the truncator glyph(s) at\n         the right margin.  Otherwise, leave room for the continuation\n         glyph(s).  Truncation and continuation glyphs are not inserted\n         for window-based redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:86802")) "*/") "\n      " (span (|@| (class "keyword") (id "F:86811")) "if") " (" (span (|@| (class "negation-char") (id "F:86815")) "!") "FRAME_WINDOW_P (it->f))\n        {\n          " (span (|@| (class "keyword") (id "F:86846")) "if") " (it->line_wrap == TRUNCATE)\n            it->last_visible_x -= it->truncation_pixel_width;\n          " (span (|@| (class "keyword") (id "F:86935")) "else") "\n            it->last_visible_x -= it->continuation_pixel_width;\n        }\n\n      it->header_line_p = WINDOW_WANTS_HEADER_LINE_P (w);\n      it->current_y = WINDOW_HEADER_LINE_HEIGHT (w) + w->vscroll;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:87134")) "/* ") (span (|@| (class "comment") (id "F:87137")) "Leave room for a border glyph.  ") (span (|@| (class "comment-delimiter") (id "F:87169")) "*/") "\n  " (span (|@| (class "keyword") (id "F:87174")) "if") " (" (span (|@| (class "negation-char") (id "F:87178")) "!") "FRAME_WINDOW_P (it->f)\n      && " (span (|@| (class "negation-char") (id "F:87211")) "!") "WINDOW_RIGHTMOST_P (it->w))\n    it->last_visible_x -= 1;\n\n  it->last_visible_y = window_text_bottom_y (w);\n\n  " (span (|@| (class "comment-delimiter") (id "F:87322")) "/* ") (span (|@| (class "comment") (id "F:87325")) "For mode lines and alike, arrange for the first glyph having a\n     left box line if the face specifies a box.  ") (span (|@| (class "comment-delimiter") (id "F:87437")) "*/") "\n  " (span (|@| (class "keyword") (id "F:87442")) "if") " (base_face_id != DEFAULT_FACE_ID)\n    {\n      " (span (|@| (class "keyword") (id "F:87491")) "struct") " " (span (|@| (class "type") (id "F:87498")) "face") " *" (span (|@| (class "variable-name") (id "F:87504")) "face") ";\n\n      it->face_id = remapped_base_face_id;\n\n      " (span (|@| (class "comment-delimiter") (id "F:87561")) "/* ") (span (|@| (class "comment") (id "F:87564")) "If we have a boxed mode line, make the first character appear\n         with a left box line.  ") (span (|@| (class "comment-delimiter") (id "F:87651")) "*/") "\n      face = FACE_FROM_ID (it->f, remapped_base_face_id);\n      " (span (|@| (class "keyword") (id "F:87718")) "if") " (face->box != FACE_NO_BOX)\n        it->start_of_box_run_p = 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:87786")) "/* ") (span (|@| (class "comment") (id "F:87789")) "If we are to reorder bidirectional text, init the bidi\n     iterator.  ") (span (|@| (class "comment-delimiter") (id "F:87860")) "*/") "\n  " (span (|@| (class "keyword") (id "F:87865")) "if") " (it->bidi_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:87893")) "/* ") (span (|@| (class "comment") (id "F:87896")) "Note the paragraph direction that this buffer wants to\n         use.  ") (span (|@| (class "comment-delimiter") (id "F:87959")) "*/") "\n      " (span (|@| (class "keyword") (id "F:87968")) "if") " (EQ (current_buffer->bidi_paragraph_direction, Qleft_to_right))\n        it->paragraph_embedding = L2R;\n      " (span (|@| (class "keyword") (id "F:88073")) "else") " " (span (|@| (class "keyword") (id "F:88078")) "if") " (EQ (current_buffer->bidi_paragraph_direction, Qright_to_left))\n        it->paragraph_embedding = R2L;\n      " (span (|@| (class "keyword") (id "F:88183")) "else") "\n        it->paragraph_embedding = NEUTRAL_DIR;\n      bidi_init_it (charpos, bytepos, &it->bidi_it);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:88290")) "/* ") (span (|@| (class "comment") (id "F:88293")) "If a buffer position was specified, set the iterator there,\n     getting overlays and face properties from that position.  ") (span (|@| (class "comment-delimiter") (id "F:88416")) "*/") "\n  " (span (|@| (class "keyword") (id "F:88421")) "if") " (charpos >= BUF_BEG (current_buffer))\n    {\n      it->end_charpos = ZV;\n      it->face_id = -1;\n      IT_CHARPOS (*it) = charpos;\n\n      " (span (|@| (class "comment-delimiter") (id "F:88561")) "/* ") (span (|@| (class "comment") (id "F:88564")) "Compute byte position if not specified.  ") (span (|@| (class "comment-delimiter") (id "F:88605")) "*/") "\n      " (span (|@| (class "keyword") (id "F:88614")) "if") " (bytepos < charpos)\n        IT_BYTEPOS (*it) = CHAR_TO_BYTE (charpos);\n      " (span (|@| (class "keyword") (id "F:88687")) "else") "\n        IT_BYTEPOS (*it) = bytepos;\n\n      it->start = it->current;\n\n      " (span (|@| (class "comment-delimiter") (id "F:88760")) "/* ") (span (|@| (class "comment") (id "F:88763")) "Compute faces etc.  ") (span (|@| (class "comment-delimiter") (id "F:88783")) "*/") "\n      reseat (it, it->current.pos, 1);\n    }\n\n  CHECK_IT (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:88853")) "/* ") (span (|@| (class "comment") (id "F:88856")) "Initialize IT for the display of window W with window start POS.  ") (span (|@| (class "comment-delimiter") (id "F:88922")) "*/") "\n\n" (span (|@| (class "type") (id "F:88926")) "void") "\n" (span (|@| (class "function-name") (id "F:88931")) "start_display") " (" (span (|@| (class "type") (id "F:88946")) "it") ", w, pos)\n     " (span (|@| (class "keyword") (id "F:88963")) "struct") " " (span (|@| (class "type") (id "F:88970")) "it") " *" (span (|@| (class "variable-name") (id "F:88974")) "it") ";\n     " (span (|@| (class "keyword") (id "F:88983")) "struct") " " (span (|@| (class "type") (id "F:88990")) "window") " *" (span (|@| (class "variable-name") (id "F:88998")) "w") ";\n     " (span (|@| (class "keyword") (id "F:89006")) "struct") " " (span (|@| (class "type") (id "F:89013")) "text_pos") " " (span (|@| (class "variable-name") (id "F:89022")) "pos") ";\n{\n  " (span (|@| (class "keyword") (id "F:89031")) "struct") " " (span (|@| (class "type") (id "F:89038")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:89049")) "row") ";\n  " (span (|@| (class "type") (id "F:89056")) "int") " " (span (|@| (class "variable-name") (id "F:89060")) "first_vpos") " = WINDOW_WANTS_HEADER_LINE_P (w) ? 1 : 0;\n\n  row = w->desired_matrix->rows + first_vpos;\n  init_iterator (it, w, CHARPOS (pos), BYTEPOS (pos), row, DEFAULT_FACE_ID);\n  it->first_vpos = first_vpos;\n\n  " (span (|@| (class "comment-delimiter") (id "F:89271")) "/* ") (span (|@| (class "comment") (id "F:89274")) "Don't reseat to previous visible line start if current start\n     position is in a string or image.  ") (span (|@| (class "comment-delimiter") (id "F:89375")) "*/") "\n  " (span (|@| (class "keyword") (id "F:89380")) "if") " (it->method == GET_FROM_BUFFER && it->line_wrap != TRUNCATE)\n    {\n      " (span (|@| (class "type") (id "F:89456")) "int") " " (span (|@| (class "variable-name") (id "F:89460")) "start_at_line_beg_p") ";\n      " (span (|@| (class "type") (id "F:89487")) "int") " " (span (|@| (class "variable-name") (id "F:89491")) "first_y") " = it->current_y;\n\n      " (span (|@| (class "comment-delimiter") (id "F:89523")) "/* ") (span (|@| (class "comment") (id "F:89526")) "If window start is not at a line start, skip forward to POS to\n         get the correct continuation lines width.  ") (span (|@| (class "comment-delimiter") (id "F:89634")) "*/") "\n      start_at_line_beg_p = (CHARPOS (pos) == BEGV\n                             || FETCH_BYTE (BYTEPOS (pos) - 1) == " (span (|@| (class "string") (id "F:89733")) "'\\n'") ");\n      " (span (|@| (class "keyword") (id "F:89746")) "if") " (" (span (|@| (class "negation-char") (id "F:89750")) "!") "start_at_line_beg_p)\n        {\n          " (span (|@| (class "type") (id "F:89778")) "int") " " (span (|@| (class "variable-name") (id "F:89782")) "new_x") ";\n\n          reseat_at_previous_visible_line_start (it);\n          move_it_to (it, CHARPOS (pos), -1, -1, -1, MOVE_TO_POS);\n\n          new_x = it->current_x + it->pixel_width;\n\n          " (span (|@| (class "comment-delimiter") (id "F:89946")) "/* ") (span (|@| (class "comment") (id "F:89949")) "If lines are continued, this line may end in the middle\n             of a multi-glyph character (e.g. a control character\n             displayed as \\003, or in the middle of an overlay\n             string).  In this case move_it_to above will not have\n             taken us to the start of the continuation line but to the\n             end of the continued line.  ") (span (|@| (class "comment-delimiter") (id "F:90278")) "*/") "\n          " (span (|@| (class "keyword") (id "F:90284")) "if") " (it->current_x > 0\n              && it->line_wrap != TRUNCATE " (span (|@| (class "comment-delimiter") (id "F:90342")) "/* ") (span (|@| (class "comment") (id "F:90345")) "Lines are continued.  ") (span (|@| (class "comment-delimiter") (id "F:90367")) "*/") "\n              && (" (span (|@| (class "comment-delimiter") (id "F:90381")) "/* ") (span (|@| (class "comment") (id "F:90384")) "And glyph doesn't fit on the line.  ") (span (|@| (class "comment-delimiter") (id "F:90420")) "*/") "\n                  new_x > it->last_visible_x\n                  " (span (|@| (class "comment-delimiter") (id "F:90458")) "/* ") (span (|@| (class "comment") (id "F:90461")) "Or it fits exactly and we're on a window\n                     system frame.  ") (span (|@| (class "comment-delimiter") (id "F:90524")) "*/") "\n                  || (new_x == it->last_visible_x\n                      && FRAME_WINDOW_P (it->f))))\n            {\n              " (span (|@| (class "keyword") (id "F:90614")) "if") " (it->current.dpvec_index >= 0\n                  || it->current.overlay_string_index >= 0)\n                {\n                  set_iterator_to_next (it, 1);\n                  move_it_in_display_line_to (it, -1, -1, 0);\n                }\n\n              it->continuation_lines_width += it->current_x;\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:90849")) "/* ") (span (|@| (class "comment") (id "F:90852")) "We're starting a new display line, not affected by the\n             height of the continued line, so clear the appropriate\n             fields in the iterator structure.  ") (span (|@| (class "comment-delimiter") (id "F:91009")) "*/") "\n          it->max_ascent = it->max_descent = 0;\n          it->max_phys_ascent = it->max_phys_descent = 0;\n\n          it->current_y = first_y;\n          it->vpos = 0;\n          it->current_x = it->hpos = 0;\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:91196")) "/* ") (span (|@| (class "comment") (id "F:91199")) "Return 1 if POS is a position in ellipses displayed for invisible\n   text.  W is the window we display, for text property lookup.  ") (span (|@| (class "comment-delimiter") (id "F:91330")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:91334")) "static") " " (span (|@| (class "type") (id "F:91341")) "int") "\n" (span (|@| (class "function-name") (id "F:91345")) "in_ellipses_for_invisible_text_p") " (pos, w)\n     " (span (|@| (class "keyword") (id "F:91392")) "struct") " " (span (|@| (class "type") (id "F:91399")) "display_pos") " *" (span (|@| (class "variable-name") (id "F:91412")) "pos") ";\n     " (span (|@| (class "keyword") (id "F:91422")) "struct") " " (span (|@| (class "type") (id "F:91429")) "window") " *" (span (|@| (class "variable-name") (id "F:91437")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:91444")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:91456")) "prop") ", " (span (|@| (class "variable-name") (id "F:91462")) "window") ";\n  " (span (|@| (class "type") (id "F:91472")) "int") " " (span (|@| (class "variable-name") (id "F:91476")) "ellipses_p") " = 0;\n  " (span (|@| (class "type") (id "F:91494")) "int") " " (span (|@| (class "variable-name") (id "F:91498")) "charpos") " = CHARPOS (pos->pos);\n\n  " (span (|@| (class "comment-delimiter") (id "F:91531")) "/* ") (span (|@| (class "comment") (id "F:91534")) "If POS specifies a position in a display vector, this might\n     be for an ellipsis displayed for invisible text.  We won't\n     get the iterator set up for delivering that ellipsis unless\n     we make sure that it gets aware of the invisible text.  ") (span (|@| (class "comment-delimiter") (id "F:91784")) "*/") "\n  " (span (|@| (class "keyword") (id "F:91789")) "if") " (pos->dpvec_index >= 0\n      && pos->overlay_string_index < 0\n      && CHARPOS (pos->string_pos) < 0\n      && charpos > BEGV\n      && (XSETWINDOW (window, w),\n          prop = Fget_char_property (make_number (charpos),\n                                     Qinvisible, window),\n          " (span (|@| (class "negation-char") (id "F:92037")) "!") "TEXT_PROP_MEANS_INVISIBLE (prop)))\n    {\n      prop = Fget_char_property (make_number (charpos - 1), Qinvisible,\n                                 window);\n      ellipses_p = 2 == TEXT_PROP_MEANS_INVISIBLE (prop);\n    }\n\n  " (span (|@| (class "keyword") (id "F:92232")) "return") " ellipses_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:92255")) "/* ") (span (|@| (class "comment") (id "F:92258")) "Initialize IT for stepping through current_buffer in window W,\n   starting at position POS that includes overlay string and display\n   vector/ control character translation position information.  Value\n   is zero if there are overlay strings with newlines at POS.  ") (span (|@| (class "comment-delimiter") (id "F:92523")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:92527")) "static") " " (span (|@| (class "type") (id "F:92534")) "int") "\n" (span (|@| (class "function-name") (id "F:92538")) "init_from_display_pos") " (" (span (|@| (class "type") (id "F:92561")) "it") ", w, pos)\n     " (span (|@| (class "keyword") (id "F:92578")) "struct") " " (span (|@| (class "type") (id "F:92585")) "it") " *" (span (|@| (class "variable-name") (id "F:92589")) "it") ";\n     " (span (|@| (class "keyword") (id "F:92598")) "struct") " " (span (|@| (class "type") (id "F:92605")) "window") " *" (span (|@| (class "variable-name") (id "F:92613")) "w") ";\n     " (span (|@| (class "keyword") (id "F:92621")) "struct") " " (span (|@| (class "type") (id "F:92628")) "display_pos") " *" (span (|@| (class "variable-name") (id "F:92641")) "pos") ";\n{\n  " (span (|@| (class "type") (id "F:92650")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:92660")) "charpos") " = CHARPOS (pos->pos), " (span (|@| (class "variable-name") (id "F:92690")) "bytepos") " = BYTEPOS (pos->pos);\n  " (span (|@| (class "type") (id "F:92722")) "int") " " (span (|@| (class "variable-name") (id "F:92726")) "i") ", " (span (|@| (class "variable-name") (id "F:92729")) "overlay_strings_with_newlines") " = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:92767")) "/* ") (span (|@| (class "comment") (id "F:92770")) "If POS specifies a position in a display vector, this might\n     be for an ellipsis displayed for invisible text.  We won't\n     get the iterator set up for delivering that ellipsis unless\n     we make sure that it gets aware of the invisible text.  ") (span (|@| (class "comment-delimiter") (id "F:93020")) "*/") "\n  " (span (|@| (class "keyword") (id "F:93025")) "if") " (in_ellipses_for_invisible_text_p (pos, w))\n    {\n      --charpos;\n      bytepos = 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:93123")) "/* ") (span (|@| (class "comment") (id "F:93126")) "Keep in mind: the call to reseat in init_iterator skips invisible\n     text, so we might end up at a position different from POS.  This\n     is only a problem when POS is a row start after a newline and an\n     overlay starts there with an after-string, and the overlay has an\n     invisible property.  Since we don't skip invisible text in\n     display_line and elsewhere immediately after consuming the\n     newline before the row start, such a POS will not be in a string,\n     but the call to init_iterator below will move us to the\n     after-string.  ") (span (|@| (class "comment-delimiter") (id "F:93683")) "*/") "\n  init_iterator (it, w, charpos, bytepos, " (span (|@| (class "constant") (id "F:93728")) "NULL") ", DEFAULT_FACE_ID);\n\n  " (span (|@| (class "comment-delimiter") (id "F:93755")) "/* ") (span (|@| (class "comment") (id "F:93758")) "This only scans the current chunk -- it should scan all chunks.\n     However, OVERLAY_STRING_CHUNK_SIZE has been increased from 3 in 21.1\n     to 16 in 22.1 to make this a lesser problem.  ") (span (|@| (class "comment-delimiter") (id "F:93947")) "*/") "\n  " (span (|@| (class "keyword") (id "F:93952")) "for") " (i = 0; i < it->n_overlay_strings && i < OVERLAY_STRING_CHUNK_SIZE; ++i)\n    {\n      " (span (|@| (class "keyword") (id "F:94041")) "const") " " (span (|@| (class "type") (id "F:94047")) "char") " *" (span (|@| (class "variable-name") (id "F:94053")) "s") " = SDATA (it->overlay_strings[i]);\n      " (span (|@| (class "keyword") (id "F:94095")) "const") " " (span (|@| (class "type") (id "F:94101")) "char") " *" (span (|@| (class "variable-name") (id "F:94107")) "e") " = s + SBYTES (it->overlay_strings[i]);\n\n      " (span (|@| (class "keyword") (id "F:94155")) "while") " (s < e && *s != " (span (|@| (class "string") (id "F:94177")) "'\\n'") ")\n        ++s;\n\n      " (span (|@| (class "keyword") (id "F:94196")) "if") " (s < e)\n        {\n          overlay_strings_with_newlines = 1;\n          " (span (|@| (class "keyword") (id "F:94251")) "break") ";\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:94270")) "/* ") (span (|@| (class "comment") (id "F:94273")) "If position is within an overlay string, set up IT to the right\n     overlay string.  ") (span (|@| (class "comment-delimiter") (id "F:94359")) "*/") "\n  " (span (|@| (class "keyword") (id "F:94364")) "if") " (pos->overlay_string_index >= 0)\n    {\n      " (span (|@| (class "type") (id "F:94412")) "int") " " (span (|@| (class "variable-name") (id "F:94416")) "relative_index") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:94439")) "/* ") (span (|@| (class "comment") (id "F:94442")) "If the first overlay string happens to have a `display'\n         property for an image, the iterator will be set up for that\n         image, and we have to undo that setup first before we can\n         correct the overlay string index.  ") (span (|@| (class "comment-delimiter") (id "F:94657")) "*/") "\n      " (span (|@| (class "keyword") (id "F:94666")) "if") " (it->method == GET_FROM_IMAGE)\n        pop_it (it);\n\n      " (span (|@| (class "comment-delimiter") (id "F:94721")) "/* ") (span (|@| (class "comment") (id "F:94724")) "We already have the first chunk of overlay strings in\n         IT->overlay_strings.  Load more until the one for\n         pos->overlay_string_index is in IT->overlay_strings.  ") (span (|@| (class "comment-delimiter") (id "F:94886")) "*/") "\n      " (span (|@| (class "keyword") (id "F:94895")) "if") " (pos->overlay_string_index >= OVERLAY_STRING_CHUNK_SIZE)\n        {\n          " (span (|@| (class "type") (id "F:94961")) "int") " " (span (|@| (class "variable-name") (id "F:94965")) "n") " = pos->overlay_string_index / OVERLAY_STRING_CHUNK_SIZE;\n          it->current.overlay_string_index = 0;\n          " (span (|@| (class "keyword") (id "F:95068")) "while") " (n--)\n            {\n              load_overlay_strings (it, 0);\n              it->current.overlay_string_index += OVERLAY_STRING_CHUNK_SIZE;\n            }\n        }\n\n      it->current.overlay_string_index = pos->overlay_string_index;\n      relative_index = (it->current.overlay_string_index\n                        % OVERLAY_STRING_CHUNK_SIZE);\n      it->string = it->overlay_strings[relative_index];\n      xassert (STRINGP (it->string));\n      it->current.string_pos = pos->string_pos;\n      it->method = GET_FROM_STRING;\n    }\n\n  " (span (|@| (class "keyword") (id "F:95550")) "if") " (CHARPOS (pos->string_pos) >= 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:95598")) "/* ") (span (|@| (class "comment") (id "F:95601")) "Recorded position is not in an overlay string, but in another\n         string.  This can only be a string from a `display' property.\n         IT should already be filled with that string.  ") (span (|@| (class "comment-delimiter") (id "F:95776")) "*/") "\n      it->current.string_pos = pos->string_pos;\n      xassert (STRINGP (it->string));\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:95874")) "/* ") (span (|@| (class "comment") (id "F:95877")) "Restore position in display vector translations, control\n     character translations or ellipses.  ") (span (|@| (class "comment-delimiter") (id "F:95976")) "*/") "\n  " (span (|@| (class "keyword") (id "F:95981")) "if") " (pos->dpvec_index >= 0)\n    {\n      " (span (|@| (class "keyword") (id "F:96020")) "if") " (it->dpvec == " (span (|@| (class "constant") (id "F:96037")) "NULL") ")\n        get_next_display_element (it);\n      xassert (it->dpvec && it->current.dpvec_index == 0);\n      it->current.dpvec_index = pos->dpvec_index;\n    }\n\n  CHECK_IT (it);\n  " (span (|@| (class "keyword") (id "F:96210")) "return") " " (span (|@| (class "negation-char") (id "F:96217")) "!") "overlay_strings_with_newlines;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:96253")) "/* ") (span (|@| (class "comment") (id "F:96256")) "Initialize IT for stepping through current_buffer in window W\n   starting at ROW->start.  ") (span (|@| (class "comment-delimiter") (id "F:96346")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:96350")) "static") " " (span (|@| (class "type") (id "F:96357")) "void") "\n" (span (|@| (class "function-name") (id "F:96362")) "init_to_row_start") " (" (span (|@| (class "type") (id "F:96381")) "it") ", w, row)\n     " (span (|@| (class "keyword") (id "F:96398")) "struct") " " (span (|@| (class "type") (id "F:96405")) "it") " *" (span (|@| (class "variable-name") (id "F:96409")) "it") ";\n     " (span (|@| (class "keyword") (id "F:96418")) "struct") " " (span (|@| (class "type") (id "F:96425")) "window") " *" (span (|@| (class "variable-name") (id "F:96433")) "w") ";\n     " (span (|@| (class "keyword") (id "F:96441")) "struct") " " (span (|@| (class "type") (id "F:96448")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:96459")) "row") ";\n{\n  init_from_display_pos (it, w, &row->start);\n  it->start = row->start;\n  it->continuation_lines_width = row->continuation_lines_width;\n  CHECK_IT (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:96623")) "/* ") (span (|@| (class "comment") (id "F:96626")) "Initialize IT for stepping through current_buffer in window W\n   starting in the line following ROW, i.e. starting at ROW->end.\n   Value is zero if there are overlay strings with newlines at ROW's\n   end position.  ") (span (|@| (class "comment-delimiter") (id "F:96841")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:96845")) "static") " " (span (|@| (class "type") (id "F:96852")) "int") "\n" (span (|@| (class "function-name") (id "F:96856")) "init_to_row_end") " (" (span (|@| (class "type") (id "F:96873")) "it") ", w, row)\n     " (span (|@| (class "keyword") (id "F:96890")) "struct") " " (span (|@| (class "type") (id "F:96897")) "it") " *" (span (|@| (class "variable-name") (id "F:96901")) "it") ";\n     " (span (|@| (class "keyword") (id "F:96910")) "struct") " " (span (|@| (class "type") (id "F:96917")) "window") " *" (span (|@| (class "variable-name") (id "F:96925")) "w") ";\n     " (span (|@| (class "keyword") (id "F:96933")) "struct") " " (span (|@| (class "type") (id "F:96940")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:96951")) "row") ";\n{\n  " (span (|@| (class "type") (id "F:96960")) "int") " " (span (|@| (class "variable-name") (id "F:96964")) "success") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:96980")) "if") " (init_from_display_pos (it, w, &row->end))\n    {\n      " (span (|@| (class "keyword") (id "F:97038")) "if") " (row->continued_p)\n        it->continuation_lines_width\n          = row->continuation_lines_width + row->pixel_width;\n      CHECK_IT (it);\n      success = 1;\n    }\n\n  " (span (|@| (class "keyword") (id "F:97194")) "return") " success;\n}\n\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:97217")) "/***********************************************************************") (span (|@| (class "comment") (id "F:97289")) "\n                           Text properties\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:97383")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:97387")) "/* ") (span (|@| (class "comment") (id "F:97390")) "Called when IT reaches IT->stop_charpos.  Handle text property and\n   overlay changes.  Set IT->stop_charpos to the next position where\n   to stop.  ") (span (|@| (class "comment-delimiter") (id "F:97539")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:97543")) "static") " " (span (|@| (class "type") (id "F:97550")) "void") "\n" (span (|@| (class "function-name") (id "F:97555")) "handle_stop") " (" (span (|@| (class "type") (id "F:97568")) "it") ")\n     " (span (|@| (class "keyword") (id "F:97577")) "struct") " " (span (|@| (class "type") (id "F:97584")) "it") " *" (span (|@| (class "variable-name") (id "F:97588")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:97596")) "enum") " " (span (|@| (class "type") (id "F:97601")) "prop_handled") " " (span (|@| (class "variable-name") (id "F:97614")) "handled") ";\n  " (span (|@| (class "type") (id "F:97625")) "int") " " (span (|@| (class "variable-name") (id "F:97629")) "handle_overlay_change_p") ";\n  " (span (|@| (class "keyword") (id "F:97656")) "struct") " " (span (|@| (class "type") (id "F:97663")) "props") " *" (span (|@| (class "variable-name") (id "F:97670")) "p") ";\n\n  it->dpvec = " (span (|@| (class "constant") (id "F:97688")) "NULL") ";\n  it->current.dpvec_index = -1;\n  handle_overlay_change_p = " (span (|@| (class "negation-char") (id "F:97754")) "!") "it->ignore_overlay_strings_at_pos_p;\n  it->ignore_overlay_strings_at_pos_p = 0;\n  it->ellipsis_p = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:97860")) "/* ") (span (|@| (class "comment") (id "F:97863")) "Use face of preceding text for ellipsis (if invisible) ") (span (|@| (class "comment-delimiter") (id "F:97918")) "*/") "\n  " (span (|@| (class "keyword") (id "F:97923")) "if") " (it->selective_display_ellipsis_p)\n    it->saved_face_id = it->face_id;\n\n  " (span (|@| (class "keyword") (id "F:98001")) "do") "\n    {\n      handled = HANDLED_NORMALLY;\n\n      " (span (|@| (class "comment-delimiter") (id "F:98051")) "/* ") (span (|@| (class "comment") (id "F:98054")) "Call text property handlers.  ") (span (|@| (class "comment-delimiter") (id "F:98084")) "*/") "\n      " (span (|@| (class "keyword") (id "F:98093")) "for") " (p = it_props; p->handler; ++p)\n        {\n          handled = p->handler (it);\n\n          " (span (|@| (class "keyword") (id "F:98166")) "if") " (handled == HANDLED_RECOMPUTE_PROPS)\n            " (span (|@| (class "keyword") (id "F:98211")) "break") ";\n          " (span (|@| (class "keyword") (id "F:98221")) "else") " " (span (|@| (class "keyword") (id "F:98226")) "if") " (handled == HANDLED_RETURN)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:98271")) "/* ") (span (|@| (class "comment") (id "F:98274")) "We still want to show before and after strings from\n                 overlays even if the actual buffer text is replaced.  ") (span (|@| (class "comment-delimiter") (id "F:98383")) "*/") "\n              " (span (|@| (class "keyword") (id "F:98393")) "if") " (" (span (|@| (class "negation-char") (id "F:98397")) "!") "handle_overlay_change_p\n                  || it->sp > 1\n                  || " (span (|@| (class "negation-char") (id "F:98447")) "!") "get_overlay_strings_1 (it, 0, 0))\n                {\n                  " (span (|@| (class "keyword") (id "F:98490")) "if") " (it->ellipsis_p)\n                    setup_for_ellipsis (it, 0);\n                  " (span (|@| (class "comment-delimiter") (id "F:98548")) "/* ") (span (|@| (class "comment") (id "F:98551")) "When handling a display spec, we might load an\n                     empty string.  In that case, discard it here.  We\n                     used to discard it in handle_single_display_spec,\n                     but that causes get_overlay_strings_1, above, to\n                     ignore overlay strings that we must check.  ") (span (|@| (class "comment-delimiter") (id "F:98819")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:98826")) "if") " (STRINGP (it->string) && " (span (|@| (class "negation-char") (id "F:98854")) "!") "SCHARS (it->string))\n                    pop_it (it);\n                  " (span (|@| (class "keyword") (id "F:98899")) "return") ";\n                }\n              " (span (|@| (class "keyword") (id "F:98918")) "else") " " (span (|@| (class "keyword") (id "F:98923")) "if") " (STRINGP (it->string) && " (span (|@| (class "negation-char") (id "F:98951")) "!") "SCHARS (it->string))\n                pop_it (it);\n              " (span (|@| (class "keyword") (id "F:98995")) "else") "\n                {\n                  it->ignore_overlay_strings_at_pos_p = 1;\n                  it->string_from_display_prop_p = 0;\n                  handle_overlay_change_p = 0;\n                }\n              handled = HANDLED_RECOMPUTE_PROPS;\n              " (span (|@| (class "keyword") (id "F:99175")) "break") ";\n            }\n          " (span (|@| (class "keyword") (id "F:99192")) "else") " " (span (|@| (class "keyword") (id "F:99197")) "if") " (handled == HANDLED_OVERLAY_STRING_CONSUMED)\n            handle_overlay_change_p = 0;\n        }\n\n      " (span (|@| (class "keyword") (id "F:99289")) "if") " (handled != HANDLED_RECOMPUTE_PROPS)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:99335")) "/* ") (span (|@| (class "comment") (id "F:99338")) "Don't check for overlay strings below when set to deliver\n             characters from a display vector.  ") (span (|@| (class "comment-delimiter") (id "F:99437")) "*/") "\n          " (span (|@| (class "keyword") (id "F:99443")) "if") " (it->method == GET_FROM_DISPLAY_VECTOR)\n            handle_overlay_change_p = 0;\n\n          " (span (|@| (class "comment-delimiter") (id "F:99524")) "/* ") (span (|@| (class "comment") (id "F:99527")) "Handle overlay changes.\n             This sets HANDLED to HANDLED_RECOMPUTE_PROPS\n             if it finds overlays.  ") (span (|@| (class "comment-delimiter") (id "F:99631")) "*/") "\n          " (span (|@| (class "keyword") (id "F:99637")) "if") " (handle_overlay_change_p)\n            handled = handle_overlay_change (it);\n        }\n\n      " (span (|@| (class "keyword") (id "F:99719")) "if") " (it->ellipsis_p)\n        {\n          setup_for_ellipsis (it, 0);\n          " (span (|@| (class "keyword") (id "F:99776")) "break") ";\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:99794")) "while") " (handled == HANDLED_RECOMPUTE_PROPS);\n\n  " (span (|@| (class "comment-delimiter") (id "F:99841")) "/* ") (span (|@| (class "comment") (id "F:99844")) "Determine where to stop next.  ") (span (|@| (class "comment-delimiter") (id "F:99875")) "*/") "\n  " (span (|@| (class "keyword") (id "F:99880")) "if") " (handled == HANDLED_NORMALLY)\n    compute_stop_pos (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:99944")) "/* ") (span (|@| (class "comment") (id "F:99947")) "Compute IT->stop_charpos from text property and overlay change\n   information for IT's current position.  ") (span (|@| (class "comment-delimiter") (id "F:100053")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:100057")) "static") " " (span (|@| (class "type") (id "F:100064")) "void") "\n" (span (|@| (class "function-name") (id "F:100069")) "compute_stop_pos") " (" (span (|@| (class "type") (id "F:100087")) "it") ")\n     " (span (|@| (class "keyword") (id "F:100096")) "struct") " " (span (|@| (class "type") (id "F:100103")) "it") " *" (span (|@| (class "variable-name") (id "F:100107")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:100115")) "register") " " (span (|@| (class "type") (id "F:100124")) "INTERVAL") " " (span (|@| (class "variable-name") (id "F:100133")) "iv") ", " (span (|@| (class "variable-name") (id "F:100137")) "next_iv") ";\n  " (span (|@| (class "type") (id "F:100148")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:100160")) "object") ", " (span (|@| (class "variable-name") (id "F:100168")) "limit") ", " (span (|@| (class "variable-name") (id "F:100175")) "position") ";\n  " (span (|@| (class "type") (id "F:100187")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:100197")) "charpos") ", " (span (|@| (class "variable-name") (id "F:100206")) "bytepos") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:100218")) "/* ") (span (|@| (class "comment") (id "F:100221")) "If nowhere else, stop at the end.  ") (span (|@| (class "comment-delimiter") (id "F:100256")) "*/") "\n  it->stop_charpos = it->end_charpos;\n\n  " (span (|@| (class "keyword") (id "F:100300")) "if") " (STRINGP (it->string))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:100338")) "/* ") (span (|@| (class "comment") (id "F:100341")) "Strings are usually short, so don't limit the search for\n         properties.  ") (span (|@| (class "comment-delimiter") (id "F:100413")) "*/") "\n      object = it->string;\n      limit = Qnil;\n      charpos = IT_STRING_CHARPOS (*it);\n      bytepos = IT_STRING_BYTEPOS (*it);\n    }\n  " (span (|@| (class "keyword") (id "F:100553")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:100570")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:100580")) "pos") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:100592")) "/* ") (span (|@| (class "comment") (id "F:100595")) "If next overlay change is in front of the current stop pos\n         (which is IT->end_charpos), stop there.  Note: value of\n         next_overlay_change is point-max if no overlay change\n         follows.  ") (span (|@| (class "comment-delimiter") (id "F:100780")) "*/") "\n      charpos = IT_CHARPOS (*it);\n      bytepos = IT_BYTEPOS (*it);\n      pos = next_overlay_change (charpos);\n      " (span (|@| (class "keyword") (id "F:100900")) "if") " (pos < it->stop_charpos)\n        it->stop_charpos = pos;\n\n      " (span (|@| (class "comment-delimiter") (id "F:100960")) "/* ") (span (|@| (class "comment") (id "F:100963")) "If showing the region, we have to stop at the region\n         start or end because the face might change there.  ") (span (|@| (class "comment-delimiter") (id "F:101069")) "*/") "\n      " (span (|@| (class "keyword") (id "F:101078")) "if") " (it->region_beg_charpos > 0)\n        {\n          " (span (|@| (class "keyword") (id "F:101116")) "if") " (IT_CHARPOS (*it) < it->region_beg_charpos)\n            it->stop_charpos = min (it->stop_charpos, it->region_beg_charpos);\n          " (span (|@| (class "keyword") (id "F:101238")) "else") " " (span (|@| (class "keyword") (id "F:101243")) "if") " (IT_CHARPOS (*it) < it->region_end_charpos)\n            it->stop_charpos = min (it->stop_charpos, it->region_end_charpos);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:101372")) "/* ") (span (|@| (class "comment") (id "F:101375")) "Set up variables for computing the stop position from text\n         property changes.  ") (span (|@| (class "comment-delimiter") (id "F:101462")) "*/") "\n      XSETBUFFER (object, current_buffer);\n      limit = make_number (IT_CHARPOS (*it) + TEXT_PROP_DISTANCE_LIMIT);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:101590")) "/* ") (span (|@| (class "comment") (id "F:101593")) "Get the interval containing IT's position.  Value is a null\n     interval if there isn't such an interval.  ") (span (|@| (class "comment-delimiter") (id "F:101701")) "*/") "\n  position = make_number (charpos);\n  iv = validate_interval_range (object, &position, &position, 0);\n  " (span (|@| (class "keyword") (id "F:101808")) "if") " (" (span (|@| (class "negation-char") (id "F:101812")) "!") "NULL_INTERVAL_P (iv))\n    {\n      " (span (|@| (class "type") (id "F:101847")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:101859")) "values_here") "[LAST_PROP_IDX];\n      " (span (|@| (class "keyword") (id "F:101893")) "struct") " " (span (|@| (class "type") (id "F:101900")) "props") " *" (span (|@| (class "variable-name") (id "F:101907")) "p") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:101917")) "/* ") (span (|@| (class "comment") (id "F:101920")) "Get properties here.  ") (span (|@| (class "comment-delimiter") (id "F:101942")) "*/") "\n      " (span (|@| (class "keyword") (id "F:101951")) "for") " (p = it_props; p->handler; ++p)\n        values_here[p->idx] = textget (iv->plist, *p->name);\n\n      " (span (|@| (class "comment-delimiter") (id "F:102048")) "/* ") (span (|@| (class "comment") (id "F:102051")) "Look for an interval following iv that has different\n         properties.  ") (span (|@| (class "comment-delimiter") (id "F:102119")) "*/") "\n      " (span (|@| (class "keyword") (id "F:102128")) "for") " (next_iv = next_interval (iv);\n           (" (span (|@| (class "negation-char") (id "F:102168")) "!") "NULL_INTERVAL_P (next_iv)\n            && (NILP (limit)\n                || XFASTINT (limit) > next_iv->position));\n           next_iv = next_interval (next_iv))\n        {\n          " (span (|@| (class "keyword") (id "F:102307")) "for") " (p = it_props; p->handler; ++p)\n            {\n              " (span (|@| (class "type") (id "F:102357")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:102369")) "new_value") ";\n\n              new_value = textget (next_iv->plist, *p->name);\n              " (span (|@| (class "keyword") (id "F:102443")) "if") " (" (span (|@| (class "negation-char") (id "F:102447")) "!") "EQ (values_here[p->idx], new_value))\n                " (span (|@| (class "keyword") (id "F:102487")) "break") ";\n            }\n\n          " (span (|@| (class "keyword") (id "F:102505")) "if") " (p->handler)\n            " (span (|@| (class "keyword") (id "F:102526")) "break") ";\n        }\n\n      " (span (|@| (class "keyword") (id "F:102543")) "if") " (" (span (|@| (class "negation-char") (id "F:102547")) "!") "NULL_INTERVAL_P (next_iv))\n        {\n          " (span (|@| (class "keyword") (id "F:102581")) "if") " (INTEGERP (limit)\n              && next_iv->position >= XFASTINT (limit))\n            " (span (|@| (class "comment-delimiter") (id "F:102656")) "/* ") (span (|@| (class "comment") (id "F:102659")) "No text property change up to limit.  ") (span (|@| (class "comment-delimiter") (id "F:102697")) "*/") "\n            it->stop_charpos = min (XFASTINT (limit), it->stop_charpos);\n          " (span (|@| (class "keyword") (id "F:102769")) "else") "\n            " (span (|@| (class "comment-delimiter") (id "F:102779")) "/* ") (span (|@| (class "comment") (id "F:102782")) "Text properties change in next_iv.  ") (span (|@| (class "comment-delimiter") (id "F:102818")) "*/") "\n            it->stop_charpos = min (it->stop_charpos, next_iv->position);\n        }\n    }\n\n  composition_compute_stop_pos (&it->cmp_it, charpos, bytepos,\n                                it->stop_charpos, it->string);\n\n  xassert (STRINGP (it->string)\n           || (it->stop_charpos >= BEGV\n               && it->stop_charpos >= IT_CHARPOS (*it)));\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:103117")) "/* ") (span (|@| (class "comment") (id "F:103120")) "Return the position of the next overlay change after POS in\n   current_buffer.  Value is point-max if no overlay change\n   follows.  This is like `next-overlay-change' but doesn't use\n   xmalloc.  ") (span (|@| (class "comment-delimiter") (id "F:103317")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:103321")) "static") " " (span (|@| (class "type") (id "F:103328")) "EMACS_INT") "\n" (span (|@| (class "function-name") (id "F:103338")) "next_overlay_change") " (pos)\n     " (span (|@| (class "type") (id "F:103369")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:103379")) "pos") ";\n{\n  " (span (|@| (class "type") (id "F:103388")) "int") " " (span (|@| (class "variable-name") (id "F:103392")) "noverlays") ";\n  " (span (|@| (class "type") (id "F:103405")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:103415")) "endpos") ";\n  " (span (|@| (class "type") (id "F:103425")) "Lisp_Object") " *" (span (|@| (class "variable-name") (id "F:103438")) "overlays") ";\n  " (span (|@| (class "type") (id "F:103450")) "int") " " (span (|@| (class "variable-name") (id "F:103454")) "i") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:103460")) "/* ") (span (|@| (class "comment") (id "F:103463")) "Get all overlays at the given position.  ") (span (|@| (class "comment-delimiter") (id "F:103504")) "*/") "\n  GET_OVERLAYS_AT (pos, overlays, noverlays, &endpos, 1);\n\n  " (span (|@| (class "comment-delimiter") (id "F:103568")) "/* ") (span (|@| (class "comment") (id "F:103571")) "If any of these overlays ends before endpos,\n     use its ending point instead.  ") (span (|@| (class "comment-delimiter") (id "F:103652")) "*/") "\n  " (span (|@| (class "keyword") (id "F:103657")) "for") " (i = 0; i < noverlays; ++i)\n    {\n      " (span (|@| (class "type") (id "F:103701")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:103713")) "oend") ";\n      " (span (|@| (class "type") (id "F:103725")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:103735")) "oendpos") ";\n\n      oend = OVERLAY_END (overlays[i]);\n      oendpos = OVERLAY_POSITION (oend);\n      endpos = min (endpos, oendpos);\n    }\n\n  " (span (|@| (class "keyword") (id "F:103873")) "return") " endpos;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:103894")) "/***********************************************************************") (span (|@| (class "comment") (id "F:103966")) "\n                            Fontification\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:104059")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:104063")) "/* ") (span (|@| (class "comment") (id "F:104066")) "Handle changes in the `fontified' property of the current buffer by\n   calling hook functions from Qfontification_functions to fontify\n   regions of text.  ") (span (|@| (class "comment-delimiter") (id "F:104222")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:104226")) "static") " " (span (|@| (class "keyword") (id "F:104233")) "enum") " " (span (|@| (class "type") (id "F:104238")) "prop_handled") "\n" (span (|@| (class "function-name") (id "F:104251")) "handle_fontified_prop") " (" (span (|@| (class "type") (id "F:104274")) "it") ")\n     " (span (|@| (class "keyword") (id "F:104283")) "struct") " " (span (|@| (class "type") (id "F:104290")) "it") " *" (span (|@| (class "variable-name") (id "F:104294")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:104302")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:104314")) "prop") ", " (span (|@| (class "variable-name") (id "F:104320")) "pos") ";\n  " (span (|@| (class "keyword") (id "F:104327")) "enum") " " (span (|@| (class "type") (id "F:104332")) "prop_handled") " " (span (|@| (class "variable-name") (id "F:104345")) "handled") " = HANDLED_NORMALLY;\n\n  " (span (|@| (class "keyword") (id "F:104376")) "if") " (" (span (|@| (class "negation-char") (id "F:104380")) "!") "NILP (Vmemory_full))\n    " (span (|@| (class "keyword") (id "F:104406")) "return") " handled;\n\n  " (span (|@| (class "comment-delimiter") (id "F:104425")) "/* ") (span (|@| (class "comment") (id "F:104428")) "Get the value of the `fontified' property at IT's current buffer\n     position.  (The `fontified' property doesn't have a special\n     meaning in strings.)  If the value is nil, call functions from\n     Qfontification_functions.  ") (span (|@| (class "comment-delimiter") (id "F:104658")) "*/") "\n  " (span (|@| (class "keyword") (id "F:104663")) "if") " (" (span (|@| (class "negation-char") (id "F:104667")) "!") "STRINGP (it->string)\n      && it->s == " (span (|@| (class "constant") (id "F:104707")) "NULL") "\n      && " (span (|@| (class "negation-char") (id "F:104721")) "!") "NILP (Vfontification_functions)\n      && " (span (|@| (class "negation-char") (id "F:104763")) "!") "NILP (Vrun_hooks)\n      && (pos = make_number (IT_CHARPOS (*it)),\n          prop = Fget_char_property (pos, Qfontified, Qnil),\n          " (span (|@| (class "comment-delimiter") (id "F:104887")) "/* ") (span (|@| (class "comment") (id "F:104890")) "Ignore the special cased nil value always present at EOB since\n             no amount of fontifying will be able to change it.  ") (span (|@| (class "comment-delimiter") (id "F:105011")) "*/") "\n          NILP (prop) && IT_CHARPOS (*it) < Z))\n    {\n      " (span (|@| (class "type") (id "F:105067")) "int") " " (span (|@| (class "variable-name") (id "F:105071")) "count") " = SPECPDL_INDEX ();\n      " (span (|@| (class "type") (id "F:105103")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:105115")) "val") ";\n\n      val = Vfontification_functions;\n      specbind (Qfontification_functions, Qnil);\n\n      " (span (|@| (class "keyword") (id "F:105215")) "if") " (" (span (|@| (class "negation-char") (id "F:105219")) "!") "CONSP (val) || EQ (XCAR (val), Qlambda))\n        safe_call1 (val, pos);\n      " (span (|@| (class "keyword") (id "F:105291")) "else") "\n        {\n          " (span (|@| (class "type") (id "F:105302")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:105314")) "globals") ", " (span (|@| (class "variable-name") (id "F:105323")) "fn") ";\n          " (span (|@| (class "keyword") (id "F:105330")) "struct") " " (span (|@| (class "type") (id "F:105337")) "gcpro") " " (span (|@| (class "variable-name") (id "F:105343")) "gcpro1") ", " (span (|@| (class "variable-name") (id "F:105351")) "gcpro2") ";\n\n          globals = Qnil;\n          GCPRO2 (val, globals);\n\n          " (span (|@| (class "keyword") (id "F:105409")) "for") " (; CONSP (val); val = XCDR (val))\n            {\n              fn = XCAR (val);\n\n              " (span (|@| (class "keyword") (id "F:105486")) "if") " (EQ (fn, Qt))\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:105511")) "/* ") (span (|@| (class "comment") (id "F:105514")) "A value of t indicates this hook has a local\n                     binding; it means to run the global binding too.\n                     In a global value, t should not occur.  If it\n                     does, we must ignore it to avoid an endless\n                     loop.  ") (span (|@| (class "comment-delimiter") (id "F:105733")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:105740")) "for") " (globals = Fdefault_value (Qfontification_functions);\n                       CONSP (globals);\n                       globals = XCDR (globals))\n                    {\n                      fn = XCAR (globals);\n                      " (span (|@| (class "keyword") (id "F:105904")) "if") " (" (span (|@| (class "negation-char") (id "F:105908")) "!") "EQ (fn, Qt))\n                        safe_call1 (fn, pos);\n                    }\n                }\n              " (span (|@| (class "keyword") (id "F:105966")) "else") "\n                safe_call1 (fn, pos);\n            }\n\n          UNGCPRO;\n        }\n\n      unbind_to (count, Qnil);\n\n      " (span (|@| (class "comment-delimiter") (id "F:106057")) "/* ") (span (|@| (class "comment") (id "F:106060")) "Return HANDLED_RECOMPUTE_PROPS only if function fontified\n         something.  This avoids an endless loop if they failed to\n         fontify the text for which reason ever.  ") (span (|@| (class "comment-delimiter") (id "F:106221")) "*/") "\n      " (span (|@| (class "keyword") (id "F:106230")) "if") " (" (span (|@| (class "negation-char") (id "F:106234")) "!") "NILP (Fget_char_property (pos, Qfontified, Qnil)))\n        handled = HANDLED_RECOMPUTE_PROPS;\n    }\n\n  " (span (|@| (class "keyword") (id "F:106331")) "return") " handled;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:106353")) "/***********************************************************************") (span (|@| (class "comment") (id "F:106425")) "\n                                Faces\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:106507")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:106511")) "/* ") (span (|@| (class "comment") (id "F:106514")) "Set up iterator IT from face properties at its current position.\n   Called from handle_stop.  ") (span (|@| (class "comment-delimiter") (id "F:106608")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:106612")) "static") " " (span (|@| (class "keyword") (id "F:106619")) "enum") " " (span (|@| (class "type") (id "F:106624")) "prop_handled") "\n" (span (|@| (class "function-name") (id "F:106637")) "handle_face_prop") " (" (span (|@| (class "type") (id "F:106655")) "it") ")\n     " (span (|@| (class "keyword") (id "F:106664")) "struct") " " (span (|@| (class "type") (id "F:106671")) "it") " *" (span (|@| (class "variable-name") (id "F:106675")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:106683")) "int") " " (span (|@| (class "variable-name") (id "F:106687")) "new_face_id") ";\n  " (span (|@| (class "type") (id "F:106702")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:106712")) "next_stop") ";\n\n  " (span (|@| (class "keyword") (id "F:106726")) "if") " (" (span (|@| (class "negation-char") (id "F:106730")) "!") "STRINGP (it->string))\n    {\n      new_face_id\n        = face_at_buffer_position (it->w,\n                                   IT_CHARPOS (*it),\n                                   it->region_beg_charpos,\n                                   it->region_end_charpos,\n                                   &next_stop,\n                                   (IT_CHARPOS (*it)\n                                    + TEXT_PROP_DISTANCE_LIMIT),\n                                   0, it->base_face_id);\n\n      " (span (|@| (class "comment-delimiter") (id "F:107016")) "/* ") (span (|@| (class "comment") (id "F:107019")) "Is this a start of a run of characters with box face?\n         Caveat: this can be called for a freshly initialized\n         iterator; face_id is -1 in this case.  We know that the new\n         face will not change until limit, i.e. if the new face has a\n         box, all characters up to limit will have one.  But, as\n         usual, we don't know whether limit is really the end.  ") (span (|@| (class "comment-delimiter") (id "F:107368")) "*/") "\n      " (span (|@| (class "keyword") (id "F:107377")) "if") " (new_face_id != it->face_id)\n        {\n          " (span (|@| (class "keyword") (id "F:107415")) "struct") " " (span (|@| (class "type") (id "F:107422")) "face") " *" (span (|@| (class "variable-name") (id "F:107428")) "new_face") " = FACE_FROM_ID (it->f, new_face_id);\n\n          " (span (|@| (class "comment-delimiter") (id "F:107478")) "/* ") (span (|@| (class "comment") (id "F:107481")) "If new face has a box but old face has not, this is\n             the start of a run of characters with box, i.e. it has\n             a shadow on the left side.  The value of face_id of the\n             iterator will be -1 if this is the initial call that gets\n             the face.  In this case, we have to look in front of IT's\n             position and see whether there is a face != new_face_id.  ") (span (|@| (class "comment-delimiter") (id "F:107848")) "*/") "\n          it->start_of_box_run_p\n            = (new_face->box != FACE_NO_BOX\n               && (it->face_id >= 0\n                   || IT_CHARPOS (*it) == BEG\n                   || new_face_id != face_before_it_pos (it)));\n          it->face_box_p = new_face->box != FACE_NO_BOX;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:108086")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:108103")) "int") " " (span (|@| (class "variable-name") (id "F:108107")) "base_face_id") ", " (span (|@| (class "variable-name") (id "F:108121")) "bufpos") ";\n      " (span (|@| (class "type") (id "F:108135")) "int") " " (span (|@| (class "variable-name") (id "F:108139")) "i") ";\n      " (span (|@| (class "type") (id "F:108148")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:108160")) "from_overlay") "\n        = (it->current.overlay_string_index >= 0\n           ? it->string_overlays[it->current.overlay_string_index]\n           : Qnil);\n\n      " (span (|@| (class "comment-delimiter") (id "F:108295")) "/* ") (span (|@| (class "comment") (id "F:108298")) "See if we got to this string directly or indirectly from\n         an overlay property.  That includes the before-string or\n         after-string of an overlay, strings in display properties\n         provided by an overlay, their text properties, etc.\n\n         FROM_OVERLAY is the overlay that brought us here, or nil if none.  ") (span (|@| (class "comment-delimiter") (id "F:108598")) "*/") "\n      " (span (|@| (class "keyword") (id "F:108607")) "if") " (" (span (|@| (class "negation-char") (id "F:108611")) "!") " NILP (from_overlay))\n        " (span (|@| (class "keyword") (id "F:108635")) "for") " (i = it->sp - 1; i >= 0; i--)\n          {\n            " (span (|@| (class "keyword") (id "F:108679")) "if") " (it->stack[i].current.overlay_string_index >= 0)\n              from_overlay\n                = it->string_overlays[it->stack[i].current.overlay_string_index];\n            " (span (|@| (class "keyword") (id "F:108824")) "else") " " (span (|@| (class "keyword") (id "F:108829")) "if") " (" (span (|@| (class "negation-char") (id "F:108833")) "!") " NILP (it->stack[i].from_overlay))\n              from_overlay = it->stack[i].from_overlay;\n\n            " (span (|@| (class "keyword") (id "F:108924")) "if") " (" (span (|@| (class "negation-char") (id "F:108928")) "!") "NILP (from_overlay))\n              " (span (|@| (class "keyword") (id "F:108957")) "break") ";\n          }\n\n      " (span (|@| (class "keyword") (id "F:108976")) "if") " (" (span (|@| (class "negation-char") (id "F:108980")) "!") " NILP (from_overlay))\n        {\n          bufpos = IT_CHARPOS (*it);\n          " (span (|@| (class "comment-delimiter") (id "F:109039")) "/* ") (span (|@| (class "comment") (id "F:109042")) "For a string from an overlay, the base face depends\n             only on text properties and ignores overlays.  ") (span (|@| (class "comment-delimiter") (id "F:109147")) "*/") "\n          base_face_id\n            = face_for_overlay_string (it->w,\n                                       IT_CHARPOS (*it),\n                                       it->region_beg_charpos,\n                                       it->region_end_charpos,\n                                       &next_stop,\n                                       (IT_CHARPOS (*it)\n                                        + TEXT_PROP_DISTANCE_LIMIT),\n                                       0,\n                                       from_overlay);\n        }\n      " (span (|@| (class "keyword") (id "F:109439")) "else") "\n        {\n          bufpos = 0;\n\n          " (span (|@| (class "comment-delimiter") (id "F:109466")) "/* ") (span (|@| (class "comment") (id "F:109469")) "For strings from a `display' property, use the face at\n             IT's current buffer position as the base face to merge\n             with, so that overlay strings appear in the same face as\n             surrounding text, unless they specify their own\n             faces.  ") (span (|@| (class "comment-delimiter") (id "F:109716")) "*/") "\n          base_face_id = underlying_face_id (it);\n        }\n\n      new_face_id = face_at_string_position (it->w,\n                                             it->string,\n                                             IT_STRING_CHARPOS (*it),\n                                             bufpos,\n                                             it->region_beg_charpos,\n                                             it->region_end_charpos,\n                                             &next_stop,\n                                             base_face_id, 0);\n\n      " (span (|@| (class "comment-delimiter") (id "F:110018")) "/* ") (span (|@| (class "comment") (id "F:110021")) "Is this a start of a run of characters with box?  Caveat:\n         this can be called for a freshly allocated iterator; face_id\n         is -1 is this case.  We know that the new face will not\n         change until the next check pos, i.e. if the new face has a\n         box, all characters up to that position will have a\n         box.  But, as usual, we don't know whether that position\n         is really the end.  ") (span (|@| (class "comment-delimiter") (id "F:110397")) "*/") "\n      " (span (|@| (class "keyword") (id "F:110406")) "if") " (new_face_id != it->face_id)\n        {\n          " (span (|@| (class "keyword") (id "F:110444")) "struct") " " (span (|@| (class "type") (id "F:110451")) "face") " *" (span (|@| (class "variable-name") (id "F:110457")) "new_face") " = FACE_FROM_ID (it->f, new_face_id);\n          " (span (|@| (class "keyword") (id "F:110506")) "struct") " " (span (|@| (class "type") (id "F:110513")) "face") " *" (span (|@| (class "variable-name") (id "F:110519")) "old_face") " = FACE_FROM_ID (it->f, it->face_id);\n\n          " (span (|@| (class "comment-delimiter") (id "F:110569")) "/* ") (span (|@| (class "comment") (id "F:110572")) "If new face has a box but old face hasn't, this is the\n             start of a run of characters with box, i.e. it has a\n             shadow on the left side.  ") (span (|@| (class "comment-delimiter") (id "F:110718")) "*/") "\n          it->start_of_box_run_p\n            = new_face->box && (old_face == " (span (|@| (class "constant") (id "F:110784")) "NULL") " || " (span (|@| (class "negation-char") (id "F:110792")) "!") "old_face->box);\n          it->face_box_p = new_face->box != FACE_NO_BOX;\n        }\n    }\n\n  it->face_id = new_face_id;\n  " (span (|@| (class "keyword") (id "F:110900")) "return") " HANDLED_NORMALLY;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:110929")) "/* ") (span (|@| (class "comment") (id "F:110932")) "Return the ID of the face ``underlying'' IT's current position,\n   which is in a string.  If the iterator is associated with a\n   buffer, return the face at IT's current buffer position.\n   Otherwise, use the iterator's base_face_id.  ") (span (|@| (class "comment-delimiter") (id "F:111167")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:111171")) "static") " " (span (|@| (class "type") (id "F:111178")) "int") "\n" (span (|@| (class "function-name") (id "F:111182")) "underlying_face_id") " (" (span (|@| (class "type") (id "F:111202")) "it") ")\n     " (span (|@| (class "keyword") (id "F:111211")) "struct") " " (span (|@| (class "type") (id "F:111218")) "it") " *" (span (|@| (class "variable-name") (id "F:111222")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:111230")) "int") " " (span (|@| (class "variable-name") (id "F:111234")) "face_id") " = it->base_face_id, " (span (|@| (class "variable-name") (id "F:111262")) "i") ";\n\n  xassert (STRINGP (it->string));\n\n  " (span (|@| (class "keyword") (id "F:111303")) "for") " (i = it->sp - 1; i >= 0; --i)\n    " (span (|@| (class "keyword") (id "F:111341")) "if") " (NILP (it->stack[i].string))\n      face_id = it->stack[i].face_id;\n\n  " (span (|@| (class "keyword") (id "F:111414")) "return") " face_id;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:111434")) "/* ") (span (|@| (class "comment") (id "F:111437")) "Compute the face one character before or after the current position\n   of IT.  BEFORE_P non-zero means get the face in front of IT's\n   position.  Value is the id of the face.  ") (span (|@| (class "comment-delimiter") (id "F:111614")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:111618")) "static") " " (span (|@| (class "type") (id "F:111625")) "int") "\n" (span (|@| (class "function-name") (id "F:111629")) "face_before_or_after_it_pos") " (" (span (|@| (class "type") (id "F:111658")) "it") ", before_p)\n     " (span (|@| (class "keyword") (id "F:111677")) "struct") " " (span (|@| (class "type") (id "F:111684")) "it") " *" (span (|@| (class "variable-name") (id "F:111688")) "it") ";\n     " (span (|@| (class "type") (id "F:111697")) "int") " " (span (|@| (class "variable-name") (id "F:111701")) "before_p") ";\n{\n  " (span (|@| (class "type") (id "F:111715")) "int") " " (span (|@| (class "variable-name") (id "F:111719")) "face_id") ", " (span (|@| (class "variable-name") (id "F:111728")) "limit") ";\n  " (span (|@| (class "type") (id "F:111737")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:111747")) "next_check_charpos") ";\n  " (span (|@| (class "keyword") (id "F:111769")) "struct") " " (span (|@| (class "type") (id "F:111776")) "text_pos") " " (span (|@| (class "variable-name") (id "F:111785")) "pos") ";\n\n  xassert (it->s == " (span (|@| (class "constant") (id "F:111811")) "NULL") ");\n\n  " (span (|@| (class "keyword") (id "F:111821")) "if") " (STRINGP (it->string))\n    {\n      " (span (|@| (class "type") (id "F:111859")) "int") " " (span (|@| (class "variable-name") (id "F:111863")) "bufpos") ", " (span (|@| (class "variable-name") (id "F:111871")) "base_face_id") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:111892")) "/* ") (span (|@| (class "comment") (id "F:111895")) "No face change past the end of the string (for the case\n         we are padding with spaces).  No face change before the\n         string start.  ") (span (|@| (class "comment-delimiter") (id "F:112026")) "*/") "\n      " (span (|@| (class "keyword") (id "F:112035")) "if") " (IT_STRING_CHARPOS (*it) >= SCHARS (it->string)\n          || (IT_STRING_CHARPOS (*it) == 0 && before_p))\n        " (span (|@| (class "keyword") (id "F:112137")) "return") " it->face_id;\n\n      " (span (|@| (class "comment-delimiter") (id "F:112164")) "/* ") (span (|@| (class "comment") (id "F:112167")) "Set pos to the position before or after IT's current position.  ") (span (|@| (class "comment-delimiter") (id "F:112231")) "*/") "\n      " (span (|@| (class "keyword") (id "F:112240")) "if") " (before_p)\n        pos = string_pos (IT_STRING_CHARPOS (*it) - 1, it->string);\n      " (span (|@| (class "keyword") (id "F:112321")) "else") "\n        " (span (|@| (class "comment-delimiter") (id "F:112327")) "/* ") (span (|@| (class "comment") (id "F:112330")) "For composition, we must check the character after the\n           composition.  ") (span (|@| (class "comment-delimiter") (id "F:112410")) "*/") "\n        pos = (it->what == IT_COMPOSITION\n               ? string_pos (IT_STRING_CHARPOS (*it)\n                             + it->cmp_it.nchars, it->string)\n               : string_pos (IT_STRING_CHARPOS (*it) + 1, it->string));\n\n      " (span (|@| (class "keyword") (id "F:112607")) "if") " (it->current.overlay_string_index >= 0)\n        bufpos = IT_CHARPOS (*it);\n      " (span (|@| (class "keyword") (id "F:112684")) "else") "\n        bufpos = 0;\n\n      base_face_id = underlying_face_id (it);\n\n      " (span (|@| (class "comment-delimiter") (id "F:112756")) "/* ") (span (|@| (class "comment") (id "F:112759")) "Get the face for ASCII, or unibyte.  ") (span (|@| (class "comment-delimiter") (id "F:112796")) "*/") "\n      face_id = face_at_string_position (it->w,\n                                         it->string,\n                                         CHARPOS (pos),\n                                         bufpos,\n                                         it->region_beg_charpos,\n                                         it->region_end_charpos,\n                                         &next_check_charpos,\n                                         base_face_id, 0);\n\n      " (span (|@| (class "comment-delimiter") (id "F:113018")) "/* ") (span (|@| (class "comment") (id "F:113021")) "Correct the face for charsets different from ASCII.  Do it\n         for the multibyte case only.  The face returned above is\n         suitable for unibyte text if IT->string is unibyte.  ") (span (|@| (class "comment-delimiter") (id "F:113194")) "*/") "\n      " (span (|@| (class "keyword") (id "F:113203")) "if") " (STRING_MULTIBYTE (it->string))\n        {\n          " (span (|@| (class "keyword") (id "F:113244")) "const") " " (span (|@| (class "type") (id "F:113250")) "unsigned") " " (span (|@| (class "type") (id "F:113259")) "char") " *" (span (|@| (class "variable-name") (id "F:113265")) "p") " = SDATA (it->string) + BYTEPOS (pos);\n          " (span (|@| (class "type") (id "F:113308")) "int") " " (span (|@| (class "variable-name") (id "F:113312")) "rest") " = SBYTES (it->string) - BYTEPOS (pos);\n          " (span (|@| (class "type") (id "F:113359")) "int") " " (span (|@| (class "variable-name") (id "F:113363")) "c") ", " (span (|@| (class "variable-name") (id "F:113366")) "len") ";\n          " (span (|@| (class "keyword") (id "F:113374")) "struct") " " (span (|@| (class "type") (id "F:113381")) "face") " *" (span (|@| (class "variable-name") (id "F:113387")) "face") " = FACE_FROM_ID (it->f, face_id);\n\n          c = string_char_and_length (p, &len);\n          face_id = FACE_FOR_CHAR (it->f, face, c, CHARPOS (pos), it->string);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:113550")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:113567")) "if") " ((IT_CHARPOS (*it) >= ZV && " (span (|@| (class "negation-char") (id "F:113598")) "!") "before_p)\n          || (IT_CHARPOS (*it) <= BEGV && before_p))\n        " (span (|@| (class "keyword") (id "F:113656")) "return") " it->face_id;\n\n      limit = IT_CHARPOS (*it) + TEXT_PROP_DISTANCE_LIMIT;\n      pos = it->current.pos;\n\n      " (span (|@| (class "keyword") (id "F:113772")) "if") " (before_p)\n        DEC_TEXT_POS (pos, it->multibyte_p);\n      " (span (|@| (class "keyword") (id "F:113830")) "else") "\n        {\n          " (span (|@| (class "keyword") (id "F:113841")) "if") " (it->what == IT_COMPOSITION)\n            " (span (|@| (class "comment-delimiter") (id "F:113878")) "/* ") (span (|@| (class "comment") (id "F:113881")) "For composition, we must check the position after the\n               composition.  ") (span (|@| (class "comment-delimiter") (id "F:113957")) "*/") "\n            pos.charpos += it->cmp_it.nchars, pos.bytepos += it->len;\n          " (span (|@| (class "keyword") (id "F:114026")) "else") "\n            INC_TEXT_POS (pos, it->multibyte_p);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:114083")) "/* ") (span (|@| (class "comment") (id "F:114086")) "Determine face for CHARSET_ASCII, or unibyte.  ") (span (|@| (class "comment-delimiter") (id "F:114133")) "*/") "\n      face_id = face_at_buffer_position (it->w,\n                                         CHARPOS (pos),\n                                         it->region_beg_charpos,\n                                         it->region_end_charpos,\n                                         &next_check_charpos,\n                                         limit, 0, -1);\n\n      " (span (|@| (class "comment-delimiter") (id "F:114320")) "/* ") (span (|@| (class "comment") (id "F:114323")) "Correct the face for charsets different from ASCII.  Do it\n         for the multibyte case only.  The face returned above is\n         suitable for unibyte text if current_buffer is unibyte.  ") (span (|@| (class "comment-delimiter") (id "F:114500")) "*/") "\n      " (span (|@| (class "keyword") (id "F:114509")) "if") " (it->multibyte_p)\n        {\n          " (span (|@| (class "type") (id "F:114536")) "int") " " (span (|@| (class "variable-name") (id "F:114540")) "c") " = FETCH_MULTIBYTE_CHAR (BYTEPOS (pos));\n          " (span (|@| (class "keyword") (id "F:114585")) "struct") " " (span (|@| (class "type") (id "F:114592")) "face") " *" (span (|@| (class "variable-name") (id "F:114598")) "face") " = FACE_FROM_ID (it->f, face_id);\n          face_id = FACE_FOR_CHAR (it->f, face, c, CHARPOS (pos), Qnil);\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:114714")) "return") " face_id;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:114736")) "/***********************************************************************") (span (|@| (class "comment") (id "F:114808")) "\n                            Invisible text\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:114902")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:114906")) "/* ") (span (|@| (class "comment") (id "F:114909")) "Set up iterator IT from invisible properties at its current\n   position.  Called from handle_stop.  ") (span (|@| (class "comment-delimiter") (id "F:115009")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:115013")) "static") " " (span (|@| (class "keyword") (id "F:115020")) "enum") " " (span (|@| (class "type") (id "F:115025")) "prop_handled") "\n" (span (|@| (class "function-name") (id "F:115038")) "handle_invisible_prop") " (" (span (|@| (class "type") (id "F:115061")) "it") ")\n     " (span (|@| (class "keyword") (id "F:115070")) "struct") " " (span (|@| (class "type") (id "F:115077")) "it") " *" (span (|@| (class "variable-name") (id "F:115081")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:115089")) "enum") " " (span (|@| (class "type") (id "F:115094")) "prop_handled") " " (span (|@| (class "variable-name") (id "F:115107")) "handled") " = HANDLED_NORMALLY;\n\n  " (span (|@| (class "keyword") (id "F:115138")) "if") " (STRINGP (it->string))\n    {\n      " (span (|@| (class "keyword") (id "F:115176")) "extern") " " (span (|@| (class "type") (id "F:115183")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:115195")) "Qinvisible") ";\n      " (span (|@| (class "type") (id "F:115213")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:115225")) "prop") ", " (span (|@| (class "variable-name") (id "F:115231")) "end_charpos") ", " (span (|@| (class "variable-name") (id "F:115244")) "limit") ", " (span (|@| (class "variable-name") (id "F:115251")) "charpos") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:115267")) "/* ") (span (|@| (class "comment") (id "F:115270")) "Get the value of the invisible text property at the\n         current position.  Value will be nil if there is no such\n         property.  ") (span (|@| (class "comment-delimiter") (id "F:115394")) "*/") "\n      charpos = make_number (IT_STRING_CHARPOS (*it));\n      prop = Fget_text_property (charpos, Qinvisible, it->string);\n\n      " (span (|@| (class "keyword") (id "F:115526")) "if") " (" (span (|@| (class "negation-char") (id "F:115530")) "!") "NILP (prop)\n          && IT_STRING_CHARPOS (*it) < it->end_charpos)\n        {\n          handled = HANDLED_RECOMPUTE_PROPS;\n\n          " (span (|@| (class "comment-delimiter") (id "F:115637")) "/* ") (span (|@| (class "comment") (id "F:115640")) "Get the position at which the next change of the\n             invisible text property can be found in IT->string.\n             Value will be nil if the property value is the same for\n             all the rest of IT->string.  ") (span (|@| (class "comment-delimiter") (id "F:115844")) "*/") "\n          XSETINT (limit, SCHARS (it->string));\n          end_charpos = Fnext_single_property_change (charpos, Qinvisible,\n                                                      it->string, limit);\n\n          " (span (|@| (class "comment-delimiter") (id "F:115992")) "/* ") (span (|@| (class "comment") (id "F:115995")) "Text at current position is invisible.  The next\n             change in the property is at position end_charpos.\n             Move IT's current position to that position.  ") (span (|@| (class "comment-delimiter") (id "F:116153")) "*/") "\n          " (span (|@| (class "keyword") (id "F:116159")) "if") " (INTEGERP (end_charpos)\n              && XFASTINT (end_charpos) < XFASTINT (limit))\n            {\n              " (span (|@| (class "keyword") (id "F:116253")) "struct") " " (span (|@| (class "type") (id "F:116260")) "text_pos") " " (span (|@| (class "variable-name") (id "F:116269")) "old") ";\n              old = it->current.string_pos;\n              IT_STRING_CHARPOS (*it) = XFASTINT (end_charpos);\n              compute_string_pos (&it->current.string_pos, old, it->string);\n            }\n          " (span (|@| (class "keyword") (id "F:116448")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:116467")) "/* ") (span (|@| (class "comment") (id "F:116470")) "The rest of the string is invisible.  If this is an\n                 overlay string, proceed with the next overlay string\n                 or whatever comes and return a character from there.  ") (span (|@| (class "comment-delimiter") (id "F:116635")) "*/") "\n              " (span (|@| (class "keyword") (id "F:116645")) "if") " (it->current.overlay_string_index >= 0)\n                {\n                  next_overlay_string (it);\n                  " (span (|@| (class "comment-delimiter") (id "F:116726")) "/* ") (span (|@| (class "comment") (id "F:116729")) "Don't check for overlay strings when we just\n                     finished processing them.  ") (span (|@| (class "comment-delimiter") (id "F:116808")) "*/") "\n                  handled = HANDLED_OVERLAY_STRING_CONSUMED;\n                }\n              " (span (|@| (class "keyword") (id "F:116869")) "else") "\n                {\n                  IT_STRING_CHARPOS (*it) = SCHARS (it->string);\n                  IT_STRING_BYTEPOS (*it) = SBYTES (it->string);\n                }\n            }\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:117002")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:117019")) "int") " " (span (|@| (class "variable-name") (id "F:117023")) "invis_p") ";\n      " (span (|@| (class "type") (id "F:117038")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:117048")) "newpos") ", " (span (|@| (class "variable-name") (id "F:117056")) "next_stop") ", " (span (|@| (class "variable-name") (id "F:117067")) "start_charpos") ", " (span (|@| (class "variable-name") (id "F:117082")) "tem") ";\n      " (span (|@| (class "type") (id "F:117093")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:117105")) "pos") ", " (span (|@| (class "variable-name") (id "F:117110")) "prop") ", " (span (|@| (class "variable-name") (id "F:117116")) "overlay") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:117132")) "/* ") (span (|@| (class "comment") (id "F:117135")) "First of all, is there invisible text at this position?  ") (span (|@| (class "comment-delimiter") (id "F:117192")) "*/") "\n      tem = start_charpos = IT_CHARPOS (*it);\n      pos = make_number (tem);\n      prop = get_char_property_and_overlay (pos, Qinvisible, it->window,\n                                            &overlay);\n      invis_p = TEXT_PROP_MEANS_INVISIBLE (prop);\n\n      " (span (|@| (class "comment-delimiter") (id "F:117422")) "/* ") (span (|@| (class "comment") (id "F:117425")) "If we are on invisible text, skip over it.  ") (span (|@| (class "comment-delimiter") (id "F:117469")) "*/") "\n      " (span (|@| (class "keyword") (id "F:117478")) "if") " (invis_p && start_charpos < it->end_charpos)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:117532")) "/* ") (span (|@| (class "comment") (id "F:117535")) "Record whether we have to display an ellipsis for the\n             invisible text.  ") (span (|@| (class "comment-delimiter") (id "F:117612")) "*/") "\n          " (span (|@| (class "type") (id "F:117618")) "int") " " (span (|@| (class "variable-name") (id "F:117622")) "display_ellipsis_p") " = invis_p == 2;\n\n          handled = HANDLED_RECOMPUTE_PROPS;\n\n          " (span (|@| (class "comment-delimiter") (id "F:117700")) "/* ") (span (|@| (class "comment") (id "F:117703")) "Loop skipping over invisible text.  The loop is left at\n             ZV or with IT on the first char being visible again.  ") (span (|@| (class "comment-delimiter") (id "F:117819")) "*/") "\n          " (span (|@| (class "keyword") (id "F:117825")) "do") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:117842")) "/* ") (span (|@| (class "comment") (id "F:117845")) "Try to skip some invisible text.  Return value is the\n                 position reached which can be equal to where we start\n                 if there is nothing invisible there.  This skips both\n                 over invisible text properties and overlays with\n                 invisible property.  ") (span (|@| (class "comment-delimiter") (id "F:118089")) "*/") "\n              newpos = skip_invisible (tem, &next_stop, ZV, it->window);\n\n              " (span (|@| (class "comment-delimiter") (id "F:118166")) "/* ") (span (|@| (class "comment") (id "F:118169")) "If we skipped nothing at all we weren't at invisible\n                 text in the first place.  If everything to the end of\n                 the buffer was skipped, end the loop.  ") (span (|@| (class "comment-delimiter") (id "F:118321")) "*/") "\n              " (span (|@| (class "keyword") (id "F:118331")) "if") " (newpos == tem || newpos >= ZV)\n                invis_p = 0;\n              " (span (|@| (class "keyword") (id "F:118388")) "else") "\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:118401")) "/* ") (span (|@| (class "comment") (id "F:118404")) "We skipped some characters but not necessarily\n                     all there are.  Check if we ended up on visible\n                     text.  Fget_char_property returns the property of\n                     the char before the given position, i.e. if we\n                     get invis_p = 0, this means that the char at\n                     newpos is visible.  ") (span (|@| (class "comment-delimiter") (id "F:118696")) "*/") "\n                  pos = make_number (newpos);\n                  prop = Fget_char_property (pos, Qinvisible, it->window);\n                  invis_p = TEXT_PROP_MEANS_INVISIBLE (prop);\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:118852")) "/* ") (span (|@| (class "comment") (id "F:118855")) "If we ended up on invisible text, proceed to\n                 skip starting with next_stop.  ") (span (|@| (class "comment-delimiter") (id "F:118934")) "*/") "\n              " (span (|@| (class "keyword") (id "F:118944")) "if") " (invis_p)\n                tem = next_stop;\n\n              " (span (|@| (class "comment-delimiter") (id "F:118991")) "/* ") (span (|@| (class "comment") (id "F:118994")) "If there are adjacent invisible texts, don't lose the\n                 second one's ellipsis. ") (span (|@| (class "comment-delimiter") (id "F:119088")) "*/") "\n              " (span (|@| (class "keyword") (id "F:119105")) "if") " (invis_p == 2)\n                display_ellipsis_p = 1;\n            }\n          " (span (|@| (class "keyword") (id "F:119173")) "while") " (invis_p);\n\n          " (span (|@| (class "comment-delimiter") (id "F:119194")) "/* ") (span (|@| (class "comment") (id "F:119197")) "The position newpos is now either ZV or on visible text.  ") (span (|@| (class "comment-delimiter") (id "F:119255")) "*/") "\n          " (span (|@| (class "keyword") (id "F:119261")) "if") " (it->bidi_p && newpos < ZV)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:119306")) "/* ") (span (|@| (class "comment") (id "F:119309")) "With bidi iteration, the region of invisible text\n                 could start and/or end in the middle of a non-base\n                 embedding level.  Therefore, we need to skip\n                 invisible text using the bidi iterator, starting at\n                 IT's current position, until we find ourselves\n                 outside the invisible text.  Skipping invisible text\n                 _after_ bidi iteration avoids affecting the visual\n                 order of the displayed text when invisible properties\n                 are added or removed.  ") (span (|@| (class "comment-delimiter") (id "F:119759")) "*/") "\n              " (span (|@| (class "keyword") (id "F:119769")) "if") " (it->bidi_it.first_elt)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:119804")) "/* ") (span (|@| (class "comment") (id "F:119807")) "If we were `reseat'ed to a new paragraph,\n                     determine the paragraph base direction.  We need\n                     to do it now because next_element_from_buffer may\n                     not have a chance to do it, if we are going to\n                     skip any text at the beginning, which resets the\n                     FIRST_ELT flag.  ") (span (|@| (class "comment-delimiter") (id "F:120096")) "*/") "\n                  bidi_paragraph_init (it->paragraph_embedding, &it->bidi_it);\n                }\n              " (span (|@| (class "keyword") (id "F:120175")) "do") "\n                {\n                  bidi_move_to_visually_next (&it->bidi_it);\n                }\n              " (span (|@| (class "keyword") (id "F:120240")) "while") " (it->stop_charpos <= it->bidi_it.charpos\n                     && it->bidi_it.charpos < newpos);\n              IT_CHARPOS (*it) = it->bidi_it.charpos;\n              IT_BYTEPOS (*it) = it->bidi_it.bytepos;\n              " (span (|@| (class "comment-delimiter") (id "F:120429")) "/* ") (span (|@| (class "comment") (id "F:120432")) "If we overstepped NEWPOS, record its position in the\n                 iterator, so that we skip invisible text if later the\n                 bidi iteration lands us in the invisible region\n                 again. ") (span (|@| (class "comment-delimiter") (id "F:120603")) "*/") "\n              " (span (|@| (class "keyword") (id "F:120613")) "if") " (IT_CHARPOS (*it) >= newpos)\n                it->prev_stop = newpos;\n            }\n          " (span (|@| (class "keyword") (id "F:120681")) "else") "\n            {\n              IT_CHARPOS (*it) = newpos;\n              IT_BYTEPOS (*it) = CHAR_TO_BYTE (newpos);\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:120787")) "/* ") (span (|@| (class "comment") (id "F:120790")) "If there are before-strings at the start of invisible\n             text, and the text is invisible because of a text\n             property, arrange to show before-strings because 20.x did\n             it that way.  (If the text is invisible because of an\n             overlay property instead of a text property, this is\n             already handled in the overlay code.)  ") (span (|@| (class "comment-delimiter") (id "F:121128")) "*/") "\n          " (span (|@| (class "keyword") (id "F:121134")) "if") " (NILP (overlay)\n              && get_overlay_strings (it, it->stop_charpos))\n            {\n              handled = HANDLED_RECOMPUTE_PROPS;\n              it->stack[it->sp - 1].display_ellipsis_p = display_ellipsis_p;\n            }\n          " (span (|@| (class "keyword") (id "F:121336")) "else") " " (span (|@| (class "keyword") (id "F:121341")) "if") " (display_ellipsis_p)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:121393")) "/* ") (span (|@| (class "comment") (id "F:121396")) "Make sure that the glyphs of the ellipsis will get\n                 correct `charpos' values.  If we would not update\n                 it->position here, the glyphs would belong to the\n                 last visible character _before_ the invisible\n                 text, which confuses `set_cursor_from_row'.\n\n                 We use the last invisible position instead of the\n                 first because this way the cursor is always drawn on\n                 the first \".\" of the ellipsis, whenever PT is inside\n                 the invisible text.  Otherwise the cursor would be\n                 placed _after_ the ellipsis when the point is after the\n                 first invisible character.  ") (span (|@| (class "comment-delimiter") (id "F:122099")) "*/") "\n              " (span (|@| (class "keyword") (id "F:122109")) "if") " (" (span (|@| (class "negation-char") (id "F:122113")) "!") "STRINGP (it->object))\n                {\n                  it->position.charpos = newpos - 1;\n                  it->position.bytepos = CHAR_TO_BYTE (it->position.charpos);\n                }\n              it->ellipsis_p = 1;\n              " (span (|@| (class "comment-delimiter") (id "F:122281")) "/* ") (span (|@| (class "comment") (id "F:122284")) "Let the ellipsis display before\n                 considering any properties of the following char.\n                 Fixes jasonr@gnu.org 01 Oct 07 bug.  ") (span (|@| (class "comment-delimiter") (id "F:122409")) "*/") "\n              handled = HANDLED_RETURN;\n            }\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:122471")) "return") " handled;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:122491")) "/* ") (span (|@| (class "comment") (id "F:122494")) "Make iterator IT return `...' next.\n   Replaces LEN characters from buffer.  ") (span (|@| (class "comment-delimiter") (id "F:122571")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:122575")) "static") " " (span (|@| (class "type") (id "F:122582")) "void") "\n" (span (|@| (class "function-name") (id "F:122587")) "setup_for_ellipsis") " (" (span (|@| (class "type") (id "F:122607")) "it") ", len)\n     " (span (|@| (class "keyword") (id "F:122621")) "struct") " " (span (|@| (class "type") (id "F:122628")) "it") " *" (span (|@| (class "variable-name") (id "F:122632")) "it") ";\n     " (span (|@| (class "type") (id "F:122641")) "int") " " (span (|@| (class "variable-name") (id "F:122645")) "len") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:122654")) "/* ") (span (|@| (class "comment") (id "F:122657")) "Use the display table definition for `...'.  Invalid glyphs\n     will be handled by the method returning elements from dpvec.  ") (span (|@| (class "comment-delimiter") (id "F:122784")) "*/") "\n  " (span (|@| (class "keyword") (id "F:122789")) "if") " (it->dp && VECTORP (DISP_INVIS_VECTOR (it->dp)))\n    {\n      " (span (|@| (class "keyword") (id "F:122853")) "struct") " " (span (|@| (class "type") (id "F:122860")) "Lisp_Vector") " *" (span (|@| (class "variable-name") (id "F:122873")) "v") " = XVECTOR (DISP_INVIS_VECTOR (it->dp));\n      it->dpvec = v->contents;\n      it->dpend = v->contents + v->size;\n    }\n  " (span (|@| (class "keyword") (id "F:122995")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:123012")) "/* ") (span (|@| (class "comment") (id "F:123015")) "Default `...'.  ") (span (|@| (class "comment-delimiter") (id "F:123031")) "*/") "\n      it->dpvec = default_invis_vector;\n      it->dpend = default_invis_vector + 3;\n    }\n\n  it->dpvec_char_len = len;\n  it->current.dpvec_index = 0;\n  it->dpvec_face_id = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:123213")) "/* ") (span (|@| (class "comment") (id "F:123216")) "Remember the current face id in case glyphs specify faces.\n     IT's face is restored in set_iterator_to_next.\n     saved_face_id was set to preceding char's face in handle_stop.  ") (span (|@| (class "comment-delimiter") (id "F:123396")) "*/") "\n  " (span (|@| (class "keyword") (id "F:123401")) "if") " (it->saved_face_id < 0 || it->saved_face_id != it->face_id)\n    it->saved_face_id = it->face_id = DEFAULT_FACE_ID;\n\n  it->method = GET_FROM_DISPLAY_VECTOR;\n  it->ellipsis_p = 1;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:123588")) "/***********************************************************************") (span (|@| (class "comment") (id "F:123660")) "\n                            'display' property\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:123758")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:123762")) "/* ") (span (|@| (class "comment") (id "F:123765")) "Set up iterator IT from `display' property at its current position.\n   Called from handle_stop.\n   We return HANDLED_RETURN if some part of the display property\n   overrides the display of the buffer text itself.\n   Otherwise we return HANDLED_NORMALLY.  ") (span (|@| (class "comment-delimiter") (id "F:124020")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:124024")) "static") " " (span (|@| (class "keyword") (id "F:124031")) "enum") " " (span (|@| (class "type") (id "F:124036")) "prop_handled") "\n" (span (|@| (class "function-name") (id "F:124049")) "handle_display_prop") " (" (span (|@| (class "type") (id "F:124070")) "it") ")\n     " (span (|@| (class "keyword") (id "F:124079")) "struct") " " (span (|@| (class "type") (id "F:124086")) "it") " *" (span (|@| (class "variable-name") (id "F:124090")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:124098")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:124110")) "prop") ", " (span (|@| (class "variable-name") (id "F:124116")) "object") ", " (span (|@| (class "variable-name") (id "F:124124")) "overlay") ";\n  " (span (|@| (class "keyword") (id "F:124135")) "struct") " " (span (|@| (class "type") (id "F:124142")) "text_pos") " *" (span (|@| (class "variable-name") (id "F:124152")) "position") ";\n  " (span (|@| (class "comment-delimiter") (id "F:124164")) "/* ") (span (|@| (class "comment") (id "F:124167")) "Nonzero if some property replaces the display of the text itself.  ") (span (|@| (class "comment-delimiter") (id "F:124234")) "*/") "\n  " (span (|@| (class "type") (id "F:124239")) "int") " " (span (|@| (class "variable-name") (id "F:124243")) "display_replaced_p") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:124270")) "if") " (STRINGP (it->string))\n    {\n      object = it->string;\n      position = &it->current.string_pos;\n    }\n  " (span (|@| (class "keyword") (id "F:124379")) "else") "\n    {\n      XSETWINDOW (object, it->w);\n      position = &it->current.pos;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:124468")) "/* ") (span (|@| (class "comment") (id "F:124471")) "Reset those iterator values set from display property values.  ") (span (|@| (class "comment-delimiter") (id "F:124534")) "*/") "\n  it->slice.x = it->slice.y = it->slice.width = it->slice.height = Qnil;\n  it->space_width = Qnil;\n  it->font_height = Qnil;\n  it->voffset = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:124684")) "/* ") (span (|@| (class "comment") (id "F:124687")) "We don't support recursive `display' properties, i.e. string\n     values that have a string `display' property, that have a string\n     `display' property etc.  ") (span (|@| (class "comment-delimiter") (id "F:124848")) "*/") "\n  " (span (|@| (class "keyword") (id "F:124853")) "if") " (" (span (|@| (class "negation-char") (id "F:124857")) "!") "it->string_from_display_prop_p)\n    it->area = TEXT_AREA;\n\n  prop = get_char_property_and_overlay (make_number (position->charpos),\n                                        Qdisplay, object, &overlay);\n  " (span (|@| (class "keyword") (id "F:125026")) "if") " (NILP (prop))\n    " (span (|@| (class "keyword") (id "F:125047")) "return") " HANDLED_NORMALLY;\n  " (span (|@| (class "comment-delimiter") (id "F:125074")) "/* ") (span (|@| (class "comment") (id "F:125077")) "Now OVERLAY is the overlay that gave us this property, or nil\n     if it was a text property.  ") (span (|@| (class "comment-delimiter") (id "F:125172")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:125178")) "if") " (" (span (|@| (class "negation-char") (id "F:125182")) "!") "STRINGP (it->string))\n    object = it->w->buffer;\n\n  " (span (|@| (class "keyword") (id "F:125236")) "if") " (CONSP (prop)\n      " (span (|@| (class "comment-delimiter") (id "F:125259")) "/* ") (span (|@| (class "comment") (id "F:125262")) "Simple properties.  ") (span (|@| (class "comment-delimiter") (id "F:125282")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:125294")) "!") "EQ (XCAR (prop), Qimage)\n      && " (span (|@| (class "negation-char") (id "F:125329")) "!") "EQ (XCAR (prop), Qspace)\n      && " (span (|@| (class "negation-char") (id "F:125364")) "!") "EQ (XCAR (prop), Qwhen)\n      && " (span (|@| (class "negation-char") (id "F:125398")) "!") "EQ (XCAR (prop), Qslice)\n      && " (span (|@| (class "negation-char") (id "F:125433")) "!") "EQ (XCAR (prop), Qspace_width)\n      && " (span (|@| (class "negation-char") (id "F:125474")) "!") "EQ (XCAR (prop), Qheight)\n      && " (span (|@| (class "negation-char") (id "F:125510")) "!") "EQ (XCAR (prop), Qraise)\n      " (span (|@| (class "comment-delimiter") (id "F:125542")) "/* ") (span (|@| (class "comment") (id "F:125545")) "Marginal area specifications.  ") (span (|@| (class "comment-delimiter") (id "F:125576")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:125588")) "!") "(CONSP (XCAR (prop)) && EQ (XCAR (XCAR (prop)), Qmargin))\n      && " (span (|@| (class "negation-char") (id "F:125656")) "!") "EQ (XCAR (prop), Qleft_fringe)\n      && " (span (|@| (class "negation-char") (id "F:125697")) "!") "EQ (XCAR (prop), Qright_fringe)\n      && " (span (|@| (class "negation-char") (id "F:125739")) "!") "NILP (XCAR (prop)))\n    {\n      " (span (|@| (class "keyword") (id "F:125772")) "for") " (; CONSP (prop); prop = XCDR (prop))\n        {\n          " (span (|@| (class "keyword") (id "F:125819")) "if") " (handle_single_display_spec (it, XCAR (prop), object, overlay,\n                                          position, display_replaced_p))\n            {\n              display_replaced_p = 1;\n              " (span (|@| (class "comment-delimiter") (id "F:125968")) "/* ") (span (|@| (class "comment") (id "F:125971")) "If some text in a string is replaced, `position' no\n                 longer points to the position of `object'.  ") (span (|@| (class "comment-delimiter") (id "F:126070")) "*/") "\n              " (span (|@| (class "keyword") (id "F:126080")) "if") " (STRINGP (object))\n                " (span (|@| (class "keyword") (id "F:126104")) "break") ";\n            }\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:126129")) "else") " " (span (|@| (class "keyword") (id "F:126134")) "if") " (VECTORP (prop))\n    {\n      " (span (|@| (class "type") (id "F:126166")) "int") " " (span (|@| (class "variable-name") (id "F:126170")) "i") ";\n      " (span (|@| (class "keyword") (id "F:126179")) "for") " (i = 0; i < ASIZE (prop); ++i)\n        " (span (|@| (class "keyword") (id "F:126215")) "if") " (handle_single_display_spec (it, AREF (prop, i), object, overlay,\n                                        position, display_replaced_p))\n          {\n            display_replaced_p = 1;\n            " (span (|@| (class "comment-delimiter") (id "F:126359")) "/* ") (span (|@| (class "comment") (id "F:126362")) "If some text in a string is replaced, `position' no\n               longer points to the position of `object'.  ") (span (|@| (class "comment-delimiter") (id "F:126466")) "*/") "\n            " (span (|@| (class "keyword") (id "F:126474")) "if") " (STRINGP (object))\n              " (span (|@| (class "keyword") (id "F:126503")) "break") ";\n          }\n    }\n  " (span (|@| (class "keyword") (id "F:126523")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:126540")) "if") " (handle_single_display_spec (it, prop, object, overlay,\n                                      position, 0))\n        display_replaced_p = 1;\n    }\n\n  " (span (|@| (class "keyword") (id "F:126657")) "return") " display_replaced_p ? HANDLED_RETURN : HANDLED_NORMALLY;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:126724")) "/* ") (span (|@| (class "comment") (id "F:126727")) "Value is the position of the end of the `display' property starting\n   at START_POS in OBJECT.  ") (span (|@| (class "comment-delimiter") (id "F:126823")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:126827")) "static") " " (span (|@| (class "keyword") (id "F:126834")) "struct") " " (span (|@| (class "type") (id "F:126841")) "text_pos") "\n" (span (|@| (class "function-name") (id "F:126850")) "display_prop_end") " (" (span (|@| (class "type") (id "F:126868")) "it") ", object, start_pos)\n     " (span (|@| (class "keyword") (id "F:126896")) "struct") " " (span (|@| (class "type") (id "F:126903")) "it") " *" (span (|@| (class "variable-name") (id "F:126907")) "it") ";\n     " (span (|@| (class "type") (id "F:126916")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:126928")) "object") ";\n     " (span (|@| (class "keyword") (id "F:126941")) "struct") " " (span (|@| (class "type") (id "F:126948")) "text_pos") " " (span (|@| (class "variable-name") (id "F:126957")) "start_pos") ";\n{\n  " (span (|@| (class "type") (id "F:126972")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:126984")) "end") ";\n  " (span (|@| (class "keyword") (id "F:126991")) "struct") " " (span (|@| (class "type") (id "F:126998")) "text_pos") " " (span (|@| (class "variable-name") (id "F:127007")) "end_pos") ";\n\n  end = Fnext_single_char_property_change (make_number (CHARPOS (start_pos)),\n                                           Qdisplay, object, Qnil);\n  CHARPOS (end_pos) = XFASTINT (end);\n  " (span (|@| (class "keyword") (id "F:127168")) "if") " (STRINGP (object))\n    compute_string_pos (&end_pos, start_pos, it->string);\n  " (span (|@| (class "keyword") (id "F:127250")) "else") "\n    BYTEPOS (end_pos) = CHAR_TO_BYTE (XFASTINT (end));\n\n  " (span (|@| (class "keyword") (id "F:127313")) "return") " end_pos;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:127333")) "/* ") (span (|@| (class "comment") (id "F:127336")) "Set up IT from a single `display' specification PROP.  OBJECT\n   is the object in which the `display' property was found.  *POSITION\n   is the position at which it was found.  DISPLAY_REPLACED_P non-zero\n   means that we previously saw a display specification which already\n   replaced text display with something else, for example an image;\n   we ignore such properties after the first one has been processed.\n\n   OVERLAY is the overlay this `display' property came from,\n   or nil if it was a text property.\n\n   If PROP is a `space' or `image' specification, and in some other\n   cases too, set *POSITION to the position where the `display'\n   property ends.\n\n   Value is non-zero if something was found which replaces the display\n   of buffer or string text.  ") (span (|@| (class "comment-delimiter") (id "F:128099")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:128103")) "static") " " (span (|@| (class "type") (id "F:128110")) "int") "\n" (span (|@| (class "function-name") (id "F:128114")) "handle_single_display_spec") " (" (span (|@| (class "type") (id "F:128142")) "it") ", spec, object, overlay, position,\n                            display_replaced_before_p)\n     " (span (|@| (class "keyword") (id "F:128218")) "struct") " " (span (|@| (class "type") (id "F:128225")) "it") " *" (span (|@| (class "variable-name") (id "F:128229")) "it") ";\n     " (span (|@| (class "type") (id "F:128238")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:128250")) "spec") ";\n     " (span (|@| (class "type") (id "F:128261")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:128273")) "object") ";\n     " (span (|@| (class "type") (id "F:128286")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:128298")) "overlay") ";\n     " (span (|@| (class "keyword") (id "F:128312")) "struct") " " (span (|@| (class "type") (id "F:128319")) "text_pos") " *" (span (|@| (class "variable-name") (id "F:128329")) "position") ";\n     " (span (|@| (class "type") (id "F:128344")) "int") " " (span (|@| (class "variable-name") (id "F:128348")) "display_replaced_before_p") ";\n{\n  " (span (|@| (class "type") (id "F:128379")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:128391")) "form") ";\n  " (span (|@| (class "type") (id "F:128399")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:128411")) "location") ", " (span (|@| (class "variable-name") (id "F:128421")) "value") ";\n  " (span (|@| (class "keyword") (id "F:128430")) "struct") " " (span (|@| (class "type") (id "F:128437")) "text_pos") " " (span (|@| (class "variable-name") (id "F:128446")) "start_pos") ", " (span (|@| (class "variable-name") (id "F:128457")) "save_pos") ";\n  " (span (|@| (class "type") (id "F:128469")) "int") " " (span (|@| (class "variable-name") (id "F:128473")) "valid_p") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:128485")) "/* ") (span (|@| (class "comment") (id "F:128488")) "If SPEC is a list of the form `(when FORM . VALUE)', evaluate FORM.\n     If the result is non-nil, use VALUE instead of SPEC.  ") (span (|@| (class "comment-delimiter") (id "F:128615")) "*/") "\n  form = Qt;\n  " (span (|@| (class "keyword") (id "F:128633")) "if") " (CONSP (spec) && EQ (XCAR (spec), Qwhen))\n    {\n      spec = XCDR (spec);\n      " (span (|@| (class "keyword") (id "F:128716")) "if") " (" (span (|@| (class "negation-char") (id "F:128720")) "!") "CONSP (spec))\n        " (span (|@| (class "keyword") (id "F:128736")) "return") " 0;\n      form = XCAR (spec);\n      spec = XCDR (spec);\n    }\n\n  " (span (|@| (class "keyword") (id "F:128807")) "if") " (" (span (|@| (class "negation-char") (id "F:128811")) "!") "NILP (form) && " (span (|@| (class "negation-char") (id "F:128827")) "!") "EQ (form, Qt))\n    {\n      " (span (|@| (class "type") (id "F:128855")) "int") " " (span (|@| (class "variable-name") (id "F:128859")) "count") " = SPECPDL_INDEX ();\n      " (span (|@| (class "keyword") (id "F:128891")) "struct") " " (span (|@| (class "type") (id "F:128898")) "gcpro") " " (span (|@| (class "variable-name") (id "F:128904")) "gcpro1") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:128919")) "/* ") (span (|@| (class "comment") (id "F:128922")) "Bind `object' to the object having the `display' property, a\n         buffer or string.  Bind `position' to the position in the\n         object where the property was found, and `buffer-position'\n         to the current position in the buffer.  ") (span (|@| (class "comment-delimiter") (id "F:129146")) "*/") "\n      specbind (Qobject, object);\n      specbind (Qposition, make_number (CHARPOS (*position)));\n      specbind (Qbuffer_position,\n                make_number (STRINGP (object)\n                             ? IT_CHARPOS (*it) : CHARPOS (*position)));\n      GCPRO1 (form);\n      form = safe_eval (form);\n      UNGCPRO;\n      unbind_to (count, Qnil);\n    }\n\n  " (span (|@| (class "keyword") (id "F:129471")) "if") " (NILP (form))\n    " (span (|@| (class "keyword") (id "F:129492")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:129505")) "/* ") (span (|@| (class "comment") (id "F:129508")) "Handle `(height HEIGHT)' specifications.  ") (span (|@| (class "comment-delimiter") (id "F:129550")) "*/") "\n  " (span (|@| (class "keyword") (id "F:129555")) "if") " (CONSP (spec)\n      && EQ (XCAR (spec), Qheight)\n      && CONSP (XCDR (spec)))\n    {\n      " (span (|@| (class "keyword") (id "F:129649")) "if") " (" (span (|@| (class "negation-char") (id "F:129653")) "!") "FRAME_WINDOW_P (it->f))\n        " (span (|@| (class "keyword") (id "F:129679")) "return") " 0;\n\n      it->font_height = XCAR (XCDR (spec));\n      " (span (|@| (class "keyword") (id "F:129740")) "if") " (" (span (|@| (class "negation-char") (id "F:129744")) "!") "NILP (it->font_height))\n        {\n          " (span (|@| (class "keyword") (id "F:129775")) "struct") " " (span (|@| (class "type") (id "F:129782")) "face") " *" (span (|@| (class "variable-name") (id "F:129788")) "face") " = FACE_FROM_ID (it->f, it->face_id);\n          " (span (|@| (class "type") (id "F:129833")) "int") " " (span (|@| (class "variable-name") (id "F:129837")) "new_height") " = -1;\n\n          " (span (|@| (class "keyword") (id "F:129858")) "if") " (CONSP (it->font_height)\n              && (EQ (XCAR (it->font_height), Qplus)\n                  || EQ (XCAR (it->font_height), Qminus))\n              && CONSP (XCDR (it->font_height))\n              && INTEGERP (XCAR (XCDR (it->font_height))))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:130083")) "/* ") (span (|@| (class "comment") (id "F:130086")) "`(+ N)' or `(- N)' where N is an integer.  ") (span (|@| (class "comment-delimiter") (id "F:130129")) "*/") "\n              " (span (|@| (class "type") (id "F:130139")) "int") " " (span (|@| (class "variable-name") (id "F:130143")) "steps") " = XINT (XCAR (XCDR (it->font_height)));\n              " (span (|@| (class "keyword") (id "F:130196")) "if") " (EQ (XCAR (it->font_height), Qplus))\n                steps = - steps;\n              it->face_id = smaller_face (it->f, it->face_id, steps);\n            }\n          " (span (|@| (class "keyword") (id "F:130328")) "else") " " (span (|@| (class "keyword") (id "F:130333")) "if") " (FUNCTIONP (it->font_height))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:130380")) "/* ") (span (|@| (class "comment") (id "F:130383")) "Call function with current height as argument.\n                 Value is the new height.  ") (span (|@| (class "comment-delimiter") (id "F:130459")) "*/") "\n              " (span (|@| (class "type") (id "F:130469")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:130481")) "height") ";\n              height = safe_call1 (it->font_height,\n                                   face->lface[LFACE_HEIGHT_INDEX]);\n              " (span (|@| (class "keyword") (id "F:130582")) "if") " (NUMBERP (height))\n                new_height = XFLOATINT (height);\n            }\n          " (span (|@| (class "keyword") (id "F:130649")) "else") " " (span (|@| (class "keyword") (id "F:130654")) "if") " (NUMBERP (it->font_height))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:130699")) "/* ") (span (|@| (class "comment") (id "F:130702")) "Value is a multiple of the canonical char height.  ") (span (|@| (class "comment-delimiter") (id "F:130753")) "*/") "\n              " (span (|@| (class "keyword") (id "F:130763")) "struct") " " (span (|@| (class "type") (id "F:130770")) "face") " *" (span (|@| (class "variable-name") (id "F:130776")) "face") ";\n\n              face = FACE_FROM_ID (it->f,\n                                   lookup_basic_face (it->f, DEFAULT_FACE_ID));\n              new_height = (XFLOATINT (it->font_height)\n                            * XINT (face->lface[LFACE_HEIGHT_INDEX]));\n            }\n          " (span (|@| (class "keyword") (id "F:130979")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:130998")) "/* ") (span (|@| (class "comment") (id "F:131001")) "Evaluate IT->font_height with `height' bound to the\n                 current specified height to get the new height.  ") (span (|@| (class "comment-delimiter") (id "F:131105")) "*/") "\n              " (span (|@| (class "type") (id "F:131115")) "int") " " (span (|@| (class "variable-name") (id "F:131119")) "count") " = SPECPDL_INDEX ();\n\n              specbind (Qheight, face->lface[LFACE_HEIGHT_INDEX]);\n              value = safe_eval (it->font_height);\n              unbind_to (count, Qnil);\n\n              " (span (|@| (class "keyword") (id "F:131290")) "if") " (NUMBERP (value))\n                new_height = XFLOATINT (value);\n            }\n\n          " (span (|@| (class "keyword") (id "F:131356")) "if") " (new_height > 0)\n            it->face_id = face_with_height (it->f, it->face_id, new_height);\n        }\n\n      " (span (|@| (class "keyword") (id "F:131456")) "return") " 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:131475")) "/* ") (span (|@| (class "comment") (id "F:131478")) "Handle `(space-width WIDTH)'.  ") (span (|@| (class "comment-delimiter") (id "F:131509")) "*/") "\n  " (span (|@| (class "keyword") (id "F:131514")) "if") " (CONSP (spec)\n      && EQ (XCAR (spec), Qspace_width)\n      && CONSP (XCDR (spec)))\n    {\n      " (span (|@| (class "keyword") (id "F:131613")) "if") " (" (span (|@| (class "negation-char") (id "F:131617")) "!") "FRAME_WINDOW_P (it->f))\n        " (span (|@| (class "keyword") (id "F:131643")) "return") " 0;\n\n      value = XCAR (XCDR (spec));\n      " (span (|@| (class "keyword") (id "F:131694")) "if") " (NUMBERP (value) && XFLOATINT (value) > 0)\n        it->space_width = value;\n\n      " (span (|@| (class "keyword") (id "F:131773")) "return") " 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:131792")) "/* ") (span (|@| (class "comment") (id "F:131795")) "Handle `(slice X Y WIDTH HEIGHT)'.  ") (span (|@| (class "comment-delimiter") (id "F:131831")) "*/") "\n  " (span (|@| (class "keyword") (id "F:131836")) "if") " (CONSP (spec)\n      && EQ (XCAR (spec), Qslice))\n    {\n      " (span (|@| (class "type") (id "F:131900")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:131912")) "tem") ";\n\n      " (span (|@| (class "keyword") (id "F:131924")) "if") " (" (span (|@| (class "negation-char") (id "F:131928")) "!") "FRAME_WINDOW_P (it->f))\n        " (span (|@| (class "keyword") (id "F:131954")) "return") " 0;\n\n      " (span (|@| (class "keyword") (id "F:131971")) "if") " (tem = XCDR (spec), CONSP (tem))\n        {\n          it->slice.x = XCAR (tem);\n          " (span (|@| (class "keyword") (id "F:132042")) "if") " (tem = XCDR (tem), CONSP (tem))\n            {\n              it->slice.y = XCAR (tem);\n              " (span (|@| (class "keyword") (id "F:132124")) "if") " (tem = XCDR (tem), CONSP (tem))\n                {\n                  it->slice.width = XCAR (tem);\n                  " (span (|@| (class "keyword") (id "F:132201")) "if") " (tem = XCDR (tem), CONSP (tem))\n                    it->slice.height = XCAR (tem);\n                }\n            }\n        }\n\n      " (span (|@| (class "keyword") (id "F:132294")) "return") " 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:132313")) "/* ") (span (|@| (class "comment") (id "F:132316")) "Handle `(raise FACTOR)'.  ") (span (|@| (class "comment-delimiter") (id "F:132342")) "*/") "\n  " (span (|@| (class "keyword") (id "F:132347")) "if") " (CONSP (spec)\n      && EQ (XCAR (spec), Qraise)\n      && CONSP (XCDR (spec)))\n    {\n      " (span (|@| (class "keyword") (id "F:132440")) "if") " (" (span (|@| (class "negation-char") (id "F:132444")) "!") "FRAME_WINDOW_P (it->f))\n        " (span (|@| (class "keyword") (id "F:132470")) "return") " 0;\n\n" (span (|@| (class "preprocessor") (id "F:132481")) "#ifdef") " HAVE_WINDOW_SYSTEM\n      value = XCAR (XCDR (spec));\n      " (span (|@| (class "keyword") (id "F:132547")) "if") " (NUMBERP (value))\n        {\n          " (span (|@| (class "keyword") (id "F:132574")) "struct") " " (span (|@| (class "type") (id "F:132581")) "face") " *" (span (|@| (class "variable-name") (id "F:132587")) "face") " = FACE_FROM_ID (it->f, it->face_id);\n          it->voffset = - (XFLOATINT (value)\n                           * (FONT_HEIGHT (face->font)));\n        }\n" (span (|@| (class "preprocessor") (id "F:132707")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:132714")) "/* ") (span (|@| (class "comment") (id "F:132717")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:132736")) "*/") "\n\n      " (span (|@| (class "keyword") (id "F:132746")) "return") " 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:132765")) "/* ") (span (|@| (class "comment") (id "F:132768")) "Don't handle the other kinds of display specifications\n     inside a string that we got from a `display' property.  ") (span (|@| (class "comment-delimiter") (id "F:132884")) "*/") "\n  " (span (|@| (class "keyword") (id "F:132889")) "if") " (it->string_from_display_prop_p)\n    " (span (|@| (class "keyword") (id "F:132929")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:132942")) "/* ") (span (|@| (class "comment") (id "F:132945")) "Characters having this form of property are not displayed, so\n     we have to find the end of the property.  ") (span (|@| (class "comment-delimiter") (id "F:133054")) "*/") "\n  start_pos = *position;\n  *position = display_prop_end (it, object, start_pos);\n  value = Qnil;\n\n  " (span (|@| (class "comment-delimiter") (id "F:133157")) "/* ") (span (|@| (class "comment") (id "F:133160")) "Stop the scan at that end position--we assume that all\n     text properties change there.  ") (span (|@| (class "comment-delimiter") (id "F:133251")) "*/") "\n  it->stop_charpos = position->charpos;\n\n  " (span (|@| (class "comment-delimiter") (id "F:133297")) "/* ") (span (|@| (class "comment") (id "F:133300")) "Handle `(left-fringe BITMAP [FACE])'\n     and `(right-fringe BITMAP [FACE])'.  ") (span (|@| (class "comment-delimiter") (id "F:133379")) "*/") "\n  " (span (|@| (class "keyword") (id "F:133384")) "if") " (CONSP (spec)\n      && (EQ (XCAR (spec), Qleft_fringe)\n          || EQ (XCAR (spec), Qright_fringe))\n      && CONSP (XCDR (spec)))\n    {\n      " (span (|@| (class "type") (id "F:133523")) "int") " " (span (|@| (class "variable-name") (id "F:133527")) "face_id") " = lookup_basic_face (it->f, DEFAULT_FACE_ID);\n      " (span (|@| (class "type") (id "F:133587")) "int") " " (span (|@| (class "variable-name") (id "F:133591")) "fringe_bitmap") ";\n\n      " (span (|@| (class "keyword") (id "F:133613")) "if") " (" (span (|@| (class "negation-char") (id "F:133617")) "!") "FRAME_WINDOW_P (it->f))\n        " (span (|@| (class "comment-delimiter") (id "F:133643")) "/* ") (span (|@| (class "comment") (id "F:133646")) "If we return here, POSITION has been advanced\n           across the text with this property.  ") (span (|@| (class "comment-delimiter") (id "F:133733")) "*/") "\n        " (span (|@| (class "keyword") (id "F:133737")) "return") " 0;\n\n" (span (|@| (class "preprocessor") (id "F:133748")) "#ifdef") " HAVE_WINDOW_SYSTEM\n      value = XCAR (XCDR (spec));\n      " (span (|@| (class "keyword") (id "F:133814")) "if") " (" (span (|@| (class "negation-char") (id "F:133818")) "!") "SYMBOLP (value)\n          || " (span (|@| (class "negation-char") (id "F:133841")) "!") "(fringe_bitmap = lookup_fringe_bitmap (value)))\n        " (span (|@| (class "comment-delimiter") (id "F:133891")) "/* ") (span (|@| (class "comment") (id "F:133894")) "If we return here, POSITION has been advanced\n           across the text with this property.  ") (span (|@| (class "comment-delimiter") (id "F:133981")) "*/") "\n        " (span (|@| (class "keyword") (id "F:133985")) "return") " 0;\n\n      " (span (|@| (class "keyword") (id "F:134002")) "if") " (CONSP (XCDR (XCDR (spec))))\n        {\n          " (span (|@| (class "type") (id "F:134040")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:134052")) "face_name") " = XCAR (XCDR (XCDR (spec)));\n          " (span (|@| (class "type") (id "F:134094")) "int") " " (span (|@| (class "variable-name") (id "F:134098")) "face_id2") " = lookup_derived_face (it->f, face_name,\n                                              FRINGE_FACE_ID, 0);\n          " (span (|@| (class "keyword") (id "F:134182")) "if") " (face_id2 >= 0)\n            face_id = face_id2;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:134236")) "/* ") (span (|@| (class "comment") (id "F:134239")) "Save current settings of IT so that we can restore them\n         when we are finished with the glyph property value.  ") (span (|@| (class "comment-delimiter") (id "F:134350")) "*/") "\n\n      save_pos = it->position;\n      it->position = *position;\n      push_it (it);\n      it->position = save_pos;\n\n      it->area = TEXT_AREA;\n      it->what = IT_IMAGE;\n      it->image_id = -1; " (span (|@| (class "comment-delimiter") (id "F:134549")) "/* ") (span (|@| (class "comment") (id "F:134552")) "no image ") (span (|@| (class "comment-delimiter") (id "F:134561")) "*/") "\n      it->position = start_pos;\n      it->object = NILP (object) ? it->w->buffer : object;\n      it->method = GET_FROM_IMAGE;\n      it->from_overlay = Qnil;\n      it->face_id = face_id;\n\n      " (span (|@| (class "comment-delimiter") (id "F:134757")) "/* ") (span (|@| (class "comment") (id "F:134760")) "Say that we haven't consumed the characters with\n         `display' property yet.  The call to pop_it in\n         set_iterator_to_next will clean this up.  ") (span (|@| (class "comment-delimiter") (id "F:134902")) "*/") "\n      *position = start_pos;\n\n      " (span (|@| (class "keyword") (id "F:134941")) "if") " (EQ (XCAR (spec), Qleft_fringe))\n        {\n          it->left_user_fringe_bitmap = fringe_bitmap;\n          it->left_user_fringe_face_id = face_id;\n        }\n      " (span (|@| (class "keyword") (id "F:135080")) "else") "\n        {\n          it->right_user_fringe_bitmap = fringe_bitmap;\n          it->right_user_fringe_face_id = face_id;\n        }\n" (span (|@| (class "preprocessor") (id "F:135191")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:135198")) "/* ") (span (|@| (class "comment") (id "F:135201")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:135220")) "*/") "\n      " (span (|@| (class "keyword") (id "F:135229")) "return") " 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:135248")) "/* ") (span (|@| (class "comment") (id "F:135251")) "Prepare to handle `((margin left-margin) ...)',\n     `((margin right-margin) ...)' and `((margin nil) ...)'\n     prefixes for display specifications.  ") (span (|@| (class "comment-delimiter") (id "F:135402")) "*/") "\n  location = Qunbound;\n  " (span (|@| (class "keyword") (id "F:135430")) "if") " (CONSP (spec) && CONSP (XCAR (spec)))\n    {\n      " (span (|@| (class "type") (id "F:135483")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:135495")) "tem") ";\n\n      value = XCDR (spec);\n      " (span (|@| (class "keyword") (id "F:135534")) "if") " (CONSP (value))\n        value = XCAR (value);\n\n      tem = XCAR (spec);\n      " (span (|@| (class "keyword") (id "F:135608")) "if") " (EQ (XCAR (tem), Qmargin)\n          && (tem = XCDR (tem),\n              tem = CONSP (tem) ? XCAR (tem) : Qnil,\n              (NILP (tem)\n               || EQ (tem, Qleft_margin)\n               || EQ (tem, Qright_margin))))\n        location = tem;\n    }\n\n  " (span (|@| (class "keyword") (id "F:135825")) "if") " (EQ (location, Qunbound))\n    {\n      location = Qnil;\n      value = spec;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:135912")) "/* ") (span (|@| (class "comment") (id "F:135915")) "After this point, VALUE is the property after any\n     margin prefix has been stripped.  It must be a string,\n     an image specification, or `(space ...)'.\n\n     LOCATION specifies where to display: `left-margin',\n     `right-margin' or nil.  ") (span (|@| (class "comment-delimiter") (id "F:136159")) "*/") "\n\n  valid_p = (STRINGP (value)\n" (span (|@| (class "preprocessor") (id "F:136192")) "#ifdef") " HAVE_WINDOW_SYSTEM\n             || (FRAME_WINDOW_P (it->f) && valid_image_p (value))\n" (span (|@| (class "preprocessor") (id "F:136284")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:136291")) "/* ") (span (|@| (class "comment") (id "F:136294")) "not HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:136317")) "*/") "\n             || (CONSP (value) && EQ (XCAR (value), Qspace)));\n\n  " (span (|@| (class "keyword") (id "F:136386")) "if") " (valid_p && " (span (|@| (class "negation-char") (id "F:136401")) "!") "display_replaced_before_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:136441")) "/* ") (span (|@| (class "comment") (id "F:136444")) "Save current settings of IT so that we can restore them\n         when we are finished with the glyph property value.  ") (span (|@| (class "comment-delimiter") (id "F:136555")) "*/") "\n      save_pos = it->position;\n      it->position = *position;\n      push_it (it);\n      it->position = save_pos;\n      it->from_overlay = overlay;\n\n      " (span (|@| (class "keyword") (id "F:136713")) "if") " (NILP (location))\n        it->area = TEXT_AREA;\n      " (span (|@| (class "keyword") (id "F:136763")) "else") " " (span (|@| (class "keyword") (id "F:136768")) "if") " (EQ (location, Qleft_margin))\n        it->area = LEFT_MARGIN_AREA;\n      " (span (|@| (class "keyword") (id "F:136837")) "else") "\n        it->area = RIGHT_MARGIN_AREA;\n\n      " (span (|@| (class "keyword") (id "F:136880")) "if") " (STRINGP (value))\n        {\n          it->string = value;\n          it->multibyte_p = STRING_MULTIBYTE (it->string);\n          it->current.overlay_string_index = -1;\n          IT_STRING_CHARPOS (*it) = IT_STRING_BYTEPOS (*it) = 0;\n          it->end_charpos = it->string_nchars = SCHARS (it->string);\n          it->method = GET_FROM_STRING;\n          it->stop_charpos = 0;\n          it->string_from_display_prop_p = 1;\n          " (span (|@| (class "comment-delimiter") (id "F:137241")) "/* ") (span (|@| (class "comment") (id "F:137244")) "Say that we haven't consumed the characters with\n             `display' property yet.  The call to pop_it in\n             set_iterator_to_next will clean this up.  ") (span (|@| (class "comment-delimiter") (id "F:137394")) "*/") "\n          " (span (|@| (class "keyword") (id "F:137400")) "if") " (BUFFERP (object))\n            *position = start_pos;\n        }\n      " (span (|@| (class "keyword") (id "F:137459")) "else") " " (span (|@| (class "keyword") (id "F:137464")) "if") " (CONSP (value) && EQ (XCAR (value), Qspace))\n        {\n          it->method = GET_FROM_STRETCH;\n          it->object = value;\n          *position = it->position = start_pos;\n        }\n" (span (|@| (class "preprocessor") (id "F:137616")) "#ifdef") " HAVE_WINDOW_SYSTEM\n      " (span (|@| (class "keyword") (id "F:137648")) "else") "\n        {\n          it->what = IT_IMAGE;\n          it->image_id = lookup_image (it->f, value);\n          it->position = start_pos;\n          it->object = NILP (object) ? it->w->buffer : object;\n          it->method = GET_FROM_IMAGE;\n\n          " (span (|@| (class "comment-delimiter") (id "F:137848")) "/* ") (span (|@| (class "comment") (id "F:137851")) "Say that we haven't consumed the characters with\n             `display' property yet.  The call to pop_it in\n             set_iterator_to_next will clean this up.  ") (span (|@| (class "comment-delimiter") (id "F:138001")) "*/") "\n          *position = start_pos;\n        }\n" (span (|@| (class "preprocessor") (id "F:138033")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:138040")) "/* ") (span (|@| (class "comment") (id "F:138043")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:138062")) "*/") "\n\n      " (span (|@| (class "keyword") (id "F:138072")) "return") " 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:138091")) "/* ") (span (|@| (class "comment") (id "F:138094")) "Invalid property or property not supported.  Restore\n     POSITION to what it was before.  ") (span (|@| (class "comment-delimiter") (id "F:138185")) "*/") "\n  *position = start_pos;\n  " (span (|@| (class "keyword") (id "F:138215")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:138229")) "/* ") (span (|@| (class "comment") (id "F:138232")) "Check if SPEC is a display sub-property value whose text should be\n   treated as intangible.  ") (span (|@| (class "comment-delimiter") (id "F:138326")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:138330")) "static") " " (span (|@| (class "type") (id "F:138337")) "int") "\n" (span (|@| (class "function-name") (id "F:138341")) "single_display_spec_intangible_p") " (prop)\n     " (span (|@| (class "type") (id "F:138386")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:138398")) "prop") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:138408")) "/* ") (span (|@| (class "comment") (id "F:138411")) "Skip over `when FORM'.  ") (span (|@| (class "comment-delimiter") (id "F:138435")) "*/") "\n  " (span (|@| (class "keyword") (id "F:138440")) "if") " (CONSP (prop) && EQ (XCAR (prop), Qwhen))\n    {\n      prop = XCDR (prop);\n      " (span (|@| (class "keyword") (id "F:138523")) "if") " (" (span (|@| (class "negation-char") (id "F:138527")) "!") "CONSP (prop))\n        " (span (|@| (class "keyword") (id "F:138543")) "return") " 0;\n      prop = XCDR (prop);\n    }\n\n  " (span (|@| (class "keyword") (id "F:138588")) "if") " (STRINGP (prop))\n    " (span (|@| (class "keyword") (id "F:138612")) "return") " 1;\n\n  " (span (|@| (class "keyword") (id "F:138625")) "if") " (" (span (|@| (class "negation-char") (id "F:138629")) "!") "CONSP (prop))\n    " (span (|@| (class "keyword") (id "F:138648")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:138661")) "/* ") (span (|@| (class "comment") (id "F:138664")) "Skip over `margin LOCATION'.  If LOCATION is in the margins,\n     we don't need to treat text as intangible.  ") (span (|@| (class "comment-delimiter") (id "F:138774")) "*/") "\n  " (span (|@| (class "keyword") (id "F:138779")) "if") " (EQ (XCAR (prop), Qmargin))\n    {\n      prop = XCDR (prop);\n      " (span (|@| (class "keyword") (id "F:138848")) "if") " (" (span (|@| (class "negation-char") (id "F:138852")) "!") "CONSP (prop))\n        " (span (|@| (class "keyword") (id "F:138868")) "return") " 0;\n\n      prop = XCDR (prop);\n      " (span (|@| (class "keyword") (id "F:138911")) "if") " (" (span (|@| (class "negation-char") (id "F:138915")) "!") "CONSP (prop)\n          || EQ (XCAR (prop), Qleft_margin)\n          || EQ (XCAR (prop), Qright_margin))\n        " (span (|@| (class "keyword") (id "F:139006")) "return") " 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:139025")) "return") " (CONSP (prop)\n          && (EQ (XCAR (prop), Qimage)\n              || EQ (XCAR (prop), Qspace)));\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:139120")) "/* ") (span (|@| (class "comment") (id "F:139123")) "Check if PROP is a display property value whose text should be\n   treated as intangible.  ") (span (|@| (class "comment-delimiter") (id "F:139213")) "*/") "\n\n" (span (|@| (class "type") (id "F:139217")) "int") "\n" (span (|@| (class "function-name") (id "F:139221")) "display_prop_intangible_p") " (prop)\n     " (span (|@| (class "type") (id "F:139259")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:139271")) "prop") ";\n{\n  " (span (|@| (class "keyword") (id "F:139281")) "if") " (CONSP (prop)\n      && CONSP (XCAR (prop))\n      && " (span (|@| (class "negation-char") (id "F:139336")) "!") "EQ (Qmargin, XCAR (XCAR (prop))))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:139383")) "/* ") (span (|@| (class "comment") (id "F:139386")) "A list of sub-properties.  ") (span (|@| (class "comment-delimiter") (id "F:139413")) "*/") "\n      " (span (|@| (class "keyword") (id "F:139422")) "while") " (CONSP (prop))\n        {\n          " (span (|@| (class "keyword") (id "F:139449")) "if") " (single_display_spec_intangible_p (XCAR (prop)))\n            " (span (|@| (class "keyword") (id "F:139506")) "return") " 1;\n          prop = XCDR (prop);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:139550")) "else") " " (span (|@| (class "keyword") (id "F:139555")) "if") " (VECTORP (prop))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:139587")) "/* ") (span (|@| (class "comment") (id "F:139590")) "A vector of sub-properties.  ") (span (|@| (class "comment-delimiter") (id "F:139619")) "*/") "\n      " (span (|@| (class "type") (id "F:139628")) "int") " " (span (|@| (class "variable-name") (id "F:139632")) "i") ";\n      " (span (|@| (class "keyword") (id "F:139641")) "for") " (i = 0; i < ASIZE (prop); ++i)\n        " (span (|@| (class "keyword") (id "F:139677")) "if") " (single_display_spec_intangible_p (AREF (prop, i)))\n          " (span (|@| (class "keyword") (id "F:139735")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:139753")) "else") "\n    " (span (|@| (class "keyword") (id "F:139762")) "return") " single_display_spec_intangible_p (prop);\n\n  " (span (|@| (class "keyword") (id "F:139813")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:139827")) "/* ") (span (|@| (class "comment") (id "F:139830")) "Return 1 if PROP is a display sub-property value containing STRING.  ") (span (|@| (class "comment-delimiter") (id "F:139899")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:139903")) "static") " " (span (|@| (class "type") (id "F:139910")) "int") "\n" (span (|@| (class "function-name") (id "F:139914")) "single_display_spec_string_p") " (prop, string)\n     " (span (|@| (class "type") (id "F:139963")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:139975")) "prop") ", " (span (|@| (class "variable-name") (id "F:139981")) "string") ";\n{\n  " (span (|@| (class "keyword") (id "F:139993")) "if") " (EQ (string, prop))\n    " (span (|@| (class "keyword") (id "F:140020")) "return") " 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:140033")) "/* ") (span (|@| (class "comment") (id "F:140036")) "Skip over `when FORM'.  ") (span (|@| (class "comment-delimiter") (id "F:140060")) "*/") "\n  " (span (|@| (class "keyword") (id "F:140065")) "if") " (CONSP (prop) && EQ (XCAR (prop), Qwhen))\n    {\n      prop = XCDR (prop);\n      " (span (|@| (class "keyword") (id "F:140148")) "if") " (" (span (|@| (class "negation-char") (id "F:140152")) "!") "CONSP (prop))\n        " (span (|@| (class "keyword") (id "F:140168")) "return") " 0;\n      prop = XCDR (prop);\n    }\n\n  " (span (|@| (class "keyword") (id "F:140213")) "if") " (CONSP (prop))\n    " (span (|@| (class "comment-delimiter") (id "F:140235")) "/* ") (span (|@| (class "comment") (id "F:140238")) "Skip over `margin LOCATION'.  ") (span (|@| (class "comment-delimiter") (id "F:140268")) "*/") "\n    " (span (|@| (class "keyword") (id "F:140275")) "if") " (EQ (XCAR (prop), Qmargin))\n      {\n        prop = XCDR (prop);\n        " (span (|@| (class "keyword") (id "F:140336")) "if") " (" (span (|@| (class "negation-char") (id "F:140340")) "!") "CONSP (prop))\n          " (span (|@| (class "keyword") (id "F:140358")) "return") " 0;\n\n        prop = XCDR (prop);\n        " (span (|@| (class "keyword") (id "F:140391")) "if") " (" (span (|@| (class "negation-char") (id "F:140395")) "!") "CONSP (prop))\n          " (span (|@| (class "keyword") (id "F:140413")) "return") " 0;\n      }\n\n  " (span (|@| (class "keyword") (id "F:140434")) "return") " CONSP (prop) && EQ (XCAR (prop), string);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:140487")) "/* ") (span (|@| (class "comment") (id "F:140490")) "Return 1 if STRING appears in the `display' property PROP.  ") (span (|@| (class "comment-delimiter") (id "F:140550")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:140554")) "static") " " (span (|@| (class "type") (id "F:140561")) "int") "\n" (span (|@| (class "function-name") (id "F:140565")) "display_prop_string_p") " (prop, string)\n     " (span (|@| (class "type") (id "F:140607")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:140619")) "prop") ", " (span (|@| (class "variable-name") (id "F:140625")) "string") ";\n{\n  " (span (|@| (class "keyword") (id "F:140637")) "if") " (CONSP (prop)\n      && CONSP (XCAR (prop))\n      && " (span (|@| (class "negation-char") (id "F:140692")) "!") "EQ (Qmargin, XCAR (XCAR (prop))))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:140739")) "/* ") (span (|@| (class "comment") (id "F:140742")) "A list of sub-properties.  ") (span (|@| (class "comment-delimiter") (id "F:140769")) "*/") "\n      " (span (|@| (class "keyword") (id "F:140778")) "while") " (CONSP (prop))\n        {\n          " (span (|@| (class "keyword") (id "F:140805")) "if") " (single_display_spec_string_p (XCAR (prop), string))\n            " (span (|@| (class "keyword") (id "F:140866")) "return") " 1;\n          prop = XCDR (prop);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:140910")) "else") " " (span (|@| (class "keyword") (id "F:140915")) "if") " (VECTORP (prop))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:140947")) "/* ") (span (|@| (class "comment") (id "F:140950")) "A vector of sub-properties.  ") (span (|@| (class "comment-delimiter") (id "F:140979")) "*/") "\n      " (span (|@| (class "type") (id "F:140988")) "int") " " (span (|@| (class "variable-name") (id "F:140992")) "i") ";\n      " (span (|@| (class "keyword") (id "F:141001")) "for") " (i = 0; i < ASIZE (prop); ++i)\n        " (span (|@| (class "keyword") (id "F:141037")) "if") " (single_display_spec_string_p (AREF (prop, i), string))\n          " (span (|@| (class "keyword") (id "F:141099")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:141117")) "else") "\n    " (span (|@| (class "keyword") (id "F:141126")) "return") " single_display_spec_string_p (prop, string);\n\n  " (span (|@| (class "keyword") (id "F:141181")) "return") " 0;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:141194")) "/* ") (span (|@| (class "comment") (id "F:141197")) "Look for STRING in overlays and text properties in W's buffer,\n   between character positions FROM and TO (excluding TO).\n   BACK_P non-zero means look back (in this case, TO is supposed to be\n   less than FROM).\n   Value is the first character position where STRING was found, or\n   zero if it wasn't found before hitting TO.\n\n   W's buffer must be current.\n\n   This function may only use code that doesn't eval because it is\n   called asynchronously from note_mouse_highlight.  ") (span (|@| (class "comment-delimiter") (id "F:141677")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:141681")) "static") " " (span (|@| (class "type") (id "F:141688")) "EMACS_INT") "\n" (span (|@| (class "function-name") (id "F:141698")) "string_buffer_position_lim") " (w, string, from, to, back_p)\n     " (span (|@| (class "keyword") (id "F:141760")) "struct") " " (span (|@| (class "type") (id "F:141767")) "window") " *" (span (|@| (class "variable-name") (id "F:141775")) "w") ";\n     " (span (|@| (class "type") (id "F:141783")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:141795")) "string") ";\n     " (span (|@| (class "type") (id "F:141808")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:141818")) "from") ", " (span (|@| (class "variable-name") (id "F:141824")) "to") ";\n     " (span (|@| (class "type") (id "F:141833")) "int") " " (span (|@| (class "variable-name") (id "F:141837")) "back_p") ";\n{\n  " (span (|@| (class "type") (id "F:141849")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:141861")) "limit") ", " (span (|@| (class "variable-name") (id "F:141868")) "prop") ", " (span (|@| (class "variable-name") (id "F:141874")) "pos") ";\n  " (span (|@| (class "type") (id "F:141881")) "int") " " (span (|@| (class "variable-name") (id "F:141885")) "found") " = 0;\n\n  pos = make_number (from);\n\n  " (span (|@| (class "keyword") (id "F:141928")) "if") " (" (span (|@| (class "negation-char") (id "F:141932")) "!") "back_p)  " (span (|@| (class "comment-delimiter") (id "F:141941")) "/* ") (span (|@| (class "comment") (id "F:141944")) "looking forward ") (span (|@| (class "comment-delimiter") (id "F:141960")) "*/") "\n    {\n      limit = make_number (min (to, ZV));\n      " (span (|@| (class "keyword") (id "F:142017")) "while") " (" (span (|@| (class "negation-char") (id "F:142024")) "!") "found && " (span (|@| (class "negation-char") (id "F:142034")) "!") "EQ (pos, limit))\n        {\n          prop = Fget_char_property (pos, Qdisplay, Qnil);\n          " (span (|@| (class "keyword") (id "F:142110")) "if") " (" (span (|@| (class "negation-char") (id "F:142114")) "!") "NILP (prop) && display_prop_string_p (prop, string))\n            found = 1;\n          " (span (|@| (class "keyword") (id "F:142187")) "else") "\n            pos = Fnext_single_char_property_change (pos, Qdisplay, Qnil,\n                                                     limit);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:142289")) "else") "          " (span (|@| (class "comment-delimiter") (id "F:142295")) "/* ") (span (|@| (class "comment") (id "F:142298")) "looking back ") (span (|@| (class "comment-delimiter") (id "F:142311")) "*/") "\n    {\n      limit = make_number (max (to, BEGV));\n      " (span (|@| (class "keyword") (id "F:142370")) "while") " (" (span (|@| (class "negation-char") (id "F:142377")) "!") "found && " (span (|@| (class "negation-char") (id "F:142387")) "!") "EQ (pos, limit))\n        {\n          prop = Fget_char_property (pos, Qdisplay, Qnil);\n          " (span (|@| (class "keyword") (id "F:142463")) "if") " (" (span (|@| (class "negation-char") (id "F:142467")) "!") "NILP (prop) && display_prop_string_p (prop, string))\n            found = 1;\n          " (span (|@| (class "keyword") (id "F:142540")) "else") "\n            pos = Fprevious_single_char_property_change (pos, Qdisplay, Qnil,\n                                                         limit);\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:142644")) "return") " found ? XINT (pos) : 0;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:142678")) "/* ") (span (|@| (class "comment") (id "F:142681")) "Determine which buffer position in W's buffer STRING comes from.\n   AROUND_CHARPOS is an approximate position where it could come from.\n   Value is the buffer position or 0 if it couldn't be determined.\n\n   W's buffer must be current.\n\n   This function is necessary because we don't record buffer positions\n   in glyphs generated from strings (to keep struct glyph small).\n   This function may only use code that doesn't eval because it is\n   called asynchronously from note_mouse_highlight.  ") (span (|@| (class "comment-delimiter") (id "F:143174")) "*/") "\n\n" (span (|@| (class "type") (id "F:143178")) "EMACS_INT") "\n" (span (|@| (class "function-name") (id "F:143188")) "string_buffer_position") " (w, string, around_charpos)\n     " (span (|@| (class "keyword") (id "F:143244")) "struct") " " (span (|@| (class "type") (id "F:143251")) "window") " *" (span (|@| (class "variable-name") (id "F:143259")) "w") ";\n     " (span (|@| (class "type") (id "F:143267")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:143279")) "string") ";\n     " (span (|@| (class "type") (id "F:143292")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:143302")) "around_charpos") ";\n{\n  " (span (|@| (class "type") (id "F:143322")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:143334")) "limit") ", " (span (|@| (class "variable-name") (id "F:143341")) "prop") ", " (span (|@| (class "variable-name") (id "F:143347")) "pos") ";\n  " (span (|@| (class "keyword") (id "F:143354")) "const") " " (span (|@| (class "type") (id "F:143360")) "int") " " (span (|@| (class "variable-name") (id "F:143364")) "MAX_DISTANCE") " = 1000;\n  " (span (|@| (class "type") (id "F:143387")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:143397")) "found") " = string_buffer_position_lim (w, string, around_charpos,\n                                                around_charpos + MAX_DISTANCE,\n                                                0);\n\n  " (span (|@| (class "keyword") (id "F:143510")) "if") " (" (span (|@| (class "negation-char") (id "F:143514")) "!") "found)\n    found = string_buffer_position_lim (w, string, around_charpos,\n                                        around_charpos - MAX_DISTANCE, 1);\n  " (span (|@| (class "keyword") (id "F:143631")) "return") " found;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:143651")) "/***********************************************************************") (span (|@| (class "comment") (id "F:143723")) "\n                        `composition' property\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:143821")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:143825")) "/* ") (span (|@| (class "comment") (id "F:143828")) "Set up iterator IT from `composition' property at its current\n   position.  Called from handle_stop.  ") (span (|@| (class "comment-delimiter") (id "F:143930")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:143934")) "static") " " (span (|@| (class "keyword") (id "F:143941")) "enum") " " (span (|@| (class "type") (id "F:143946")) "prop_handled") "\n" (span (|@| (class "function-name") (id "F:143959")) "handle_composition_prop") " (" (span (|@| (class "type") (id "F:143984")) "it") ")\n     " (span (|@| (class "keyword") (id "F:143993")) "struct") " " (span (|@| (class "type") (id "F:144000")) "it") " *" (span (|@| (class "variable-name") (id "F:144004")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:144012")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:144024")) "prop") ", " (span (|@| (class "variable-name") (id "F:144030")) "string") ";\n  " (span (|@| (class "type") (id "F:144040")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:144050")) "pos") ", " (span (|@| (class "variable-name") (id "F:144055")) "pos_byte") ", " (span (|@| (class "variable-name") (id "F:144065")) "start") ", " (span (|@| (class "variable-name") (id "F:144072")) "end") ";\n\n  " (span (|@| (class "keyword") (id "F:144080")) "if") " (STRINGP (it->string))\n    {\n      " (span (|@| (class "type") (id "F:144118")) "unsigned") " " (span (|@| (class "type") (id "F:144127")) "char") " *" (span (|@| (class "variable-name") (id "F:144133")) "s") ";\n\n      pos = IT_STRING_CHARPOS (*it);\n      pos_byte = IT_STRING_BYTEPOS (*it);\n      string = it->string;\n      s = SDATA (string) + pos_byte;\n      it->c = STRING_CHAR (s);\n    }\n  " (span (|@| (class "keyword") (id "F:144319")) "else") "\n    {\n      pos = IT_CHARPOS (*it);\n      pos_byte = IT_BYTEPOS (*it);\n      string = Qnil;\n      it->c = FETCH_CHAR (pos_byte);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:144462")) "/* ") (span (|@| (class "comment") (id "F:144465")) "If there's a valid composition and point is not inside of the\n     composition (in the case that the composition is from the current\n     buffer), draw a glyph composed from the composition components.  ") (span (|@| (class "comment-delimiter") (id "F:144668")) "*/") "\n  " (span (|@| (class "keyword") (id "F:144673")) "if") " (find_composition (pos, -1, &start, &end, &prop, string)\n      && COMPOSITION_VALID_P (start, end, prop)\n      && (STRINGP (it->string) || (PT <= start || PT >= end)))\n    {\n      " (span (|@| (class "keyword") (id "F:144856")) "if") " (start != pos)\n        {\n          " (span (|@| (class "keyword") (id "F:144880")) "if") " (STRINGP (it->string))\n            pos_byte = string_char_to_byte (it->string, start);\n          " (span (|@| (class "keyword") (id "F:144966")) "else") "\n            pos_byte = CHAR_TO_BYTE (start);\n        }\n      it->cmp_it.id = get_composition_id (start, pos_byte, end - start,\n                                               prop, string);\n\n      " (span (|@| (class "keyword") (id "F:145118")) "if") " (it->cmp_it.id >= 0)\n        {\n          it->cmp_it.ch = -1;\n          it->cmp_it.nchars = COMPOSITION_LENGTH (prop);\n          it->cmp_it.nglyphs = -1;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:145258")) "return") " HANDLED_NORMALLY;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:145289")) "/***********************************************************************") (span (|@| (class "comment") (id "F:145361")) "\n                           Overlay strings\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:145455")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:145459")) "/* ") (span (|@| (class "comment") (id "F:145462")) "The following structure is used to record overlay strings for\n   later sorting in load_overlay_strings.  ") (span (|@| (class "comment-delimiter") (id "F:145567")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:145571")) "struct") " " (span (|@| (class "type") (id "F:145578")) "overlay_entry") "\n{\n  " (span (|@| (class "type") (id "F:145596")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:145608")) "overlay") ";\n  " (span (|@| (class "type") (id "F:145619")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:145631")) "string") ";\n  " (span (|@| (class "type") (id "F:145641")) "int") " " (span (|@| (class "variable-name") (id "F:145645")) "priority") ";\n  " (span (|@| (class "type") (id "F:145657")) "int") " " (span (|@| (class "variable-name") (id "F:145661")) "after_string_p") ";\n};\n\n\n" (span (|@| (class "comment-delimiter") (id "F:145682")) "/* ") (span (|@| (class "comment") (id "F:145685")) "Set up iterator IT from overlay strings at its current position.\n   Called from handle_stop.  ") (span (|@| (class "comment-delimiter") (id "F:145779")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:145783")) "static") " " (span (|@| (class "keyword") (id "F:145790")) "enum") " " (span (|@| (class "type") (id "F:145795")) "prop_handled") "\n" (span (|@| (class "function-name") (id "F:145808")) "handle_overlay_change") " (" (span (|@| (class "type") (id "F:145831")) "it") ")\n     " (span (|@| (class "keyword") (id "F:145840")) "struct") " " (span (|@| (class "type") (id "F:145847")) "it") " *" (span (|@| (class "variable-name") (id "F:145851")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:145859")) "if") " (" (span (|@| (class "negation-char") (id "F:145863")) "!") "STRINGP (it->string) && get_overlay_strings (it, 0))\n    " (span (|@| (class "keyword") (id "F:145921")) "return") " HANDLED_RECOMPUTE_PROPS;\n  " (span (|@| (class "keyword") (id "F:145955")) "else") "\n    " (span (|@| (class "keyword") (id "F:145964")) "return") " HANDLED_NORMALLY;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:145993")) "/* ") (span (|@| (class "comment") (id "F:145996")) "Set up the next overlay string for delivery by IT, if there is an\n   overlay string to deliver.  Called by set_iterator_to_next when the\n   end of the current overlay string is reached.  If there are more\n   overlay strings to display, IT->string and\n   IT->current.overlay_string_index are set appropriately here.\n   Otherwise IT->string is set to nil.  ") (span (|@| (class "comment-delimiter") (id "F:146351")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:146355")) "static") " " (span (|@| (class "type") (id "F:146362")) "void") "\n" (span (|@| (class "function-name") (id "F:146367")) "next_overlay_string") " (" (span (|@| (class "type") (id "F:146388")) "it") ")\n     " (span (|@| (class "keyword") (id "F:146397")) "struct") " " (span (|@| (class "type") (id "F:146404")) "it") " *" (span (|@| (class "variable-name") (id "F:146408")) "it") ";\n{\n  ++it->current.overlay_string_index;\n  " (span (|@| (class "keyword") (id "F:146454")) "if") " (it->current.overlay_string_index == it->n_overlay_strings)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:146529")) "/* ") (span (|@| (class "comment") (id "F:146532")) "No more overlay strings.  Restore IT's settings to what\n         they were before overlay strings were processed, and\n         continue to deliver from current_buffer.  ") (span (|@| (class "comment-delimiter") (id "F:146687")) "*/") "\n\n      it->ellipsis_p = (it->stack[it->sp - 1].display_ellipsis_p != 0);\n      pop_it (it);\n      xassert (it->sp > 0\n               || (NILP (it->string)\n                   && it->method == GET_FROM_BUFFER\n                   && it->stop_charpos >= BEGV\n                   && it->stop_charpos <= it->end_charpos));\n      it->current.overlay_string_index = -1;\n      it->n_overlay_strings = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:147041")) "/* ") (span (|@| (class "comment") (id "F:147044")) "If we're at the end of the buffer, record that we have\n         processed the overlay strings there already, so that\n         next_element_from_buffer doesn't try it again.  ") (span (|@| (class "comment-delimiter") (id "F:147204")) "*/") "\n      " (span (|@| (class "keyword") (id "F:147213")) "if") " (NILP (it->string) && IT_CHARPOS (*it) >= it->end_charpos)\n        it->overlay_strings_at_end_processed_p = 1;\n    }\n  " (span (|@| (class "keyword") (id "F:147328")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:147345")) "/* ") (span (|@| (class "comment") (id "F:147348")) "There are more overlay strings to process.  If\n         IT->current.overlay_string_index has advanced to a position\n         where we must load IT->overlay_strings with more strings, do\n         it.  ") (span (|@| (class "comment-delimiter") (id "F:147527")) "*/") "\n      " (span (|@| (class "type") (id "F:147536")) "int") " " (span (|@| (class "variable-name") (id "F:147540")) "i") " = it->current.overlay_string_index % OVERLAY_STRING_CHUNK_SIZE;\n\n      " (span (|@| (class "keyword") (id "F:147613")) "if") " (it->current.overlay_string_index && i == 0)\n        load_overlay_strings (it, 0);\n\n      " (span (|@| (class "comment-delimiter") (id "F:147699")) "/* ") (span (|@| (class "comment") (id "F:147702")) "Initialize IT to deliver display elements from the overlay\n         string.  ") (span (|@| (class "comment-delimiter") (id "F:147779")) "*/") "\n      it->string = it->overlay_strings[i];\n      it->multibyte_p = STRING_MULTIBYTE (it->string);\n      SET_TEXT_POS (it->current.string_pos, 0, 0);\n      it->method = GET_FROM_STRING;\n      it->stop_charpos = 0;\n      " (span (|@| (class "keyword") (id "F:148001")) "if") " (it->cmp_it.stop_pos >= 0)\n        it->cmp_it.stop_pos = 0;\n    }\n\n  CHECK_IT (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:148085")) "/* ") (span (|@| (class "comment") (id "F:148088")) "Compare two overlay_entry structures E1 and E2.  Used as a\n   comparison function for qsort in load_overlay_strings.  Overlay\n   strings for the same position are sorted so that\n\n   1. All after-strings come in front of before-strings, except\n   when they come from the same overlay.\n\n   2. Within after-strings, strings are sorted so that overlay strings\n   from overlays with higher priorities come first.\n\n   2. Within before-strings, strings are sorted so that overlay\n   strings from overlays with higher priorities come last.\n\n   Value is analogous to strcmp.  ") (span (|@| (class "comment-delimiter") (id "F:148655")) "*/") "\n\n\n" (span (|@| (class "keyword") (id "F:148660")) "static") " " (span (|@| (class "type") (id "F:148667")) "int") "\n" (span (|@| (class "function-name") (id "F:148671")) "compare_overlay_entries") " (e1, e2)\n     " (span (|@| (class "type") (id "F:148709")) "void") " *" (span (|@| (class "variable-name") (id "F:148715")) "e1") ", *" (span (|@| (class "variable-name") (id "F:148720")) "e2") ";\n{\n  " (span (|@| (class "keyword") (id "F:148728")) "struct") " " (span (|@| (class "type") (id "F:148735")) "overlay_entry") " *" (span (|@| (class "variable-name") (id "F:148750")) "entry1") " = (" (span (|@| (class "keyword") (id "F:148760")) "struct") " " (span (|@| (class "type") (id "F:148767")) "overlay_entry") " *) e1;\n  " (span (|@| (class "keyword") (id "F:148790")) "struct") " " (span (|@| (class "type") (id "F:148797")) "overlay_entry") " *" (span (|@| (class "variable-name") (id "F:148812")) "entry2") " = (" (span (|@| (class "keyword") (id "F:148822")) "struct") " " (span (|@| (class "type") (id "F:148829")) "overlay_entry") " *) e2;\n  " (span (|@| (class "type") (id "F:148852")) "int") " " (span (|@| (class "variable-name") (id "F:148856")) "result") ";\n\n  " (span (|@| (class "keyword") (id "F:148867")) "if") " (entry1->after_string_p != entry2->after_string_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:148933")) "/* ") (span (|@| (class "comment") (id "F:148936")) "Let after-strings appear in front of before-strings if\n         they come from different overlays.  ") (span (|@| (class "comment-delimiter") (id "F:149029")) "*/") "\n      " (span (|@| (class "keyword") (id "F:149038")) "if") " (EQ (entry1->overlay, entry2->overlay))\n        result = entry1->after_string_p ? 1 : -1;\n      " (span (|@| (class "keyword") (id "F:149130")) "else") "\n        result = entry1->after_string_p ? -1 : 1;\n    }\n  " (span (|@| (class "keyword") (id "F:149186")) "else") " " (span (|@| (class "keyword") (id "F:149191")) "if") " (entry1->after_string_p)\n    " (span (|@| (class "comment-delimiter") (id "F:149223")) "/* ") (span (|@| (class "comment") (id "F:149226")) "After-strings sorted in order of decreasing priority.  ") (span (|@| (class "comment-delimiter") (id "F:149281")) "*/") "\n    result = entry2->priority - entry1->priority;\n  " (span (|@| (class "keyword") (id "F:149336")) "else") "\n    " (span (|@| (class "comment-delimiter") (id "F:149345")) "/* ") (span (|@| (class "comment") (id "F:149348")) "Before-strings sorted in order of increasing priority.  ") (span (|@| (class "comment-delimiter") (id "F:149404")) "*/") "\n    result = entry1->priority - entry2->priority;\n\n  " (span (|@| (class "keyword") (id "F:149460")) "return") " result;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:149479")) "/* ") (span (|@| (class "comment") (id "F:149482")) "Load the vector IT->overlay_strings with overlay strings from IT's\n   current buffer position, or from CHARPOS if that is > 0.  Set\n   IT->n_overlays to the total number of overlay strings found.\n\n   Overlay strings are processed OVERLAY_STRING_CHUNK_SIZE strings at\n   a time.  On entry into load_overlay_strings,\n   IT->current.overlay_string_index gives the number of overlay\n   strings that have already been loaded by previous calls to this\n   function.\n\n   IT->add_overlay_start contains an additional overlay start\n   position to consider for taking overlay strings from, if non-zero.\n   This position comes into play when the overlay has an `invisible'\n   property, and both before and after-strings.  When we've skipped to\n   the end of the overlay, because of its `invisible' property, we\n   nevertheless want its before-string to appear.\n   IT->add_overlay_start will contain the overlay start position\n   in this case.\n\n   Overlay strings are sorted so that after-string strings come in\n   front of before-string strings.  Within before and after-strings,\n   strings are sorted by overlay priority.  See also function\n   compare_overlay_entries.  ") (span (|@| (class "comment-delimiter") (id "F:150641")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:150645")) "static") " " (span (|@| (class "type") (id "F:150652")) "void") "\n" (span (|@| (class "function-name") (id "F:150657")) "load_overlay_strings") " (" (span (|@| (class "type") (id "F:150679")) "it") ", charpos)\n     " (span (|@| (class "keyword") (id "F:150697")) "struct") " " (span (|@| (class "type") (id "F:150704")) "it") " *" (span (|@| (class "variable-name") (id "F:150708")) "it") ";\n     " (span (|@| (class "type") (id "F:150717")) "int") " " (span (|@| (class "variable-name") (id "F:150721")) "charpos") ";\n{\n  " (span (|@| (class "keyword") (id "F:150734")) "extern") " " (span (|@| (class "type") (id "F:150741")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:150753")) "Qwindow") ", " (span (|@| (class "variable-name") (id "F:150762")) "Qpriority") ";\n  " (span (|@| (class "type") (id "F:150775")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:150787")) "overlay") ", " (span (|@| (class "variable-name") (id "F:150796")) "window") ", " (span (|@| (class "variable-name") (id "F:150804")) "str") ", " (span (|@| (class "variable-name") (id "F:150809")) "invisible") ";\n  " (span (|@| (class "keyword") (id "F:150822")) "struct") " " (span (|@| (class "type") (id "F:150829")) "Lisp_Overlay") " *" (span (|@| (class "variable-name") (id "F:150843")) "ov") ";\n  " (span (|@| (class "type") (id "F:150849")) "int") " " (span (|@| (class "variable-name") (id "F:150853")) "start") ", " (span (|@| (class "variable-name") (id "F:150860")) "end") ";\n  " (span (|@| (class "type") (id "F:150867")) "int") " " (span (|@| (class "variable-name") (id "F:150871")) "size") " = 20;\n  " (span (|@| (class "type") (id "F:150884")) "int") " " (span (|@| (class "variable-name") (id "F:150888")) "n") " = 0, " (span (|@| (class "variable-name") (id "F:150895")) "i") ", " (span (|@| (class "variable-name") (id "F:150898")) "j") ", " (span (|@| (class "variable-name") (id "F:150901")) "invis_p") ";\n  " (span (|@| (class "keyword") (id "F:150912")) "struct") " " (span (|@| (class "type") (id "F:150919")) "overlay_entry") " *" (span (|@| (class "variable-name") (id "F:150934")) "entries") "\n    = (" (span (|@| (class "keyword") (id "F:150949")) "struct") " " (span (|@| (class "type") (id "F:150956")) "overlay_entry") " *) alloca (size * " (span (|@| (class "keyword") (id "F:150988")) "sizeof") " *entries);\n\n  " (span (|@| (class "keyword") (id "F:151009")) "if") " (charpos <= 0)\n    charpos = IT_CHARPOS (*it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:151062")) "/* ") (span (|@| (class "comment") (id "F:151065")) "Append the overlay string STRING of overlay OVERLAY to vector\n     `entries' which has size `size' and currently contains `n'\n     elements.  AFTER_P non-zero means STRING is an after-string of\n     OVERLAY.  ") (span (|@| (class "comment-delimiter") (id "F:151274")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:151277")) "#define") " " (span (|@| (class "function-name") (id "F:151285")) "RECORD_OVERLAY_STRING") "(" (span (|@| (class "variable-name") (id "F:151307")) "OVERLAY") ", " (span (|@| (class "variable-name") (id "F:151316")) "STRING") ", " (span (|@| (class "variable-name") (id "F:151324")) "AFTER_P") ")                 \\\n  " (span (|@| (class "keyword") (id "F:151339")) "do") "                                                                    \\\n    {                                                                   \\\n      " (span (|@| (class "type") (id "F:151374")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:151386")) "priority") ";                                             \\\n                                                                        \\\n      " (span (|@| (class "keyword") (id "F:151420")) "if") " (n == size)                                                    \\\n        {                                                               \\\n          " (span (|@| (class "type") (id "F:151458")) "int") " " (span (|@| (class "variable-name") (id "F:151462")) "new_size") " = 2 * size;                                      \\\n          " (span (|@| (class "keyword") (id "F:151492")) "struct") " " (span (|@| (class "type") (id "F:151499")) "overlay_entry") " *" (span (|@| (class "variable-name") (id "F:151514")) "old") " = entries;                          \\\n          entries =                                                     \\\n            (" (span (|@| (class "keyword") (id "F:151568")) "struct") " " (span (|@| (class "type") (id "F:151575")) "overlay_entry") " *) alloca (new_size                   \\\n                                             * " (span (|@| (class "keyword") (id "F:151625")) "sizeof") " *entries);        \\\n          bcopy (old, entries, size * " (span (|@| (class "keyword") (id "F:151676")) "sizeof") " *entries);                 \\\n          size = new_size;                                              \\\n        }                                                               \\\n                                                                        \\\n      entries[n].string = (STRING);                                     \\\n      entries[n].overlay = (OVERLAY);                                   \\\n      priority = Foverlay_get ((OVERLAY), Qpriority);                   \\\n      entries[n].priority = INTEGERP (priority) ? XINT (priority) : 0;  \\\n      entries[n].after_string_p = (AFTER_P);                            \\\n      ++n;                                                              \\\n    }                                                                   \\\n  " (span (|@| (class "keyword") (id "F:152054")) "while") " (0)\n\n  " (span (|@| (class "comment-delimiter") (id "F:152067")) "/* ") (span (|@| (class "comment") (id "F:152070")) "Process overlay before the overlay center.  ") (span (|@| (class "comment-delimiter") (id "F:152114")) "*/") "\n  " (span (|@| (class "keyword") (id "F:152119")) "for") " (ov = current_buffer->overlays_before; ov; ov = ov->next)\n    {\n      XSETMISC (overlay, ov);\n      xassert (OVERLAYP (overlay));\n      start = OVERLAY_POSITION (OVERLAY_START (overlay));\n      end = OVERLAY_POSITION (OVERLAY_END (overlay));\n\n      " (span (|@| (class "keyword") (id "F:152372")) "if") " (end < charpos)\n        " (span (|@| (class "keyword") (id "F:152392")) "break") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:152406")) "/* ") (span (|@| (class "comment") (id "F:152409")) "Skip this overlay if it doesn't start or end at IT's current\n         position.  ") (span (|@| (class "comment-delimiter") (id "F:152483")) "*/") "\n      " (span (|@| (class "keyword") (id "F:152492")) "if") " (end != charpos && start != charpos)\n        " (span (|@| (class "keyword") (id "F:152533")) "continue") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:152550")) "/* ") (span (|@| (class "comment") (id "F:152553")) "Skip this overlay if it doesn't apply to IT->w.  ") (span (|@| (class "comment-delimiter") (id "F:152602")) "*/") "\n      window = Foverlay_get (overlay, Qwindow);\n      " (span (|@| (class "keyword") (id "F:152659")) "if") " (WINDOWP (window) && XWINDOW (window) != it->w)\n        " (span (|@| (class "keyword") (id "F:152711")) "continue") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:152728")) "/* ") (span (|@| (class "comment") (id "F:152731")) "If the text ``under'' the overlay is invisible, both before-\n         and after-strings from this overlay are visible; start and\n         end position are indistinguishable.  ") (span (|@| (class "comment-delimiter") (id "F:152892")) "*/") "\n      invisible = Foverlay_get (overlay, Qinvisible);\n      invis_p = TEXT_PROP_MEANS_INVISIBLE (invisible);\n\n      " (span (|@| (class "comment-delimiter") (id "F:153011")) "/* ") (span (|@| (class "comment") (id "F:153014")) "If overlay has a non-empty before-string, record it.  ") (span (|@| (class "comment-delimiter") (id "F:153068")) "*/") "\n      " (span (|@| (class "keyword") (id "F:153077")) "if") " ((start == charpos || (end == charpos && invis_p))\n          && (str = Foverlay_get (overlay, Qbefore_string), STRINGP (str))\n          && SCHARS (str))\n        RECORD_OVERLAY_STRING (overlay, str, 0);\n\n      " (span (|@| (class "comment-delimiter") (id "F:153268")) "/* ") (span (|@| (class "comment") (id "F:153271")) "If overlay has a non-empty after-string, record it.  ") (span (|@| (class "comment-delimiter") (id "F:153324")) "*/") "\n      " (span (|@| (class "keyword") (id "F:153333")) "if") " ((end == charpos || (start == charpos && invis_p))\n          && (str = Foverlay_get (overlay, Qafter_string), STRINGP (str))\n          && SCHARS (str))\n        RECORD_OVERLAY_STRING (overlay, str, 1);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:153525")) "/* ") (span (|@| (class "comment") (id "F:153528")) "Process overlays after the overlay center.  ") (span (|@| (class "comment-delimiter") (id "F:153572")) "*/") "\n  " (span (|@| (class "keyword") (id "F:153577")) "for") " (ov = current_buffer->overlays_after; ov; ov = ov->next)\n    {\n      XSETMISC (overlay, ov);\n      xassert (OVERLAYP (overlay));\n      start = OVERLAY_POSITION (OVERLAY_START (overlay));\n      end = OVERLAY_POSITION (OVERLAY_END (overlay));\n\n      " (span (|@| (class "keyword") (id "F:153829")) "if") " (start > charpos)\n        " (span (|@| (class "keyword") (id "F:153851")) "break") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:153865")) "/* ") (span (|@| (class "comment") (id "F:153868")) "Skip this overlay if it doesn't start or end at IT's current\n         position.  ") (span (|@| (class "comment-delimiter") (id "F:153942")) "*/") "\n      " (span (|@| (class "keyword") (id "F:153951")) "if") " (end != charpos && start != charpos)\n        " (span (|@| (class "keyword") (id "F:153992")) "continue") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:154009")) "/* ") (span (|@| (class "comment") (id "F:154012")) "Skip this overlay if it doesn't apply to IT->w.  ") (span (|@| (class "comment-delimiter") (id "F:154061")) "*/") "\n      window = Foverlay_get (overlay, Qwindow);\n      " (span (|@| (class "keyword") (id "F:154118")) "if") " (WINDOWP (window) && XWINDOW (window) != it->w)\n        " (span (|@| (class "keyword") (id "F:154170")) "continue") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:154187")) "/* ") (span (|@| (class "comment") (id "F:154190")) "If the text ``under'' the overlay is invisible, it has a zero\n         dimension, and both before- and after-strings apply.  ") (span (|@| (class "comment-delimiter") (id "F:154308")) "*/") "\n      invisible = Foverlay_get (overlay, Qinvisible);\n      invis_p = TEXT_PROP_MEANS_INVISIBLE (invisible);\n\n      " (span (|@| (class "comment-delimiter") (id "F:154427")) "/* ") (span (|@| (class "comment") (id "F:154430")) "If overlay has a non-empty before-string, record it.  ") (span (|@| (class "comment-delimiter") (id "F:154484")) "*/") "\n      " (span (|@| (class "keyword") (id "F:154493")) "if") " ((start == charpos || (end == charpos && invis_p))\n          && (str = Foverlay_get (overlay, Qbefore_string), STRINGP (str))\n          && SCHARS (str))\n        RECORD_OVERLAY_STRING (overlay, str, 0);\n\n      " (span (|@| (class "comment-delimiter") (id "F:154684")) "/* ") (span (|@| (class "comment") (id "F:154687")) "If overlay has a non-empty after-string, record it.  ") (span (|@| (class "comment-delimiter") (id "F:154740")) "*/") "\n      " (span (|@| (class "keyword") (id "F:154749")) "if") " ((end == charpos || (start == charpos && invis_p))\n          && (str = Foverlay_get (overlay, Qafter_string), STRINGP (str))\n          && SCHARS (str))\n        RECORD_OVERLAY_STRING (overlay, str, 1);\n    }\n\n" (span (|@| (class "preprocessor") (id "F:154939")) "#undef") " RECORD_OVERLAY_STRING\n\n  " (span (|@| (class "comment-delimiter") (id "F:154971")) "/* ") (span (|@| (class "comment") (id "F:154974")) "Sort entries.  ") (span (|@| (class "comment-delimiter") (id "F:154989")) "*/") "\n  " (span (|@| (class "keyword") (id "F:154994")) "if") " (n > 1)\n    qsort (entries, n, " (span (|@| (class "keyword") (id "F:155028")) "sizeof") " *entries, compare_overlay_entries);\n\n  " (span (|@| (class "comment-delimiter") (id "F:155074")) "/* ") (span (|@| (class "comment") (id "F:155077")) "Record the total number of strings to process.  ") (span (|@| (class "comment-delimiter") (id "F:155125")) "*/") "\n  it->n_overlay_strings = n;\n\n  " (span (|@| (class "comment-delimiter") (id "F:155160")) "/* ") (span (|@| (class "comment") (id "F:155163")) "IT->current.overlay_string_index is the number of overlay strings\n     that have already been consumed by IT.  Copy some of the\n     remaining overlay strings to IT->overlay_strings.  ") (span (|@| (class "comment-delimiter") (id "F:155347")) "*/") "\n  i = 0;\n  j = it->current.overlay_string_index;\n  " (span (|@| (class "keyword") (id "F:155401")) "while") " (i < OVERLAY_STRING_CHUNK_SIZE && j < n)\n    {\n      it->overlay_strings[i] = entries[j].string;\n      it->string_overlays[i++] = entries[j++].overlay;\n    }\n\n  CHECK_IT (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:155587")) "/* ") (span (|@| (class "comment") (id "F:155590")) "Get the first chunk of overlay strings at IT's current buffer\n   position, or at CHARPOS if that is > 0.  Value is non-zero if at\n   least one overlay string was found.  ") (span (|@| (class "comment-delimiter") (id "F:155760")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:155764")) "static") " " (span (|@| (class "type") (id "F:155771")) "int") "\n" (span (|@| (class "function-name") (id "F:155775")) "get_overlay_strings_1") " (" (span (|@| (class "type") (id "F:155798")) "it") ", charpos, compute_stop_p)\n     " (span (|@| (class "keyword") (id "F:155832")) "struct") " " (span (|@| (class "type") (id "F:155839")) "it") " *" (span (|@| (class "variable-name") (id "F:155843")) "it") ";\n     " (span (|@| (class "type") (id "F:155852")) "int") " " (span (|@| (class "variable-name") (id "F:155856")) "charpos") ";\n     " (span (|@| (class "type") (id "F:155870")) "int") " " (span (|@| (class "variable-name") (id "F:155874")) "compute_stop_p") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:155894")) "/* ") (span (|@| (class "comment") (id "F:155897")) "Get the first OVERLAY_STRING_CHUNK_SIZE overlay strings to\n     process.  This fills IT->overlay_strings with strings, and sets\n     IT->n_overlay_strings to the total number of strings to process.\n     IT->pos.overlay_string_index has to be set temporarily to zero\n     because load_overlay_strings needs this; it must be set to -1\n     when no overlay strings are found because a zero value would\n     indicate a position in the first overlay string.  ") (span (|@| (class "comment-delimiter") (id "F:156351")) "*/") "\n  it->current.overlay_string_index = 0;\n  load_overlay_strings (it, charpos);\n\n  " (span (|@| (class "comment-delimiter") (id "F:156435")) "/* ") (span (|@| (class "comment") (id "F:156438")) "If we found overlay strings, set up IT to deliver display\n     elements from the first one.  Otherwise set up IT to deliver\n     from current_buffer.  ") (span (|@| (class "comment-delimiter") (id "F:156589")) "*/") "\n  " (span (|@| (class "keyword") (id "F:156594")) "if") " (it->n_overlay_strings)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:156633")) "/* ") (span (|@| (class "comment") (id "F:156636")) "Make sure we know settings in current_buffer, so that we can\n         restore meaningful values when we're done with the overlay\n         strings.  ") (span (|@| (class "comment-delimiter") (id "F:156770")) "*/") "\n      " (span (|@| (class "keyword") (id "F:156779")) "if") " (compute_stop_p)\n        compute_stop_pos (it);\n      xassert (it->face_id >= 0);\n\n      " (span (|@| (class "comment-delimiter") (id "F:156864")) "/* ") (span (|@| (class "comment") (id "F:156867")) "Save IT's settings.  They are restored after all overlay\n         strings have been processed.  ") (span (|@| (class "comment-delimiter") (id "F:156956")) "*/") "\n      xassert (" (span (|@| (class "negation-char") (id "F:156974")) "!") "compute_stop_p || it->sp == 0);\n\n      " (span (|@| (class "comment-delimiter") (id "F:157014")) "/* ") (span (|@| (class "comment") (id "F:157017")) "When called from handle_stop, there might be an empty display\n         string loaded.  In that case, don't bother saving it.  ") (span (|@| (class "comment-delimiter") (id "F:157143")) "*/") "\n      " (span (|@| (class "keyword") (id "F:157152")) "if") " (" (span (|@| (class "negation-char") (id "F:157156")) "!") "STRINGP (it->string) || SCHARS (it->string))\n        push_it (it);\n\n      " (span (|@| (class "comment-delimiter") (id "F:157224")) "/* ") (span (|@| (class "comment") (id "F:157227")) "Set up IT to deliver display elements from the first overlay\n         string.  ") (span (|@| (class "comment-delimiter") (id "F:157299")) "*/") "\n      IT_STRING_CHARPOS (*it) = IT_STRING_BYTEPOS (*it) = 0;\n      it->string = it->overlay_strings[0];\n      it->from_overlay = Qnil;\n      it->stop_charpos = 0;\n      xassert (STRINGP (it->string));\n      it->end_charpos = SCHARS (it->string);\n      it->multibyte_p = STRING_MULTIBYTE (it->string);\n      it->method = GET_FROM_STRING;\n      " (span (|@| (class "keyword") (id "F:157645")) "return") " 1;\n    }\n\n  it->current.overlay_string_index = -1;\n  " (span (|@| (class "keyword") (id "F:157705")) "return") " 0;\n}\n\n" (span (|@| (class "keyword") (id "F:157718")) "static") " " (span (|@| (class "type") (id "F:157725")) "int") "\n" (span (|@| (class "function-name") (id "F:157729")) "get_overlay_strings") " (" (span (|@| (class "type") (id "F:157750")) "it") ", charpos)\n     " (span (|@| (class "keyword") (id "F:157768")) "struct") " " (span (|@| (class "type") (id "F:157775")) "it") " *" (span (|@| (class "variable-name") (id "F:157779")) "it") ";\n     " (span (|@| (class "type") (id "F:157788")) "int") " " (span (|@| (class "variable-name") (id "F:157792")) "charpos") ";\n{\n  it->string = Qnil;\n  it->method = GET_FROM_BUFFER;\n\n  (" (span (|@| (class "type") (id "F:157860")) "void") ") get_overlay_strings_1 (it, charpos, 1);\n\n  CHECK_IT (it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:157927")) "/* ") (span (|@| (class "comment") (id "F:157930")) "Value is non-zero if we found at least one overlay string.  ") (span (|@| (class "comment-delimiter") (id "F:157990")) "*/") "\n  " (span (|@| (class "keyword") (id "F:157995")) "return") " STRINGP (it->string);\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:158030")) "/***********************************************************************") (span (|@| (class "comment") (id "F:158102")) "\n                      Saving and restoring state\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:158209")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:158213")) "/* ") (span (|@| (class "comment") (id "F:158216")) "Save current settings of IT on IT->stack.  Called, for example,\n   before setting up IT for an overlay string, to be able to restore\n   IT's settings to what they were after the overlay string has been\n   processed.  ") (span (|@| (class "comment-delimiter") (id "F:158433")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:158437")) "static") " " (span (|@| (class "type") (id "F:158444")) "void") "\n" (span (|@| (class "function-name") (id "F:158449")) "push_it") " (" (span (|@| (class "type") (id "F:158458")) "it") ")\n     " (span (|@| (class "keyword") (id "F:158467")) "struct") " " (span (|@| (class "type") (id "F:158474")) "it") " *" (span (|@| (class "variable-name") (id "F:158478")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:158486")) "struct") " " (span (|@| (class "type") (id "F:158493")) "iterator_stack_entry") " *" (span (|@| (class "variable-name") (id "F:158515")) "p") ";\n\n  xassert (it->sp < IT_STACK_SIZE);\n  p = it->stack + it->sp;\n\n  p->stop_charpos = it->stop_charpos;\n  p->prev_stop = it->prev_stop;\n  p->base_level_stop = it->base_level_stop;\n  p->cmp_it = it->cmp_it;\n  xassert (it->face_id >= 0);\n  p->face_id = it->face_id;\n  p->string = it->string;\n  p->method = it->method;\n  p->from_overlay = it->from_overlay;\n  " (span (|@| (class "keyword") (id "F:158872")) "switch") " (p->method)\n    {\n    " (span (|@| (class "keyword") (id "F:158901")) "case") " GET_FROM_IMAGE:\n      p->u.image.object = it->object;\n      p->u.image.image_id = it->image_id;\n      p->u.image.slice = it->slice;\n      " (span (|@| (class "keyword") (id "F:159044")) "break") ";\n    " (span (|@| (class "keyword") (id "F:159055")) "case") " GET_FROM_STRETCH:\n      p->u.stretch.object = it->object;\n      " (span (|@| (class "keyword") (id "F:159124")) "break") ";\n    }\n  p->position = it->position;\n  p->current = it->current;\n  p->end_charpos = it->end_charpos;\n  p->string_nchars = it->string_nchars;\n  p->area = it->area;\n  p->multibyte_p = it->multibyte_p;\n  p->avoid_cursor_p = it->avoid_cursor_p;\n  p->space_width = it->space_width;\n  p->font_height = it->font_height;\n  p->voffset = it->voffset;\n  p->string_from_display_prop_p = it->string_from_display_prop_p;\n  p->display_ellipsis_p = 0;\n  p->line_wrap = it->line_wrap;\n  ++it->sp;\n}\n\n" (span (|@| (class "keyword") (id "F:159613")) "static") " " (span (|@| (class "type") (id "F:159620")) "void") "\n" (span (|@| (class "function-name") (id "F:159625")) "iterate_out_of_display_property") " (" (span (|@| (class "type") (id "F:159658")) "it") ")\n     " (span (|@| (class "keyword") (id "F:159667")) "struct") " " (span (|@| (class "type") (id "F:159674")) "it") " *" (span (|@| (class "variable-name") (id "F:159678")) "it") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:159686")) "/* ") (span (|@| (class "comment") (id "F:159689")) "Maybe initialize paragraph direction.  If we are at the beginning\n     of a new paragraph, next_element_from_buffer may not have a\n     chance to do that.  ") (span (|@| (class "comment-delimiter") (id "F:159845")) "*/") "\n  " (span (|@| (class "keyword") (id "F:159850")) "if") " (it->bidi_it.first_elt && it->bidi_it.charpos < ZV)\n    bidi_paragraph_init (it->paragraph_embedding, &it->bidi_it);\n  " (span (|@| (class "comment-delimiter") (id "F:159972")) "/* ") (span (|@| (class "comment") (id "F:159975")) "prev_stop can be zero, so check against BEGV as well.  ") (span (|@| (class "comment-delimiter") (id "F:160030")) "*/") "\n  " (span (|@| (class "keyword") (id "F:160035")) "while") " (it->bidi_it.charpos >= BEGV\n         && it->prev_stop <= it->bidi_it.charpos\n         && it->bidi_it.charpos < CHARPOS (it->position))\n    bidi_move_to_visually_next (&it->bidi_it);\n  " (span (|@| (class "comment-delimiter") (id "F:160212")) "/* ") (span (|@| (class "comment") (id "F:160215")) "Record the stop_pos we just crossed, for when we cross it\n     back, maybe.  ") (span (|@| (class "comment-delimiter") (id "F:160292")) "*/") "\n  " (span (|@| (class "keyword") (id "F:160297")) "if") " (it->bidi_it.charpos > CHARPOS (it->position))\n    it->prev_stop = CHARPOS (it->position);\n  " (span (|@| (class "comment-delimiter") (id "F:160393")) "/* ") (span (|@| (class "comment") (id "F:160396")) "If we ended up not where pop_it put us, resync IT's\n     positional members with the bidi iterator. ") (span (|@| (class "comment-delimiter") (id "F:160496")) "*/") "\n  " (span (|@| (class "keyword") (id "F:160501")) "if") " (it->bidi_it.charpos != CHARPOS (it->position))\n    {\n      SET_TEXT_POS (it->position,\n                    it->bidi_it.charpos, it->bidi_it.bytepos);\n      it->current.pos = it->position;\n    }\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:160688")) "/* ") (span (|@| (class "comment") (id "F:160691")) "Restore IT's settings from IT->stack.  Called, for example, when no\n   more overlay strings must be processed, and we return to delivering\n   display elements from a buffer, or when the end of a string from a\n   `display' property is reached and we return to delivering display\n   elements from an overlay string, or from a buffer.  ") (span (|@| (class "comment-delimiter") (id "F:161024")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:161028")) "static") " " (span (|@| (class "type") (id "F:161035")) "void") "\n" (span (|@| (class "function-name") (id "F:161040")) "pop_it") " (" (span (|@| (class "type") (id "F:161048")) "it") ")\n     " (span (|@| (class "keyword") (id "F:161057")) "struct") " " (span (|@| (class "type") (id "F:161064")) "it") " *" (span (|@| (class "variable-name") (id "F:161068")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:161076")) "struct") " " (span (|@| (class "type") (id "F:161083")) "iterator_stack_entry") " *" (span (|@| (class "variable-name") (id "F:161105")) "p") ";\n\n  xassert (it->sp > 0);\n  --it->sp;\n  p = it->stack + it->sp;\n  it->stop_charpos = p->stop_charpos;\n  it->prev_stop = p->prev_stop;\n  it->base_level_stop = p->base_level_stop;\n  it->cmp_it = p->cmp_it;\n  it->face_id = p->face_id;\n  it->current = p->current;\n  it->position = p->position;\n  it->string = p->string;\n  it->from_overlay = p->from_overlay;\n  " (span (|@| (class "keyword") (id "F:161463")) "if") " (NILP (it->string))\n    SET_TEXT_POS (it->current.string_pos, -1, -1);\n  it->method = p->method;\n  " (span (|@| (class "keyword") (id "F:161565")) "switch") " (it->method)\n    {\n    " (span (|@| (class "keyword") (id "F:161595")) "case") " GET_FROM_IMAGE:\n      it->image_id = p->u.image.image_id;\n      it->object = p->u.image.object;\n      it->slice = p->u.image.slice;\n      " (span (|@| (class "keyword") (id "F:161738")) "break") ";\n    " (span (|@| (class "keyword") (id "F:161749")) "case") " GET_FROM_STRETCH:\n      it->object = p->u.comp.object;\n      " (span (|@| (class "keyword") (id "F:161815")) "break") ";\n    " (span (|@| (class "keyword") (id "F:161826")) "case") " GET_FROM_BUFFER:\n      it->object = it->w->buffer;\n      " (span (|@| (class "keyword") (id "F:161888")) "if") " (it->bidi_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:161910")) "/* ") (span (|@| (class "comment") (id "F:161913")) "Bidi-iterate until we get out of the portion of text, if\n             any, covered by a `display' text property or an overlay\n             with `display' property.  (We cannot just jump there,\n             because the internal coherency of the bidi iterator state\n             can not be preserved across such jumps.)  We also must\n             determine the paragraph base direction if the overlay we\n             just processed is at the beginning of a new\n             paragraph.  ") (span (|@| (class "comment-delimiter") (id "F:162348")) "*/") "\n          iterate_out_of_display_property (it);\n        }\n      " (span (|@| (class "keyword") (id "F:162401")) "break") ";\n    " (span (|@| (class "keyword") (id "F:162412")) "case") " GET_FROM_STRING:\n      it->object = it->string;\n      " (span (|@| (class "keyword") (id "F:162471")) "break") ";\n    " (span (|@| (class "keyword") (id "F:162482")) "case") " GET_FROM_DISPLAY_VECTOR:\n      " (span (|@| (class "keyword") (id "F:162518")) "if") " (it->s)\n        it->method = GET_FROM_C_STRING;\n      " (span (|@| (class "keyword") (id "F:162568")) "else") " " (span (|@| (class "keyword") (id "F:162573")) "if") " (STRINGP (it->string))\n        it->method = GET_FROM_STRING;\n      " (span (|@| (class "keyword") (id "F:162636")) "else") "\n        {\n          it->method = GET_FROM_BUFFER;\n          it->object = it->w->buffer;\n        }\n    }\n  it->end_charpos = p->end_charpos;\n  it->string_nchars = p->string_nchars;\n  it->area = p->area;\n  it->multibyte_p = p->multibyte_p;\n  it->avoid_cursor_p = p->avoid_cursor_p;\n  it->space_width = p->space_width;\n  it->font_height = p->font_height;\n  it->voffset = p->voffset;\n  it->string_from_display_prop_p = p->string_from_display_prop_p;\n  it->line_wrap = p->line_wrap;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:163097")) "/***********************************************************************") (span (|@| (class "comment") (id "F:163169")) "\n                          Moving over lines\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:163264")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:163268")) "/* ") (span (|@| (class "comment") (id "F:163271")) "Set IT's current position to the previous line start.  ") (span (|@| (class "comment-delimiter") (id "F:163326")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:163330")) "static") " " (span (|@| (class "type") (id "F:163337")) "void") "\n" (span (|@| (class "function-name") (id "F:163342")) "back_to_previous_line_start") " (" (span (|@| (class "type") (id "F:163371")) "it") ")\n     " (span (|@| (class "keyword") (id "F:163380")) "struct") " " (span (|@| (class "type") (id "F:163387")) "it") " *" (span (|@| (class "variable-name") (id "F:163391")) "it") ";\n{\n  IT_CHARPOS (*it) = find_next_newline_no_quit (IT_CHARPOS (*it) - 1, -1);\n  IT_BYTEPOS (*it) = CHAR_TO_BYTE (IT_CHARPOS (*it));\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:163530")) "/* ") (span (|@| (class "comment") (id "F:163533")) "Move IT to the next line start.\n\n   Value is non-zero if a newline was found.  Set *SKIPPED_P to 1 if\n   we skipped over part of the text (as opposed to moving the iterator\n   continuously over the text).  Otherwise, don't change the value\n   of *SKIPPED_P.\n\n   Newlines may come from buffer text, overlay strings, or strings\n   displayed via the `display' property.  That's the reason we can't\n   simply use find_next_newline_no_quit.\n\n   Note that this function may not skip over invisible text that is so\n   because of text properties and immediately follows a newline.  If\n   it would, function reseat_at_next_visible_line_start, when called\n   from set_iterator_to_next, would effectively make invisible\n   characters following a newline part of the wrong glyph row, which\n   leads to wrong cursor motion.  ") (span (|@| (class "comment-delimiter") (id "F:164345")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:164349")) "static") " " (span (|@| (class "type") (id "F:164356")) "int") "\n" (span (|@| (class "function-name") (id "F:164360")) "forward_to_next_line_start") " (" (span (|@| (class "type") (id "F:164388")) "it") ", skipped_p)\n     " (span (|@| (class "keyword") (id "F:164408")) "struct") " " (span (|@| (class "type") (id "F:164415")) "it") " *" (span (|@| (class "variable-name") (id "F:164419")) "it") ";\n     " (span (|@| (class "type") (id "F:164428")) "int") " *" (span (|@| (class "variable-name") (id "F:164433")) "skipped_p") ";\n{\n  " (span (|@| (class "type") (id "F:164448")) "int") " " (span (|@| (class "variable-name") (id "F:164452")) "old_selective") ", " (span (|@| (class "variable-name") (id "F:164467")) "newline_found_p") ", " (span (|@| (class "variable-name") (id "F:164484")) "n") ";\n  " (span (|@| (class "keyword") (id "F:164489")) "const") " " (span (|@| (class "type") (id "F:164495")) "int") " " (span (|@| (class "variable-name") (id "F:164499")) "MAX_NEWLINE_DISTANCE") " = 500;\n\n  " (span (|@| (class "comment-delimiter") (id "F:164530")) "/* ") (span (|@| (class "comment") (id "F:164533")) "If already on a newline, just consume it to avoid unintended\n     skipping over invisible text below.  ") (span (|@| (class "comment-delimiter") (id "F:164636")) "*/") "\n  " (span (|@| (class "keyword") (id "F:164641")) "if") " (it->what == IT_CHARACTER\n      && it->c == " (span (|@| (class "string") (id "F:164688")) "'\\n'") "\n      && CHARPOS (it->position) == IT_CHARPOS (*it))\n    {\n      set_iterator_to_next (it, 0);\n      it->c = 0;\n      " (span (|@| (class "keyword") (id "F:164811")) "return") " 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:164830")) "/* ") (span (|@| (class "comment") (id "F:164833")) "Don't handle selective display in the following.  It's (a)\n     unnecessary because it's done by the caller, and (b) leads to an\n     infinite recursion because next_element_from_ellipsis indirectly\n     calls this function.  ") (span (|@| (class "comment-delimiter") (id "F:165059")) "*/") "\n  old_selective = it->selective;\n  it->selective = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:165119")) "/* ") (span (|@| (class "comment") (id "F:165122")) "Scan for a newline within MAX_NEWLINE_DISTANCE display elements\n     from buffer text.  ") (span (|@| (class "comment-delimiter") (id "F:165210")) "*/") "\n  " (span (|@| (class "keyword") (id "F:165215")) "for") " (n = newline_found_p = 0;\n       " (span (|@| (class "negation-char") (id "F:165252")) "!") "newline_found_p && n < MAX_NEWLINE_DISTANCE;\n       n += STRINGP (it->string) ? 0 : 1)\n    {\n      " (span (|@| (class "keyword") (id "F:165352")) "if") " (" (span (|@| (class "negation-char") (id "F:165356")) "!") "get_next_display_element (it))\n        " (span (|@| (class "keyword") (id "F:165389")) "return") " 0;\n      newline_found_p = it->what == IT_CHARACTER && it->c == " (span (|@| (class "string") (id "F:165460")) "'\\n'") ";\n      set_iterator_to_next (it, 0);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:165511")) "/* ") (span (|@| (class "comment") (id "F:165514")) "If we didn't find a newline near enough, see if we can use a\n     short-cut.  ") (span (|@| (class "comment-delimiter") (id "F:165592")) "*/") "\n  " (span (|@| (class "keyword") (id "F:165597")) "if") " (" (span (|@| (class "negation-char") (id "F:165601")) "!") "newline_found_p)\n    {\n      " (span (|@| (class "type") (id "F:165631")) "int") " " (span (|@| (class "variable-name") (id "F:165635")) "start") " = IT_CHARPOS (*it);\n      " (span (|@| (class "type") (id "F:165667")) "int") " " (span (|@| (class "variable-name") (id "F:165671")) "limit") " = find_next_newline_no_quit (start, 1);\n      " (span (|@| (class "type") (id "F:165723")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:165735")) "pos") ";\n\n      xassert (" (span (|@| (class "negation-char") (id "F:165756")) "!") "STRINGP (it->string));\n\n      " (span (|@| (class "comment-delimiter") (id "F:165787")) "/* ") (span (|@| (class "comment") (id "F:165790")) "If there isn't any `display' property in sight, and no\n         overlays, we can just use the position of the newline in\n         buffer text.  ") (span (|@| (class "comment-delimiter") (id "F:165920")) "*/") "\n      " (span (|@| (class "keyword") (id "F:165929")) "if") " (it->stop_charpos >= limit\n          || ((pos = Fnext_single_property_change (make_number (start),\n                                                   Qdisplay,\n                                                   Qnil, make_number (limit)),\n               NILP (pos))\n              && next_overlay_change (start) == ZV))\n        {\n          IT_CHARPOS (*it) = limit;\n          IT_BYTEPOS (*it) = CHAR_TO_BYTE (limit);\n          *skipped_p = newline_found_p = 1;\n        }\n      " (span (|@| (class "keyword") (id "F:166268")) "else") "\n        {\n          " (span (|@| (class "keyword") (id "F:166279")) "while") " (get_next_display_element (it)\n                 && " (span (|@| (class "negation-char") (id "F:166322")) "!") "newline_found_p)\n            {\n              newline_found_p = ITERATOR_AT_END_OF_LINE_P (it);\n              set_iterator_to_next (it, 0);\n            }\n        }\n    }\n\n  it->selective = old_selective;\n  " (span (|@| (class "keyword") (id "F:166493")) "return") " newline_found_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:166521")) "/* ") (span (|@| (class "comment") (id "F:166524")) "Set IT's current position to the previous visible line start.  Skip\n   invisible text that is so either due to text properties or due to\n   selective display.  Caution: this does not change IT->current_x and\n   IT->hpos.  ") (span (|@| (class "comment-delimiter") (id "F:166746")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:166750")) "static") " " (span (|@| (class "type") (id "F:166757")) "void") "\n" (span (|@| (class "function-name") (id "F:166762")) "back_to_previous_visible_line_start") " (" (span (|@| (class "type") (id "F:166799")) "it") ")\n     " (span (|@| (class "keyword") (id "F:166808")) "struct") " " (span (|@| (class "type") (id "F:166815")) "it") " *" (span (|@| (class "variable-name") (id "F:166819")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:166827")) "while") " (IT_CHARPOS (*it) > BEGV)\n    {\n      back_to_previous_line_start (it);\n\n      " (span (|@| (class "keyword") (id "F:166912")) "if") " (IT_CHARPOS (*it) <= BEGV)\n        " (span (|@| (class "keyword") (id "F:166943")) "break") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:166957")) "/* ") (span (|@| (class "comment") (id "F:166960")) "If selective > 0, then lines indented more than its value are\n         invisible.  ") (span (|@| (class "comment-delimiter") (id "F:167036")) "*/") "\n      " (span (|@| (class "keyword") (id "F:167045")) "if") " (it->selective > 0\n          && indented_beyond_p (IT_CHARPOS (*it), IT_BYTEPOS (*it),\n                                (" (span (|@| (class "type") (id "F:167133")) "double") ") it->selective)) " (span (|@| (class "comment-delimiter") (id "F:167157")) "/* ") (span (|@| (class "comment") (id "F:167160")) "iftc ") (span (|@| (class "comment-delimiter") (id "F:167165")) "*/") "\n        " (span (|@| (class "keyword") (id "F:167169")) "continue") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:167186")) "/* ") (span (|@| (class "comment") (id "F:167189")) "Check the newline before point for invisibility.  ") (span (|@| (class "comment-delimiter") (id "F:167239")) "*/") "\n      {\n        " (span (|@| (class "type") (id "F:167251")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:167263")) "prop") ";\n        prop = Fget_char_property (make_number (IT_CHARPOS (*it) - 1),\n                                     Qinvisible, it->window);\n        " (span (|@| (class "keyword") (id "F:167368")) "if") " (TEXT_PROP_MEANS_INVISIBLE (prop))\n          " (span (|@| (class "keyword") (id "F:167409")) "continue") ";\n      }\n\n      " (span (|@| (class "keyword") (id "F:167434")) "if") " (IT_CHARPOS (*it) <= BEGV)\n        " (span (|@| (class "keyword") (id "F:167465")) "break") ";\n\n      {\n        " (span (|@| (class "keyword") (id "F:167482")) "struct") " " (span (|@| (class "type") (id "F:167489")) "it") " " (span (|@| (class "variable-name") (id "F:167492")) "it2") ";\n        " (span (|@| (class "type") (id "F:167498")) "int") " " (span (|@| (class "variable-name") (id "F:167502")) "pos") ";\n        " (span (|@| (class "type") (id "F:167508")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:167518")) "beg") ", " (span (|@| (class "variable-name") (id "F:167523")) "end") ";\n        " (span (|@| (class "type") (id "F:167529")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:167541")) "val") ", " (span (|@| (class "variable-name") (id "F:167546")) "overlay") ";\n\n        " (span (|@| (class "comment-delimiter") (id "F:167557")) "/* ") (span (|@| (class "comment") (id "F:167560")) "If newline is part of a composition, continue from start of composition ") (span (|@| (class "comment-delimiter") (id "F:167632")) "*/") "\n        " (span (|@| (class "keyword") (id "F:167636")) "if") " (find_composition (IT_CHARPOS (*it), -1, &beg, &end, &val, Qnil)\n            && beg < IT_CHARPOS (*it))\n          " (span (|@| (class "keyword") (id "F:167739")) "goto") " " (span (|@| (class "constant") (id "F:167744")) "replaced") ";\n\n        " (span (|@| (class "comment-delimiter") (id "F:167756")) "/* ") (span (|@| (class "comment") (id "F:167759")) "If newline is replaced by a display property, find start of overlay\n           or interval and continue search from that point.  ") (span (|@| (class "comment-delimiter") (id "F:167881")) "*/") "\n        it2 = *it;\n        pos = --IT_CHARPOS (it2);\n        --IT_BYTEPOS (it2);\n        it2.sp = 0;\n        it2.string_from_display_prop_p = 0;\n        " (span (|@| (class "keyword") (id "F:167995")) "if") " (handle_display_prop (&it2) == HANDLED_RETURN\n            && " (span (|@| (class "negation-char") (id "F:168052")) "!") "NILP (val = get_char_property_and_overlay\n                      (make_number (pos), Qdisplay, Qnil, &overlay))\n            && (OVERLAYP (overlay)\n                ? (beg = OVERLAY_POSITION (OVERLAY_START (overlay)))\n                : get_property_and_range (pos, Qdisplay, &val, &beg, &end, Qnil)))\n          " (span (|@| (class "keyword") (id "F:168305")) "goto") " " (span (|@| (class "constant") (id "F:168310")) "replaced") ";\n\n        " (span (|@| (class "comment-delimiter") (id "F:168322")) "/* ") (span (|@| (class "comment") (id "F:168325")) "Newline is not replaced by anything -- so we are done.  ") (span (|@| (class "comment-delimiter") (id "F:168381")) "*/") "\n        " (span (|@| (class "keyword") (id "F:168385")) "break") ";\n\n      " (span (|@| (class "constant") (id "F:168399")) "replaced") ":\n        " (span (|@| (class "keyword") (id "F:168410")) "if") " (beg < BEGV)\n          beg = BEGV;\n        IT_CHARPOS (*it) = beg;\n        IT_BYTEPOS (*it) = buf_charpos_to_bytepos (current_buffer, beg);\n      }\n    }\n\n  it->continuation_lines_width = 0;\n\n  xassert (IT_CHARPOS (*it) >= BEGV);\n  xassert (IT_CHARPOS (*it) == BEGV\n           || FETCH_BYTE (IT_BYTEPOS (*it) - 1) == " (span (|@| (class "string") (id "F:168702")) "'\\n'") ");\n  CHECK_IT (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:168730")) "/* ") (span (|@| (class "comment") (id "F:168733")) "Reseat iterator IT at the previous visible line start.  Skip\n   invisible text that is so either due to text properties or due to\n   selective display.  At the end, update IT's overlay information,\n   face information etc.  ") (span (|@| (class "comment-delimiter") (id "F:168957")) "*/") "\n\n" (span (|@| (class "type") (id "F:168961")) "void") "\n" (span (|@| (class "function-name") (id "F:168966")) "reseat_at_previous_visible_line_start") " (" (span (|@| (class "type") (id "F:169005")) "it") ")\n     " (span (|@| (class "keyword") (id "F:169014")) "struct") " " (span (|@| (class "type") (id "F:169021")) "it") " *" (span (|@| (class "variable-name") (id "F:169025")) "it") ";\n{\n  back_to_previous_visible_line_start (it);\n  reseat (it, it->current.pos, 1);\n  CHECK_IT (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:169131")) "/* ") (span (|@| (class "comment") (id "F:169134")) "Reseat iterator IT on the next visible line start in the current\n   buffer.  ON_NEWLINE_P non-zero means position IT on the newline\n   preceding the line start.  Skip over invisible text that is so\n   because of selective display.  Compute faces, overlays etc at the\n   new position.  Note that this function does not skip over text that\n   is invisible because of text properties.  ") (span (|@| (class "comment-delimiter") (id "F:169517")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:169521")) "static") " " (span (|@| (class "type") (id "F:169528")) "void") "\n" (span (|@| (class "function-name") (id "F:169533")) "reseat_at_next_visible_line_start") " (" (span (|@| (class "type") (id "F:169568")) "it") ", on_newline_p)\n     " (span (|@| (class "keyword") (id "F:169591")) "struct") " " (span (|@| (class "type") (id "F:169598")) "it") " *" (span (|@| (class "variable-name") (id "F:169602")) "it") ";\n     " (span (|@| (class "type") (id "F:169611")) "int") " " (span (|@| (class "variable-name") (id "F:169615")) "on_newline_p") ";\n{\n  " (span (|@| (class "type") (id "F:169633")) "int") " " (span (|@| (class "variable-name") (id "F:169637")) "newline_found_p") ", " (span (|@| (class "variable-name") (id "F:169654")) "skipped_p") " = 0;\n\n  newline_found_p = forward_to_next_line_start (it, &skipped_p);\n\n  " (span (|@| (class "comment-delimiter") (id "F:169738")) "/* ") (span (|@| (class "comment") (id "F:169741")) "Skip over lines that are invisible because they are indented\n     more than the value of IT->selective.  ") (span (|@| (class "comment-delimiter") (id "F:169846")) "*/") "\n  " (span (|@| (class "keyword") (id "F:169851")) "if") " (it->selective > 0)\n    " (span (|@| (class "keyword") (id "F:169878")) "while") " (IT_CHARPOS (*it) < ZV\n           && indented_beyond_p (IT_CHARPOS (*it), IT_BYTEPOS (*it),\n                                 (" (span (|@| (class "type") (id "F:169975")) "double") ") it->selective)) " (span (|@| (class "comment-delimiter") (id "F:169999")) "/* ") (span (|@| (class "comment") (id "F:170002")) "iftc ") (span (|@| (class "comment-delimiter") (id "F:170007")) "*/") "\n      {\n        xassert (IT_BYTEPOS (*it) == BEGV\n                 || FETCH_BYTE (IT_BYTEPOS (*it) - 1) == " (span (|@| (class "string") (id "F:170096")) "'\\n'") ");\n        newline_found_p = forward_to_next_line_start (it, &skipped_p);\n      }\n\n  " (span (|@| (class "comment-delimiter") (id "F:170178")) "/* ") (span (|@| (class "comment") (id "F:170181")) "Position on the newline if that's what's requested.  ") (span (|@| (class "comment-delimiter") (id "F:170234")) "*/") "\n  " (span (|@| (class "keyword") (id "F:170239")) "if") " (on_newline_p && newline_found_p)\n    {\n      " (span (|@| (class "keyword") (id "F:170288")) "if") " (STRINGP (it->string))\n        {\n          " (span (|@| (class "keyword") (id "F:170320")) "if") " (IT_STRING_CHARPOS (*it) > 0)\n            {\n              --IT_STRING_CHARPOS (*it);\n              --IT_STRING_BYTEPOS (*it);\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:170444")) "else") " " (span (|@| (class "keyword") (id "F:170449")) "if") " (IT_CHARPOS (*it) > BEGV)\n        {\n          --IT_CHARPOS (*it);\n          --IT_BYTEPOS (*it);\n          reseat (it, it->current.pos, 0);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:170574")) "else") " " (span (|@| (class "keyword") (id "F:170579")) "if") " (skipped_p)\n    reseat (it, it->current.pos, 0);\n\n  CHECK_IT (it);\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:170655")) "/***********************************************************************") (span (|@| (class "comment") (id "F:170727")) "\n                   Changing an iterator's position\n**********************************************************************") (span (|@| (class "comment-delimiter") (id "F:170835")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:170839")) "/* ") (span (|@| (class "comment") (id "F:170842")) "Change IT's current position to POS in current_buffer.  If FORCE_P\n   is non-zero, always check for text properties at the new position.\n   Otherwise, text properties are only looked up if POS >=\n   IT->check_charpos of a property.  ") (span (|@| (class "comment-delimiter") (id "F:171075")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:171079")) "static") " " (span (|@| (class "type") (id "F:171086")) "void") "\n" (span (|@| (class "function-name") (id "F:171091")) "reseat") " (" (span (|@| (class "type") (id "F:171099")) "it") ", pos, force_p)\n     " (span (|@| (class "keyword") (id "F:171122")) "struct") " " (span (|@| (class "type") (id "F:171129")) "it") " *" (span (|@| (class "variable-name") (id "F:171133")) "it") ";\n     " (span (|@| (class "keyword") (id "F:171142")) "struct") " " (span (|@| (class "type") (id "F:171149")) "text_pos") " " (span (|@| (class "variable-name") (id "F:171158")) "pos") ";\n     " (span (|@| (class "type") (id "F:171168")) "int") " " (span (|@| (class "variable-name") (id "F:171172")) "force_p") ";\n{\n  " (span (|@| (class "type") (id "F:171185")) "int") " " (span (|@| (class "variable-name") (id "F:171189")) "original_pos") " = IT_CHARPOS (*it);\n\n  reseat_1 (it, pos, 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:171251")) "/* ") (span (|@| (class "comment") (id "F:171254")) "Determine where to check text properties.  Avoid doing it\n     where possible because text property lookup is very expensive.  ") (span (|@| (class "comment-delimiter") (id "F:171381")) "*/") "\n  " (span (|@| (class "keyword") (id "F:171386")) "if") " (force_p\n      || CHARPOS (pos) > it->stop_charpos\n      || CHARPOS (pos) < original_pos)\n    {\n      " (span (|@| (class "keyword") (id "F:171491")) "if") " (it->bidi_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:171513")) "/* ") (span (|@| (class "comment") (id "F:171516")) "For bidi iteration, we need to prime prev_stop and\n             base_level_stop with our best estimations.  ") (span (|@| (class "comment-delimiter") (id "F:171617")) "*/") "\n          " (span (|@| (class "keyword") (id "F:171623")) "if") " (CHARPOS (pos) < it->prev_stop)\n            {\n              handle_stop_backwards (it, BEGV);\n              " (span (|@| (class "keyword") (id "F:171713")) "if") " (CHARPOS (pos) < it->base_level_stop)\n                it->base_level_stop = 0;\n            }\n          " (span (|@| (class "keyword") (id "F:171791")) "else") " " (span (|@| (class "keyword") (id "F:171796")) "if") " (CHARPOS (pos) > it->stop_charpos\n                   && it->stop_charpos >= BEGV)\n            handle_stop_backwards (it, it->stop_charpos);\n          " (span (|@| (class "keyword") (id "F:171921")) "else") "  " (span (|@| (class "comment-delimiter") (id "F:171926")) "/* ") (span (|@| (class "comment") (id "F:171929")) "force_p ") (span (|@| (class "comment-delimiter") (id "F:171937")) "*/") "\n            handle_stop (it);\n        }\n      " (span (|@| (class "keyword") (id "F:171972")) "else") "\n        {\n          handle_stop (it);\n          it->prev_stop = it->base_level_stop = 0;\n        }\n\n    }\n\n  CHECK_IT (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:172077")) "/* ") (span (|@| (class "comment") (id "F:172080")) "Change IT's buffer position to POS.  SET_STOP_P non-zero means set\n   IT->stop_pos to POS, also.  ") (span (|@| (class "comment-delimiter") (id "F:172178")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:172182")) "static") " " (span (|@| (class "type") (id "F:172189")) "void") "\n" (span (|@| (class "function-name") (id "F:172194")) "reseat_1") " (" (span (|@| (class "type") (id "F:172204")) "it") ", pos, set_stop_p)\n     " (span (|@| (class "keyword") (id "F:172230")) "struct") " " (span (|@| (class "type") (id "F:172237")) "it") " *" (span (|@| (class "variable-name") (id "F:172241")) "it") ";\n     " (span (|@| (class "keyword") (id "F:172250")) "struct") " " (span (|@| (class "type") (id "F:172257")) "text_pos") " " (span (|@| (class "variable-name") (id "F:172266")) "pos") ";\n     " (span (|@| (class "type") (id "F:172276")) "int") " " (span (|@| (class "variable-name") (id "F:172280")) "set_stop_p") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:172296")) "/* ") (span (|@| (class "comment") (id "F:172299")) "Don't call this function when scanning a C string.  ") (span (|@| (class "comment-delimiter") (id "F:172351")) "*/") "\n  xassert (it->s == " (span (|@| (class "constant") (id "F:172374")) "NULL") ");\n\n  " (span (|@| (class "comment-delimiter") (id "F:172384")) "/* ") (span (|@| (class "comment") (id "F:172387")) "POS must be a reasonable value.  ") (span (|@| (class "comment-delimiter") (id "F:172420")) "*/") "\n  xassert (CHARPOS (pos) >= BEGV && CHARPOS (pos) <= ZV);\n\n  it->current.pos = it->position = pos;\n  it->end_charpos = ZV;\n  it->dpvec = " (span (|@| (class "constant") (id "F:172560")) "NULL") ";\n  it->current.dpvec_index = -1;\n  it->current.overlay_string_index = -1;\n  IT_STRING_CHARPOS (*it) = -1;\n  IT_STRING_BYTEPOS (*it) = -1;\n  it->string = Qnil;\n  it->string_from_display_prop_p = 0;\n  it->method = GET_FROM_BUFFER;\n  it->object = it->w->buffer;\n  it->area = TEXT_AREA;\n  it->multibyte_p = " (span (|@| (class "negation-char") (id "F:172868")) "!") "NILP (current_buffer->enable_multibyte_characters);\n  it->sp = 0;\n  it->string_from_display_prop_p = 0;\n  it->face_before_selective_p = 0;\n  " (span (|@| (class "keyword") (id "F:173010")) "if") " (it->bidi_p)\n    it->bidi_it.first_elt = 1;\n\n  " (span (|@| (class "keyword") (id "F:173060")) "if") " (set_stop_p)\n    {\n      it->stop_charpos = CHARPOS (pos);\n      it->base_level_stop = CHARPOS (pos);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:173175")) "/* ") (span (|@| (class "comment") (id "F:173178")) "Set up IT for displaying a string, starting at CHARPOS in window W.\n   If S is non-null, it is a C string to iterate over.  Otherwise,\n   STRING gives a Lisp string to iterate over.\n\n   If PRECISION > 0, don't return more then PRECISION number of\n   characters from the string.\n\n   If FIELD_WIDTH > 0, return padding spaces until FIELD_WIDTH\n   characters have been returned.  FIELD_WIDTH < 0 means an infinite\n   field width.\n\n   MULTIBYTE = 0 means disable processing of multibyte characters,\n   MULTIBYTE > 0 means enable it,\n   MULTIBYTE < 0 means use IT->multibyte_p.\n\n   IT must be initialized via a prior call to init_iterator before\n   calling this function.  ") (span (|@| (class "comment-delimiter") (id "F:173846")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:173850")) "static") " " (span (|@| (class "type") (id "F:173857")) "void") "\n" (span (|@| (class "function-name") (id "F:173862")) "reseat_to_string") " (" (span (|@| (class "type") (id "F:173880")) "it") ", s, string, charpos, precision, field_width, multibyte)\n     " (span (|@| (class "keyword") (id "F:173944")) "struct") " " (span (|@| (class "type") (id "F:173951")) "it") " *" (span (|@| (class "variable-name") (id "F:173955")) "it") ";\n     " (span (|@| (class "type") (id "F:173964")) "unsigned") " " (span (|@| (class "type") (id "F:173973")) "char") " *" (span (|@| (class "variable-name") (id "F:173979")) "s") ";\n     " (span (|@| (class "type") (id "F:173987")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:173999")) "string") ";\n     " (span (|@| (class "type") (id "F:174012")) "int") " " (span (|@| (class "variable-name") (id "F:174016")) "charpos") ";\n     " (span (|@| (class "type") (id "F:174030")) "int") " " (span (|@| (class "variable-name") (id "F:174034")) "precision") ", " (span (|@| (class "variable-name") (id "F:174045")) "field_width") ", " (span (|@| (class "variable-name") (id "F:174058")) "multibyte") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:174073")) "/* ") (span (|@| (class "comment") (id "F:174076")) "No region in strings.  ") (span (|@| (class "comment-delimiter") (id "F:174099")) "*/") "\n  it->region_beg_charpos = it->region_end_charpos = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:174161")) "/* ") (span (|@| (class "comment") (id "F:174164")) "No text property checks performed by default, but see below.  ") (span (|@| (class "comment-delimiter") (id "F:174226")) "*/") "\n  it->stop_charpos = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:174257")) "/* ") (span (|@| (class "comment") (id "F:174260")) "Set iterator position and end position.  ") (span (|@| (class "comment-delimiter") (id "F:174301")) "*/") "\n  bzero (&it->current, " (span (|@| (class "keyword") (id "F:174327")) "sizeof") " it->current);\n  it->current.overlay_string_index = -1;\n  it->current.dpvec_index = -1;\n  xassert (charpos >= 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:174450")) "/* ") (span (|@| (class "comment") (id "F:174453")) "If STRING is specified, use its multibyteness, otherwise use the\n     setting of MULTIBYTE, if specified.  ") (span (|@| (class "comment-delimiter") (id "F:174560")) "*/") "\n  " (span (|@| (class "keyword") (id "F:174565")) "if") " (multibyte >= 0)\n    it->multibyte_p = multibyte > 0;\n\n  " (span (|@| (class "keyword") (id "F:174625")) "if") " (s == " (span (|@| (class "constant") (id "F:174634")) "NULL") ")\n    {\n      xassert (STRINGP (string));\n      it->string = string;\n      it->s = " (span (|@| (class "constant") (id "F:174721")) "NULL") ";\n      it->end_charpos = it->string_nchars = SCHARS (string);\n      it->method = GET_FROM_STRING;\n      it->current.string_pos = string_pos (charpos, string);\n    }\n  " (span (|@| (class "keyword") (id "F:174893")) "else") "\n    {\n      it->s = s;\n      it->string = Qnil;\n\n      " (span (|@| (class "comment-delimiter") (id "F:174953")) "/* ") (span (|@| (class "comment") (id "F:174956")) "Note that we use IT->current.pos, not it->current.string_pos,\n         for displaying C strings.  ") (span (|@| (class "comment-delimiter") (id "F:175047")) "*/") "\n      IT_STRING_CHARPOS (*it) = IT_STRING_BYTEPOS (*it) = -1;\n      " (span (|@| (class "keyword") (id "F:175118")) "if") " (it->multibyte_p)\n        {\n          it->current.pos = c_string_pos (charpos, s, 1);\n          it->end_charpos = it->string_nchars = number_of_chars (s, 1);\n        }\n      " (span (|@| (class "keyword") (id "F:175267")) "else") "\n        {\n          IT_CHARPOS (*it) = IT_BYTEPOS (*it) = charpos;\n          it->end_charpos = it->string_nchars = strlen (s);\n        }\n\n      it->method = GET_FROM_C_STRING;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:175429")) "/* ") (span (|@| (class "comment") (id "F:175432")) "PRECISION > 0 means don't return more than PRECISION characters\n     from the string.  ") (span (|@| (class "comment-delimiter") (id "F:175519")) "*/") "\n  " (span (|@| (class "keyword") (id "F:175524")) "if") " (precision > 0 && it->end_charpos - charpos > precision)\n    it->end_charpos = it->string_nchars = charpos + precision;\n\n  " (span (|@| (class "comment-delimiter") (id "F:175650")) "/* ") (span (|@| (class "comment") (id "F:175653")) "FIELD_WIDTH > 0 means pad with spaces until FIELD_WIDTH\n     characters have been returned.  FIELD_WIDTH == 0 means don't pad,\n     FIELD_WIDTH < 0 means infinite field width.  This is useful for\n     padding with `-' at the end of a mode line.  ") (span (|@| (class "comment-delimiter") (id "F:175899")) "*/") "\n  " (span (|@| (class "keyword") (id "F:175904")) "if") " (field_width < 0)\n    field_width = INFINITY;\n  " (span (|@| (class "keyword") (id "F:175955")) "if") " (field_width > it->end_charpos - charpos)\n    it->end_charpos = charpos + field_width;\n\n  " (span (|@| (class "comment-delimiter") (id "F:176048")) "/* ") (span (|@| (class "comment") (id "F:176051")) "Use the standard display table for displaying strings.  ") (span (|@| (class "comment-delimiter") (id "F:176107")) "*/") "\n  " (span (|@| (class "keyword") (id "F:176112")) "if") " (DISP_TABLE_P (Vstandard_display_table))\n    it->dp = XCHAR_TABLE (Vstandard_display_table);\n\n  it->stop_charpos = charpos;\n  " (span (|@| (class "keyword") (id "F:176241")) "if") " (s == " (span (|@| (class "constant") (id "F:176250")) "NULL") " && it->multibyte_p)\n    {\n      " (span (|@| (class "type") (id "F:176287")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:176297")) "endpos") " = SCHARS (it->string);\n      " (span (|@| (class "keyword") (id "F:176333")) "if") " (endpos > it->end_charpos)\n        endpos = it->end_charpos;\n      composition_compute_stop_pos (&it->cmp_it, charpos, -1, endpos,\n                                    it->string);\n    }\n  CHECK_IT (it);\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:176510")) "/***********************************************************************") (span (|@| (class "comment") (id "F:176582")) "\n                              Iteration\n**********************************************************************") (span (|@| (class "comment-delimiter") (id "F:176672")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:176676")) "/* ") (span (|@| (class "comment") (id "F:176679")) "Map enum it_method value to corresponding next_element_from_* function.  ") (span (|@| (class "comment-delimiter") (id "F:176752")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:176756")) "static") " " (span (|@| (class "type") (id "F:176763")) "int") " (* " (span (|@| (class "function-name") (id "F:176770")) "get_next_element") "[NUM_IT_METHODS]) P_ ((" (span (|@| (class "keyword") (id "F:176809")) "struct") " " (span (|@| (class "type") (id "F:176816")) "it") " *" (span (|@| (class "variable-name") (id "F:176820")) "it") ")) =\n{\n  next_element_from_buffer,\n  next_element_from_display_vector,\n  next_element_from_string,\n  next_element_from_c_string,\n  next_element_from_image,\n  next_element_from_stretch\n};\n\n" (span (|@| (class "preprocessor") (id "F:177010")) "#define") " " (span (|@| (class "function-name") (id "F:177018")) "GET_NEXT_DISPLAY_ELEMENT") "(" (span (|@| (class "variable-name") (id "F:177043")) "it") ") (*get_next_element[(it)->method]) (it)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:177088")) "/* ") (span (|@| (class "comment") (id "F:177091")) "Return 1 iff a character at CHARPOS (and BYTEPOS) is composed\n   (possibly with the following characters).  ") (span (|@| (class "comment-delimiter") (id "F:177199")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:177203")) "#define") " " (span (|@| (class "function-name") (id "F:177211")) "CHAR_COMPOSED_P") "(" (span (|@| (class "variable-name") (id "F:177227")) "IT") "," (span (|@| (class "variable-name") (id "F:177230")) "CHARPOS") "," (span (|@| (class "variable-name") (id "F:177238")) "BYTEPOS") "," (span (|@| (class "variable-name") (id "F:177246")) "END_CHARPOS") ")                 \\\n  ((IT)->cmp_it.id >= 0                                                 \\\n   || ((IT)->cmp_it.stop_pos == (CHARPOS)                               \\\n       && composition_reseat_it (&(IT)->cmp_it, CHARPOS, BYTEPOS,       \\\n                                 END_CHARPOS, (IT)->w,                  \\\n                                 FACE_FROM_ID ((IT)->f, (IT)->face_id), \\\n                                 (IT)->string)))\n\n\n" (span (|@| (class "comment-delimiter") (id "F:177510")) "/* ") (span (|@| (class "comment") (id "F:177513")) "Load IT's display element fields with information about the next\n   display element from the current position of IT.  Value is zero if\n   end of buffer (or C string) is reached.  ") (span (|@| (class "comment-delimiter") (id "F:177692")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:177696")) "static") " " (span (|@| (class "keyword") (id "F:177703")) "struct") " " (span (|@| (class "type") (id "F:177710")) "frame") " *" (span (|@| (class "variable-name") (id "F:177717")) "last_escape_glyph_frame") " = " (span (|@| (class "constant") (id "F:177743")) "NULL") ";\n" (span (|@| (class "keyword") (id "F:177749")) "static") " " (span (|@| (class "type") (id "F:177756")) "unsigned") " " (span (|@| (class "variable-name") (id "F:177765")) "last_escape_glyph_face_id") " = (1 << FACE_ID_BITS);\n" (span (|@| (class "keyword") (id "F:177814")) "static") " " (span (|@| (class "type") (id "F:177821")) "int") " " (span (|@| (class "variable-name") (id "F:177825")) "last_escape_glyph_merged_face_id") " = 0;\n\n" (span (|@| (class "type") (id "F:177864")) "int") "\n" (span (|@| (class "function-name") (id "F:177868")) "get_next_display_element") " (" (span (|@| (class "type") (id "F:177894")) "it") ")\n     " (span (|@| (class "keyword") (id "F:177903")) "struct") " " (span (|@| (class "type") (id "F:177910")) "it") " *" (span (|@| (class "variable-name") (id "F:177914")) "it") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:177922")) "/* ") (span (|@| (class "comment") (id "F:177925")) "Non-zero means that we found a display element.  Zero means that\n     we hit the end of what we iterate over.  Performance note: the\n     function pointer `method' used here turns out to be faster than\n     using a sequence of if-statements.  ") (span (|@| (class "comment-delimiter") (id "F:178168")) "*/") "\n  " (span (|@| (class "type") (id "F:178173")) "int") " " (span (|@| (class "variable-name") (id "F:178177")) "success_p") ";\n\n " (span (|@| (class "constant") (id "F:178190")) "get_next") ":\n  success_p = GET_NEXT_DISPLAY_ELEMENT (it);\n\n  " (span (|@| (class "keyword") (id "F:178248")) "if") " (it->what == IT_CHARACTER)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:178290")) "/* ") (span (|@| (class "comment") (id "F:178293")) "UAX#9, L4: \"A character is depicted by a mirrored glyph if\n         and only if (a) the resolved directionality of that character\n         is R...\"  ") (span (|@| (class "comment-delimiter") (id "F:178428")) "*/") "\n      " (span (|@| (class "comment-delimiter") (id "F:178437")) "/* ") (span (|@| (class "comment") (id "F:178440")) "FIXME: Do we need an exception for characters from display\n         tables?  ") (span (|@| (class "comment-delimiter") (id "F:178510")) "*/") "\n      " (span (|@| (class "keyword") (id "F:178519")) "if") " (it->bidi_p && it->bidi_it.type == STRONG_R)\n        it->c = bidi_mirror_char (it->c);\n      " (span (|@| (class "comment-delimiter") (id "F:178608")) "/* ") (span (|@| (class "comment") (id "F:178611")) "Map via display table or translate control characters.\n         IT->c, IT->len etc. have been set to the next character by\n         the function call above.  If we have a display table, and it\n         contains an entry for IT->c, translate it.  Don't do this if\n         IT->c itself comes from a display table, otherwise we could\n         end up in an infinite recursion.  (An alternative could be to\n         count the recursion depth of this function and signal an\n         error when a certain maximum depth is reached.)  Is it worth\n         it?  ") (span (|@| (class "comment-delimiter") (id "F:179108")) "*/") "\n      " (span (|@| (class "keyword") (id "F:179117")) "if") " (success_p && it->dpvec == " (span (|@| (class "constant") (id "F:179147")) "NULL") ")\n        {\n          " (span (|@| (class "type") (id "F:179159")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:179171")) "dv") ";\n          " (span (|@| (class "keyword") (id "F:179178")) "struct") " " (span (|@| (class "type") (id "F:179185")) "charset") " *" (span (|@| (class "variable-name") (id "F:179194")) "unibyte") " = CHARSET_FROM_ID (charset_unibyte);\n          " (span (|@| (class "keyword") (id "F:179242")) "enum") " { " (span (|@| (class "variable-name") (id "F:179249")) "char_is_other") " = 0, " (span (|@| (class "variable-name") (id "F:179268")) "char_is_nbsp") ", " (span (|@| (class "variable-name") (id "F:179282")) "char_is_soft_hyphen") " }\n          nbsp_or_shy = char_is_other;\n          " (span (|@| (class "type") (id "F:179339")) "int") " " (span (|@| (class "variable-name") (id "F:179343")) "decoded") " = it->c;\n\n          " (span (|@| (class "keyword") (id "F:179364")) "if") " (it->dp\n              && (dv = DISP_CHAR_VECTOR (it->dp, it->c),\n                  VECTORP (dv)))\n            {\n              " (span (|@| (class "keyword") (id "F:179458")) "struct") " " (span (|@| (class "type") (id "F:179465")) "Lisp_Vector") " *" (span (|@| (class "variable-name") (id "F:179478")) "v") " = XVECTOR (dv);\n\n              " (span (|@| (class "comment-delimiter") (id "F:179504")) "/* ") (span (|@| (class "comment") (id "F:179507")) "Return the first character from the display table\n                 entry, if not empty.  If empty, don't display the\n                 current character.  ") (span (|@| (class "comment-delimiter") (id "F:179633")) "*/") "\n              " (span (|@| (class "keyword") (id "F:179643")) "if") " (v->size)\n                {\n                  it->dpvec_char_len = it->len;\n                  it->dpvec = v->contents;\n                  it->dpend = v->contents + v->size;\n                  it->current.dpvec_index = 0;\n                  it->dpvec_face_id = -1;\n                  it->saved_face_id = it->face_id;\n                  it->method = GET_FROM_DISPLAY_VECTOR;\n                  it->ellipsis_p = 0;\n                }\n              " (span (|@| (class "keyword") (id "F:179937")) "else") "\n                {\n                  set_iterator_to_next (it, 0);\n                }\n              " (span (|@| (class "keyword") (id "F:179991")) "goto") " " (span (|@| (class "constant") (id "F:179996")) "get_next") ";\n            }\n\n          " (span (|@| (class "keyword") (id "F:180017")) "if") " (unibyte_display_via_language_environment\n              && " (span (|@| (class "negation-char") (id "F:180072")) "!") "ASCII_CHAR_P (it->c))\n            decoded = DECODE_CHAR (unibyte, it->c);\n\n          " (span (|@| (class "keyword") (id "F:180144")) "if") " (it->c >= 0x80 && " (span (|@| (class "negation-char") (id "F:180165")) "!") " NILP (Vnobreak_char_display))\n            {\n              " (span (|@| (class "keyword") (id "F:180211")) "if") " (it->multibyte_p)\n                nbsp_or_shy = (it->c == 0xA0   ? char_is_nbsp\n                               : it->c == 0xAD ? char_is_soft_hyphen\n                               :                 char_is_other);\n              " (span (|@| (class "keyword") (id "F:180379")) "else") " " (span (|@| (class "keyword") (id "F:180384")) "if") " (unibyte_display_via_language_environment)\n                nbsp_or_shy = (decoded == 0xA0   ? char_is_nbsp\n                               : decoded == 0xAD ? char_is_soft_hyphen\n                               :                   char_is_other);\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:180587")) "/* ") (span (|@| (class "comment") (id "F:180590")) "Translate control characters into `\\003' or `^C' form.\n             Control characters coming from a display table entry are\n             currently not translated because we use IT->dpvec to hold\n             the translation.  This could easily be changed but I\n             don't believe that it is worth doing.\n\n             If it->multibyte_p is nonzero, non-printable non-ASCII\n             characters are also translated to octal form.\n\n             If it->multibyte_p is zero, eight-bit characters that\n             don't have corresponding multibyte char code are also\n             translated to octal form.  ") (span (|@| (class "comment-delimiter") (id "F:181143")) "*/") "\n          " (span (|@| (class "keyword") (id "F:181149")) "if") " ((it->c < " (span (|@| (class "string") (id "F:181162")) "' '") "\n               ? (it->area != TEXT_AREA\n                  " (span (|@| (class "comment-delimiter") (id "F:181203")) "/* ") (span (|@| (class "comment") (id "F:181206")) "In mode line, treat \\n, \\t like other crl chars.  ") (span (|@| (class "comment-delimiter") (id "F:181256")) "*/") "\n                  || (it->c != " (span (|@| (class "string") (id "F:181276")) "'\\t'") "\n                      && it->glyph_row\n                      && (it->glyph_row->mode_line_p || it->avoid_cursor_p))\n                  || (it->c != " (span (|@| (class "string") (id "F:181386")) "'\\n'") " && it->c != " (span (|@| (class "string") (id "F:181403")) "'\\t'") "))\n               : (nbsp_or_shy\n                  || (it->multibyte_p\n                      ? " (span (|@| (class "negation-char") (id "F:181467")) "!") " CHAR_PRINTABLE_P (it->c)\n                      : (" (span (|@| (class "negation-char") (id "F:181505")) "!") " unibyte_display_via_language_environment\n                         ? it->c >= 0x80\n                         : (decoded >= 0x80 && decoded < 0xA0))))))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:181629")) "/* ") (span (|@| (class "comment") (id "F:181632")) "IT->c is a control character which must be displayed\n                 either as '\\003' or as `^C' where the '\\\\' and '^'\n                 can be defined in the display table.  Fill\n                 IT->ctl_chars with glyphs for what we have to\n                 display.  Then, set IT->dpvec to these glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:181885")) "*/") "\n              " (span (|@| (class "type") (id "F:181895")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:181907")) "gc") ";\n              " (span (|@| (class "type") (id "F:181918")) "int") " " (span (|@| (class "variable-name") (id "F:181922")) "ctl_len") ";\n              " (span (|@| (class "type") (id "F:181938")) "int") " " (span (|@| (class "variable-name") (id "F:181942")) "face_id") ", " (span (|@| (class "variable-name") (id "F:181951")) "lface_id") " = 0 ;\n              " (span (|@| (class "type") (id "F:181973")) "int") " " (span (|@| (class "variable-name") (id "F:181977")) "escape_glyph") ";\n\n              " (span (|@| (class "comment-delimiter") (id "F:181999")) "/* ") (span (|@| (class "comment") (id "F:182002")) "Handle control characters with ^.  ") (span (|@| (class "comment-delimiter") (id "F:182037")) "*/") "\n\n              " (span (|@| (class "keyword") (id "F:182048")) "if") " (it->c < 128 && it->ctl_arrow_p)\n                {\n                  " (span (|@| (class "type") (id "F:182092")) "int") " " (span (|@| (class "variable-name") (id "F:182096")) "g") ";\n\n                  g = " (span (|@| (class "string") (id "F:182108")) "'^'") ";           " (span (|@| (class "comment-delimiter") (id "F:182118")) "/* ") (span (|@| (class "comment") (id "F:182121")) "default glyph for Control ") (span (|@| (class "comment-delimiter") (id "F:182147")) "*/") "\n                  " (span (|@| (class "comment-delimiter") (id "F:182154")) "/* ") (span (|@| (class "comment") (id "F:182157")) "Set IT->ctl_chars[0] to the glyph for `^'.  ") (span (|@| (class "comment-delimiter") (id "F:182201")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:182208")) "if") " (it->dp\n                      && (gc = DISP_CTRL_GLYPH (it->dp), GLYPH_CODE_P (gc))\n                      && GLYPH_CODE_CHAR_VALID_P (gc))\n                    {\n                      g = GLYPH_CODE_CHAR (gc);\n                      lface_id = GLYPH_CODE_FACE (gc);\n                    }\n                  " (span (|@| (class "keyword") (id "F:182417")) "if") " (lface_id)\n                    {\n                      face_id = merge_faces (it->f, Qt, lface_id, it->face_id);\n                    }\n                  " (span (|@| (class "keyword") (id "F:182517")) "else") " " (span (|@| (class "keyword") (id "F:182522")) "if") " (it->f == last_escape_glyph_frame\n                           && it->face_id == last_escape_glyph_face_id)\n                    {\n                      face_id = last_escape_glyph_merged_face_id;\n                    }\n                  " (span (|@| (class "keyword") (id "F:182682")) "else") "\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:182703")) "/* ") (span (|@| (class "comment") (id "F:182706")) "Merge the escape-glyph face into the current face.  ") (span (|@| (class "comment-delimiter") (id "F:182758")) "*/") "\n                      face_id = merge_faces (it->f, Qescape_glyph, 0,\n                                             it->face_id);\n                      last_escape_glyph_frame = it->f;\n                      last_escape_glyph_face_id = it->face_id;\n                      last_escape_glyph_merged_face_id = face_id;\n                    }\n\n                  XSETINT (it->ctl_chars[0], g);\n                  XSETINT (it->ctl_chars[1], it->c ^ 0100);\n                  ctl_len = 2;\n                  " (span (|@| (class "keyword") (id "F:183094")) "goto") " " (span (|@| (class "constant") (id "F:183099")) "display_control") ";\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:183128")) "/* ") (span (|@| (class "comment") (id "F:183131")) "Handle non-break space in the mode where it only gets\n                 highlighting.  ") (span (|@| (class "comment-delimiter") (id "F:183203")) "*/") "\n\n              " (span (|@| (class "keyword") (id "F:183214")) "if") " (EQ (Vnobreak_char_display, Qt)\n                  && nbsp_or_shy == char_is_nbsp)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:183293")) "/* ") (span (|@| (class "comment") (id "F:183296")) "Merge the no-break-space face into the current face.  ") (span (|@| (class "comment-delimiter") (id "F:183350")) "*/") "\n                  face_id = merge_faces (it->f, Qnobreak_space, 0,\n                                         it->face_id);\n\n                  it->c = " (span (|@| (class "string") (id "F:183439")) "' '") ";\n                  XSETINT (it->ctl_chars[0], " (span (|@| (class "string") (id "F:183475")) "' '") ");\n                  ctl_len = 1;\n                  " (span (|@| (class "keyword") (id "F:183502")) "goto") " " (span (|@| (class "constant") (id "F:183507")) "display_control") ";\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:183536")) "/* ") (span (|@| (class "comment") (id "F:183539")) "Handle sequences that start with the \"escape glyph\".  ") (span (|@| (class "comment-delimiter") (id "F:183593")) "*/") "\n\n              " (span (|@| (class "comment-delimiter") (id "F:183604")) "/* ") (span (|@| (class "comment") (id "F:183607")) "the default escape glyph is \\.  ") (span (|@| (class "comment-delimiter") (id "F:183639")) "*/") "\n              escape_glyph = " (span (|@| (class "string") (id "F:183664")) "'\\\\'") ";\n\n              " (span (|@| (class "keyword") (id "F:183678")) "if") " (it->dp\n                  && (gc = DISP_ESCAPE_GLYPH (it->dp), GLYPH_CODE_P (gc))\n                  && GLYPH_CODE_CHAR_VALID_P (gc))\n                {\n                  escape_glyph = GLYPH_CODE_CHAR (gc);\n                  lface_id = GLYPH_CODE_FACE (gc);\n                }\n              " (span (|@| (class "keyword") (id "F:183879")) "if") " (lface_id)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:183901")) "/* ") (span (|@| (class "comment") (id "F:183904")) "The display table specified a face.\n                     Merge it into face_id and also into escape_glyph.  ") (span (|@| (class "comment-delimiter") (id "F:183998")) "*/") "\n                  face_id = merge_faces (it->f, Qt, lface_id,\n                                         it->face_id);\n                }\n              " (span (|@| (class "keyword") (id "F:184080")) "else") " " (span (|@| (class "keyword") (id "F:184085")) "if") " (it->f == last_escape_glyph_frame\n                       && it->face_id == last_escape_glyph_face_id)\n                {\n                  face_id = last_escape_glyph_merged_face_id;\n                }\n              " (span (|@| (class "keyword") (id "F:184239")) "else") "\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:184252")) "/* ") (span (|@| (class "comment") (id "F:184255")) "Merge the escape-glyph face into the current face.  ") (span (|@| (class "comment-delimiter") (id "F:184307")) "*/") "\n                  face_id = merge_faces (it->f, Qescape_glyph, 0,\n                                         it->face_id);\n                  last_escape_glyph_frame = it->f;\n                  last_escape_glyph_face_id = it->face_id;\n                  last_escape_glyph_merged_face_id = face_id;\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:184524")) "/* ") (span (|@| (class "comment") (id "F:184527")) "Handle soft hyphens in the mode where they only get\n                 highlighting.  ") (span (|@| (class "comment-delimiter") (id "F:184597")) "*/") "\n\n              " (span (|@| (class "keyword") (id "F:184608")) "if") " (EQ (Vnobreak_char_display, Qt)\n                  && nbsp_or_shy == char_is_soft_hyphen)\n                {\n                  it->c = " (span (|@| (class "string") (id "F:184702")) "'-'") ";\n                  XSETINT (it->ctl_chars[0], " (span (|@| (class "string") (id "F:184738")) "'-'") ");\n                  ctl_len = 1;\n                  " (span (|@| (class "keyword") (id "F:184765")) "goto") " " (span (|@| (class "constant") (id "F:184770")) "display_control") ";\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:184799")) "/* ") (span (|@| (class "comment") (id "F:184802")) "Handle non-break space and soft hyphen\n                 with the escape glyph.  ") (span (|@| (class "comment-delimiter") (id "F:184868")) "*/") "\n\n              " (span (|@| (class "keyword") (id "F:184879")) "if") " (nbsp_or_shy)\n                {\n                  XSETINT (it->ctl_chars[0], escape_glyph);\n                  it->c = (nbsp_or_shy == char_is_nbsp ? " (span (|@| (class "string") (id "F:184989")) "' '") " : " (span (|@| (class "string") (id "F:184995")) "'-'") ");\n                  XSETINT (it->ctl_chars[1], it->c);\n                  ctl_len = 2;\n                  " (span (|@| (class "keyword") (id "F:185061")) "goto") " " (span (|@| (class "constant") (id "F:185066")) "display_control") ";\n                }\n\n              {\n                " (span (|@| (class "type") (id "F:185099")) "unsigned") " " (span (|@| (class "type") (id "F:185108")) "char") " " (span (|@| (class "variable-name") (id "F:185113")) "str") "[MAX_MULTIBYTE_LENGTH];\n                " (span (|@| (class "type") (id "F:185142")) "int") " " (span (|@| (class "variable-name") (id "F:185146")) "len") ";\n                " (span (|@| (class "type") (id "F:185153")) "int") " " (span (|@| (class "variable-name") (id "F:185157")) "i") ";\n\n                " (span (|@| (class "comment-delimiter") (id "F:185163")) "/* ") (span (|@| (class "comment") (id "F:185166")) "Set IT->ctl_chars[0] to the glyph for `\\\\'.  ") (span (|@| (class "comment-delimiter") (id "F:185211")) "*/") "\n                " (span (|@| (class "keyword") (id "F:185216")) "if") " (CHAR_BYTE8_P (it->c))\n                  {\n                    str[0] = CHAR_TO_BYTE8 (it->c);\n                    len = 1;\n                  }\n                " (span (|@| (class "keyword") (id "F:185309")) "else") " " (span (|@| (class "keyword") (id "F:185314")) "if") " (it->c < 256)\n                  {\n                    str[0] = it->c;\n                    len = 1;\n                  }\n                " (span (|@| (class "keyword") (id "F:185382")) "else") "\n                  {\n                    " (span (|@| (class "comment-delimiter") (id "F:185399")) "/* ") (span (|@| (class "comment") (id "F:185402")) "It's an invalid character, which shouldn't\n                       happen actually, but due to bugs it may\n                       happen.  Let's print the char as is, there's\n                       not much meaningful we can do with it.  ") (span (|@| (class "comment-delimiter") (id "F:185597")) "*/") "\n                    str[0] = it->c;\n                    str[1] = it->c >> 8;\n                    str[2] = it->c >> 16;\n                    str[3] = it->c >> 24;\n                    len = 4;\n                  }\n\n                " (span (|@| (class "keyword") (id "F:185729")) "for") " (i = 0; i < len; i++)\n                  {\n                    " (span (|@| (class "type") (id "F:185767")) "int") " " (span (|@| (class "variable-name") (id "F:185771")) "g") ";\n                    XSETINT (it->ctl_chars[i * 4], escape_glyph);\n                    " (span (|@| (class "comment-delimiter") (id "F:185832")) "/* ") (span (|@| (class "comment") (id "F:185835")) "Insert three more glyphs into IT->ctl_chars for\n                       the octal display of the character.  ") (span (|@| (class "comment-delimiter") (id "F:185929")) "*/") "\n                    g = ((str[i] >> 6) & 7) + " (span (|@| (class "string") (id "F:185964")) "'0'") ";\n                    XSETINT (it->ctl_chars[i * 4 + 1], g);\n                    g = ((str[i] >> 3) & 7) + " (span (|@| (class "string") (id "F:186046")) "'0'") ";\n                    XSETINT (it->ctl_chars[i * 4 + 2], g);\n                    g = (str[i] & 7) + " (span (|@| (class "string") (id "F:186121")) "'0'") ";\n                    XSETINT (it->ctl_chars[i * 4 + 3], g);\n                  }\n                ctl_len = len * 4;\n              }\n\n            " (span (|@| (class "constant") (id "F:186213")) "display_control") ":\n              " (span (|@| (class "comment-delimiter") (id "F:186237")) "/* ") (span (|@| (class "comment") (id "F:186240")) "Set up IT->dpvec and return first character from it.  ") (span (|@| (class "comment-delimiter") (id "F:186294")) "*/") "\n              it->dpvec_char_len = it->len;\n              it->dpvec = it->ctl_chars;\n              it->dpend = it->dpvec + ctl_len;\n              it->current.dpvec_index = 0;\n              it->dpvec_face_id = face_id;\n              it->saved_face_id = it->face_id;\n              it->method = GET_FROM_DISPLAY_VECTOR;\n              it->ellipsis_p = 0;\n              " (span (|@| (class "keyword") (id "F:186599")) "goto") " " (span (|@| (class "constant") (id "F:186604")) "get_next") ";\n            }\n        }\n    }\n\n" (span (|@| (class "preprocessor") (id "F:186631")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "comment-delimiter") (id "F:186659")) "/* ") (span (|@| (class "comment") (id "F:186662")) "Adjust face id for a multibyte character.  There are no multibyte\n     character in unibyte text.  ") (span (|@| (class "comment-delimiter") (id "F:186761")) "*/") "\n  " (span (|@| (class "keyword") (id "F:186766")) "if") " ((it->what == IT_CHARACTER || it->what == IT_COMPOSITION)\n      && it->multibyte_p\n      && success_p\n      && FRAME_WINDOW_P (it->f))\n    {\n      " (span (|@| (class "keyword") (id "F:186916")) "struct") " " (span (|@| (class "type") (id "F:186923")) "face") " *" (span (|@| (class "variable-name") (id "F:186929")) "face") " = FACE_FROM_ID (it->f, it->face_id);\n\n      " (span (|@| (class "keyword") (id "F:186978")) "if") " (it->what == IT_COMPOSITION && it->cmp_it.ch >= 0)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:187038")) "/* ") (span (|@| (class "comment") (id "F:187041")) "Automatic composition with glyph-string.   ") (span (|@| (class "comment-delimiter") (id "F:187084")) "*/") "\n          " (span (|@| (class "type") (id "F:187090")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:187102")) "gstring") " = composition_gstring_from_id (it->cmp_it.id);\n\n          it->face_id = face_for_font (it->f, LGSTRING_FONT (gstring), face);\n        }\n      " (span (|@| (class "keyword") (id "F:187238")) "else") "\n        {\n          " (span (|@| (class "type") (id "F:187249")) "int") " " (span (|@| (class "variable-name") (id "F:187253")) "pos") " = (it->s ? -1\n                     : STRINGP (it->string) ? IT_STRING_CHARPOS (*it)\n                     : IT_CHARPOS (*it));\n\n          it->face_id = FACE_FOR_CHAR (it->f, face, it->c, pos, it->string);\n        }\n    }\n" (span (|@| (class "preprocessor") (id "F:187435")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:187445")) "/* ") (span (|@| (class "comment") (id "F:187448")) "Is this character the last one of a run of characters with\n     box?  If yes, set IT->end_of_box_run_p to 1.  ") (span (|@| (class "comment-delimiter") (id "F:187558")) "*/") "\n  " (span (|@| (class "keyword") (id "F:187563")) "if") " (it->face_box_p\n      && it->s == " (span (|@| (class "constant") (id "F:187600")) "NULL") ")\n    {\n      " (span (|@| (class "keyword") (id "F:187618")) "if") " (it->method == GET_FROM_STRING && it->sp)\n        {\n          " (span (|@| (class "type") (id "F:187669")) "int") " " (span (|@| (class "variable-name") (id "F:187673")) "face_id") " = underlying_face_id (it);\n          " (span (|@| (class "keyword") (id "F:187711")) "struct") " " (span (|@| (class "type") (id "F:187718")) "face") " *" (span (|@| (class "variable-name") (id "F:187724")) "face") " = FACE_FROM_ID (it->f, face_id);\n\n          " (span (|@| (class "keyword") (id "F:187766")) "if") " (face)\n            {\n              " (span (|@| (class "keyword") (id "F:187790")) "if") " (face->box == FACE_NO_BOX)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:187828")) "/* ") (span (|@| (class "comment") (id "F:187831")) "If the box comes from face properties in a\n                     display string, check faces in that string.  ") (span (|@| (class "comment-delimiter") (id "F:187926")) "*/") "\n                  " (span (|@| (class "type") (id "F:187933")) "int") " " (span (|@| (class "variable-name") (id "F:187937")) "string_face_id") " = face_after_it_pos (it);\n                  it->end_of_box_run_p\n                    = (FACE_FROM_ID (it->f, string_face_id)->box\n                       == FACE_NO_BOX);\n                }\n              " (span (|@| (class "comment-delimiter") (id "F:188091")) "/* ") (span (|@| (class "comment") (id "F:188094")) "Otherwise, the box comes from the underlying face.\n                 If this is the last string character displayed, check\n                 the next buffer location.  ") (span (|@| (class "comment-delimiter") (id "F:188232")) "*/") "\n              " (span (|@| (class "keyword") (id "F:188242")) "else") " " (span (|@| (class "keyword") (id "F:188247")) "if") " ((IT_STRING_CHARPOS (*it) >= SCHARS (it->string) - 1)\n                       && (it->current.overlay_string_index\n                           == it->n_overlay_strings - 1))\n                {\n                  " (span (|@| (class "type") (id "F:188395")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:188405")) "ignore") ";\n                  " (span (|@| (class "type") (id "F:188417")) "int") " " (span (|@| (class "variable-name") (id "F:188421")) "next_face_id") ";\n                  " (span (|@| (class "keyword") (id "F:188439")) "struct") " " (span (|@| (class "type") (id "F:188446")) "text_pos") " " (span (|@| (class "variable-name") (id "F:188455")) "pos") " = it->current.pos;\n                  INC_TEXT_POS (pos, it->multibyte_p);\n\n                  next_face_id = face_at_buffer_position\n                    (it->w, CHARPOS (pos), it->region_beg_charpos,\n                     it->region_end_charpos, &ignore,\n                     (IT_CHARPOS (*it) + TEXT_PROP_DISTANCE_LIMIT), 0,\n                     -1);\n                  it->end_of_box_run_p\n                    = (FACE_FROM_ID (it->f, next_face_id)->box\n                       == FACE_NO_BOX);\n                }\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:188845")) "else") "\n        {\n          " (span (|@| (class "type") (id "F:188856")) "int") " " (span (|@| (class "variable-name") (id "F:188860")) "face_id") " = face_after_it_pos (it);\n          it->end_of_box_run_p\n            = (face_id != it->face_id\n               && FACE_FROM_ID (it->f, face_id)->box == FACE_NO_BOX);\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:189024")) "/* ") (span (|@| (class "comment") (id "F:189027")) "Value is 0 if end of buffer or string reached.  ") (span (|@| (class "comment-delimiter") (id "F:189075")) "*/") "\n  " (span (|@| (class "keyword") (id "F:189080")) "return") " success_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:189102")) "/* ") (span (|@| (class "comment") (id "F:189105")) "Move IT to the next display element.\n\n   RESEAT_P non-zero means if called on a newline in buffer text,\n   skip to the next visible line start.\n\n   Functions get_next_display_element and set_iterator_to_next are\n   separate because I find this arrangement easier to handle than a\n   get_next_display_element function that also increments IT's\n   position.  The way it is we can first look at an iterator's current\n   display element, decide whether it fits on a line, and if it does,\n   increment the iterator position.  The other way around we probably\n   would either need a flag indicating whether the iterator has to be\n   incremented the next time, or we would have to implement a\n   decrement position function which would not be easy to write.  ") (span (|@| (class "comment-delimiter") (id "F:189857")) "*/") "\n\n" (span (|@| (class "type") (id "F:189861")) "void") "\n" (span (|@| (class "function-name") (id "F:189866")) "set_iterator_to_next") " (" (span (|@| (class "type") (id "F:189888")) "it") ", reseat_p)\n     " (span (|@| (class "keyword") (id "F:189907")) "struct") " " (span (|@| (class "type") (id "F:189914")) "it") " *" (span (|@| (class "variable-name") (id "F:189918")) "it") ";\n     " (span (|@| (class "type") (id "F:189927")) "int") " " (span (|@| (class "variable-name") (id "F:189931")) "reseat_p") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:189945")) "/* ") (span (|@| (class "comment") (id "F:189948")) "Reset flags indicating start and end of a sequence of characters\n     with box.  Reset them at the start of this function because\n     moving the iterator to a new position might set them.  ") (span (|@| (class "comment-delimiter") (id "F:190138")) "*/") "\n  it->start_of_box_run_p = it->end_of_box_run_p = 0;\n\n  " (span (|@| (class "keyword") (id "F:190197")) "switch") " (it->method)\n    {\n    " (span (|@| (class "keyword") (id "F:190227")) "case") " GET_FROM_BUFFER:\n      " (span (|@| (class "comment-delimiter") (id "F:190255")) "/* ") (span (|@| (class "comment") (id "F:190258")) "The current display element of IT is a character from\n         current_buffer.  Advance in the buffer, and maybe skip over\n         invisible lines that are so because of selective display.  ") (span (|@| (class "comment-delimiter") (id "F:190435")) "*/") "\n      " (span (|@| (class "keyword") (id "F:190444")) "if") " (ITERATOR_AT_END_OF_LINE_P (it) && reseat_p)\n        reseat_at_next_visible_line_start (it, 0);\n      " (span (|@| (class "keyword") (id "F:190542")) "else") " " (span (|@| (class "keyword") (id "F:190547")) "if") " (it->cmp_it.id >= 0)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:190577")) "/* ") (span (|@| (class "comment") (id "F:190580")) "We are currently getting glyphs from a composition.  ") (span (|@| (class "comment-delimiter") (id "F:190633")) "*/") "\n          " (span (|@| (class "type") (id "F:190639")) "int") " " (span (|@| (class "variable-name") (id "F:190643")) "i") ";\n\n          " (span (|@| (class "keyword") (id "F:190650")) "if") " (" (span (|@| (class "negation-char") (id "F:190654")) "!") " it->bidi_p)\n            {\n              IT_CHARPOS (*it) += it->cmp_it.nchars;\n              IT_BYTEPOS (*it) += it->cmp_it.nbytes;\n              " (span (|@| (class "keyword") (id "F:190774")) "if") " (it->cmp_it.to < it->cmp_it.nglyphs)\n                {\n                  it->cmp_it.from = it->cmp_it.to;\n                }\n              " (span (|@| (class "keyword") (id "F:190866")) "else") "\n                {\n                  it->cmp_it.id = -1;\n                  composition_compute_stop_pos (&it->cmp_it, IT_CHARPOS (*it),\n                                                IT_BYTEPOS (*it),\n                                                it->stop_charpos, Qnil);\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:191033")) "else") " " (span (|@| (class "keyword") (id "F:191038")) "if") " (" (span (|@| (class "negation-char") (id "F:191042")) "!") " it->cmp_it.reversed_p)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:191081")) "/* ") (span (|@| (class "comment") (id "F:191084")) "Composition created while scanning forward.  ") (span (|@| (class "comment-delimiter") (id "F:191129")) "*/") "\n              " (span (|@| (class "comment-delimiter") (id "F:191139")) "/* ") (span (|@| (class "comment") (id "F:191142")) "Update IT's char/byte positions to point to the first\n                 character of the next grapheme cluster, or to the\n                 character visually after the current composition.  ") (span (|@| (class "comment-delimiter") (id "F:191303")) "*/") "\n              " (span (|@| (class "keyword") (id "F:191313")) "for") " (i = 0; i < it->cmp_it.nchars; i++)\n                bidi_move_to_visually_next (&it->bidi_it);\n              IT_BYTEPOS (*it) = it->bidi_it.bytepos;\n              IT_CHARPOS (*it) = it->bidi_it.charpos;\n\n              " (span (|@| (class "keyword") (id "F:191500")) "if") " (it->cmp_it.to < it->cmp_it.nglyphs)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:191548")) "/* ") (span (|@| (class "comment") (id "F:191551")) "Proceed to the next grapheme cluster.  ") (span (|@| (class "comment-delimiter") (id "F:191590")) "*/") "\n                  it->cmp_it.from = it->cmp_it.to;\n                }\n              " (span (|@| (class "keyword") (id "F:191641")) "else") "\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:191654")) "/* ") (span (|@| (class "comment") (id "F:191657")) "No more grapheme clusters in this composition.\n                     Find the next stop position.  ") (span (|@| (class "comment-delimiter") (id "F:191741")) "*/") "\n                  " (span (|@| (class "type") (id "F:191748")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:191758")) "stop") " = it->stop_charpos;\n                  " (span (|@| (class "keyword") (id "F:191787")) "if") " (it->bidi_it.scan_dir < 0)\n                    " (span (|@| (class "comment-delimiter") (id "F:191823")) "/* ") (span (|@| (class "comment") (id "F:191826")) "Now we are scanning backward and don't know\n                       where to stop.  ") (span (|@| (class "comment-delimiter") (id "F:191895")) "*/") "\n                    stop = -1;\n                  composition_compute_stop_pos (&it->cmp_it, IT_CHARPOS (*it),\n                                                IT_BYTEPOS (*it), stop, Qnil);\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:192031")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:192050")) "/* ") (span (|@| (class "comment") (id "F:192053")) "Composition created while scanning backward.  ") (span (|@| (class "comment-delimiter") (id "F:192099")) "*/") "\n              " (span (|@| (class "comment-delimiter") (id "F:192109")) "/* ") (span (|@| (class "comment") (id "F:192112")) "Update IT's char/byte positions to point to the last\n                 character of the previous grapheme cluster, or the\n                 character visually after the current composition.  ") (span (|@| (class "comment-delimiter") (id "F:192273")) "*/") "\n              " (span (|@| (class "keyword") (id "F:192283")) "for") " (i = 0; i < it->cmp_it.nchars; i++)\n                bidi_move_to_visually_next (&it->bidi_it);\n              IT_BYTEPOS (*it) = it->bidi_it.bytepos;\n              IT_CHARPOS (*it) = it->bidi_it.charpos;\n              " (span (|@| (class "keyword") (id "F:192469")) "if") " (it->cmp_it.from > 0)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:192502")) "/* ") (span (|@| (class "comment") (id "F:192505")) "Proceed to the previous grapheme cluster.  ") (span (|@| (class "comment-delimiter") (id "F:192548")) "*/") "\n                  it->cmp_it.to = it->cmp_it.from;\n                }\n              " (span (|@| (class "keyword") (id "F:192599")) "else") "\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:192612")) "/* ") (span (|@| (class "comment") (id "F:192615")) "No more grapheme clusters in this composition.\n                     Find the next stop position.  ") (span (|@| (class "comment-delimiter") (id "F:192699")) "*/") "\n                  " (span (|@| (class "type") (id "F:192706")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:192716")) "stop") " = it->stop_charpos;\n                  " (span (|@| (class "keyword") (id "F:192745")) "if") " (it->bidi_it.scan_dir < 0)\n                    " (span (|@| (class "comment-delimiter") (id "F:192781")) "/* ") (span (|@| (class "comment") (id "F:192784")) "Now we are scanning backward and don't know\n                       where to stop.  ") (span (|@| (class "comment-delimiter") (id "F:192853")) "*/") "\n                    stop = -1;\n                  composition_compute_stop_pos (&it->cmp_it, IT_CHARPOS (*it),\n                                                IT_BYTEPOS (*it), stop, Qnil);\n                }\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:192995")) "else") "\n        {\n          xassert (it->len != 0);\n\n          " (span (|@| (class "keyword") (id "F:193034")) "if") " (" (span (|@| (class "negation-char") (id "F:193038")) "!") "it->bidi_p)\n            {\n              IT_BYTEPOS (*it) += it->len;\n              IT_CHARPOS (*it) += 1;\n            }\n          " (span (|@| (class "keyword") (id "F:193134")) "else") "\n            {\n              " (span (|@| (class "type") (id "F:193153")) "int") " " (span (|@| (class "variable-name") (id "F:193157")) "prev_scan_dir") " = it->bidi_it.scan_dir;\n              " (span (|@| (class "comment-delimiter") (id "F:193202")) "/* ") (span (|@| (class "comment") (id "F:193205")) "If this is a new paragraph, determine its base\n                 direction (a.k.a. its base embedding level).  ") (span (|@| (class "comment-delimiter") (id "F:193301")) "*/") "\n              " (span (|@| (class "keyword") (id "F:193311")) "if") " (it->bidi_it.new_paragraph)\n                bidi_paragraph_init (it->paragraph_embedding, &it->bidi_it);\n              bidi_move_to_visually_next (&it->bidi_it);\n              IT_BYTEPOS (*it) = it->bidi_it.bytepos;\n              IT_CHARPOS (*it) = it->bidi_it.charpos;\n              " (span (|@| (class "keyword") (id "F:193556")) "if") " (prev_scan_dir != it->bidi_it.scan_dir)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:193607")) "/* ") (span (|@| (class "comment") (id "F:193610")) "As the scan direction was changed, we must\n                     re-compute the stop position for composition.  ") (span (|@| (class "comment-delimiter") (id "F:193707")) "*/") "\n                  " (span (|@| (class "type") (id "F:193714")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:193724")) "stop") " = it->stop_charpos;\n                  " (span (|@| (class "keyword") (id "F:193753")) "if") " (it->bidi_it.scan_dir < 0)\n                    stop = -1;\n                  composition_compute_stop_pos (&it->cmp_it, IT_CHARPOS (*it),\n                                                IT_BYTEPOS (*it), stop, Qnil);\n                }\n            }\n          xassert (IT_BYTEPOS (*it) == CHAR_TO_BYTE (IT_CHARPOS (*it)));\n        }\n      " (span (|@| (class "keyword") (id "F:193988")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:194000")) "case") " GET_FROM_C_STRING:\n      " (span (|@| (class "comment-delimiter") (id "F:194030")) "/* ") (span (|@| (class "comment") (id "F:194033")) "Current display element of IT is from a C string.  ") (span (|@| (class "comment-delimiter") (id "F:194084")) "*/") "\n      IT_BYTEPOS (*it) += it->len;\n      IT_CHARPOS (*it) += 1;\n      " (span (|@| (class "keyword") (id "F:194157")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:194169")) "case") " GET_FROM_DISPLAY_VECTOR:\n      " (span (|@| (class "comment-delimiter") (id "F:194205")) "/* ") (span (|@| (class "comment") (id "F:194208")) "Current display element of IT is from a display table entry.\n         Advance in the display table definition.  Reset it to null if\n         end reached, and continue with characters from buffers/\n         strings.  ") (span (|@| (class "comment-delimiter") (id "F:194403")) "*/") "\n      ++it->current.dpvec_index;\n\n      " (span (|@| (class "comment-delimiter") (id "F:194446")) "/* ") (span (|@| (class "comment") (id "F:194449")) "Restore face of the iterator to what they were before the\n         display vector entry (these entries may contain faces).  ") (span (|@| (class "comment-delimiter") (id "F:194573")) "*/") "\n      it->face_id = it->saved_face_id;\n\n      " (span (|@| (class "keyword") (id "F:194622")) "if") " (it->dpvec + it->current.dpvec_index == it->dpend)\n        {\n          " (span (|@| (class "type") (id "F:194682")) "int") " " (span (|@| (class "variable-name") (id "F:194686")) "recheck_faces") " = it->ellipsis_p;\n\n          " (span (|@| (class "keyword") (id "F:194722")) "if") " (it->s)\n            it->method = GET_FROM_C_STRING;\n          " (span (|@| (class "keyword") (id "F:194773")) "else") " " (span (|@| (class "keyword") (id "F:194778")) "if") " (STRINGP (it->string))\n            it->method = GET_FROM_STRING;\n          " (span (|@| (class "keyword") (id "F:194842")) "else") "\n            {\n              it->method = GET_FROM_BUFFER;\n              it->object = it->w->buffer;\n            }\n\n          it->dpvec = " (span (|@| (class "constant") (id "F:194949")) "NULL") ";\n          it->current.dpvec_index = -1;\n\n          " (span (|@| (class "comment-delimiter") (id "F:194992")) "/* ") (span (|@| (class "comment") (id "F:194995")) "Skip over characters which were displayed via IT->dpvec.  ") (span (|@| (class "comment-delimiter") (id "F:195053")) "*/") "\n          " (span (|@| (class "keyword") (id "F:195059")) "if") " (it->dpvec_char_len < 0)\n            reseat_at_next_visible_line_start (it, 1);\n          " (span (|@| (class "keyword") (id "F:195138")) "else") " " (span (|@| (class "keyword") (id "F:195143")) "if") " (it->dpvec_char_len > 0)\n            {\n              " (span (|@| (class "keyword") (id "F:195185")) "if") " (it->method == GET_FROM_STRING\n                  && it->n_overlay_strings > 0)\n                it->ignore_overlay_strings_at_pos_p = 1;\n              it->len = it->dpvec_char_len;\n              set_iterator_to_next (it, reseat_p);\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:195388")) "/* ") (span (|@| (class "comment") (id "F:195391")) "Maybe recheck faces after display vector ") (span (|@| (class "comment-delimiter") (id "F:195432")) "*/") "\n          " (span (|@| (class "keyword") (id "F:195438")) "if") " (recheck_faces)\n            it->stop_charpos = IT_CHARPOS (*it);\n        }\n      " (span (|@| (class "keyword") (id "F:195508")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:195520")) "case") " GET_FROM_STRING:\n      " (span (|@| (class "comment-delimiter") (id "F:195548")) "/* ") (span (|@| (class "comment") (id "F:195551")) "Current display element is a character from a Lisp string.  ") (span (|@| (class "comment-delimiter") (id "F:195611")) "*/") "\n      xassert (it->s == " (span (|@| (class "constant") (id "F:195638")) "NULL") " && STRINGP (it->string));\n      " (span (|@| (class "keyword") (id "F:195675")) "if") " (it->cmp_it.id >= 0)\n        {\n          IT_STRING_CHARPOS (*it) += it->cmp_it.nchars;\n          IT_STRING_BYTEPOS (*it) += it->cmp_it.nbytes;\n          " (span (|@| (class "keyword") (id "F:195803")) "if") " (it->cmp_it.to < it->cmp_it.nglyphs)\n            it->cmp_it.from = it->cmp_it.to;\n          " (span (|@| (class "keyword") (id "F:195884")) "else") "\n            {\n              it->cmp_it.id = -1;\n              composition_compute_stop_pos (&it->cmp_it,\n                                            IT_STRING_CHARPOS (*it),\n                                            IT_STRING_BYTEPOS (*it),\n                                            it->stop_charpos, it->string);\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:196097")) "else") "\n        {\n          IT_STRING_BYTEPOS (*it) += it->len;\n          IT_STRING_CHARPOS (*it) += 1;\n        }\n\n    " (span (|@| (class "constant") (id "F:196185")) "consider_string_end") ":\n\n      " (span (|@| (class "keyword") (id "F:196213")) "if") " (it->current.overlay_string_index >= 0)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:196262")) "/* ") (span (|@| (class "comment") (id "F:196265")) "IT->string is an overlay string.  Advance to the\n             next, if there is one.  ") (span (|@| (class "comment-delimiter") (id "F:196344")) "*/") "\n          " (span (|@| (class "keyword") (id "F:196350")) "if") " (IT_STRING_CHARPOS (*it) >= SCHARS (it->string))\n            {\n              it->ellipsis_p = 0;\n              next_overlay_string (it);\n              " (span (|@| (class "keyword") (id "F:196476")) "if") " (it->ellipsis_p)\n                setup_for_ellipsis (it, 0);\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:196542")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:196553")) "/* ") (span (|@| (class "comment") (id "F:196556")) "IT->string is not an overlay string.  If we reached\n             its end, and there is something on IT->stack, proceed\n             with what is on the stack.  This can be either another\n             string, this time an overlay string, or a buffer.  ") (span (|@| (class "comment-delimiter") (id "F:196786")) "*/") "\n          " (span (|@| (class "keyword") (id "F:196792")) "if") " (IT_STRING_CHARPOS (*it) == SCHARS (it->string)\n              && it->sp > 0)\n            {\n              pop_it (it);\n              " (span (|@| (class "keyword") (id "F:196899")) "if") " (it->method == GET_FROM_STRING)\n                " (span (|@| (class "keyword") (id "F:196936")) "goto") " " (span (|@| (class "constant") (id "F:196941")) "consider_string_end") ";\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:196978")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:196990")) "case") " GET_FROM_IMAGE:\n    " (span (|@| (class "keyword") (id "F:197015")) "case") " GET_FROM_STRETCH:\n      " (span (|@| (class "comment-delimiter") (id "F:197044")) "/* ") (span (|@| (class "comment") (id "F:197047")) "The position etc with which we have to proceed are on\n         the stack.  The position may be at the end of a string,\n         if the `display' property takes up the whole string.  ") (span (|@| (class "comment-delimiter") (id "F:197222")) "*/") "\n      xassert (it->sp > 0);\n      pop_it (it);\n      " (span (|@| (class "keyword") (id "F:197278")) "if") " (it->method == GET_FROM_STRING)\n        " (span (|@| (class "keyword") (id "F:197314")) "goto") " " (span (|@| (class "constant") (id "F:197319")) "consider_string_end") ";\n      " (span (|@| (class "keyword") (id "F:197346")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:197358")) "default") ":\n      " (span (|@| (class "comment-delimiter") (id "F:197373")) "/* ") (span (|@| (class "comment") (id "F:197376")) "There are no other methods defined, so this should be a bug.  ") (span (|@| (class "comment-delimiter") (id "F:197438")) "*/") "\n      abort ();\n    }\n\n  xassert (it->method != GET_FROM_STRING\n           || (STRINGP (it->string)\n               && IT_STRING_CHARPOS (*it) >= 0));\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:197580")) "/* ") (span (|@| (class "comment") (id "F:197583")) "Load IT's display element fields with information about the next\n   display element which comes from a display table entry or from the\n   result of translating a control character to one of the forms `^C'\n   or `\\003'.\n\n   IT->dpvec holds the glyphs to return as characters.\n   IT->saved_face_id holds the face id before the display vector--it\n   is restored into IT->face_id in set_iterator_to_next.  ") (span (|@| (class "comment-delimiter") (id "F:197985")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:197989")) "static") " " (span (|@| (class "type") (id "F:197996")) "int") "\n" (span (|@| (class "function-name") (id "F:198000")) "next_element_from_display_vector") " (" (span (|@| (class "type") (id "F:198034")) "it") ")\n     " (span (|@| (class "keyword") (id "F:198043")) "struct") " " (span (|@| (class "type") (id "F:198050")) "it") " *" (span (|@| (class "variable-name") (id "F:198054")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:198062")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:198074")) "gc") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:198081")) "/* ") (span (|@| (class "comment") (id "F:198084")) "Precondition.  ") (span (|@| (class "comment-delimiter") (id "F:198099")) "*/") "\n  xassert (it->dpvec && it->current.dpvec_index >= 0);\n\n  it->face_id = it->saved_face_id;\n\n  " (span (|@| (class "comment-delimiter") (id "F:198196")) "/* ") (span (|@| (class "comment") (id "F:198199")) "KFS: This code used to check ip->dpvec[0] instead of the current element.\n     That seemed totally bogus - so I changed it...  ") (span (|@| (class "comment-delimiter") (id "F:198326")) "*/") "\n  gc = it->dpvec[it->current.dpvec_index];\n\n  " (span (|@| (class "keyword") (id "F:198375")) "if") " (GLYPH_CODE_P (gc) && GLYPH_CODE_CHAR_VALID_P (gc))\n    {\n      it->c = GLYPH_CODE_CHAR (gc);\n      it->len = CHAR_BYTES (it->c);\n\n      " (span (|@| (class "comment-delimiter") (id "F:198515")) "/* ") (span (|@| (class "comment") (id "F:198518")) "The entry may contain a face id to use.  Such a face id is\n         the id of a Lisp face, not a realized face.  A face id of\n         zero means no face is specified.  ") (span (|@| (class "comment-delimiter") (id "F:198673")) "*/") "\n      " (span (|@| (class "keyword") (id "F:198682")) "if") " (it->dpvec_face_id >= 0)\n        it->face_id = it->dpvec_face_id;\n      " (span (|@| (class "keyword") (id "F:198750")) "else") "\n        {\n          " (span (|@| (class "type") (id "F:198761")) "int") " " (span (|@| (class "variable-name") (id "F:198765")) "lface_id") " = GLYPH_CODE_FACE (gc);\n          " (span (|@| (class "keyword") (id "F:198801")) "if") " (lface_id > 0)\n            it->face_id = merge_faces (it->f, Qt, lface_id,\n                                       it->saved_face_id);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:198914")) "else") "\n    " (span (|@| (class "comment-delimiter") (id "F:198923")) "/* ") (span (|@| (class "comment") (id "F:198926")) "Display table entry is invalid.  Return a space.  ") (span (|@| (class "comment-delimiter") (id "F:198976")) "*/") "\n    it->c = " (span (|@| (class "string") (id "F:198991")) "' '") ", it->len = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:199012")) "/* ") (span (|@| (class "comment") (id "F:199015")) "Don't change position and object of the iterator here.  They are\n     still the values of the character that had this display table\n     entry or was translated, and that's what we want.  ") (span (|@| (class "comment-delimiter") (id "F:199203")) "*/") "\n  it->what = IT_CHARACTER;\n  " (span (|@| (class "keyword") (id "F:199235")) "return") " 1;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:199249")) "/* ") (span (|@| (class "comment") (id "F:199252")) "Load IT with the next display element from Lisp string IT->string.\n   IT->current.string_pos is the current position within the string.\n   If IT->current.overlay_string_index >= 0, the Lisp string is an\n   overlay string.  ") (span (|@| (class "comment-delimiter") (id "F:199475")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:199479")) "static") " " (span (|@| (class "type") (id "F:199486")) "int") "\n" (span (|@| (class "function-name") (id "F:199490")) "next_element_from_string") " (" (span (|@| (class "type") (id "F:199516")) "it") ")\n     " (span (|@| (class "keyword") (id "F:199525")) "struct") " " (span (|@| (class "type") (id "F:199532")) "it") " *" (span (|@| (class "variable-name") (id "F:199536")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:199544")) "struct") " " (span (|@| (class "type") (id "F:199551")) "text_pos") " " (span (|@| (class "variable-name") (id "F:199560")) "position") ";\n\n  xassert (STRINGP (it->string));\n  xassert (IT_STRING_CHARPOS (*it) >= 0);\n  position = it->current.string_pos;\n\n  " (span (|@| (class "comment-delimiter") (id "F:199687")) "/* ") (span (|@| (class "comment") (id "F:199690")) "Time to check for invisible text?  ") (span (|@| (class "comment-delimiter") (id "F:199725")) "*/") "\n  " (span (|@| (class "keyword") (id "F:199730")) "if") " (IT_STRING_CHARPOS (*it) < it->end_charpos\n      && IT_STRING_CHARPOS (*it) == it->stop_charpos)\n    {\n      handle_stop (it);\n\n      " (span (|@| (class "comment-delimiter") (id "F:199867")) "/* ") (span (|@| (class "comment") (id "F:199870")) "Since a handler may have changed IT->method, we must\n         recurse here.  ") (span (|@| (class "comment-delimiter") (id "F:199940")) "*/") "\n      " (span (|@| (class "keyword") (id "F:199949")) "return") " GET_NEXT_DISPLAY_ELEMENT (it);\n    }\n\n  " (span (|@| (class "keyword") (id "F:199996")) "if") " (it->current.overlay_string_index >= 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:200051")) "/* ") (span (|@| (class "comment") (id "F:200054")) "Get the next character from an overlay string.  In overlay\n         strings, There is no field width or padding with spaces to\n         do.  ") (span (|@| (class "comment-delimiter") (id "F:200181")) "*/") "\n      " (span (|@| (class "keyword") (id "F:200190")) "if") " (IT_STRING_CHARPOS (*it) >= SCHARS (it->string))\n        {\n          it->what = IT_EOB;\n          " (span (|@| (class "keyword") (id "F:200270")) "return") " 0;\n        }\n      " (span (|@| (class "keyword") (id "F:200289")) "else") " " (span (|@| (class "keyword") (id "F:200294")) "if") " (CHAR_COMPOSED_P (it, IT_STRING_CHARPOS (*it),\n                                IT_STRING_BYTEPOS (*it), SCHARS (it->string))\n               && next_element_from_composition (it))\n        {\n          " (span (|@| (class "keyword") (id "F:200447")) "return") " 1;\n        }\n      " (span (|@| (class "keyword") (id "F:200466")) "else") " " (span (|@| (class "keyword") (id "F:200471")) "if") " (STRING_MULTIBYTE (it->string))\n        {\n          " (span (|@| (class "type") (id "F:200512")) "int") " " (span (|@| (class "variable-name") (id "F:200516")) "remaining") " = SBYTES (it->string) - IT_STRING_BYTEPOS (*it);\n          " (span (|@| (class "keyword") (id "F:200578")) "const") " " (span (|@| (class "type") (id "F:200584")) "unsigned") " " (span (|@| (class "type") (id "F:200593")) "char") " *" (span (|@| (class "variable-name") (id "F:200599")) "s") " = (SDATA (it->string)\n                                    + IT_STRING_BYTEPOS (*it));\n          it->c = string_char_and_length (s, &it->len);\n        }\n      " (span (|@| (class "keyword") (id "F:200717")) "else") "\n        {\n          it->c = SREF (it->string, IT_STRING_BYTEPOS (*it));\n          it->len = 1;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:200807")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:200824")) "/* ") (span (|@| (class "comment") (id "F:200827")) "Get the next character from a Lisp string that is not an\n         overlay string.  Such strings come from the mode line, for\n         example.  We may have to pad with spaces, or truncate the\n         string.  See also next_element_from_c_string.  ") (span (|@| (class "comment-delimiter") (id "F:201054")) "*/") "\n      " (span (|@| (class "keyword") (id "F:201063")) "if") " (IT_STRING_CHARPOS (*it) >= it->end_charpos)\n        {\n          it->what = IT_EOB;\n          " (span (|@| (class "keyword") (id "F:201139")) "return") " 0;\n        }\n      " (span (|@| (class "keyword") (id "F:201158")) "else") " " (span (|@| (class "keyword") (id "F:201163")) "if") " (IT_STRING_CHARPOS (*it) >= it->string_nchars)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:201219")) "/* ") (span (|@| (class "comment") (id "F:201222")) "Pad with spaces.  ") (span (|@| (class "comment-delimiter") (id "F:201240")) "*/") "\n          it->c = " (span (|@| (class "string") (id "F:201254")) "' '") ", it->len = 1;\n          CHARPOS (position) = BYTEPOS (position) = -1;\n        }\n      " (span (|@| (class "keyword") (id "F:201330")) "else") " " (span (|@| (class "keyword") (id "F:201335")) "if") " (CHAR_COMPOSED_P (it, IT_STRING_CHARPOS (*it),\n                                IT_STRING_BYTEPOS (*it), it->string_nchars)\n               && next_element_from_composition (it))\n        {\n          " (span (|@| (class "keyword") (id "F:201486")) "return") " 1;\n        }\n      " (span (|@| (class "keyword") (id "F:201505")) "else") " " (span (|@| (class "keyword") (id "F:201510")) "if") " (STRING_MULTIBYTE (it->string))\n        {\n          " (span (|@| (class "type") (id "F:201551")) "int") " " (span (|@| (class "variable-name") (id "F:201555")) "maxlen") " = SBYTES (it->string) - IT_STRING_BYTEPOS (*it);\n          " (span (|@| (class "keyword") (id "F:201614")) "const") " " (span (|@| (class "type") (id "F:201620")) "unsigned") " " (span (|@| (class "type") (id "F:201629")) "char") " *" (span (|@| (class "variable-name") (id "F:201635")) "s") " = (SDATA (it->string)\n                                    + IT_STRING_BYTEPOS (*it));\n          it->c = string_char_and_length (s, &it->len);\n        }\n      " (span (|@| (class "keyword") (id "F:201753")) "else") "\n        {\n          it->c = SREF (it->string, IT_STRING_BYTEPOS (*it));\n          it->len = 1;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:201844")) "/* ") (span (|@| (class "comment") (id "F:201847")) "Record what we have and where it came from.  ") (span (|@| (class "comment-delimiter") (id "F:201892")) "*/") "\n  it->what = IT_CHARACTER;\n  it->object = it->string;\n  it->position = position;\n  " (span (|@| (class "keyword") (id "F:201978")) "return") " 1;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:201992")) "/* ") (span (|@| (class "comment") (id "F:201995")) "Load IT with next display element from C string IT->s.\n   IT->string_nchars is the maximum number of characters to return\n   from the string.  IT->end_charpos may be greater than\n   IT->string_nchars when this function is called, in which case we\n   may have to return padding spaces.  Value is zero if end of string\n   reached, including padding spaces.  ") (span (|@| (class "comment-delimiter") (id "F:202351")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:202355")) "static") " " (span (|@| (class "type") (id "F:202362")) "int") "\n" (span (|@| (class "function-name") (id "F:202366")) "next_element_from_c_string") " (" (span (|@| (class "type") (id "F:202394")) "it") ")\n     " (span (|@| (class "keyword") (id "F:202403")) "struct") " " (span (|@| (class "type") (id "F:202410")) "it") " *" (span (|@| (class "variable-name") (id "F:202414")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:202422")) "int") " " (span (|@| (class "variable-name") (id "F:202426")) "success_p") " = 1;\n\n  xassert (it->s);\n  it->what = IT_CHARACTER;\n  BYTEPOS (it->position) = CHARPOS (it->position) = 0;\n  it->object = Qnil;\n\n  " (span (|@| (class "comment-delimiter") (id "F:202567")) "/* ") (span (|@| (class "comment") (id "F:202570")) "IT's position can be greater IT->string_nchars in case a field\n     width or precision has been specified when the iterator was\n     initialized.  ") (span (|@| (class "comment-delimiter") (id "F:202717")) "*/") "\n  " (span (|@| (class "keyword") (id "F:202722")) "if") " (IT_CHARPOS (*it) >= it->end_charpos)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:202775")) "/* ") (span (|@| (class "comment") (id "F:202778")) "End of the game.  ") (span (|@| (class "comment-delimiter") (id "F:202796")) "*/") "\n      it->what = IT_EOB;\n      success_p = 0;\n    }\n  " (span (|@| (class "keyword") (id "F:202853")) "else") " " (span (|@| (class "keyword") (id "F:202858")) "if") " (IT_CHARPOS (*it) >= it->string_nchars)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:202913")) "/* ") (span (|@| (class "comment") (id "F:202916")) "Pad with spaces.  ") (span (|@| (class "comment-delimiter") (id "F:202934")) "*/") "\n      it->c = " (span (|@| (class "string") (id "F:202951")) "' '") ", it->len = 1;\n      BYTEPOS (it->position) = CHARPOS (it->position) = -1;\n    }\n  " (span (|@| (class "keyword") (id "F:203037")) "else") " " (span (|@| (class "keyword") (id "F:203042")) "if") " (it->multibyte_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:203075")) "/* ") (span (|@| (class "comment") (id "F:203078")) "Implementation note: The calls to strlen apparently aren't a\n         performance problem because there is no noticeable performance\n         difference between Emacs running in unibyte or multibyte mode.  ") (span (|@| (class "comment-delimiter") (id "F:203270")) "*/") "\n      " (span (|@| (class "type") (id "F:203279")) "int") " " (span (|@| (class "variable-name") (id "F:203283")) "maxlen") " = strlen (it->s) - IT_BYTEPOS (*it);\n      it->c = string_char_and_length (it->s + IT_BYTEPOS (*it), &it->len);\n    }\n  " (span (|@| (class "keyword") (id "F:203410")) "else") "\n    it->c = it->s[IT_BYTEPOS (*it)], it->len = 1;\n\n  " (span (|@| (class "keyword") (id "F:203468")) "return") " success_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:203490")) "/* ") (span (|@| (class "comment") (id "F:203493")) "Set up IT to return characters from an ellipsis, if appropriate.\n   The definition of the ellipsis glyphs may come from a display table\n   entry.  This function fills IT with the first glyph from the\n   ellipsis if an ellipsis is to be displayed.  ") (span (|@| (class "comment-delimiter") (id "F:203741")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:203745")) "static") " " (span (|@| (class "type") (id "F:203752")) "int") "\n" (span (|@| (class "function-name") (id "F:203756")) "next_element_from_ellipsis") " (" (span (|@| (class "type") (id "F:203784")) "it") ")\n     " (span (|@| (class "keyword") (id "F:203793")) "struct") " " (span (|@| (class "type") (id "F:203800")) "it") " *" (span (|@| (class "variable-name") (id "F:203804")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:203812")) "if") " (it->selective_display_ellipsis_p)\n    setup_for_ellipsis (it, it->len);\n  " (span (|@| (class "keyword") (id "F:203890")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:203907")) "/* ") (span (|@| (class "comment") (id "F:203910")) "The face at the current position may be different from the\n         face we find after the invisible text.  Remember what it\n         was in IT->saved_face_id, and signal that it's there by\n         setting face_before_selective_p.  ") (span (|@| (class "comment-delimiter") (id "F:204122")) "*/") "\n      it->saved_face_id = it->face_id;\n      it->method = GET_FROM_BUFFER;\n      it->object = it->w->buffer;\n      reseat_at_next_visible_line_start (it, 1);\n      it->face_before_selective_p = 1;\n    }\n\n  " (span (|@| (class "keyword") (id "F:204331")) "return") " GET_NEXT_DISPLAY_ELEMENT (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:204373")) "/* ") (span (|@| (class "comment") (id "F:204376")) "Deliver an image display element.  The iterator IT is already\n   filled with image information (done in handle_display_prop).  Value\n   is always 1.  ") (span (|@| (class "comment-delimiter") (id "F:204526")) "*/") "\n\n\n" (span (|@| (class "keyword") (id "F:204531")) "static") " " (span (|@| (class "type") (id "F:204538")) "int") "\n" (span (|@| (class "function-name") (id "F:204542")) "next_element_from_image") " (" (span (|@| (class "type") (id "F:204567")) "it") ")\n     " (span (|@| (class "keyword") (id "F:204576")) "struct") " " (span (|@| (class "type") (id "F:204583")) "it") " *" (span (|@| (class "variable-name") (id "F:204587")) "it") ";\n{\n  it->what = IT_IMAGE;\n  " (span (|@| (class "keyword") (id "F:204618")) "return") " 1;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:204632")) "/* ") (span (|@| (class "comment") (id "F:204635")) "Fill iterator IT with next display element from a stretch glyph\n   property.  IT->object is the value of the text property.  Value is\n   always 1.  ") (span (|@| (class "comment-delimiter") (id "F:204783")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:204787")) "static") " " (span (|@| (class "type") (id "F:204794")) "int") "\n" (span (|@| (class "function-name") (id "F:204798")) "next_element_from_stretch") " (" (span (|@| (class "type") (id "F:204825")) "it") ")\n     " (span (|@| (class "keyword") (id "F:204834")) "struct") " " (span (|@| (class "type") (id "F:204841")) "it") " *" (span (|@| (class "variable-name") (id "F:204845")) "it") ";\n{\n  it->what = IT_STRETCH;\n  " (span (|@| (class "keyword") (id "F:204878")) "return") " 1;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:204891")) "/* ") (span (|@| (class "comment") (id "F:204894")) "Scan forward from CHARPOS in the current buffer, until we find a\n   stop position > current IT's position.  Then handle the stop\n   position before that.  This is called when we bump into a stop\n   position while reordering bidirectional text.  CHARPOS should be\n   the last previously processed stop_pos (or BEGV, if none were\n   processed yet) whose position is less that IT's current\n   position.  ") (span (|@| (class "comment-delimiter") (id "F:205295")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:205299")) "static") " " (span (|@| (class "type") (id "F:205306")) "void") "\n" (span (|@| (class "function-name") (id "F:205311")) "handle_stop_backwards") " (" (span (|@| (class "type") (id "F:205334")) "it") ", charpos)\n     " (span (|@| (class "keyword") (id "F:205352")) "struct") " " (span (|@| (class "type") (id "F:205359")) "it") " *" (span (|@| (class "variable-name") (id "F:205363")) "it") ";\n     " (span (|@| (class "type") (id "F:205372")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:205382")) "charpos") ";\n{\n  " (span (|@| (class "type") (id "F:205395")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:205405")) "where_we_are") " = IT_CHARPOS (*it);\n  " (span (|@| (class "keyword") (id "F:205440")) "struct") " " (span (|@| (class "type") (id "F:205447")) "display_pos") " " (span (|@| (class "variable-name") (id "F:205459")) "save_current") " = it->current;\n  " (span (|@| (class "keyword") (id "F:205489")) "struct") " " (span (|@| (class "type") (id "F:205496")) "text_pos") " " (span (|@| (class "variable-name") (id "F:205505")) "save_position") " = it->position;\n  " (span (|@| (class "keyword") (id "F:205537")) "struct") " " (span (|@| (class "type") (id "F:205544")) "text_pos") " " (span (|@| (class "variable-name") (id "F:205553")) "pos1") ";\n  " (span (|@| (class "type") (id "F:205561")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:205571")) "next_stop") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:205585")) "/* ") (span (|@| (class "comment") (id "F:205588")) "Scan in strict logical order.  ") (span (|@| (class "comment-delimiter") (id "F:205619")) "*/") "\n  it->bidi_p = 0;\n  " (span (|@| (class "keyword") (id "F:205642")) "do") "\n    {\n      it->prev_stop = charpos;\n      SET_TEXT_POS (pos1, charpos, CHAR_TO_BYTE (charpos));\n      reseat_1 (it, pos1, 0);\n      compute_stop_pos (it);\n      " (span (|@| (class "comment-delimiter") (id "F:205807")) "/* ") (span (|@| (class "comment") (id "F:205810")) "We must advance forward, right?  ") (span (|@| (class "comment-delimiter") (id "F:205843")) "*/") "\n      " (span (|@| (class "keyword") (id "F:205852")) "if") " (it->stop_charpos <= it->prev_stop)\n        abort ();\n      charpos = it->stop_charpos;\n    }\n  " (span (|@| (class "keyword") (id "F:205944")) "while") " (charpos <= where_we_are);\n\n  next_stop = it->stop_charpos;\n  it->stop_charpos = it->prev_stop;\n  it->bidi_p = 1;\n  it->current = save_current;\n  it->position = save_position;\n  handle_stop (it);\n  it->stop_charpos = next_stop;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:206181")) "/* ") (span (|@| (class "comment") (id "F:206184")) "Load IT with the next display element from current_buffer.  Value\n   is zero if end of buffer reached.  IT->stop_charpos is the next\n   position at which to stop and check for text properties or buffer\n   end.  ") (span (|@| (class "comment-delimiter") (id "F:206395")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:206399")) "static") " " (span (|@| (class "type") (id "F:206406")) "int") "\n" (span (|@| (class "function-name") (id "F:206410")) "next_element_from_buffer") " (" (span (|@| (class "type") (id "F:206436")) "it") ")\n     " (span (|@| (class "keyword") (id "F:206445")) "struct") " " (span (|@| (class "type") (id "F:206452")) "it") " *" (span (|@| (class "variable-name") (id "F:206456")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:206464")) "int") " " (span (|@| (class "variable-name") (id "F:206468")) "success_p") " = 1;\n\n  xassert (IT_CHARPOS (*it) >= BEGV);\n\n  " (span (|@| (class "comment-delimiter") (id "F:206525")) "/* ") (span (|@| (class "comment") (id "F:206528")) "With bidi reordering, the character to display might not be the\n     character at IT_CHARPOS.  BIDI_IT.FIRST_ELT non-zero means that\n     we were reseat()ed to a new buffer position, which is potentially\n     a different paragraph.  ") (span (|@| (class "comment-delimiter") (id "F:206761")) "*/") "\n  " (span (|@| (class "keyword") (id "F:206766")) "if") " (it->bidi_p && it->bidi_it.first_elt)\n    {\n      it->bidi_it.charpos = IT_CHARPOS (*it);\n      it->bidi_it.bytepos = IT_BYTEPOS (*it);\n      " (span (|@| (class "keyword") (id "F:206911")) "if") " (it->bidi_it.bytepos == ZV_BYTE)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:206953")) "/* ") (span (|@| (class "comment") (id "F:206956")) "Nothing to do, but reset the FIRST_ELT flag, like\n             bidi_paragraph_init does, because we are not going to\n             call it.  ") (span (|@| (class "comment-delimiter") (id "F:207082")) "*/") "\n          it->bidi_it.first_elt = 0;\n        }\n      " (span (|@| (class "keyword") (id "F:207124")) "else") " " (span (|@| (class "keyword") (id "F:207129")) "if") " (it->bidi_it.bytepos == BEGV_BYTE\n          " (span (|@| (class "comment-delimiter") (id "F:207169")) "/* ") (span (|@| (class "comment") (id "F:207172")) "FIXME: Should support all Unicode line separators.  ") (span (|@| (class "comment-delimiter") (id "F:207224")) "*/") "\n          || FETCH_CHAR (it->bidi_it.bytepos - 1) == " (span (|@| (class "string") (id "F:207273")) "'\\n'") "\n          || FETCH_CHAR (it->bidi_it.bytepos) == " (span (|@| (class "string") (id "F:207320")) "'\\n'") ")\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:207332")) "/* ") (span (|@| (class "comment") (id "F:207335")) "If we are at the beginning of a line, we can produce the\n             next element right away.  ") (span (|@| (class "comment-delimiter") (id "F:207424")) "*/") "\n          bidi_paragraph_init (it->paragraph_embedding, &it->bidi_it);\n          bidi_move_to_visually_next (&it->bidi_it);\n        }\n      " (span (|@| (class "keyword") (id "F:207546")) "else") "\n        {\n          " (span (|@| (class "type") (id "F:207557")) "int") " " (span (|@| (class "variable-name") (id "F:207561")) "orig_bytepos") " = IT_BYTEPOS (*it);\n\n          " (span (|@| (class "comment-delimiter") (id "F:207598")) "/* ") (span (|@| (class "comment") (id "F:207601")) "We need to prime the bidi iterator starting at the line's\n             beginning, before we will be able to produce the next\n             element.  ") (span (|@| (class "comment-delimiter") (id "F:207735")) "*/") "\n          IT_CHARPOS (*it) = find_next_newline_no_quit (IT_CHARPOS (*it), -1);\n          IT_BYTEPOS (*it) = CHAR_TO_BYTE (IT_CHARPOS (*it));\n          it->bidi_it.charpos = IT_CHARPOS (*it);\n          it->bidi_it.bytepos = IT_BYTEPOS (*it);\n          bidi_paragraph_init (it->paragraph_embedding, &it->bidi_it);\n          " (span (|@| (class "keyword") (id "F:208018")) "do") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:208035")) "/* ") (span (|@| (class "comment") (id "F:208038")) "Now return to buffer position where we were asked to\n                 get the next display element, and produce that.  ") (span (|@| (class "comment-delimiter") (id "F:208143")) "*/") "\n              bidi_move_to_visually_next (&it->bidi_it);\n            }\n          " (span (|@| (class "keyword") (id "F:208206")) "while") " (it->bidi_it.bytepos != orig_bytepos\n                 && it->bidi_it.bytepos < ZV_BYTE);\n        }\n\n      it->bidi_it.first_elt = 0; " (span (|@| (class "comment-delimiter") (id "F:208324")) "/* ") (span (|@| (class "comment") (id "F:208327")) "paranoia: bidi.c does this ") (span (|@| (class "comment-delimiter") (id "F:208354")) "*/") "\n      " (span (|@| (class "comment-delimiter") (id "F:208363")) "/*  ") (span (|@| (class "comment") (id "F:208367")) "Adjust IT's position information to where we ended up.  ") (span (|@| (class "comment-delimiter") (id "F:208423")) "*/") "\n      IT_CHARPOS (*it) = it->bidi_it.charpos;\n      IT_BYTEPOS (*it) = it->bidi_it.bytepos;\n      SET_TEXT_POS (it->position, IT_CHARPOS (*it), IT_BYTEPOS (*it));\n      {\n        " (span (|@| (class "type") (id "F:208598")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:208608")) "stop") " = it->stop_charpos;\n        " (span (|@| (class "keyword") (id "F:208634")) "if") " (it->bidi_it.scan_dir < 0)\n          stop = -1;\n        composition_compute_stop_pos (&it->cmp_it, IT_CHARPOS (*it),\n                                      IT_BYTEPOS (*it), stop, Qnil);\n      }\n    }\n\n  " (span (|@| (class "keyword") (id "F:208798")) "if") " (IT_CHARPOS (*it) >= it->stop_charpos)\n    {\n      " (span (|@| (class "keyword") (id "F:208852")) "if") " (IT_CHARPOS (*it) >= it->end_charpos)\n        {\n          " (span (|@| (class "type") (id "F:208899")) "int") " " (span (|@| (class "variable-name") (id "F:208903")) "overlay_strings_follow_p") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:208933")) "/* ") (span (|@| (class "comment") (id "F:208936")) "End of the game, except when overlay strings follow that\n             haven't been returned yet.  ") (span (|@| (class "comment-delimiter") (id "F:209027")) "*/") "\n          " (span (|@| (class "keyword") (id "F:209033")) "if") " (it->overlay_strings_at_end_processed_p)\n            overlay_strings_follow_p = 0;\n          " (span (|@| (class "keyword") (id "F:209115")) "else") "\n            {\n              it->overlay_strings_at_end_processed_p = 1;\n              overlay_strings_follow_p = get_overlay_strings (it, 0);\n            }\n\n          " (span (|@| (class "keyword") (id "F:209252")) "if") " (overlay_strings_follow_p)\n            success_p = GET_NEXT_DISPLAY_ELEMENT (it);\n          " (span (|@| (class "keyword") (id "F:209333")) "else") "\n            {\n              it->what = IT_EOB;\n              it->position = it->current.pos;\n              success_p = 0;\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:209448")) "else") " " (span (|@| (class "keyword") (id "F:209453")) "if") " (" (span (|@| (class "negation-char") (id "F:209457")) "!") "(" (span (|@| (class "negation-char") (id "F:209459")) "!") "it->bidi_p\n                 || BIDI_AT_BASE_LEVEL (it->bidi_it)\n                 || IT_CHARPOS (*it) == it->stop_charpos))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:209561")) "/* ") (span (|@| (class "comment") (id "F:209564")) "With bidi non-linear iteration, we could find ourselves\n             far beyond the last computed stop_charpos, with several\n             other stop positions in between that we missed.  Scan\n             them all now, in buffer's logical order, until we find\n             and handle the last stop_charpos that precedes our\n             current position.  ") (span (|@| (class "comment-delimiter") (id "F:209885")) "*/") "\n          handle_stop_backwards (it, it->stop_charpos);\n          " (span (|@| (class "keyword") (id "F:209940")) "return") " GET_NEXT_DISPLAY_ELEMENT (it);\n        }\n      " (span (|@| (class "keyword") (id "F:209987")) "else") "\n        {\n          " (span (|@| (class "keyword") (id "F:209998")) "if") " (it->bidi_p)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:210028")) "/* ") (span (|@| (class "comment") (id "F:210031")) "Take note of the stop position we just moved across,\n                 for when we will move back across it.  ") (span (|@| (class "comment-delimiter") (id "F:210126")) "*/") "\n              it->prev_stop = it->stop_charpos;\n              " (span (|@| (class "comment-delimiter") (id "F:210177")) "/* ") (span (|@| (class "comment") (id "F:210180")) "If we are at base paragraph embedding level, take\n                 note of the last stop position seen at this\n                 level.  ") (span (|@| (class "comment-delimiter") (id "F:210288")) "*/") "\n              " (span (|@| (class "keyword") (id "F:210298")) "if") " (BIDI_AT_BASE_LEVEL (it->bidi_it))\n                it->base_level_stop = it->stop_charpos;\n            }\n          handle_stop (it);\n          " (span (|@| (class "keyword") (id "F:210409")) "return") " GET_NEXT_DISPLAY_ELEMENT (it);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:210458")) "else") " " (span (|@| (class "keyword") (id "F:210463")) "if") " (it->bidi_p\n           " (span (|@| (class "comment-delimiter") (id "F:210482")) "/* ") (span (|@| (class "comment") (id "F:210485")) "We can sometimes back up for reasons that have nothing\n              to do with bidi reordering.  E.g., compositions.  The\n              code below is only needed when we are above the base\n              embedding level, so test for that explicitly.  ") (span (|@| (class "comment-delimiter") (id "F:210715")) "*/") "\n           && " (span (|@| (class "negation-char") (id "F:210725")) "!") "BIDI_AT_BASE_LEVEL (it->bidi_it)\n           && IT_CHARPOS (*it) < it->prev_stop)\n    {\n      " (span (|@| (class "keyword") (id "F:210812")) "if") " (it->base_level_stop <= 0)\n        it->base_level_stop = BEGV;\n      " (span (|@| (class "keyword") (id "F:210877")) "if") " (IT_CHARPOS (*it) < it->base_level_stop)\n        abort ();\n      handle_stop_backwards (it, it->base_level_stop);\n      " (span (|@| (class "keyword") (id "F:210993")) "return") " GET_NEXT_DISPLAY_ELEMENT (it);\n    }\n  " (span (|@| (class "keyword") (id "F:211039")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:211056")) "/* ") (span (|@| (class "comment") (id "F:211059")) "No face changes, overlays etc. in sight, so just return a\n         character from current_buffer.  ") (span (|@| (class "comment-delimiter") (id "F:211151")) "*/") "\n      " (span (|@| (class "type") (id "F:211160")) "unsigned") " " (span (|@| (class "type") (id "F:211169")) "char") " *" (span (|@| (class "variable-name") (id "F:211175")) "p") ";\n      " (span (|@| (class "type") (id "F:211184")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:211194")) "stop") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:211207")) "/* ") (span (|@| (class "comment") (id "F:211210")) "Maybe run the redisplay end trigger hook.  Performance note:\n         This doesn't seem to cost measurable time.  ") (span (|@| (class "comment-delimiter") (id "F:211317")) "*/") "\n      " (span (|@| (class "keyword") (id "F:211326")) "if") " (it->redisplay_end_trigger_charpos\n          && it->glyph_row\n          && IT_CHARPOS (*it) >= it->redisplay_end_trigger_charpos)\n        run_redisplay_end_trigger_hook (it);\n\n      stop = it->bidi_it.scan_dir < 0 ? -1 : it->end_charpos;\n      " (span (|@| (class "keyword") (id "F:211552")) "if") " (CHAR_COMPOSED_P (it, IT_CHARPOS (*it), IT_BYTEPOS (*it),\n                           stop)\n          && next_element_from_composition (it))\n        {\n          " (span (|@| (class "keyword") (id "F:211673")) "return") " 1;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:211693")) "/* ") (span (|@| (class "comment") (id "F:211696")) "Get the next character, maybe multibyte.  ") (span (|@| (class "comment-delimiter") (id "F:211738")) "*/") "\n      p = BYTE_POS_ADDR (IT_BYTEPOS (*it));\n      " (span (|@| (class "keyword") (id "F:211791")) "if") " (it->multibyte_p && " (span (|@| (class "negation-char") (id "F:211814")) "!") "ASCII_BYTE_P (*p))\n        it->c = STRING_CHAR_AND_LENGTH (p, it->len);\n      " (span (|@| (class "keyword") (id "F:211886")) "else") "\n        it->c = *p, it->len = 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:211924")) "/* ") (span (|@| (class "comment") (id "F:211927")) "Record what we have and where it came from.  ") (span (|@| (class "comment-delimiter") (id "F:211972")) "*/") "\n      it->what = IT_CHARACTER;\n      it->object = it->w->buffer;\n      it->position = it->current.pos;\n\n      " (span (|@| (class "comment-delimiter") (id "F:212085")) "/* ") (span (|@| (class "comment") (id "F:212088")) "Normally we return the character found above, except when we\n         really want to return an ellipsis for selective display.  ") (span (|@| (class "comment-delimiter") (id "F:212209")) "*/") "\n      " (span (|@| (class "keyword") (id "F:212218")) "if") " (it->selective)\n        {\n          " (span (|@| (class "keyword") (id "F:212243")) "if") " (it->c == " (span (|@| (class "string") (id "F:212256")) "'\\n'") ")\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:212276")) "/* ") (span (|@| (class "comment") (id "F:212279")) "A value of selective > 0 means hide lines indented more\n                 than that number of columns.  ") (span (|@| (class "comment-delimiter") (id "F:212368")) "*/") "\n              " (span (|@| (class "keyword") (id "F:212378")) "if") " (it->selective > 0\n                  && IT_CHARPOS (*it) + 1 < ZV\n                  && indented_beyond_p (IT_CHARPOS (*it) + 1,\n                                        IT_BYTEPOS (*it) + 1,\n                                        (" (span (|@| (class "type") (id "F:212514")) "double") ") it->selective)) " (span (|@| (class "comment-delimiter") (id "F:212538")) "/* ") (span (|@| (class "comment") (id "F:212541")) "iftc ") (span (|@| (class "comment-delimiter") (id "F:212546")) "*/") "\n                {\n                  success_p = next_element_from_ellipsis (it);\n                  it->dpvec_char_len = -1;\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:212645")) "else") " " (span (|@| (class "keyword") (id "F:212650")) "if") " (it->c == " (span (|@| (class "string") (id "F:212663")) "'\\r'") " && it->selective == -1)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:212706")) "/* ") (span (|@| (class "comment") (id "F:212709")) "A value of selective == -1 means that everything from the\n                 CR to the end of the line is invisible, with maybe an\n                 ellipsis displayed for it.  ") (span (|@| (class "comment-delimiter") (id "F:212855")) "*/") "\n              success_p = next_element_from_ellipsis (it);\n              it->dpvec_char_len = -1;\n            }\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:212961")) "/* ") (span (|@| (class "comment") (id "F:212964")) "Value is zero if end of buffer reached.  ") (span (|@| (class "comment-delimiter") (id "F:213005")) "*/") "\n  xassert (" (span (|@| (class "negation-char") (id "F:213019")) "!") "success_p || it->what != IT_CHARACTER || it->len > 0);\n  " (span (|@| (class "keyword") (id "F:213077")) "return") " success_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:213099")) "/* ") (span (|@| (class "comment") (id "F:213102")) "Run the redisplay end trigger hook for IT.  ") (span (|@| (class "comment-delimiter") (id "F:213146")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:213150")) "static") " " (span (|@| (class "type") (id "F:213157")) "void") "\n" (span (|@| (class "function-name") (id "F:213162")) "run_redisplay_end_trigger_hook") " (" (span (|@| (class "type") (id "F:213194")) "it") ")\n     " (span (|@| (class "keyword") (id "F:213203")) "struct") " " (span (|@| (class "type") (id "F:213210")) "it") " *" (span (|@| (class "variable-name") (id "F:213214")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:213222")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:213234")) "args") "[3];\n\n  " (span (|@| (class "comment-delimiter") (id "F:213246")) "/* ") (span (|@| (class "comment") (id "F:213249")) "IT->glyph_row should be non-null, i.e. we should be actually\n     displaying something, or otherwise we should not run the hook.  ") (span (|@| (class "comment-delimiter") (id "F:213379")) "*/") "\n  xassert (it->glyph_row);\n\n  " (span (|@| (class "comment-delimiter") (id "F:213412")) "/* ") (span (|@| (class "comment") (id "F:213415")) "Set up hook arguments.  ") (span (|@| (class "comment-delimiter") (id "F:213439")) "*/") "\n  args[0] = Qredisplay_end_trigger_functions;\n  args[1] = it->window;\n  XSETINT (args[2], it->redisplay_end_trigger_charpos);\n  it->redisplay_end_trigger_charpos = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:213612")) "/* ") (span (|@| (class "comment") (id "F:213615")) "Since we are *trying* to run these functions, don't try to run\n     them again, even if they get an error.  ") (span (|@| (class "comment-delimiter") (id "F:213723")) "*/") "\n  it->w->redisplay_end_trigger = Qnil;\n  Frun_hook_with_args (3, args);\n\n  " (span (|@| (class "comment-delimiter") (id "F:213801")) "/* ") (span (|@| (class "comment") (id "F:213804")) "Notice if it changed the face of the character we are on.  ") (span (|@| (class "comment-delimiter") (id "F:213863")) "*/") "\n  handle_face_prop (it);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:213895")) "/* ") (span (|@| (class "comment") (id "F:213898")) "Deliver a composition display element.  Unlike the other\n   next_element_from_XXX, this function is not registered in the array\n   get_next_element[].  It is called from next_element_from_buffer and\n   next_element_from_string when necessary.  ") (span (|@| (class "comment-delimiter") (id "F:214142")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:214146")) "static") " " (span (|@| (class "type") (id "F:214153")) "int") "\n" (span (|@| (class "function-name") (id "F:214157")) "next_element_from_composition") " (" (span (|@| (class "type") (id "F:214188")) "it") ")\n     " (span (|@| (class "keyword") (id "F:214197")) "struct") " " (span (|@| (class "type") (id "F:214204")) "it") " *" (span (|@| (class "variable-name") (id "F:214208")) "it") ";\n{\n  it->what = IT_COMPOSITION;\n  it->len = it->cmp_it.nbytes;\n  " (span (|@| (class "keyword") (id "F:214276")) "if") " (STRINGP (it->string))\n    {\n      " (span (|@| (class "keyword") (id "F:214314")) "if") " (it->c < 0)\n        {\n          IT_STRING_CHARPOS (*it) += it->cmp_it.nchars;\n          IT_STRING_BYTEPOS (*it) += it->cmp_it.nbytes;\n          " (span (|@| (class "keyword") (id "F:214433")) "return") " 0;\n        }\n      it->position = it->current.string_pos;\n      it->object = it->string;\n      it->c = composition_update_it (&it->cmp_it, IT_STRING_CHARPOS (*it),\n                                     IT_STRING_BYTEPOS (*it), it->string);\n    }\n  " (span (|@| (class "keyword") (id "F:214652")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:214669")) "if") " (it->c < 0)\n        {\n          IT_CHARPOS (*it) += it->cmp_it.nchars;\n          IT_BYTEPOS (*it) += it->cmp_it.nbytes;\n          " (span (|@| (class "keyword") (id "F:214774")) "if") " (it->bidi_p)\n            {\n              " (span (|@| (class "keyword") (id "F:214804")) "if") " (it->bidi_it.new_paragraph)\n                bidi_paragraph_init (it->paragraph_embedding, &it->bidi_it);\n              " (span (|@| (class "comment-delimiter") (id "F:214905")) "/* ") (span (|@| (class "comment") (id "F:214908")) "Resync the bidi iterator with IT's new position.\n                 FIXME: this doesn't support bidirectional text.  ") (span (|@| (class "comment-delimiter") (id "F:215009")) "*/") "\n              " (span (|@| (class "keyword") (id "F:215019")) "while") " (it->bidi_it.charpos < IT_CHARPOS (*it))\n                bidi_move_to_visually_next (&it->bidi_it);\n            }\n          " (span (|@| (class "keyword") (id "F:215121")) "return") " 0;\n        }\n      it->position = it->current.pos;\n      it->object = it->w->buffer;\n      it->c = composition_update_it (&it->cmp_it, IT_CHARPOS (*it),\n                                     IT_BYTEPOS (*it), Qnil);\n    }\n  " (span (|@| (class "keyword") (id "F:215316")) "return") " 1;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:215332")) "/***********************************************************************") (span (|@| (class "comment") (id "F:215404")) "\n             Moving an iterator without producing glyphs\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:215526")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:215530")) "/* ") (span (|@| (class "comment") (id "F:215533")) "Check if iterator is at a position corresponding to a valid buffer\n   position after some move_it_ call.  ") (span (|@| (class "comment-delimiter") (id "F:215639")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:215643")) "#define") " " (span (|@| (class "function-name") (id "F:215651")) "IT_POS_VALID_AFTER_MOVE_P") "(" (span (|@| (class "variable-name") (id "F:215677")) "it") ")                   \\\n  ((it)->method == GET_FROM_STRING                      \\\n   ? IT_STRING_CHARPOS (*it) == 0                       \\\n   : 1)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:215772")) "/* ") (span (|@| (class "comment") (id "F:215775")) "Move iterator IT to a specified buffer or X position within one\n   line on the display without producing glyphs.\n\n   OP should be a bit mask including some or all of these bits:\n    MOVE_TO_X: Stop upon reaching x-position TO_X.\n    MOVE_TO_POS: Stop upon reaching buffer or string position TO_CHARPOS.\n   Regardless of OP's value, stop upon reaching the end of the display line.\n\n   TO_X is normally a value 0 <= TO_X <= IT->last_visible_x.\n   This means, in particular, that TO_X includes window's horizontal\n   scroll amount.\n\n   The return value has several possible values that\n   say what condition caused the scan to stop:\n\n   MOVE_POS_MATCH_OR_ZV\n     - when TO_POS or ZV was reached.\n\n   MOVE_X_REACHED\n     -when TO_X was reached before TO_POS or ZV were reached.\n\n   MOVE_LINE_CONTINUED\n     - when we reached the end of the display area and the line must\n     be continued.\n\n   MOVE_LINE_TRUNCATED\n     - when we reached the end of the display area and the line is\n     truncated.\n\n   MOVE_NEWLINE_OR_CR\n     - when we stopped at a line end, i.e. a newline or a CR and selective\n     display is on.  ") (span (|@| (class "comment-delimiter") (id "F:216887")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:216891")) "static") " " (span (|@| (class "keyword") (id "F:216898")) "enum") " " (span (|@| (class "type") (id "F:216903")) "move_it_result") "\n" (span (|@| (class "function-name") (id "F:216918")) "move_it_in_display_line_to") " (" (span (|@| (class "keyword") (id "F:216946")) "struct") " " (span (|@| (class "type") (id "F:216953")) "it") " *" (span (|@| (class "variable-name") (id "F:216957")) "it") ",\n                            " (span (|@| (class "type") (id "F:216968")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:216978")) "to_charpos") ", " (span (|@| (class "type") (id "F:216990")) "int") " " (span (|@| (class "variable-name") (id "F:216994")) "to_x") ",\n                            " (span (|@| (class "keyword") (id "F:217007")) "enum") " " (span (|@| (class "type") (id "F:217012")) "move_operation_enum") " " (span (|@| (class "variable-name") (id "F:217032")) "op") ")\n{\n  " (span (|@| (class "keyword") (id "F:217040")) "enum") " " (span (|@| (class "type") (id "F:217045")) "move_it_result") " " (span (|@| (class "variable-name") (id "F:217060")) "result") " = MOVE_UNDEFINED;\n  " (span (|@| (class "keyword") (id "F:217087")) "struct") " " (span (|@| (class "type") (id "F:217094")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:217105")) "saved_glyph_row") ";\n  " (span (|@| (class "keyword") (id "F:217124")) "struct") " " (span (|@| (class "type") (id "F:217131")) "it") " " (span (|@| (class "variable-name") (id "F:217134")) "wrap_it") ", " (span (|@| (class "variable-name") (id "F:217143")) "atpos_it") ", " (span (|@| (class "variable-name") (id "F:217153")) "atx_it") ";\n  " (span (|@| (class "type") (id "F:217163")) "int") " " (span (|@| (class "variable-name") (id "F:217167")) "may_wrap") " = 0;\n  " (span (|@| (class "keyword") (id "F:217183")) "enum") " " (span (|@| (class "type") (id "F:217188")) "it_method") " " (span (|@| (class "variable-name") (id "F:217198")) "prev_method") " = it->method;\n  " (span (|@| (class "type") (id "F:217226")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:217236")) "prev_pos") " = IT_CHARPOS (*it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:217268")) "/* ") (span (|@| (class "comment") (id "F:217271")) "Don't produce glyphs in produce_glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:217312")) "*/") "\n  saved_glyph_row = it->glyph_row;\n  it->glyph_row = " (span (|@| (class "constant") (id "F:217368")) "NULL") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:217377")) "/* ") (span (|@| (class "comment") (id "F:217380")) "Use wrap_it to save a copy of IT wherever a word wrap could\n     occur.  Use atpos_it to save a copy of IT at the desired buffer\n     position, if found, so that we can scan ahead and check if the\n     word later overshoots the window edge.  Use atx_it similarly, for\n     pixel positions.  ") (span (|@| (class "comment-delimiter") (id "F:217671")) "*/") "\n  wrap_it.sp = -1;\n  atpos_it.sp = -1;\n  atx_it.sp = -1;\n\n" (span (|@| (class "preprocessor") (id "F:217732")) "#define") " " (span (|@| (class "function-name") (id "F:217740")) "BUFFER_POS_REACHED_P") "()                                  \\\n  ((op & MOVE_TO_POS) != 0                                      \\\n   && BUFFERP (it->object)                                      \\\n   && (IT_CHARPOS (*it) == to_charpos                           \\\n       || (" (span (|@| (class "negation-char") (id "F:217889")) "!") "it->bidi_p && IT_CHARPOS (*it) > to_charpos))       \\\n   && (it->method == GET_FROM_BUFFER                            \\\n       || (it->method == GET_FROM_DISPLAY_VECTOR                \\\n           && it->dpvec + it->current.dpvec_index + 1 >= it->dpend)))\n\n  " (span (|@| (class "comment-delimiter") (id "F:218098")) "/* ") (span (|@| (class "comment") (id "F:218101")) "If there's a line-/wrap-prefix, handle it.  ") (span (|@| (class "comment-delimiter") (id "F:218145")) "*/") "\n  " (span (|@| (class "keyword") (id "F:218150")) "if") " (it->hpos == 0 && it->method == GET_FROM_BUFFER\n      && it->current_y < it->last_visible_y)\n    handle_line_prefix (it);\n\n  " (span (|@| (class "keyword") (id "F:218278")) "while") " (1)\n    {\n      " (span (|@| (class "type") (id "F:218300")) "int") " " (span (|@| (class "variable-name") (id "F:218304")) "x") ", " (span (|@| (class "variable-name") (id "F:218307")) "i") ", " (span (|@| (class "variable-name") (id "F:218310")) "ascent") " = 0, " (span (|@| (class "variable-name") (id "F:218322")) "descent") " = 0;\n\n" (span (|@| (class "comment-delimiter") (id "F:218336")) "/* ") (span (|@| (class "comment") (id "F:218339")) "Utility macro to reset an iterator with x, ascent, and descent.  ") (span (|@| (class "comment-delimiter") (id "F:218404")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:218407")) "#define") " " (span (|@| (class "function-name") (id "F:218415")) "IT_RESET_X_ASCENT_DESCENT") "(" (span (|@| (class "variable-name") (id "F:218441")) "IT") ")                   \\\n  ((IT)->current_x = x, (IT)->max_ascent = ascent,      \\\n   (IT)->max_descent = descent)\n\n      " (span (|@| (class "comment-delimiter") (id "F:218541")) "/* ") (span (|@| (class "comment") (id "F:218544")) "Stop if we move beyond TO_CHARPOS (after an image or stretch\n         glyph).  ") (span (|@| (class "comment-delimiter") (id "F:218616")) "*/") "\n      " (span (|@| (class "keyword") (id "F:218625")) "if") " ((op & MOVE_TO_POS) != 0\n          && BUFFERP (it->object)\n          && it->method == GET_FROM_BUFFER\n          && ((" (span (|@| (class "negation-char") (id "F:218724")) "!") "it->bidi_p && IT_CHARPOS (*it) > to_charpos)\n              || (it->bidi_p\n                  && (prev_method == GET_FROM_IMAGE\n                      || prev_method == GET_FROM_STRETCH)\n                  " (span (|@| (class "comment-delimiter") (id "F:218878")) "/* ") (span (|@| (class "comment") (id "F:218881")) "Passed TO_CHARPOS from left to right.  ") (span (|@| (class "comment-delimiter") (id "F:218920")) "*/") "\n                  && ((prev_pos < to_charpos\n                       && IT_CHARPOS (*it) > to_charpos)\n                      " (span (|@| (class "comment-delimiter") (id "F:219005")) "/* ") (span (|@| (class "comment") (id "F:219008")) "Passed TO_CHARPOS from right to left.  ") (span (|@| (class "comment-delimiter") (id "F:219047")) "*/") "\n                      || (prev_pos > to_charpos\n                          && IT_CHARPOS (*it) < to_charpos)))))\n        {\n          " (span (|@| (class "keyword") (id "F:219133")) "if") " (it->line_wrap != WORD_WRAP || wrap_it.sp < 0)\n            {\n              result = MOVE_POS_MATCH_OR_ZV;\n              " (span (|@| (class "keyword") (id "F:219235")) "break") ";\n            }\n          " (span (|@| (class "keyword") (id "F:219252")) "else") " " (span (|@| (class "keyword") (id "F:219257")) "if") " (it->line_wrap == WORD_WRAP && atpos_it.sp < 0)\n            " (span (|@| (class "comment-delimiter") (id "F:219313")) "/* ") (span (|@| (class "comment") (id "F:219316")) "If wrap_it is valid, the current position might be in a\n               word that is wrapped.  So, save the iterator in\n               atpos_it and continue to see if wrapping happens.  ") (span (|@| (class "comment-delimiter") (id "F:219487")) "*/") "\n            atpos_it = *it;\n        }\n\n      prev_method = it->method;\n      " (span (|@| (class "keyword") (id "F:219553")) "if") " (it->method == GET_FROM_BUFFER)\n        prev_pos = IT_CHARPOS (*it);\n      " (span (|@| (class "comment-delimiter") (id "F:219624")) "/* ") (span (|@| (class "comment") (id "F:219627")) "Stop when ZV reached.\n         We used to stop here when TO_CHARPOS reached as well, but that is\n         too soon if this glyph does not fit on this line.  So we handle it\n         explicitly below.  ") (span (|@| (class "comment-delimiter") (id "F:219828")) "*/") "\n      " (span (|@| (class "keyword") (id "F:219837")) "if") " (" (span (|@| (class "negation-char") (id "F:219841")) "!") "get_next_display_element (it))\n        {\n          result = MOVE_POS_MATCH_OR_ZV;\n          " (span (|@| (class "keyword") (id "F:219913")) "break") ";\n        }\n\n      " (span (|@| (class "keyword") (id "F:219930")) "if") " (it->line_wrap == TRUNCATE)\n        {\n          " (span (|@| (class "keyword") (id "F:219967")) "if") " (BUFFER_POS_REACHED_P ())\n            {\n              result = MOVE_POS_MATCH_OR_ZV;\n              " (span (|@| (class "keyword") (id "F:220048")) "break") ";\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:220071")) "else") "\n        {\n          " (span (|@| (class "keyword") (id "F:220082")) "if") " (it->line_wrap == WORD_WRAP)\n            {\n              " (span (|@| (class "keyword") (id "F:220128")) "if") " (IT_DISPLAYING_WHITESPACE (it))\n                may_wrap = 1;\n              " (span (|@| (class "keyword") (id "F:220186")) "else") " " (span (|@| (class "keyword") (id "F:220191")) "if") " (may_wrap)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:220213")) "/* ") (span (|@| (class "comment") (id "F:220216")) "We have reached a glyph that follows one or more\n                     whitespace characters.  If the position is\n                     already found, we are done.  ") (span (|@| (class "comment-delimiter") (id "F:220351")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:220358")) "if") " (atpos_it.sp >= 0)\n                    {\n                      *it = atpos_it;\n                      result = MOVE_POS_MATCH_OR_ZV;\n                      " (span (|@| (class "keyword") (id "F:220459")) "goto") " " (span (|@| (class "constant") (id "F:220464")) "done") ";\n                    }\n                  " (span (|@| (class "keyword") (id "F:220482")) "if") " (atx_it.sp >= 0)\n                    {\n                      *it = atx_it;\n                      result = MOVE_X_REACHED;\n                      " (span (|@| (class "keyword") (id "F:220573")) "goto") " " (span (|@| (class "constant") (id "F:220578")) "done") ";\n                    }\n                  " (span (|@| (class "comment-delimiter") (id "F:220596")) "/* ") (span (|@| (class "comment") (id "F:220599")) "Otherwise, we can wrap here.  ") (span (|@| (class "comment-delimiter") (id "F:220629")) "*/") "\n                  wrap_it = *it;\n                  may_wrap = 0;\n                }\n            }\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:220690")) "/* ") (span (|@| (class "comment") (id "F:220693")) "Remember the line height for the current line, in case\n         the next element doesn't fit on the line.  ") (span (|@| (class "comment-delimiter") (id "F:220793")) "*/") "\n      ascent = it->max_ascent;\n      descent = it->max_descent;\n\n      " (span (|@| (class "comment-delimiter") (id "F:220867")) "/* ") (span (|@| (class "comment") (id "F:220870")) "The call to produce_glyphs will get the metrics of the\n         display element IT is loaded with.  Record the x-position\n         before this display element, in case it doesn't fit on the\n         line.  ") (span (|@| (class "comment-delimiter") (id "F:221055")) "*/") "\n      x = it->current_x;\n\n      PRODUCE_GLYPHS (it);\n\n      " (span (|@| (class "keyword") (id "F:221118")) "if") " (it->area != TEXT_AREA)\n        {\n          set_iterator_to_next (it, 1);\n          " (span (|@| (class "keyword") (id "F:221184")) "continue") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:221204")) "/* ") (span (|@| (class "comment") (id "F:221207")) "The number of glyphs we get back in IT->nglyphs will normally\n         be 1 except when IT->c is (i) a TAB, or (ii) a multi-glyph\n         character on a terminal frame, or (iii) a line end.  For the\n         second case, IT->nglyphs - 1 padding glyphs will be present.\n         (On X frames, there is only one glyph produced for a\n         composite character.)\n\n         The behavior implemented below means, for continuation lines,\n         that as many spaces of a TAB as fit on the current line are\n         displayed there.  For terminal frames, as many glyphs of a\n         multi-glyph character are displayed in the current line, too.\n         This is what the old redisplay code did, and we keep it that\n         way.  Under X, the whole shape of a complex character must\n         fit on the line or it will be completely displayed in the\n         next line.\n\n         Note that both for tabs and padding glyphs, all glyphs have\n         the same width.  ") (span (|@| (class "comment-delimiter") (id "F:222066")) "*/") "\n      " (span (|@| (class "keyword") (id "F:222075")) "if") " (it->nglyphs)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:222098")) "/* ") (span (|@| (class "comment") (id "F:222101")) "More than one glyph or glyph doesn't fit on line.  All\n             glyphs have the same width.  ") (span (|@| (class "comment-delimiter") (id "F:222191")) "*/") "\n          " (span (|@| (class "type") (id "F:222197")) "int") " " (span (|@| (class "variable-name") (id "F:222201")) "single_glyph_width") " = it->pixel_width / it->nglyphs;\n          " (span (|@| (class "type") (id "F:222256")) "int") " " (span (|@| (class "variable-name") (id "F:222260")) "new_x") ";\n          " (span (|@| (class "type") (id "F:222270")) "int") " " (span (|@| (class "variable-name") (id "F:222274")) "x_before_this_char") " = x;\n          " (span (|@| (class "type") (id "F:222301")) "int") " " (span (|@| (class "variable-name") (id "F:222305")) "hpos_before_this_char") " = it->hpos;\n\n          " (span (|@| (class "keyword") (id "F:222343")) "for") " (i = 0; i < it->nglyphs; ++i, x = new_x)\n            {\n              new_x = x + single_glyph_width;\n\n              " (span (|@| (class "comment-delimiter") (id "F:222442")) "/* ") (span (|@| (class "comment") (id "F:222445")) "We want to leave anything reaching TO_X to the caller.  ") (span (|@| (class "comment-delimiter") (id "F:222501")) "*/") "\n              " (span (|@| (class "keyword") (id "F:222511")) "if") " ((op & MOVE_TO_X) && new_x > to_x)\n                {\n                  " (span (|@| (class "keyword") (id "F:222557")) "if") " (BUFFER_POS_REACHED_P ())\n                    {\n                      " (span (|@| (class "keyword") (id "F:222602")) "if") " (it->line_wrap != WORD_WRAP || wrap_it.sp < 0)\n                        " (span (|@| (class "keyword") (id "F:222655")) "goto") " " (span (|@| (class "constant") (id "F:222660")) "buffer_pos_reached") ";\n                      " (span (|@| (class "keyword") (id "F:222688")) "if") " (atpos_it.sp < 0)\n                        {\n                          atpos_it = *it;\n                          IT_RESET_X_ASCENT_DESCENT (&atpos_it);\n                        }\n                    }\n                  " (span (|@| (class "keyword") (id "F:222796")) "else") "\n                    {\n                      " (span (|@| (class "keyword") (id "F:222817")) "if") " (it->line_wrap != WORD_WRAP || wrap_it.sp < 0)\n                        {\n                          it->current_x = x;\n                          result = MOVE_X_REACHED;\n                          " (span (|@| (class "keyword") (id "F:222931")) "break") ";\n                        }\n                      " (span (|@| (class "keyword") (id "F:222951")) "if") " (atx_it.sp < 0)\n                        {\n                          atx_it = *it;\n                          IT_RESET_X_ASCENT_DESCENT (&atx_it);\n                        }\n                    }\n                }\n\n              " (span (|@| (class "keyword") (id "F:223061")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:223065")) "/* ") (span (|@| (class "comment") (id "F:223068")) "Lines are continued.  ") (span (|@| (class "comment-delimiter") (id "F:223090")) "*/") "\n                  it->line_wrap != TRUNCATE\n                  && (" (span (|@| (class "comment-delimiter") (id "F:223131")) "/* ") (span (|@| (class "comment") (id "F:223134")) "And glyph doesn't fit on the line.  ") (span (|@| (class "comment-delimiter") (id "F:223170")) "*/") "\n                      new_x > it->last_visible_x\n                      " (span (|@| (class "comment-delimiter") (id "F:223216")) "/* ") (span (|@| (class "comment") (id "F:223219")) "Or it fits exactly and we're on a window\n                         system frame.  ") (span (|@| (class "comment-delimiter") (id "F:223279")) "*/") "\n                      || (new_x == it->last_visible_x\n                          && FRAME_WINDOW_P (it->f))))\n                {\n                  " (span (|@| (class "keyword") (id "F:223364")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:223368")) "/* ") (span (|@| (class "comment") (id "F:223371")) "IT->hpos == 0 means the very first glyph\n                         doesn't fit on the line, e.g. a wide image.  ") (span (|@| (class "comment-delimiter") (id "F:223461")) "*/") "\n                      it->hpos == 0\n                      || (new_x == it->last_visible_x\n                          && FRAME_WINDOW_P (it->f)))\n                    {\n                      ++it->hpos;\n                      it->current_x = new_x;\n\n                      " (span (|@| (class "comment-delimiter") (id "F:223627")) "/* ") (span (|@| (class "comment") (id "F:223630")) "The character's last glyph just barely fits\n                         in this row.  ") (span (|@| (class "comment-delimiter") (id "F:223692")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:223703")) "if") " (i == it->nglyphs - 1)\n                        {\n                          " (span (|@| (class "comment-delimiter") (id "F:223739")) "/* ") (span (|@| (class "comment") (id "F:223742")) "If this is the destination position,\n                             return a position *before* it in this row,\n                             now that we know it fits in this row.  ") (span (|@| (class "comment-delimiter") (id "F:223877")) "*/") "\n                          " (span (|@| (class "keyword") (id "F:223885")) "if") " (BUFFER_POS_REACHED_P ())\n                            {\n                              " (span (|@| (class "keyword") (id "F:223932")) "if") " (it->line_wrap != WORD_WRAP\n                                  || wrap_it.sp < 0)\n                                {\n                                  it->hpos = hpos_before_this_char;\n                                  it->current_x = x_before_this_char;\n                                  result = MOVE_POS_MATCH_OR_ZV;\n                                  " (span (|@| (class "keyword") (id "F:224119")) "break") ";\n                                }\n                              " (span (|@| (class "keyword") (id "F:224141")) "if") " (it->line_wrap == WORD_WRAP\n                                  && atpos_it.sp < 0)\n                                {\n                                  atpos_it = *it;\n                                  atpos_it.current_x = x_before_this_char;\n                                  atpos_it.hpos = hpos_before_this_char;\n                                }\n                            }\n\n                          set_iterator_to_next (it, 1);\n                          " (span (|@| (class "comment-delimiter") (id "F:224374")) "/* ") (span (|@| (class "comment") (id "F:224377")) "On graphical terminals, newlines may\n                             \"overflow\" into the fringe if\n                             overflow-newline-into-fringe is non-nil.\n                             On text-only terminals, newlines may\n                             overflow into the last glyph on the\n                             display line.") (span (|@| (class "comment-delimiter") (id "F:224611")) "*/") "\n                          " (span (|@| (class "keyword") (id "F:224619")) "if") " (" (span (|@| (class "negation-char") (id "F:224623")) "!") "FRAME_WINDOW_P (it->f)\n                              || IT_OVERFLOW_NEWLINE_INTO_FRINGE (it))\n                            {\n                              " (span (|@| (class "keyword") (id "F:224715")) "if") " (" (span (|@| (class "negation-char") (id "F:224719")) "!") "get_next_display_element (it))\n                                {\n                                  result = MOVE_POS_MATCH_OR_ZV;\n                                  " (span (|@| (class "keyword") (id "F:224800")) "break") ";\n                                }\n                              " (span (|@| (class "keyword") (id "F:224822")) "if") " (BUFFER_POS_REACHED_P ())\n                                {\n                                  " (span (|@| (class "keyword") (id "F:224863")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n                                    result = MOVE_POS_MATCH_OR_ZV;\n                                  " (span (|@| (class "keyword") (id "F:224944")) "else") "\n                                    result = MOVE_LINE_CONTINUED;\n                                  " (span (|@| (class "keyword") (id "F:224993")) "break") ";\n                                }\n                              " (span (|@| (class "keyword") (id "F:225015")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n                                {\n                                  result = MOVE_NEWLINE_OR_CR;\n                                  " (span (|@| (class "keyword") (id "F:225098")) "break") ";\n                                }\n                            }\n                        }\n                    }\n                  " (span (|@| (class "keyword") (id "F:225137")) "else") "\n                    IT_RESET_X_ASCENT_DESCENT (it);\n\n                  " (span (|@| (class "keyword") (id "F:225185")) "if") " (wrap_it.sp >= 0)\n                    {\n                      *it = wrap_it;\n                      atpos_it.sp = -1;\n                      atx_it.sp = -1;\n                    }\n\n                  TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:225321")) "\"move_it_in: continued at %d\\n\"") ",\n                               IT_CHARPOS (*it)));\n                  result = MOVE_LINE_CONTINUED;\n                  " (span (|@| (class "keyword") (id "F:225422")) "break") ";\n                }\n\n              " (span (|@| (class "keyword") (id "F:225441")) "if") " (BUFFER_POS_REACHED_P ())\n                {\n                  " (span (|@| (class "keyword") (id "F:225478")) "if") " (it->line_wrap != WORD_WRAP || wrap_it.sp < 0)\n                    " (span (|@| (class "keyword") (id "F:225534")) "goto") " " (span (|@| (class "constant") (id "F:225539")) "buffer_pos_reached") ";\n                  " (span (|@| (class "keyword") (id "F:225563")) "if") " (it->line_wrap == WORD_WRAP && atpos_it.sp < 0)\n                    {\n                      atpos_it = *it;\n                      IT_RESET_X_ASCENT_DESCENT (&atpos_it);\n                    }\n                }\n\n              " (span (|@| (class "keyword") (id "F:225713")) "if") " (new_x > it->first_visible_x)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:225754")) "/* ") (span (|@| (class "comment") (id "F:225757")) "Glyph is visible.  Increment number of glyphs that\n                     would be displayed.  ") (span (|@| (class "comment-delimiter") (id "F:225836")) "*/") "\n                  ++it->hpos;\n                }\n            }\n\n          " (span (|@| (class "keyword") (id "F:225870")) "if") " (result != MOVE_UNDEFINED)\n            " (span (|@| (class "keyword") (id "F:225905")) "break") ";\n        }\n      " (span (|@| (class "keyword") (id "F:225921")) "else") " " (span (|@| (class "keyword") (id "F:225926")) "if") " (BUFFER_POS_REACHED_P ())\n        {\n        " (span (|@| (class "constant") (id "F:225959")) "buffer_pos_reached") ":\n          IT_RESET_X_ASCENT_DESCENT (it);\n          result = MOVE_POS_MATCH_OR_ZV;\n          " (span (|@| (class "keyword") (id "F:226051")) "break") ";\n        }\n      " (span (|@| (class "keyword") (id "F:226067")) "else") " " (span (|@| (class "keyword") (id "F:226072")) "if") " ((op & MOVE_TO_X) && it->current_x >= to_x)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:226125")) "/* ") (span (|@| (class "comment") (id "F:226128")) "Stop when TO_X specified and reached.  This check is\n             necessary here because of lines consisting of a line end,\n             only.  The line end will not produce any glyphs and we\n             would never get MOVE_X_REACHED.  ") (span (|@| (class "comment-delimiter") (id "F:226345")) "*/") "\n          xassert (it->nglyphs == 0);\n          result = MOVE_X_REACHED;\n          " (span (|@| (class "keyword") (id "F:226410")) "break") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:226427")) "/* ") (span (|@| (class "comment") (id "F:226430")) "Is this a line end?  If yes, we're done.  ") (span (|@| (class "comment-delimiter") (id "F:226472")) "*/") "\n      " (span (|@| (class "keyword") (id "F:226481")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n        {\n          result = MOVE_NEWLINE_OR_CR;\n          " (span (|@| (class "keyword") (id "F:226555")) "break") ";\n        }\n\n      " (span (|@| (class "keyword") (id "F:226572")) "if") " (it->method == GET_FROM_BUFFER)\n        prev_pos = IT_CHARPOS (*it);\n      " (span (|@| (class "comment-delimiter") (id "F:226643")) "/* ") (span (|@| (class "comment") (id "F:226646")) "The current display element has been consumed.  Advance\n         to the next.  ") (span (|@| (class "comment-delimiter") (id "F:226718")) "*/") "\n      set_iterator_to_next (it, 1);\n\n      " (span (|@| (class "comment-delimiter") (id "F:226764")) "/* ") (span (|@| (class "comment") (id "F:226767")) "Stop if lines are truncated and IT's current x-position is\n         past the right edge of the window now.  ") (span (|@| (class "comment-delimiter") (id "F:226868")) "*/") "\n      " (span (|@| (class "keyword") (id "F:226877")) "if") " (it->line_wrap == TRUNCATE\n          && it->current_x >= it->last_visible_x)\n        {\n          " (span (|@| (class "keyword") (id "F:226956")) "if") " (" (span (|@| (class "negation-char") (id "F:226960")) "!") "FRAME_WINDOW_P (it->f)\n              || IT_OVERFLOW_NEWLINE_INTO_FRINGE (it))\n            {\n              " (span (|@| (class "keyword") (id "F:227046")) "if") " (" (span (|@| (class "negation-char") (id "F:227050")) "!") "get_next_display_element (it)\n                  || BUFFER_POS_REACHED_P ())\n                {\n                  result = MOVE_POS_MATCH_OR_ZV;\n                  " (span (|@| (class "keyword") (id "F:227156")) "break") ";\n                }\n              " (span (|@| (class "keyword") (id "F:227174")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n                {\n                  result = MOVE_NEWLINE_OR_CR;\n                  " (span (|@| (class "keyword") (id "F:227251")) "break") ";\n                }\n            }\n          result = MOVE_LINE_TRUNCATED;\n          " (span (|@| (class "keyword") (id "F:227305")) "break") ";\n        }\n" (span (|@| (class "preprocessor") (id "F:227315")) "#undef") " IT_RESET_X_ASCENT_DESCENT\n    }\n\n" (span (|@| (class "preprocessor") (id "F:227355")) "#undef") " BUFFER_POS_REACHED_P\n\n  " (span (|@| (class "comment-delimiter") (id "F:227386")) "/* ") (span (|@| (class "comment") (id "F:227389")) "If we scanned beyond to_pos and didn't find a point to wrap at,\n     restore the saved iterator.  ") (span (|@| (class "comment-delimiter") (id "F:227487")) "*/") "\n  " (span (|@| (class "keyword") (id "F:227492")) "if") " (atpos_it.sp >= 0)\n    *it = atpos_it;\n  " (span (|@| (class "keyword") (id "F:227536")) "else") " " (span (|@| (class "keyword") (id "F:227541")) "if") " (atx_it.sp >= 0)\n    *it = atx_it;\n\n " (span (|@| (class "constant") (id "F:227581")) "done") ":\n\n  " (span (|@| (class "comment-delimiter") (id "F:227590")) "/* ") (span (|@| (class "comment") (id "F:227593")) "Restore the iterator settings altered at the beginning of this\n     function.  ") (span (|@| (class "comment-delimiter") (id "F:227672")) "*/") "\n  it->glyph_row = saved_glyph_row;\n  " (span (|@| (class "keyword") (id "F:227712")) "return") " result;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:227730")) "/* ") (span (|@| (class "comment") (id "F:227733")) "For external use.  ") (span (|@| (class "comment-delimiter") (id "F:227752")) "*/") "\n" (span (|@| (class "type") (id "F:227755")) "void") "\n" (span (|@| (class "function-name") (id "F:227760")) "move_it_in_display_line") " (" (span (|@| (class "keyword") (id "F:227785")) "struct") " " (span (|@| (class "type") (id "F:227792")) "it") " *" (span (|@| (class "variable-name") (id "F:227796")) "it") ",\n                         " (span (|@| (class "type") (id "F:227804")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:227814")) "to_charpos") ", " (span (|@| (class "type") (id "F:227826")) "int") " " (span (|@| (class "variable-name") (id "F:227830")) "to_x") ",\n                         " (span (|@| (class "keyword") (id "F:227840")) "enum") " " (span (|@| (class "type") (id "F:227845")) "move_operation_enum") " " (span (|@| (class "variable-name") (id "F:227865")) "op") ")\n{\n  " (span (|@| (class "keyword") (id "F:227873")) "if") " (it->line_wrap == WORD_WRAP\n      && (op & MOVE_TO_X))\n    {\n      " (span (|@| (class "keyword") (id "F:227943")) "struct") " " (span (|@| (class "type") (id "F:227950")) "it") " " (span (|@| (class "variable-name") (id "F:227953")) "save_it") " = *it;\n      " (span (|@| (class "type") (id "F:227974")) "int") " " (span (|@| (class "variable-name") (id "F:227978")) "skip") " = move_it_in_display_line_to (it, to_charpos, to_x, op);\n      " (span (|@| (class "comment-delimiter") (id "F:228046")) "/* ") (span (|@| (class "comment") (id "F:228049")) "When word-wrap is on, TO_X may lie past the end\n         of a wrapped line.  Then it->current is the\n         character on the next line, so backtrack to the\n         space before the wrap point.  ") (span (|@| (class "comment-delimiter") (id "F:228225")) "*/") "\n      " (span (|@| (class "keyword") (id "F:228234")) "if") " (skip == MOVE_LINE_CONTINUED)\n        {\n          " (span (|@| (class "type") (id "F:228273")) "int") " " (span (|@| (class "variable-name") (id "F:228277")) "prev_x") " = max (it->current_x - 1, 0);\n          *it = save_it;\n          move_it_in_display_line_to\n            (it, -1, prev_x, MOVE_TO_X);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:228407")) "else") "\n    move_it_in_display_line_to (it, to_charpos, to_x, op);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:228475")) "/* ") (span (|@| (class "comment") (id "F:228478")) "Move IT forward until it satisfies one or more of the criteria in\n   TO_CHARPOS, TO_X, TO_Y, and TO_VPOS.\n\n   OP is a bit-mask that specifies where to stop, and in particular,\n   which of those four position arguments makes a difference.  See the\n   description of enum move_operation_enum.\n\n   If TO_CHARPOS is in invisible text, e.g. a truncated part of a\n   screen line, this function will set IT to the next position >\n   TO_CHARPOS.  ") (span (|@| (class "comment-delimiter") (id "F:228917")) "*/") "\n\n" (span (|@| (class "type") (id "F:228921")) "void") "\n" (span (|@| (class "function-name") (id "F:228926")) "move_it_to") " (" (span (|@| (class "type") (id "F:228938")) "it") ", to_charpos, to_x, to_y, to_vpos, op)\n     " (span (|@| (class "keyword") (id "F:228984")) "struct") " " (span (|@| (class "type") (id "F:228991")) "it") " *" (span (|@| (class "variable-name") (id "F:228995")) "it") ";\n     " (span (|@| (class "type") (id "F:229004")) "int") " " (span (|@| (class "variable-name") (id "F:229008")) "to_charpos") ", " (span (|@| (class "variable-name") (id "F:229020")) "to_x") ", " (span (|@| (class "variable-name") (id "F:229026")) "to_y") ", " (span (|@| (class "variable-name") (id "F:229032")) "to_vpos") ";\n     " (span (|@| (class "type") (id "F:229046")) "int") " " (span (|@| (class "variable-name") (id "F:229050")) "op") ";\n{\n  " (span (|@| (class "keyword") (id "F:229058")) "enum") " " (span (|@| (class "type") (id "F:229063")) "move_it_result") " " (span (|@| (class "variable-name") (id "F:229078")) "skip") ", " (span (|@| (class "variable-name") (id "F:229084")) "skip2") " = MOVE_X_REACHED;\n  " (span (|@| (class "type") (id "F:229110")) "int") " " (span (|@| (class "variable-name") (id "F:229114")) "line_height") ", " (span (|@| (class "variable-name") (id "F:229127")) "line_start_x") " = 0, " (span (|@| (class "variable-name") (id "F:229145")) "reached") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:229161")) "for") " (;;)\n    {\n      " (span (|@| (class "keyword") (id "F:229182")) "if") " (op & MOVE_TO_VPOS)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:229211")) "/* ") (span (|@| (class "comment") (id "F:229214")) "If no TO_CHARPOS and no TO_X specified, stop at the\n             start of the line TO_VPOS.  ") (span (|@| (class "comment-delimiter") (id "F:229300")) "*/") "\n          " (span (|@| (class "keyword") (id "F:229306")) "if") " ((op & (MOVE_TO_X | MOVE_TO_POS)) == 0)\n            {\n              " (span (|@| (class "keyword") (id "F:229363")) "if") " (it->vpos == to_vpos)\n                {\n                  reached = 1;\n                  " (span (|@| (class "keyword") (id "F:229413")) "break") ";\n                }\n              " (span (|@| (class "keyword") (id "F:229431")) "else") "\n                skip = move_it_in_display_line_to (it, -1, -1, 0);\n            }\n          " (span (|@| (class "keyword") (id "F:229499")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:229518")) "/* ") (span (|@| (class "comment") (id "F:229521")) "TO_VPOS >= 0 means stop at TO_X in the line at\n                 TO_VPOS, or at TO_POS, whichever comes first.  ") (span (|@| (class "comment-delimiter") (id "F:229618")) "*/") "\n              " (span (|@| (class "keyword") (id "F:229628")) "if") " (it->vpos == to_vpos)\n                {\n                  reached = 2;\n                  " (span (|@| (class "keyword") (id "F:229678")) "break") ";\n                }\n\n              skip = move_it_in_display_line_to (it, to_charpos, to_x, op);\n\n              " (span (|@| (class "keyword") (id "F:229767")) "if") " (skip == MOVE_POS_MATCH_OR_ZV || it->vpos == to_vpos)\n                {\n                  reached = 3;\n                  " (span (|@| (class "keyword") (id "F:229849")) "break") ";\n                }\n              " (span (|@| (class "keyword") (id "F:229867")) "else") " " (span (|@| (class "keyword") (id "F:229872")) "if") " (skip == MOVE_X_REACHED && it->vpos != to_vpos)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:229931")) "/* ") (span (|@| (class "comment") (id "F:229934")) "We have reached TO_X but not in the line we want.  ") (span (|@| (class "comment-delimiter") (id "F:229985")) "*/") "\n                  skip = move_it_in_display_line_to (it, to_charpos,\n                                                     -1, MOVE_TO_POS);\n                  " (span (|@| (class "keyword") (id "F:230076")) "if") " (skip == MOVE_POS_MATCH_OR_ZV)\n                    {\n                      reached = 4;\n                      " (span (|@| (class "keyword") (id "F:230147")) "break") ";\n                    }\n                }\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:230182")) "else") " " (span (|@| (class "keyword") (id "F:230187")) "if") " (op & MOVE_TO_Y)\n        {\n          " (span (|@| (class "keyword") (id "F:230213")) "struct") " " (span (|@| (class "type") (id "F:230220")) "it") " " (span (|@| (class "variable-name") (id "F:230223")) "it_backup") ";\n\n          " (span (|@| (class "keyword") (id "F:230238")) "if") " (it->line_wrap == WORD_WRAP)\n            it_backup = *it;\n\n          " (span (|@| (class "comment-delimiter") (id "F:230296")) "/* ") (span (|@| (class "comment") (id "F:230299")) "TO_Y specified means stop at TO_X in the line containing\n             TO_Y---or at TO_CHARPOS if this is reached first.  The\n             problem is that we can't really tell whether the line\n             contains TO_Y before we have completely scanned it, and\n             this may skip past TO_X.  What we do is to first scan to\n             TO_X.\n\n             If TO_X is not specified, use a TO_X of zero.  The reason\n             is to make the outcome of this function more predictable.\n             If we didn't use TO_X == 0, we would stop at the end of\n             the line which is probably not what a caller would expect\n             to happen.  ") (span (|@| (class "comment-delimiter") (id "F:230887")) "*/") "\n          skip = move_it_in_display_line_to\n            (it, to_charpos, ((op & MOVE_TO_X) ? to_x : 0),\n             (MOVE_TO_X | (op & MOVE_TO_POS)));\n\n          " (span (|@| (class "comment-delimiter") (id "F:231025")) "/* ") (span (|@| (class "comment") (id "F:231028")) "If TO_CHARPOS is reached or ZV, we don't have to do more.  ") (span (|@| (class "comment-delimiter") (id "F:231087")) "*/") "\n          " (span (|@| (class "keyword") (id "F:231093")) "if") " (skip == MOVE_POS_MATCH_OR_ZV)\n            reached = 5;\n          " (span (|@| (class "keyword") (id "F:231148")) "else") " " (span (|@| (class "keyword") (id "F:231153")) "if") " (skip == MOVE_X_REACHED)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:231195")) "/* ") (span (|@| (class "comment") (id "F:231198")) "If TO_X was reached, we want to know whether TO_Y is\n                 in the line.  We know this is the case if the already\n                 scanned glyphs make the line tall enough.  Otherwise,\n                 we must check by scanning the rest of the line.  ") (span (|@| (class "comment-delimiter") (id "F:231417")) "*/") "\n              line_height = it->max_ascent + it->max_descent;\n              " (span (|@| (class "keyword") (id "F:231482")) "if") " (to_y >= it->current_y\n                  && to_y < it->current_y + line_height)\n                {\n                  reached = 6;\n                  " (span (|@| (class "keyword") (id "F:231576")) "break") ";\n                }\n              it_backup = *it;\n              TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:231639")) "\"move_it: from %d\\n\"") ", IT_CHARPOS (*it)));\n              skip2 = move_it_in_display_line_to (it, to_charpos, -1,\n                                                  op & MOVE_TO_POS);\n              TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:231799")) "\"move_it: to %d\\n\"") ", IT_CHARPOS (*it)));\n              line_height = it->max_ascent + it->max_descent;\n              TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:231922")) "\"move_it: line_height = %d\\n\"") ", line_height));\n\n              " (span (|@| (class "keyword") (id "F:231976")) "if") " (to_y >= it->current_y\n                  && to_y < it->current_y + line_height)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:232053")) "/* ") (span (|@| (class "comment") (id "F:232056")) "If TO_Y is in this line and TO_X was reached\n                     above, we scanned too far.  We have to restore\n                     IT's settings to the ones before skipping.  ") (span (|@| (class "comment-delimiter") (id "F:232206")) "*/") "\n                  *it = it_backup;\n                  reached = 6;\n                }\n              " (span (|@| (class "keyword") (id "F:232258")) "else") "\n                {\n                  skip = skip2;\n                  " (span (|@| (class "keyword") (id "F:232289")) "if") " (skip == MOVE_POS_MATCH_OR_ZV)\n                    reached = 7;\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:232356")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:232375")) "/* ") (span (|@| (class "comment") (id "F:232378")) "Check whether TO_Y is in this line.  ") (span (|@| (class "comment-delimiter") (id "F:232415")) "*/") "\n              line_height = it->max_ascent + it->max_descent;\n              TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:232501")) "\"move_it: line_height = %d\\n\"") ", line_height));\n\n              " (span (|@| (class "keyword") (id "F:232555")) "if") " (to_y >= it->current_y\n                  && to_y < it->current_y + line_height)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:232632")) "/* ") (span (|@| (class "comment") (id "F:232635")) "When word-wrap is on, TO_X may lie past the end\n                     of a wrapped line.  Then it->current is the\n                     character on the next line, so backtrack to the\n                     space before the wrap point.  ") (span (|@| (class "comment-delimiter") (id "F:232826")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:232833")) "if") " (skip == MOVE_LINE_CONTINUED\n                      && it->line_wrap == WORD_WRAP)\n                    {\n                      " (span (|@| (class "type") (id "F:232920")) "int") " " (span (|@| (class "variable-name") (id "F:232924")) "prev_x") " = max (it->current_x - 1, 0);\n                      *it = it_backup;\n                      skip = move_it_in_display_line_to\n                        (it, -1, prev_x, MOVE_TO_X);\n                    }\n                  reached = 6;\n                }\n            }\n\n          " (span (|@| (class "keyword") (id "F:233100")) "if") " (reached)\n            " (span (|@| (class "keyword") (id "F:233118")) "break") ";\n        }\n      " (span (|@| (class "keyword") (id "F:233134")) "else") " " (span (|@| (class "keyword") (id "F:233139")) "if") " (BUFFERP (it->object)\n               && (it->method == GET_FROM_BUFFER\n                   || it->method == GET_FROM_STRETCH)\n               && IT_CHARPOS (*it) >= to_charpos)\n        skip = MOVE_POS_MATCH_OR_ZV;\n      " (span (|@| (class "keyword") (id "F:233325")) "else") "\n        skip = move_it_in_display_line_to (it, to_charpos, -1, MOVE_TO_POS);\n\n      " (span (|@| (class "keyword") (id "F:233407")) "switch") " (skip)\n        {\n        " (span (|@| (class "keyword") (id "F:233425")) "case") " MOVE_POS_MATCH_OR_ZV:\n          reached = 8;\n          " (span (|@| (class "keyword") (id "F:233471")) "goto") " " (span (|@| (class "constant") (id "F:233476")) "out") ";\n\n        " (span (|@| (class "keyword") (id "F:233483")) "case") " MOVE_NEWLINE_OR_CR:\n          set_iterator_to_next (it, 1);\n          it->continuation_lines_width = 0;\n          " (span (|@| (class "keyword") (id "F:233581")) "break") ";\n\n        " (span (|@| (class "keyword") (id "F:233590")) "case") " MOVE_LINE_TRUNCATED:\n          it->continuation_lines_width = 0;\n          reseat_at_next_visible_line_start (it, 0);\n          " (span (|@| (class "keyword") (id "F:233702")) "if") " ((op & MOVE_TO_POS) != 0\n              && IT_CHARPOS (*it) > to_charpos)\n            {\n              reached = 9;\n              " (span (|@| (class "keyword") (id "F:233805")) "goto") " " (span (|@| (class "constant") (id "F:233810")) "out") ";\n            }\n          " (span (|@| (class "keyword") (id "F:233825")) "break") ";\n\n        " (span (|@| (class "keyword") (id "F:233834")) "case") " MOVE_LINE_CONTINUED:\n          " (span (|@| (class "comment-delimiter") (id "F:233863")) "/* ") (span (|@| (class "comment") (id "F:233866")) "For continued lines ending in a tab, some of the glyphs\n             associated with the tab are displayed on the current\n             line.  Since it->current_x does not include these glyphs,\n             we use it->last_visible_x instead.  ") (span (|@| (class "comment-delimiter") (id "F:234087")) "*/") "\n          " (span (|@| (class "keyword") (id "F:234093")) "if") " (it->c == " (span (|@| (class "string") (id "F:234106")) "'\\t'") ")\n            {\n              it->continuation_lines_width += it->last_visible_x;\n              " (span (|@| (class "comment-delimiter") (id "F:234185")) "/* ") (span (|@| (class "comment") (id "F:234188")) "When moving by vpos, ensure that the iterator really\n                 advances to the next line (bug#847, bug#969).  Fixme:\n                 do we need to do this in other circumstances?  ") (span (|@| (class "comment-delimiter") (id "F:234348")) "*/") "\n              " (span (|@| (class "keyword") (id "F:234358")) "if") " (it->current_x != it->last_visible_x\n                  && (op & MOVE_TO_VPOS)\n                  && " (span (|@| (class "negation-char") (id "F:234438")) "!") "(op & (MOVE_TO_X | MOVE_TO_POS)))\n                {\n                  line_start_x = it->current_x + it->pixel_width\n                    - it->last_visible_x;\n                  set_iterator_to_next (it, 0);\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:234604")) "else") "\n            it->continuation_lines_width += it->current_x;\n          " (span (|@| (class "keyword") (id "F:234664")) "break") ";\n\n        " (span (|@| (class "keyword") (id "F:234673")) "default") ":\n          abort ();\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:234705")) "/* ") (span (|@| (class "comment") (id "F:234708")) "Reset/increment for the next run.  ") (span (|@| (class "comment-delimiter") (id "F:234743")) "*/") "\n      recenter_overlay_lists (current_buffer, IT_CHARPOS (*it));\n      it->current_x = line_start_x;\n      line_start_x = 0;\n      it->hpos = 0;\n      it->current_y += it->max_ascent + it->max_descent;\n      ++it->vpos;\n      last_height = it->max_ascent + it->max_descent;\n      last_max_ascent = it->max_ascent;\n      it->max_ascent = it->max_descent = 0;\n    }\n\n " (span (|@| (class "constant") (id "F:235112")) "out") ":\n\n  " (span (|@| (class "comment-delimiter") (id "F:235120")) "/* ") (span (|@| (class "comment") (id "F:235123")) "On text terminals, we may stop at the end of a line in the middle\n     of a multi-character glyph.  If the glyph itself is continued,\n     i.e. it is actually displayed on the next line, don't treat this\n     stopping point as valid; move to the next line instead (unless\n     that brings us offscreen).  ") (span (|@| (class "comment-delimiter") (id "F:235428")) "*/") "\n  " (span (|@| (class "keyword") (id "F:235433")) "if") " (" (span (|@| (class "negation-char") (id "F:235437")) "!") "FRAME_WINDOW_P (it->f)\n      && op & MOVE_TO_POS\n      && IT_CHARPOS (*it) == to_charpos\n      && it->what == IT_CHARACTER\n      && it->nglyphs > 1\n      && it->line_wrap == WINDOW_WRAP\n      && it->current_x == it->last_visible_x - 1\n      && it->c != " (span (|@| (class "string") (id "F:235691")) "'\\n'") "\n      && it->c != " (span (|@| (class "string") (id "F:235714")) "'\\t'") "\n      && it->vpos < XFASTINT (it->w->window_end_vpos))\n    {\n      it->continuation_lines_width += it->current_x;\n      it->current_x = it->hpos = it->max_ascent = it->max_descent = 0;\n      it->current_y += it->max_ascent + it->max_descent;\n      ++it->vpos;\n      last_height = it->max_ascent + it->max_descent;\n      last_max_ascent = it->max_ascent;\n    }\n\n  TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:236103")) "\"move_it_to: reached %d\\n\"") ", reached));\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:236146")) "/* ") (span (|@| (class "comment") (id "F:236149")) "Move iterator IT backward by a specified y-distance DY, DY >= 0.\n\n   If DY > 0, move IT backward at least that many pixels.  DY = 0\n   means move IT backward to the preceding line start or BEGV.  This\n   function may move over more than DY pixels if IT->current_y - DY\n   ends up in the middle of a line; in this case IT->current_y will be\n   set to the top of the line moved to.  ") (span (|@| (class "comment-delimiter") (id "F:236530")) "*/") "\n\n" (span (|@| (class "type") (id "F:236534")) "void") "\n" (span (|@| (class "function-name") (id "F:236539")) "move_it_vertically_backward") " (" (span (|@| (class "type") (id "F:236568")) "it") ", dy)\n     " (span (|@| (class "keyword") (id "F:236581")) "struct") " " (span (|@| (class "type") (id "F:236588")) "it") " *" (span (|@| (class "variable-name") (id "F:236592")) "it") ";\n     " (span (|@| (class "type") (id "F:236601")) "int") " " (span (|@| (class "variable-name") (id "F:236605")) "dy") ";\n{\n  " (span (|@| (class "type") (id "F:236613")) "int") " " (span (|@| (class "variable-name") (id "F:236617")) "nlines") ", " (span (|@| (class "variable-name") (id "F:236625")) "h") ";\n  " (span (|@| (class "keyword") (id "F:236630")) "struct") " " (span (|@| (class "type") (id "F:236637")) "it") " " (span (|@| (class "variable-name") (id "F:236640")) "it2") ", " (span (|@| (class "variable-name") (id "F:236645")) "it3") ";\n  " (span (|@| (class "type") (id "F:236652")) "int") " " (span (|@| (class "variable-name") (id "F:236656")) "start_pos") ";\n\n " (span (|@| (class "constant") (id "F:236669")) "move_further_back") ":\n  xassert (dy >= 0);\n\n  start_pos = IT_CHARPOS (*it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:236745")) "/* ") (span (|@| (class "comment") (id "F:236748")) "Estimate how many newlines we must move back.  ") (span (|@| (class "comment-delimiter") (id "F:236795")) "*/") "\n  nlines = max (1, dy / FRAME_LINE_HEIGHT (it->f));\n\n  " (span (|@| (class "comment-delimiter") (id "F:236853")) "/* ") (span (|@| (class "comment") (id "F:236856")) "Set the iterator's position that many lines back.  ") (span (|@| (class "comment-delimiter") (id "F:236907")) "*/") "\n  " (span (|@| (class "keyword") (id "F:236912")) "while") " (nlines-- && IT_CHARPOS (*it) > BEGV)\n    back_to_previous_visible_line_start (it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:237005")) "/* ") (span (|@| (class "comment") (id "F:237008")) "Reseat the iterator here.  When moving backward, we don't want\n     reseat to skip forward over invisible text, set up the iterator\n     to deliver from overlay strings at the new position etc.  So,\n     use reseat_1 here.  ") (span (|@| (class "comment-delimiter") (id "F:237232")) "*/") "\n  reseat_1 (it, it->current.pos, 1);\n\n  " (span (|@| (class "comment-delimiter") (id "F:237275")) "/* ") (span (|@| (class "comment") (id "F:237278")) "We are now surely at a line start.  ") (span (|@| (class "comment-delimiter") (id "F:237314")) "*/") "\n  it->current_x = it->hpos = 0;\n  it->continuation_lines_width = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:237388")) "/* ") (span (|@| (class "comment") (id "F:237391")) "Move forward and see what y-distance we moved.  First move to the\n     start of the next line so that we get its height.  We need this\n     height to be able to tell whether we reached the specified\n     y-distance.  ") (span (|@| (class "comment-delimiter") (id "F:237608")) "*/") "\n  it2 = *it;\n  it2.max_ascent = it2.max_descent = 0;\n  " (span (|@| (class "keyword") (id "F:237666")) "do") "\n    {\n      move_it_to (&it2, start_pos, -1, -1, it2.vpos + 1,\n                  MOVE_TO_POS | MOVE_TO_VPOS);\n    }\n  " (span (|@| (class "keyword") (id "F:237773")) "while") " (" (span (|@| (class "negation-char") (id "F:237780")) "!") "IT_POS_VALID_AFTER_MOVE_P (&it2));\n  xassert (IT_CHARPOS (*it) >= BEGV);\n  it3 = it2;\n\n  move_it_to (&it2, start_pos, -1, -1, -1, MOVE_TO_POS);\n  xassert (IT_CHARPOS (*it) >= BEGV);\n  " (span (|@| (class "comment-delimiter") (id "F:237965")) "/* ") (span (|@| (class "comment") (id "F:237968")) "H is the actual vertical distance from the position in *IT\n     and the starting position.  ") (span (|@| (class "comment-delimiter") (id "F:238060")) "*/") "\n  h = it2.current_y - it->current_y;\n  " (span (|@| (class "comment-delimiter") (id "F:238102")) "/* ") (span (|@| (class "comment") (id "F:238105")) "NLINES is the distance in number of lines.  ") (span (|@| (class "comment-delimiter") (id "F:238149")) "*/") "\n  nlines = it2.vpos - it->vpos;\n\n  " (span (|@| (class "comment-delimiter") (id "F:238187")) "/* ") (span (|@| (class "comment") (id "F:238190")) "Correct IT's y and vpos position\n     so that they are relative to the starting point.  ") (span (|@| (class "comment-delimiter") (id "F:238278")) "*/") "\n  it->vpos -= nlines;\n  it->current_y -= h;\n\n  " (span (|@| (class "keyword") (id "F:238328")) "if") " (dy == 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:238353")) "/* ") (span (|@| (class "comment") (id "F:238356")) "DY == 0 means move to the start of the screen line.  The\n         value of nlines is > 0 if continuation lines were involved.  ") (span (|@| (class "comment-delimiter") (id "F:238476")) "*/") "\n      " (span (|@| (class "keyword") (id "F:238485")) "if") " (nlines > 0)\n        move_it_by_lines (it, nlines, 1);\n    }\n  " (span (|@| (class "keyword") (id "F:238544")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:238561")) "/* ") (span (|@| (class "comment") (id "F:238564")) "The y-position we try to reach, relative to *IT.\n         Note that H has been subtracted in front of the if-statement.  ") (span (|@| (class "comment-delimiter") (id "F:238678")) "*/") "\n      " (span (|@| (class "type") (id "F:238687")) "int") " " (span (|@| (class "variable-name") (id "F:238691")) "target_y") " = it->current_y + h - dy;\n      " (span (|@| (class "type") (id "F:238732")) "int") " " (span (|@| (class "variable-name") (id "F:238736")) "y0") " = it3.current_y;\n      " (span (|@| (class "type") (id "F:238762")) "int") " " (span (|@| (class "variable-name") (id "F:238766")) "y1") " = line_bottom_y (&it3);\n      " (span (|@| (class "type") (id "F:238799")) "int") " " (span (|@| (class "variable-name") (id "F:238803")) "line_height") " = y1 - y0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:238833")) "/* ") (span (|@| (class "comment") (id "F:238836")) "If we did not reach target_y, try to move further backward if\n         we can.  If we moved too far backward, try to move forward.  ") (span (|@| (class "comment-delimiter") (id "F:238961")) "*/") "\n      " (span (|@| (class "keyword") (id "F:238970")) "if") " (target_y < it->current_y\n          " (span (|@| (class "comment-delimiter") (id "F:239002")) "/* ") (span (|@| (class "comment") (id "F:239005")) "This is heuristic.  In a window that's 3 lines high, with\n             a line height of 13 pixels each, recentering with point\n             on the bottom line will try to move -39/2 = 19 pixels\n             backward.  Try to avoid moving into the first line.  ") (span (|@| (class "comment-delimiter") (id "F:239244")) "*/") "\n          && (it->current_y - target_y\n              > min (window_box_height (it->w), line_height * 2 / 3))\n          && IT_CHARPOS (*it) > BEGV)\n        {\n          TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:239400")) "\"  not far enough -> move_vert %d\\n\"") ",\n                       target_y - it->current_y));\n          dy = it->current_y - target_y;\n          " (span (|@| (class "keyword") (id "F:239512")) "goto") " " (span (|@| (class "constant") (id "F:239517")) "move_further_back") ";\n        }\n      " (span (|@| (class "keyword") (id "F:239545")) "else") " " (span (|@| (class "keyword") (id "F:239550")) "if") " (target_y >= it->current_y + line_height\n               && IT_CHARPOS (*it) < ZV)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:239634")) "/* ") (span (|@| (class "comment") (id "F:239637")) "Should move forward by at least one line, maybe more.\n\n             Note: Calling move_it_by_lines can be expensive on\n             terminal frames, where compute_motion is used (via\n             vmotion) to do the job, when there are very long lines\n             and truncate-lines is nil.  That's the reason for\n             treating terminal frames specially here.  ") (span (|@| (class "comment-delimiter") (id "F:239971")) "*/") "\n\n          " (span (|@| (class "keyword") (id "F:239978")) "if") " (" (span (|@| (class "negation-char") (id "F:239982")) "!") "FRAME_WINDOW_P (it->f))\n            move_it_vertically (it, target_y - (it->current_y + line_height));\n          " (span (|@| (class "keyword") (id "F:240082")) "else") "\n            {\n              " (span (|@| (class "keyword") (id "F:240101")) "do") "\n                {\n                  move_it_by_lines (it, 1, 1);\n                }\n              " (span (|@| (class "keyword") (id "F:240152")) "while") " (target_y >= line_bottom_y (it) && IT_CHARPOS (*it) < ZV);\n            }\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:240237")) "/* ") (span (|@| (class "comment") (id "F:240240")) "Move IT by a specified amount of pixel lines DY.  DY negative means\n   move backwards.  DY = 0 means move to start of screen line.  At the\n   end, IT will be on the start of a screen line.  ") (span (|@| (class "comment-delimiter") (id "F:240430")) "*/") "\n\n" (span (|@| (class "type") (id "F:240434")) "void") "\n" (span (|@| (class "function-name") (id "F:240439")) "move_it_vertically") " (" (span (|@| (class "type") (id "F:240459")) "it") ", dy)\n    " (span (|@| (class "keyword") (id "F:240471")) "struct") " " (span (|@| (class "type") (id "F:240478")) "it") " *" (span (|@| (class "variable-name") (id "F:240482")) "it") ";\n    " (span (|@| (class "type") (id "F:240490")) "int") " " (span (|@| (class "variable-name") (id "F:240494")) "dy") ";\n{\n  " (span (|@| (class "keyword") (id "F:240502")) "if") " (dy <= 0)\n    move_it_vertically_backward (it, -dy);\n  " (span (|@| (class "keyword") (id "F:240560")) "else") "\n    {\n      TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:240598")) "\"move_it_v: from %d, %d\\n\"") ", IT_CHARPOS (*it), dy));\n      move_it_to (it, ZV, -1, it->current_y + dy, -1,\n                  MOVE_TO_POS | MOVE_TO_Y);\n      TRACE_MOVE ((stderr, " (span (|@| (class "string") (id "F:240761")) "\"move_it_v: to %d\\n\"") ", IT_CHARPOS (*it)));\n\n      " (span (|@| (class "comment-delimiter") (id "F:240810")) "/* ") (span (|@| (class "comment") (id "F:240813")) "If buffer ends in ZV without a newline, move to the start of\n         the line to satisfy the post-condition.  ") (span (|@| (class "comment-delimiter") (id "F:240917")) "*/") "\n      " (span (|@| (class "keyword") (id "F:240926")) "if") " (IT_CHARPOS (*it) == ZV\n          && ZV > BEGV\n          && FETCH_BYTE (IT_BYTEPOS (*it) - 1) != " (span (|@| (class "string") (id "F:241012")) "'\\n'") ")\n        move_it_by_lines (it, 0, 0);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:241058")) "/* ") (span (|@| (class "comment") (id "F:241061")) "Move iterator IT past the end of the text line it is in.  ") (span (|@| (class "comment-delimiter") (id "F:241119")) "*/") "\n\n" (span (|@| (class "type") (id "F:241123")) "void") "\n" (span (|@| (class "function-name") (id "F:241128")) "move_it_past_eol") " (" (span (|@| (class "type") (id "F:241146")) "it") ")\n     " (span (|@| (class "keyword") (id "F:241155")) "struct") " " (span (|@| (class "type") (id "F:241162")) "it") " *" (span (|@| (class "variable-name") (id "F:241166")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:241174")) "enum") " " (span (|@| (class "type") (id "F:241179")) "move_it_result") " " (span (|@| (class "variable-name") (id "F:241194")) "rc") ";\n\n  rc = move_it_in_display_line_to (it, Z, 0, MOVE_TO_POS);\n  " (span (|@| (class "keyword") (id "F:241260")) "if") " (rc == MOVE_NEWLINE_OR_CR)\n    set_iterator_to_next (it, 0);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:241328")) "/* ") (span (|@| (class "comment") (id "F:241331")) "Move IT by a specified number DVPOS of screen lines down.  DVPOS\n   negative means move up.  DVPOS == 0 means move to the start of the\n   screen line.  NEED_Y_P non-zero means calculate IT->current_y.  If\n   NEED_Y_P is zero, IT->current_y will be left unchanged.\n\n   Further optimization ideas: If we would know that IT->f doesn't use\n   a face with proportional font, we could be faster for\n   truncate-lines nil.  ") (span (|@| (class "comment-delimiter") (id "F:241748")) "*/") "\n\n" (span (|@| (class "type") (id "F:241752")) "void") "\n" (span (|@| (class "function-name") (id "F:241757")) "move_it_by_lines") " (" (span (|@| (class "type") (id "F:241775")) "it") ", dvpos, need_y_p)\n     " (span (|@| (class "keyword") (id "F:241801")) "struct") " " (span (|@| (class "type") (id "F:241808")) "it") " *" (span (|@| (class "variable-name") (id "F:241812")) "it") ";\n     " (span (|@| (class "type") (id "F:241821")) "int") " " (span (|@| (class "variable-name") (id "F:241825")) "dvpos") ", " (span (|@| (class "variable-name") (id "F:241832")) "need_y_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:241846")) "struct") " " (span (|@| (class "type") (id "F:241853")) "position") " " (span (|@| (class "variable-name") (id "F:241862")) "pos") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:241870")) "/* ") (span (|@| (class "comment") (id "F:241873")) "The commented-out optimization uses vmotion on terminals.  This\n     gives bad results, because elements like it->what, on which\n     callers such as pos_visible_p rely, aren't updated. ") (span (|@| (class "comment-delimiter") (id "F:242059")) "*/") "\n  " (span (|@| (class "comment-delimiter") (id "F:242064")) "/*  ") (span (|@| (class "comment") (id "F:242068")) "if (!FRAME_WINDOW_P (it->f))\n    {\n      struct text_pos textpos;\n\n      pos = *vmotion (IT_CHARPOS (*it), dvpos, it->w);\n      SET_TEXT_POS (textpos, pos.bufpos, pos.bytepos);\n      reseat (it, textpos, 1);\n      it->vpos += pos.vpos;\n      it->current_y += pos.vpos;\n    }\n    else ") (span (|@| (class "comment-delimiter") (id "F:242352")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:242358")) "if") " (dvpos == 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:242386")) "/* ") (span (|@| (class "comment") (id "F:242389")) "DVPOS == 0 means move to the start of the screen line.  ") (span (|@| (class "comment-delimiter") (id "F:242445")) "*/") "\n      move_it_vertically_backward (it, 0);\n      xassert (it->current_x == 0 && it->hpos == 0);\n      " (span (|@| (class "comment-delimiter") (id "F:242550")) "/* ") (span (|@| (class "comment") (id "F:242553")) "Let next call to line_bottom_y calculate real line height ") (span (|@| (class "comment-delimiter") (id "F:242611")) "*/") "\n      last_height = 0;\n    }\n  " (span (|@| (class "keyword") (id "F:242645")) "else") " " (span (|@| (class "keyword") (id "F:242650")) "if") " (dvpos > 0)\n    {\n      move_it_to (it, -1, -1, -1, it->vpos + dvpos, MOVE_TO_VPOS);\n      " (span (|@| (class "keyword") (id "F:242744")) "if") " (" (span (|@| (class "negation-char") (id "F:242748")) "!") "IT_POS_VALID_AFTER_MOVE_P (it))\n        move_it_to (it, IT_CHARPOS (*it) + 1, -1, -1, -1, MOVE_TO_POS);\n    }\n  " (span (|@| (class "keyword") (id "F:242854")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:242871")) "struct") " " (span (|@| (class "type") (id "F:242878")) "it") " " (span (|@| (class "variable-name") (id "F:242881")) "it2") ";\n      " (span (|@| (class "type") (id "F:242892")) "int") " " (span (|@| (class "variable-name") (id "F:242896")) "start_charpos") ", " (span (|@| (class "variable-name") (id "F:242911")) "i") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:242921")) "/* ") (span (|@| (class "comment") (id "F:242924")) "Start at the beginning of the screen line containing IT's\n         position.  This may actually move vertically backwards,\n         in case of overlays, so adjust dvpos accordingly.  ") (span (|@| (class "comment-delimiter") (id "F:243100")) "*/") "\n      dvpos += it->vpos;\n      move_it_vertically_backward (it, 0);\n      dvpos -= it->vpos;\n\n      " (span (|@| (class "comment-delimiter") (id "F:243203")) "/* ") (span (|@| (class "comment") (id "F:243206")) "Go back -DVPOS visible lines and reseat the iterator there.  ") (span (|@| (class "comment-delimiter") (id "F:243267")) "*/") "\n      start_charpos = IT_CHARPOS (*it);\n      " (span (|@| (class "keyword") (id "F:243316")) "for") " (i = -dvpos; i > 0 && IT_CHARPOS (*it) > BEGV; --i)\n        back_to_previous_visible_line_start (it);\n      reseat (it, it->current.pos, 1);\n\n      " (span (|@| (class "comment-delimiter") (id "F:243461")) "/* ") (span (|@| (class "comment") (id "F:243464")) "Move further back if we end up in a string or an image.  ") (span (|@| (class "comment-delimiter") (id "F:243521")) "*/") "\n      " (span (|@| (class "keyword") (id "F:243530")) "while") " (" (span (|@| (class "negation-char") (id "F:243537")) "!") "IT_POS_VALID_AFTER_MOVE_P (it))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:243576")) "/* ") (span (|@| (class "comment") (id "F:243579")) "First try to move to start of display line.  ") (span (|@| (class "comment-delimiter") (id "F:243624")) "*/") "\n          dvpos += it->vpos;\n          move_it_vertically_backward (it, 0);\n          dvpos -= it->vpos;\n          " (span (|@| (class "keyword") (id "F:243714")) "if") " (IT_POS_VALID_AFTER_MOVE_P (it))\n            " (span (|@| (class "keyword") (id "F:243755")) "break") ";\n          " (span (|@| (class "comment-delimiter") (id "F:243765")) "/* ") (span (|@| (class "comment") (id "F:243768")) "If start of line is still in string or image,\n             move further back.  ") (span (|@| (class "comment-delimiter") (id "F:243840")) "*/") "\n          back_to_previous_visible_line_start (it);\n          reseat (it, it->current.pos, 1);\n          dvpos--;\n        }\n\n      it->current_x = it->hpos = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:243983")) "/* ") (span (|@| (class "comment") (id "F:243986")) "Above call may have moved too far if continuation lines\n         are involved.  Scan forward and see if it did.  ") (span (|@| (class "comment-delimiter") (id "F:244092")) "*/") "\n      it2 = *it;\n      it2.vpos = it2.current_y = 0;\n      move_it_to (&it2, start_charpos, -1, -1, -1, MOVE_TO_POS);\n      it->vpos -= it2.vpos;\n      it->current_y -= it2.current_y;\n      it->current_x = it->hpos = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:244322")) "/* ") (span (|@| (class "comment") (id "F:244325")) "If we moved too far back, move IT some lines forward.  ") (span (|@| (class "comment-delimiter") (id "F:244380")) "*/") "\n      " (span (|@| (class "keyword") (id "F:244389")) "if") " (it2.vpos > -dvpos)\n        {\n          " (span (|@| (class "type") (id "F:244418")) "int") " " (span (|@| (class "variable-name") (id "F:244422")) "delta") " = it2.vpos + dvpos;\n          it2 = *it;\n          move_it_to (it, -1, -1, -1, it->vpos + delta, MOVE_TO_VPOS);\n          " (span (|@| (class "comment-delimiter") (id "F:244529")) "/* ") (span (|@| (class "comment") (id "F:244532")) "Move back again if we got too far ahead.  ") (span (|@| (class "comment-delimiter") (id "F:244574")) "*/") "\n          " (span (|@| (class "keyword") (id "F:244580")) "if") " (IT_CHARPOS (*it) >= start_charpos)\n            *it = it2;\n        }\n    }\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:244647")) "/* ") (span (|@| (class "comment") (id "F:244650")) "Return 1 if IT points into the middle of a display vector.  ") (span (|@| (class "comment-delimiter") (id "F:244710")) "*/") "\n\n" (span (|@| (class "type") (id "F:244714")) "int") "\n" (span (|@| (class "function-name") (id "F:244718")) "in_display_vector_p") " (" (span (|@| (class "type") (id "F:244739")) "it") ")\n     " (span (|@| (class "keyword") (id "F:244748")) "struct") " " (span (|@| (class "type") (id "F:244755")) "it") " *" (span (|@| (class "variable-name") (id "F:244759")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:244767")) "return") " (it->method == GET_FROM_DISPLAY_VECTOR\n          && it->current.dpvec_index > 0\n          && it->dpvec + it->current.dpvec_index != it->dpend);\n}\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:244909")) "/***********************************************************************") (span (|@| (class "comment") (id "F:244981")) "\n                               Messages\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:245072")) "*/") "\n\n\n" (span (|@| (class "comment-delimiter") (id "F:245077")) "/* ") (span (|@| (class "comment") (id "F:245080")) "Add a message with format string FORMAT and arguments ARG1 and ARG2\n   to *Messages*.  ") (span (|@| (class "comment-delimiter") (id "F:245167")) "*/") "\n\n" (span (|@| (class "type") (id "F:245171")) "void") "\n" (span (|@| (class "function-name") (id "F:245176")) "add_to_log") " (format, arg1, arg2)\n     " (span (|@| (class "type") (id "F:245213")) "char") " *" (span (|@| (class "variable-name") (id "F:245219")) "format") ";\n     " (span (|@| (class "type") (id "F:245232")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:245244")) "arg1") ", " (span (|@| (class "variable-name") (id "F:245250")) "arg2") ";\n{\n  " (span (|@| (class "type") (id "F:245260")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:245272")) "args") "[3];\n  " (span (|@| (class "type") (id "F:245283")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:245295")) "msg") ", " (span (|@| (class "variable-name") (id "F:245300")) "fmt") ";\n  " (span (|@| (class "type") (id "F:245307")) "char") " *" (span (|@| (class "variable-name") (id "F:245313")) "buffer") ";\n  " (span (|@| (class "type") (id "F:245323")) "int") " " (span (|@| (class "variable-name") (id "F:245327")) "len") ";\n  " (span (|@| (class "keyword") (id "F:245334")) "struct") " " (span (|@| (class "type") (id "F:245341")) "gcpro") " " (span (|@| (class "variable-name") (id "F:245347")) "gcpro1") ", " (span (|@| (class "variable-name") (id "F:245355")) "gcpro2") ", " (span (|@| (class "variable-name") (id "F:245363")) "gcpro3") ", " (span (|@| (class "variable-name") (id "F:245371")) "gcpro4") ";\n  USE_SAFE_ALLOCA;\n\n  " (span (|@| (class "comment-delimiter") (id "F:245401")) "/* ") (span (|@| (class "comment") (id "F:245404")) "Do nothing if called asynchronously.  Inserting text into\n     a buffer may call after-change-functions and alike and\n     that would means running Lisp asynchronously.  ") (span (|@| (class "comment-delimiter") (id "F:245574")) "*/") "\n  " (span (|@| (class "keyword") (id "F:245579")) "if") " (handling_signal)\n    " (span (|@| (class "keyword") (id "F:245604")) "return") ";\n\n  fmt = msg = Qnil;\n  GCPRO4 (fmt, msg, arg1, arg2);\n\n  args[0] = fmt = build_string (format);\n  args[1] = arg1;\n  args[2] = arg2;\n  msg = Fformat (3, args);\n\n  len = SBYTES (msg) + 1;\n  SAFE_ALLOCA (buffer, " (span (|@| (class "type") (id "F:245821")) "char") " *, len);\n  bcopy (SDATA (msg), buffer, len);\n\n  message_dolog (buffer, len - 1, 1, 0);\n  SAFE_FREE ();\n\n  UNGCPRO;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:245945")) "/* ") (span (|@| (class "comment") (id "F:245948")) "Output a newline in the *Messages* buffer if \"needs\" one.  ") (span (|@| (class "comment-delimiter") (id "F:246007")) "*/") "\n\n" (span (|@| (class "type") (id "F:246011")) "void") "\n" (span (|@| (class "function-name") (id "F:246016")) "message_log_maybe_newline") " ()\n{\n  " (span (|@| (class "keyword") (id "F:246049")) "if") " (message_log_need_newline)\n    message_dolog (" (span (|@| (class "string") (id "F:246098")) "\"\"") ", 0, 1, 0);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:246116")) "/* ") (span (|@| (class "comment") (id "F:246119")) "Add a string M of length NBYTES to the message log, optionally\n   terminated with a newline when NLFLAG is non-zero.  MULTIBYTE, if\n   nonzero, means interpret the contents of M as multibyte.  This\n   function calls low-level routines in order to bypass text property\n   hooks, etc. which might not be safe to run.\n\n   This may GC (insert may run before/after change hooks),\n   so the buffer M must NOT point to a Lisp string.  ") (span (|@| (class "comment-delimiter") (id "F:246547")) "*/") "\n\n" (span (|@| (class "type") (id "F:246551")) "void") "\n" (span (|@| (class "function-name") (id "F:246556")) "message_dolog") " (m, nbytes, nlflag, multibyte)\n     " (span (|@| (class "keyword") (id "F:246606")) "const") " " (span (|@| (class "type") (id "F:246612")) "char") " *" (span (|@| (class "variable-name") (id "F:246618")) "m") ";\n     " (span (|@| (class "type") (id "F:246626")) "int") " " (span (|@| (class "variable-name") (id "F:246630")) "nbytes") ", " (span (|@| (class "variable-name") (id "F:246638")) "nlflag") ", " (span (|@| (class "variable-name") (id "F:246646")) "multibyte") ";\n{\n  " (span (|@| (class "keyword") (id "F:246661")) "if") " (" (span (|@| (class "negation-char") (id "F:246665")) "!") "NILP (Vmemory_full))\n    " (span (|@| (class "keyword") (id "F:246691")) "return") ";\n\n  " (span (|@| (class "keyword") (id "F:246702")) "if") " (" (span (|@| (class "negation-char") (id "F:246706")) "!") "NILP (Vmessage_log_max))\n    {\n      " (span (|@| (class "keyword") (id "F:246744")) "struct") " " (span (|@| (class "type") (id "F:246751")) "buffer") " *" (span (|@| (class "variable-name") (id "F:246759")) "oldbuf") ";\n      " (span (|@| (class "type") (id "F:246773")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:246785")) "oldpoint") ", " (span (|@| (class "variable-name") (id "F:246795")) "oldbegv") ", " (span (|@| (class "variable-name") (id "F:246804")) "oldzv") ";\n      " (span (|@| (class "type") (id "F:246817")) "int") " " (span (|@| (class "variable-name") (id "F:246821")) "old_windows_or_buffers_changed") " = windows_or_buffers_changed;\n      " (span (|@| (class "type") (id "F:246888")) "int") " " (span (|@| (class "variable-name") (id "F:246892")) "point_at_end") " = 0;\n      " (span (|@| (class "type") (id "F:246916")) "int") " " (span (|@| (class "variable-name") (id "F:246920")) "zv_at_end") " = 0;\n      " (span (|@| (class "type") (id "F:246941")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:246953")) "old_deactivate_mark") ", " (span (|@| (class "variable-name") (id "F:246974")) "tem") ";\n      " (span (|@| (class "keyword") (id "F:246985")) "struct") " " (span (|@| (class "type") (id "F:246992")) "gcpro") " " (span (|@| (class "variable-name") (id "F:246998")) "gcpro1") ";\n\n      old_deactivate_mark = Vdeactivate_mark;\n      oldbuf = current_buffer;\n      Fset_buffer (Fget_buffer_create (Vmessages_buffer_name));\n      current_buffer->undo_list = Qt;\n\n      oldpoint = message_dolog_marker1;\n      set_marker_restricted (oldpoint, make_number (PT), Qnil);\n      oldbegv = message_dolog_marker2;\n      set_marker_restricted (oldbegv, make_number (BEGV), Qnil);\n      oldzv = message_dolog_marker3;\n      set_marker_restricted (oldzv, make_number (ZV), Qnil);\n      GCPRO1 (old_deactivate_mark);\n\n      " (span (|@| (class "keyword") (id "F:247536")) "if") " (PT == Z)\n        point_at_end = 1;\n      " (span (|@| (class "keyword") (id "F:247574")) "if") " (ZV == Z)\n        zv_at_end = 1;\n\n      BEGV = BEG;\n      BEGV_BYTE = BEG_BYTE;\n      ZV = Z;\n      ZV_BYTE = Z_BYTE;\n      TEMP_SET_PT_BOTH (Z, Z_BYTE);\n\n      " (span (|@| (class "comment-delimiter") (id "F:247731")) "/* ") (span (|@| (class "comment") (id "F:247734")) "Insert the string--maybe converting multibyte to single byte\n         or vice versa, so that all the text fits the buffer.  ") (span (|@| (class "comment-delimiter") (id "F:247851")) "*/") "\n      " (span (|@| (class "keyword") (id "F:247860")) "if") " (multibyte\n          && NILP (current_buffer->enable_multibyte_characters))\n        {\n          " (span (|@| (class "type") (id "F:247938")) "int") " " (span (|@| (class "variable-name") (id "F:247942")) "i") ", " (span (|@| (class "variable-name") (id "F:247945")) "c") ", " (span (|@| (class "variable-name") (id "F:247948")) "char_bytes") ";\n          " (span (|@| (class "type") (id "F:247963")) "unsigned") " " (span (|@| (class "type") (id "F:247972")) "char") " " (span (|@| (class "variable-name") (id "F:247977")) "work") "[1];\n\n          " (span (|@| (class "comment-delimiter") (id "F:247990")) "/* ") (span (|@| (class "comment") (id "F:247993")) "Convert a multibyte string to single-byte\n             for the *Message* buffer.  ") (span (|@| (class "comment-delimiter") (id "F:248068")) "*/") "\n          " (span (|@| (class "keyword") (id "F:248074")) "for") " (i = 0; i < nbytes; i += char_bytes)\n            {\n              c = string_char_and_length (m + i, &char_bytes);\n              work[0] = (ASCII_CHAR_P (c)\n                         ? c\n                         : multibyte_char_to_unibyte (c, Qnil));\n              insert_1_both (work, 1, 1, 1, 0, 0);\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:248325")) "else") " " (span (|@| (class "keyword") (id "F:248330")) "if") " (" (span (|@| (class "negation-char") (id "F:248334")) "!") " multibyte\n               && " (span (|@| (class "negation-char") (id "F:248357")) "!") " NILP (current_buffer->enable_multibyte_characters))\n        {\n          " (span (|@| (class "type") (id "F:248417")) "int") " " (span (|@| (class "variable-name") (id "F:248421")) "i") ", " (span (|@| (class "variable-name") (id "F:248424")) "c") ", " (span (|@| (class "variable-name") (id "F:248427")) "char_bytes") ";\n          " (span (|@| (class "type") (id "F:248442")) "unsigned") " " (span (|@| (class "type") (id "F:248451")) "char") " *" (span (|@| (class "variable-name") (id "F:248457")) "msg") " = (" (span (|@| (class "type") (id "F:248464")) "unsigned") " " (span (|@| (class "type") (id "F:248473")) "char") " *) m;\n          " (span (|@| (class "type") (id "F:248487")) "unsigned") " " (span (|@| (class "type") (id "F:248496")) "char") " " (span (|@| (class "variable-name") (id "F:248501")) "str") "[MAX_MULTIBYTE_LENGTH];\n          " (span (|@| (class "comment-delimiter") (id "F:248531")) "/* ") (span (|@| (class "comment") (id "F:248534")) "Convert a single-byte string to multibyte\n             for the *Message* buffer.  ") (span (|@| (class "comment-delimiter") (id "F:248609")) "*/") "\n          " (span (|@| (class "keyword") (id "F:248615")) "for") " (i = 0; i < nbytes; i++)\n            {\n              c = msg[i];\n              MAKE_CHAR_MULTIBYTE (c);\n              char_bytes = CHAR_STRING (c, str);\n              insert_1_both (str, 1, char_bytes, 1, 0, 0);\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:248812")) "else") " " (span (|@| (class "keyword") (id "F:248817")) "if") " (nbytes)\n        insert_1 (m, nbytes, 1, 0, 0);\n\n      " (span (|@| (class "keyword") (id "F:248868")) "if") " (nlflag)\n        {\n          " (span (|@| (class "type") (id "F:248886")) "int") " " (span (|@| (class "variable-name") (id "F:248890")) "this_bol") ", " (span (|@| (class "variable-name") (id "F:248900")) "this_bol_byte") ", " (span (|@| (class "variable-name") (id "F:248915")) "prev_bol") ", " (span (|@| (class "variable-name") (id "F:248925")) "prev_bol_byte") ", " (span (|@| (class "variable-name") (id "F:248940")) "dup") ";\n          insert_1 (" (span (|@| (class "string") (id "F:248958")) "\"\\n\"") ", 1, 1, 0, 0);\n\n          scan_newline (Z, Z_BYTE, BEG, BEG_BYTE, -2, 0);\n          this_bol = PT;\n          this_bol_byte = PT_BYTE;\n\n          " (span (|@| (class "comment-delimiter") (id "F:249079")) "/* ") (span (|@| (class "comment") (id "F:249082")) "See if this line duplicates the previous one.\n             If so, combine duplicates.  ") (span (|@| (class "comment-delimiter") (id "F:249162")) "*/") "\n          " (span (|@| (class "keyword") (id "F:249168")) "if") " (this_bol > BEG)\n            {\n              scan_newline (PT, PT_BYTE, BEG, BEG_BYTE, -2, 0);\n              prev_bol = PT;\n              prev_bol_byte = PT_BYTE;\n\n              dup = message_log_check_duplicate (prev_bol, prev_bol_byte,\n                                                 this_bol, this_bol_byte);\n              " (span (|@| (class "keyword") (id "F:249414")) "if") " (dup)\n                {\n                  del_range_both (prev_bol, prev_bol_byte,\n                                  this_bol, this_bol_byte, 0);\n                  " (span (|@| (class "keyword") (id "F:249511")) "if") " (dup > 1)\n                    {\n                      " (span (|@| (class "type") (id "F:249540")) "char") " " (span (|@| (class "variable-name") (id "F:249545")) "dupstr") "[40];\n                      " (span (|@| (class "type") (id "F:249565")) "int") " " (span (|@| (class "variable-name") (id "F:249569")) "duplen") ";\n\n                      " (span (|@| (class "comment-delimiter") (id "F:249586")) "/* ") (span (|@| (class "comment") (id "F:249589")) "If you change this format, don't forget to also\n                         change message_log_check_duplicate.  ") (span (|@| (class "comment-delimiter") (id "F:249678")) "*/") "\n                      sprintf (dupstr, " (span (|@| (class "string") (id "F:249706")) "\" [%d times]\"") ", dup);\n                      duplen = strlen (dupstr);\n                      TEMP_SET_PT_BOTH (Z - 1, Z_BYTE - 1);\n                      insert_1 (dupstr, duplen, 1, 0, 1);\n                    }\n                }\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:249874")) "/* ") (span (|@| (class "comment") (id "F:249877")) "If we have more than the desired maximum number of lines\n             in the *Messages* buffer now, delete the oldest ones.\n             This is safe because we don't have undo in this buffer.  ") (span (|@| (class "comment-delimiter") (id "F:250057")) "*/") "\n\n          " (span (|@| (class "keyword") (id "F:250064")) "if") " (NATNUMP (Vmessage_log_max))\n            {\n              scan_newline (Z, Z_BYTE, BEG, BEG_BYTE,\n                            -XFASTINT (Vmessage_log_max) - 1, 0);\n              del_range_both (BEG, BEG_BYTE, PT, PT_BYTE, 0);\n            }\n        }\n      BEGV = XMARKER (oldbegv)->charpos;\n      BEGV_BYTE = marker_byte_position (oldbegv);\n\n      " (span (|@| (class "keyword") (id "F:250358")) "if") " (zv_at_end)\n        {\n          ZV = Z;\n          ZV_BYTE = Z_BYTE;\n        }\n      " (span (|@| (class "keyword") (id "F:250417")) "else") "\n        {\n          ZV = XMARKER (oldzv)->charpos;\n          ZV_BYTE = marker_byte_position (oldzv);\n        }\n\n      " (span (|@| (class "keyword") (id "F:250512")) "if") " (point_at_end)\n        TEMP_SET_PT_BOTH (Z, Z_BYTE);\n      " (span (|@| (class "keyword") (id "F:250567")) "else") "\n        " (span (|@| (class "comment-delimiter") (id "F:250573")) "/* ") (span (|@| (class "comment") (id "F:250576")) "We can't do Fgoto_char (oldpoint) because it will run some\n           Lisp code.  ") (span (|@| (class "comment-delimiter") (id "F:250658")) "*/") "\n        TEMP_SET_PT_BOTH (XMARKER (oldpoint)->charpos,\n                          XMARKER (oldpoint)->bytepos);\n\n      UNGCPRO;\n      unchain_marker (XMARKER (oldpoint));\n      unchain_marker (XMARKER (oldbegv));\n      unchain_marker (XMARKER (oldzv));\n\n      tem = Fget_buffer_window (Fcurrent_buffer (), Qt);\n      set_buffer_internal (oldbuf);\n      " (span (|@| (class "keyword") (id "F:250985")) "if") " (NILP (tem))\n        windows_or_buffers_changed = old_windows_or_buffers_changed;\n      message_log_need_newline = " (span (|@| (class "negation-char") (id "F:251096")) "!") "nlflag;\n      Vdeactivate_mark = old_deactivate_mark;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:251161")) "/* ") (span (|@| (class "comment") (id "F:251164")) "We are at the end of the buffer after just having inserted a newline.\n   (Note: We depend on the fact we won't be crossing the gap.)\n   Check to see if the most recent message looks a lot like the previous one.\n   Return 0 if different, 1 if the new one should just replace it, or a\n   value N > 1 if we should also append \" [N times]\".  ") (span (|@| (class "comment-delimiter") (id "F:251502")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:251506")) "static") " " (span (|@| (class "type") (id "F:251513")) "int") "\n" (span (|@| (class "function-name") (id "F:251517")) "message_log_check_duplicate") " (prev_bol, prev_bol_byte, this_bol, this_bol_byte)\n     " (span (|@| (class "type") (id "F:251601")) "int") " " (span (|@| (class "variable-name") (id "F:251605")) "prev_bol") ", " (span (|@| (class "variable-name") (id "F:251615")) "this_bol") ";\n     " (span (|@| (class "type") (id "F:251630")) "int") " " (span (|@| (class "variable-name") (id "F:251634")) "prev_bol_byte") ", " (span (|@| (class "variable-name") (id "F:251649")) "this_bol_byte") ";\n{\n  " (span (|@| (class "type") (id "F:251668")) "int") " " (span (|@| (class "variable-name") (id "F:251672")) "i") ";\n  " (span (|@| (class "type") (id "F:251677")) "int") " " (span (|@| (class "variable-name") (id "F:251681")) "len") " = Z_BYTE - 1 - this_bol_byte;\n  " (span (|@| (class "type") (id "F:251717")) "int") " " (span (|@| (class "variable-name") (id "F:251721")) "seen_dots") " = 0;\n  " (span (|@| (class "type") (id "F:251738")) "unsigned") " " (span (|@| (class "type") (id "F:251747")) "char") " *" (span (|@| (class "variable-name") (id "F:251753")) "p1") " = BUF_BYTE_ADDRESS (current_buffer, prev_bol_byte);\n  " (span (|@| (class "type") (id "F:251810")) "unsigned") " " (span (|@| (class "type") (id "F:251819")) "char") " *" (span (|@| (class "variable-name") (id "F:251825")) "p2") " = BUF_BYTE_ADDRESS (current_buffer, this_bol_byte);\n\n  " (span (|@| (class "keyword") (id "F:251883")) "for") " (i = 0; i < len; i++)\n    {\n      " (span (|@| (class "keyword") (id "F:251921")) "if") " (i >= 3 && p1[i-3] == " (span (|@| (class "string") (id "F:251946")) "'.'") " && p1[i-2] == " (span (|@| (class "string") (id "F:251964")) "'.'") " && p1[i-1] == " (span (|@| (class "string") (id "F:251982")) "'.'") ")\n        seen_dots = 1;\n      " (span (|@| (class "keyword") (id "F:252009")) "if") " (p1[i] != p2[i])\n        " (span (|@| (class "keyword") (id "F:252030")) "return") " seen_dots;\n    }\n  p1 += len;\n  " (span (|@| (class "keyword") (id "F:252069")) "if") " (*p1 == " (span (|@| (class "string") (id "F:252080")) "'\\n'") ")\n    " (span (|@| (class "keyword") (id "F:252090")) "return") " 2;\n  " (span (|@| (class "keyword") (id "F:252102")) "if") " (*p1++ == " (span (|@| (class "string") (id "F:252115")) "' '") " && *p1++ == " (span (|@| (class "string") (id "F:252131")) "'['") ")\n    {\n      " (span (|@| (class "type") (id "F:252148")) "int") " " (span (|@| (class "variable-name") (id "F:252152")) "n") " = 0;\n      " (span (|@| (class "keyword") (id "F:252165")) "while") " (*p1 >= " (span (|@| (class "string") (id "F:252179")) "'0'") " && *p1 <= " (span (|@| (class "string") (id "F:252193")) "'9'") ")\n        n = n * 10 + *p1++ - " (span (|@| (class "string") (id "F:252220")) "'0'") ";\n      " (span (|@| (class "keyword") (id "F:252231")) "if") " (strncmp (p1, " (span (|@| (class "string") (id "F:252248")) "\" times]\\n\"") ", 8) == 0)\n        " (span (|@| (class "keyword") (id "F:252271")) "return") " n+1;\n    }\n  " (span (|@| (class "keyword") (id "F:252291")) "return") " 0;\n}\n\f\n\n" (span (|@| (class "comment-delimiter") (id "F:252306")) "/* ") (span (|@| (class "comment") (id "F:252309")) "Display an echo area message M with a specified length of NBYTES\n   bytes.  The string may include null characters.  If M is 0, clear\n   out any existing message, and let the mini-buffer text show\n   through.\n\n   This may GC, so the buffer M must NOT point to a Lisp string.  ") (span (|@| (class "comment-delimiter") (id "F:252585")) "*/") "\n\n" (span (|@| (class "type") (id "F:252589")) "void") "\n" (span (|@| (class "function-name") (id "F:252594")) "message2") " (m, nbytes, multibyte)\n     " (span (|@| (class "keyword") (id "F:252631")) "const") " " (span (|@| (class "type") (id "F:252637")) "char") " *" (span (|@| (class "variable-name") (id "F:252643")) "m") ";\n     " (span (|@| (class "type") (id "F:252651")) "int") " " (span (|@| (class "variable-name") (id "F:252655")) "nbytes") ";\n     " (span (|@| (class "type") (id "F:252668")) "int") " " (span (|@| (class "variable-name") (id "F:252672")) "multibyte") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:252687")) "/* ") (span (|@| (class "comment") (id "F:252690")) "First flush out any partial line written with print.  ") (span (|@| (class "comment-delimiter") (id "F:252744")) "*/") "\n  message_log_maybe_newline ();\n  " (span (|@| (class "keyword") (id "F:252781")) "if") " (m)\n    message_dolog (m, nbytes, 1, multibyte);\n  message2_nolog (m, nbytes, multibyte);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:252878")) "/* ") (span (|@| (class "comment") (id "F:252881")) "The non-logging counterpart of message2.  ") (span (|@| (class "comment-delimiter") (id "F:252923")) "*/") "\n\n" (span (|@| (class "type") (id "F:252927")) "void") "\n" (span (|@| (class "function-name") (id "F:252932")) "message2_nolog") " (m, nbytes, multibyte)\n     " (span (|@| (class "keyword") (id "F:252975")) "const") " " (span (|@| (class "type") (id "F:252981")) "char") " *" (span (|@| (class "variable-name") (id "F:252987")) "m") ";\n     " (span (|@| (class "type") (id "F:252995")) "int") " " (span (|@| (class "variable-name") (id "F:252999")) "nbytes") ", " (span (|@| (class "variable-name") (id "F:253007")) "multibyte") ";\n{\n  " (span (|@| (class "keyword") (id "F:253022")) "struct") " " (span (|@| (class "type") (id "F:253029")) "frame") " *" (span (|@| (class "variable-name") (id "F:253036")) "sf") " = SELECTED_FRAME ();\n  message_enable_multibyte = multibyte;\n\n  " (span (|@| (class "keyword") (id "F:253103")) "if") " (FRAME_INITIAL_P (sf))\n    {\n      " (span (|@| (class "keyword") (id "F:253141")) "if") " (noninteractive_need_newline)\n        putc (" (span (|@| (class "string") (id "F:253181")) "'\\n'") ", stderr);\n      noninteractive_need_newline = 0;\n      " (span (|@| (class "keyword") (id "F:253241")) "if") " (m)\n        fwrite (m, nbytes, 1, stderr);\n      " (span (|@| (class "keyword") (id "F:253286")) "if") " (cursor_in_echo_area == 0)\n        fprintf (stderr, " (span (|@| (class "string") (id "F:253334")) "\"\\n\"") ");\n      fflush (stderr);\n    }\n  " (span (|@| (class "comment-delimiter") (id "F:253372")) "/* ") (span (|@| (class "comment") (id "F:253375")) "A null message buffer means that the frame hasn't really been\n     initialized yet.  Error messages get reported properly by\n     cmd_error, so this must be just an informative message; toss it.  ") (span (|@| (class "comment-delimiter") (id "F:253571")) "*/") "\n  " (span (|@| (class "keyword") (id "F:253576")) "else") " " (span (|@| (class "keyword") (id "F:253581")) "if") " (INTERACTIVE\n           && sf->glyphs_initialized_p\n           && FRAME_MESSAGE_BUF (sf))\n    {\n      " (span (|@| (class "type") (id "F:253672")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:253684")) "mini_window") ";\n      " (span (|@| (class "keyword") (id "F:253703")) "struct") " " (span (|@| (class "type") (id "F:253710")) "frame") " *" (span (|@| (class "variable-name") (id "F:253717")) "f") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:253727")) "/* ") (span (|@| (class "comment") (id "F:253730")) "Get the frame containing the mini-buffer\n         that the selected frame is using.  ") (span (|@| (class "comment-delimiter") (id "F:253808")) "*/") "\n      mini_window = FRAME_MINIBUF_WINDOW (sf);\n      f = XFRAME (WINDOW_FRAME (XWINDOW (mini_window)));\n\n      FRAME_SAMPLE_VISIBILITY (f);\n      " (span (|@| (class "keyword") (id "F:253957")) "if") " (FRAME_VISIBLE_P (sf)\n          && " (span (|@| (class "negation-char") (id "F:253988")) "!") " FRAME_VISIBLE_P (f))\n        Fmake_frame_visible (WINDOW_FRAME (XWINDOW (mini_window)));\n\n      " (span (|@| (class "keyword") (id "F:254079")) "if") " (m)\n        {\n          set_message (m, Qnil, nbytes, multibyte);\n          " (span (|@| (class "keyword") (id "F:254137")) "if") " (minibuffer_auto_raise)\n            Fraise_frame  (WINDOW_FRAME (XWINDOW (mini_window)));\n        }\n      " (span (|@| (class "keyword") (id "F:254232")) "else") "\n        clear_message (1, 1);\n\n      do_pending_window_change (0);\n      echo_area_display (1);\n      do_pending_window_change (0);\n      " (span (|@| (class "keyword") (id "F:254368")) "if") " (FRAME_TERMINAL (f)->frame_up_to_date_hook != 0 && " (span (|@| (class "negation-char") (id "F:254422")) "!") " gc_in_progress)\n        (*FRAME_TERMINAL (f)->frame_up_to_date_hook) (f);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:254501")) "/* ") (span (|@| (class "comment") (id "F:254504")) "Display an echo area message M with a specified length of NBYTES\n   bytes.  The string may include null characters.  If M is not a\n   string, clear out any existing message, and let the mini-buffer\n   text show through.\n\n   This function cancels echoing.  ") (span (|@| (class "comment-delimiter") (id "F:254760")) "*/") "\n\n" (span (|@| (class "type") (id "F:254764")) "void") "\n" (span (|@| (class "function-name") (id "F:254769")) "message3") " (m, nbytes, multibyte)\n     " (span (|@| (class "type") (id "F:254806")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:254818")) "m") ";\n     " (span (|@| (class "type") (id "F:254826")) "int") " " (span (|@| (class "variable-name") (id "F:254830")) "nbytes") ";\n     " (span (|@| (class "type") (id "F:254843")) "int") " " (span (|@| (class "variable-name") (id "F:254847")) "multibyte") ";\n{\n  " (span (|@| (class "keyword") (id "F:254862")) "struct") " " (span (|@| (class "type") (id "F:254869")) "gcpro") " " (span (|@| (class "variable-name") (id "F:254875")) "gcpro1") ";\n\n  GCPRO1 (m);\n  clear_message (1,1);\n  cancel_echoing ();\n\n  " (span (|@| (class "comment-delimiter") (id "F:254945")) "/* ") (span (|@| (class "comment") (id "F:254948")) "First flush out any partial line written with print.  ") (span (|@| (class "comment-delimiter") (id "F:255002")) "*/") "\n  message_log_maybe_newline ();\n  " (span (|@| (class "keyword") (id "F:255039")) "if") " (STRINGP (m))\n    {\n      " (span (|@| (class "type") (id "F:255068")) "char") " *" (span (|@| (class "variable-name") (id "F:255074")) "buffer") ";\n      USE_SAFE_ALLOCA;\n\n      SAFE_ALLOCA (buffer, " (span (|@| (class "type") (id "F:255133")) "char") " *, nbytes);\n      bcopy (SDATA (m), buffer, nbytes);\n      message_dolog (buffer, nbytes, 1, multibyte);\n      SAFE_FREE ();\n    }\n  message3_nolog (m, nbytes, multibyte);\n\n  UNGCPRO;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:255326")) "/* ") (span (|@| (class "comment") (id "F:255329")) "The non-logging version of message3.\n   This does not cancel echoing, because it is used for echoing.\n   Perhaps we need to make a separate function for echoing\n   and make this cancel echoing.  ") (span (|@| (class "comment-delimiter") (id "F:255524")) "*/") "\n\n" (span (|@| (class "type") (id "F:255528")) "void") "\n" (span (|@| (class "function-name") (id "F:255533")) "message3_nolog") " (m, nbytes, multibyte)\n     " (span (|@| (class "type") (id "F:255576")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:255588")) "m") ";\n     " (span (|@| (class "type") (id "F:255596")) "int") " " (span (|@| (class "variable-name") (id "F:255600")) "nbytes") ", " (span (|@| (class "variable-name") (id "F:255608")) "multibyte") ";\n{\n  " (span (|@| (class "keyword") (id "F:255623")) "struct") " " (span (|@| (class "type") (id "F:255630")) "frame") " *" (span (|@| (class "variable-name") (id "F:255637")) "sf") " = SELECTED_FRAME ();\n  message_enable_multibyte = multibyte;\n\n  " (span (|@| (class "keyword") (id "F:255704")) "if") " (FRAME_INITIAL_P (sf))\n    {\n      " (span (|@| (class "keyword") (id "F:255742")) "if") " (noninteractive_need_newline)\n        putc (" (span (|@| (class "string") (id "F:255782")) "'\\n'") ", stderr);\n      noninteractive_need_newline = 0;\n      " (span (|@| (class "keyword") (id "F:255842")) "if") " (STRINGP (m))\n        fwrite (SDATA (m), nbytes, 1, stderr);\n      " (span (|@| (class "keyword") (id "F:255905")) "if") " (cursor_in_echo_area == 0)\n        fprintf (stderr, " (span (|@| (class "string") (id "F:255953")) "\"\\n\"") ");\n      fflush (stderr);\n    }\n  " (span (|@| (class "comment-delimiter") (id "F:255991")) "/* ") (span (|@| (class "comment") (id "F:255994")) "A null message buffer means that the frame hasn't really been\n     initialized yet.  Error messages get reported properly by\n     cmd_error, so this must be just an informative message; toss it.  ") (span (|@| (class "comment-delimiter") (id "F:256190")) "*/") "\n  " (span (|@| (class "keyword") (id "F:256195")) "else") " " (span (|@| (class "keyword") (id "F:256200")) "if") " (INTERACTIVE\n           && sf->glyphs_initialized_p\n           && FRAME_MESSAGE_BUF (sf))\n    {\n      " (span (|@| (class "type") (id "F:256291")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:256303")) "mini_window") ";\n      " (span (|@| (class "type") (id "F:256322")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:256334")) "frame") ";\n      " (span (|@| (class "keyword") (id "F:256347")) "struct") " " (span (|@| (class "type") (id "F:256354")) "frame") " *" (span (|@| (class "variable-name") (id "F:256361")) "f") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:256371")) "/* ") (span (|@| (class "comment") (id "F:256374")) "Get the frame containing the mini-buffer\n         that the selected frame is using.  ") (span (|@| (class "comment-delimiter") (id "F:256452")) "*/") "\n      mini_window = FRAME_MINIBUF_WINDOW (sf);\n      frame = XWINDOW (mini_window)->frame;\n      f = XFRAME (frame);\n\n      FRAME_SAMPLE_VISIBILITY (f);\n      " (span (|@| (class "keyword") (id "F:256614")) "if") " (FRAME_VISIBLE_P (sf)\n          && " (span (|@| (class "negation-char") (id "F:256645")) "!") "FRAME_VISIBLE_P (f))\n        Fmake_frame_visible (frame);\n\n      " (span (|@| (class "keyword") (id "F:256704")) "if") " (STRINGP (m) && SCHARS (m) > 0)\n        {\n          set_message (" (span (|@| (class "constant") (id "F:256758")) "NULL") ", m, nbytes, multibyte);\n          " (span (|@| (class "keyword") (id "F:256790")) "if") " (minibuffer_auto_raise)\n            Fraise_frame (frame);\n          " (span (|@| (class "comment-delimiter") (id "F:256847")) "/* ") (span (|@| (class "comment") (id "F:256850")) "Assume we are not echoing.\n             (If we are, echo_now will override this.)  ") (span (|@| (class "comment-delimiter") (id "F:256926")) "*/") "\n          echo_message_buffer = Qnil;\n        }\n      " (span (|@| (class "keyword") (id "F:256969")) "else") "\n        clear_message (1, 1);\n\n      do_pending_window_change (0);\n      echo_area_display (1);\n      do_pending_window_change (0);\n      " (span (|@| (class "keyword") (id "F:257105")) "if") " (FRAME_TERMINAL (f)->frame_up_to_date_hook != 0 && " (span (|@| (class "negation-char") (id "F:257159")) "!") " gc_in_progress)\n        (*FRAME_TERMINAL (f)->frame_up_to_date_hook) (f);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:257238")) "/* ") (span (|@| (class "comment") (id "F:257241")) "Display a null-terminated echo area message M.  If M is 0, clear\n   out any existing message, and let the mini-buffer text show through.\n\n   The buffer M must continue to exist until after the echo area gets\n   cleared or some other message gets displayed there.  Do not pass\n   text that is stored in a Lisp string.  Do not pass text in a buffer\n   that was alloca'd.  ") (span (|@| (class "comment-delimiter") (id "F:257611")) "*/") "\n\n" (span (|@| (class "type") (id "F:257615")) "void") "\n" (span (|@| (class "function-name") (id "F:257620")) "message1") " (m)\n     " (span (|@| (class "type") (id "F:257638")) "char") " *" (span (|@| (class "variable-name") (id "F:257644")) "m") ";\n{\n  message2 (m, (m ? strlen (m) : 0), 0);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:257694")) "/* ") (span (|@| (class "comment") (id "F:257697")) "The non-logging counterpart of message1.  ") (span (|@| (class "comment-delimiter") (id "F:257739")) "*/") "\n\n" (span (|@| (class "type") (id "F:257743")) "void") "\n" (span (|@| (class "function-name") (id "F:257748")) "message1_nolog") " (m)\n     " (span (|@| (class "type") (id "F:257772")) "char") " *" (span (|@| (class "variable-name") (id "F:257778")) "m") ";\n{\n  message2_nolog (m, (m ? strlen (m) : 0), 0);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:257833")) "/* ") (span (|@| (class "comment") (id "F:257836")) "Display a message M which contains a single %s\n   which gets replaced with STRING.  ") (span (|@| (class "comment-delimiter") (id "F:257920")) "*/") "\n\n" (span (|@| (class "type") (id "F:257924")) "void") "\n" (span (|@| (class "function-name") (id "F:257929")) "message_with_string") " (m, string, log)\n     " (span (|@| (class "type") (id "F:257971")) "char") " *" (span (|@| (class "variable-name") (id "F:257977")) "m") ";\n     " (span (|@| (class "type") (id "F:257985")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:257997")) "string") ";\n     " (span (|@| (class "type") (id "F:258010")) "int") " " (span (|@| (class "variable-name") (id "F:258014")) "log") ";\n{\n  CHECK_STRING (string);\n\n  " (span (|@| (class "keyword") (id "F:258049")) "if") " (noninteractive)\n    {\n      " (span (|@| (class "keyword") (id "F:258081")) "if") " (m)\n        {\n          " (span (|@| (class "keyword") (id "F:258094")) "if") " (noninteractive_need_newline)\n            putc (" (span (|@| (class "string") (id "F:258138")) "'\\n'") ", stderr);\n          noninteractive_need_newline = 0;\n          fprintf (stderr, m, SDATA (string));\n          " (span (|@| (class "keyword") (id "F:258232")) "if") " (" (span (|@| (class "negation-char") (id "F:258236")) "!") "cursor_in_echo_area)\n            fprintf (stderr, " (span (|@| (class "string") (id "F:258280")) "\"\\n\"") ");\n          fflush (stderr);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:258318")) "else") " " (span (|@| (class "keyword") (id "F:258323")) "if") " (INTERACTIVE)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:258352")) "/* ") (span (|@| (class "comment") (id "F:258355")) "The frame whose minibuffer we're going to display the message on.\n         It may be larger than the selected frame, so we need\n         to use its buffer, not the selected frame's buffer.  ") (span (|@| (class "comment-delimiter") (id "F:258531")) "*/") "\n      " (span (|@| (class "type") (id "F:258540")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:258552")) "mini_window") ";\n      " (span (|@| (class "keyword") (id "F:258571")) "struct") " " (span (|@| (class "type") (id "F:258578")) "frame") " *" (span (|@| (class "variable-name") (id "F:258585")) "f") ", *" (span (|@| (class "variable-name") (id "F:258589")) "sf") " = SELECTED_FRAME ();\n\n      " (span (|@| (class "comment-delimiter") (id "F:258620")) "/* ") (span (|@| (class "comment") (id "F:258623")) "Get the frame containing the minibuffer\n         that the selected frame is using.  ") (span (|@| (class "comment-delimiter") (id "F:258700")) "*/") "\n      mini_window = FRAME_MINIBUF_WINDOW (sf);\n      f = XFRAME (WINDOW_FRAME (XWINDOW (mini_window)));\n\n      " (span (|@| (class "comment-delimiter") (id "F:258814")) "/* ") (span (|@| (class "comment") (id "F:258817")) "A null message buffer means that the frame hasn't really been\n         initialized yet.  Error messages get reported properly by\n         cmd_error, so this must be just an informative message; toss it.  ") (span (|@| (class "comment-delimiter") (id "F:259007")) "*/") "\n      " (span (|@| (class "keyword") (id "F:259016")) "if") " (FRAME_MESSAGE_BUF (f))\n        {\n          " (span (|@| (class "type") (id "F:259049")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:259061")) "args") "[2], " (span (|@| (class "variable-name") (id "F:259070")) "message") ";\n          " (span (|@| (class "keyword") (id "F:259082")) "struct") " " (span (|@| (class "type") (id "F:259089")) "gcpro") " " (span (|@| (class "variable-name") (id "F:259095")) "gcpro1") ", " (span (|@| (class "variable-name") (id "F:259103")) "gcpro2") ";\n\n          args[0] = build_string (m);\n          args[1] = message = string;\n          GCPRO2 (args[0], message);\n          gcpro1.nvars = 2;\n\n          message = Fformat (2, args);\n\n          " (span (|@| (class "keyword") (id "F:259262")) "if") " (log)\n            message3 (message, SBYTES (message), STRING_MULTIBYTE (message));\n          " (span (|@| (class "keyword") (id "F:259345")) "else") "\n            message3_nolog (message, SBYTES (message), STRING_MULTIBYTE (message));\n\n          UNGCPRO;\n\n          " (span (|@| (class "comment-delimiter") (id "F:259444")) "/* ") (span (|@| (class "comment") (id "F:259447")) "Print should start at the beginning of the message\n             buffer next time.  ") (span (|@| (class "comment-delimiter") (id "F:259523")) "*/") "\n          message_buf_print = 0;\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:259565")) "/* ") (span (|@| (class "comment") (id "F:259568")) "Dump an informative message to the minibuf.  If M is 0, clear out\n   any existing message, and let the mini-buffer text show through.  ") (span (|@| (class "comment-delimiter") (id "F:259703")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:259707")) "/* ") (span (|@| (class "comment") (id "F:259710")) "VARARGS 1 ") (span (|@| (class "comment-delimiter") (id "F:259720")) "*/") "\n" (span (|@| (class "type") (id "F:259723")) "void") "\n" (span (|@| (class "function-name") (id "F:259728")) "message") " (m, a1, a2, a3)\n     " (span (|@| (class "type") (id "F:259757")) "char") " *" (span (|@| (class "variable-name") (id "F:259763")) "m") ";\n     " (span (|@| (class "type") (id "F:259771")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:259781")) "a1") ", " (span (|@| (class "variable-name") (id "F:259785")) "a2") ", " (span (|@| (class "variable-name") (id "F:259789")) "a3") ";\n{\n  " (span (|@| (class "keyword") (id "F:259797")) "if") " (noninteractive)\n    {\n      " (span (|@| (class "keyword") (id "F:259829")) "if") " (m)\n        {\n          " (span (|@| (class "keyword") (id "F:259842")) "if") " (noninteractive_need_newline)\n            putc (" (span (|@| (class "string") (id "F:259886")) "'\\n'") ", stderr);\n          noninteractive_need_newline = 0;\n          fprintf (stderr, m, a1, a2, a3);\n          " (span (|@| (class "keyword") (id "F:259976")) "if") " (cursor_in_echo_area == 0)\n            fprintf (stderr, " (span (|@| (class "string") (id "F:260028")) "\"\\n\"") ");\n          fflush (stderr);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:260066")) "else") " " (span (|@| (class "keyword") (id "F:260071")) "if") " (INTERACTIVE)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:260100")) "/* ") (span (|@| (class "comment") (id "F:260103")) "The frame whose mini-buffer we're going to display the message\n         on.  It may be larger than the selected frame, so we need to\n         use its buffer, not the selected frame's buffer.  ") (span (|@| (class "comment-delimiter") (id "F:260281")) "*/") "\n      " (span (|@| (class "type") (id "F:260290")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:260302")) "mini_window") ";\n      " (span (|@| (class "keyword") (id "F:260321")) "struct") " " (span (|@| (class "type") (id "F:260328")) "frame") " *" (span (|@| (class "variable-name") (id "F:260335")) "f") ", *" (span (|@| (class "variable-name") (id "F:260339")) "sf") " = SELECTED_FRAME ();\n\n      " (span (|@| (class "comment-delimiter") (id "F:260370")) "/* ") (span (|@| (class "comment") (id "F:260373")) "Get the frame containing the mini-buffer\n         that the selected frame is using.  ") (span (|@| (class "comment-delimiter") (id "F:260451")) "*/") "\n      mini_window = FRAME_MINIBUF_WINDOW (sf);\n      f = XFRAME (WINDOW_FRAME (XWINDOW (mini_window)));\n\n      " (span (|@| (class "comment-delimiter") (id "F:260565")) "/* ") (span (|@| (class "comment") (id "F:260568")) "A null message buffer means that the frame hasn't really been\n         initialized yet.  Error messages get reported properly by\n         cmd_error, so this must be just an informative message; toss\n         it.  ") (span (|@| (class "comment-delimiter") (id "F:260760")) "*/") "\n      " (span (|@| (class "keyword") (id "F:260769")) "if") " (FRAME_MESSAGE_BUF (f))\n        {\n          " (span (|@| (class "keyword") (id "F:260802")) "if") " (m)\n            {\n              " (span (|@| (class "type") (id "F:260823")) "int") " " (span (|@| (class "variable-name") (id "F:260827")) "len") ";\n              " (span (|@| (class "type") (id "F:260839")) "char") " *" (span (|@| (class "variable-name") (id "F:260845")) "a") "[3];\n              a[0] = (" (span (|@| (class "type") (id "F:260866")) "char") " *) a1;\n              a[1] = (" (span (|@| (class "type") (id "F:260893")) "char") " *) a2;\n              a[2] = (" (span (|@| (class "type") (id "F:260920")) "char") " *) a3;\n\n              len = doprnt (FRAME_MESSAGE_BUF (f),\n                            FRAME_MESSAGE_BUF_SIZE (f), m, (" (span (|@| (class "type") (id "F:261016")) "char") " *)0, 3, a);\n\n              message2 (FRAME_MESSAGE_BUF (f), len, 0);\n            }\n          " (span (|@| (class "keyword") (id "F:261093")) "else") "\n            message1 (0);\n\n          " (span (|@| (class "comment-delimiter") (id "F:261121")) "/* ") (span (|@| (class "comment") (id "F:261124")) "Print should start at the beginning of the message\n             buffer next time.  ") (span (|@| (class "comment-delimiter") (id "F:261200")) "*/") "\n          message_buf_print = 0;\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:261242")) "/* ") (span (|@| (class "comment") (id "F:261245")) "The non-logging version of message.  ") (span (|@| (class "comment-delimiter") (id "F:261282")) "*/") "\n\n" (span (|@| (class "type") (id "F:261286")) "void") "\n" (span (|@| (class "function-name") (id "F:261291")) "message_nolog") " (m, a1, a2, a3)\n     " (span (|@| (class "type") (id "F:261326")) "char") " *" (span (|@| (class "variable-name") (id "F:261332")) "m") ";\n     " (span (|@| (class "type") (id "F:261340")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:261350")) "a1") ", " (span (|@| (class "variable-name") (id "F:261354")) "a2") ", " (span (|@| (class "variable-name") (id "F:261358")) "a3") ";\n{\n  " (span (|@| (class "type") (id "F:261366")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:261378")) "old_log_max") ";\n  old_log_max = Vmessage_log_max;\n  Vmessage_log_max = Qnil;\n  message (m, a1, a2, a3);\n  Vmessage_log_max = old_log_max;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:261517")) "/* ") (span (|@| (class "comment") (id "F:261520")) "Display the current message in the current mini-buffer.  This is\n   only called from error handlers in process.c, and is not time\n   critical.  ") (span (|@| (class "comment-delimiter") (id "F:261664")) "*/") "\n\n" (span (|@| (class "type") (id "F:261668")) "void") "\n" (span (|@| (class "function-name") (id "F:261673")) "update_echo_area") " ()\n{\n  " (span (|@| (class "keyword") (id "F:261697")) "if") " (" (span (|@| (class "negation-char") (id "F:261701")) "!") "NILP (echo_area_buffer[0]))\n    {\n      " (span (|@| (class "type") (id "F:261742")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:261754")) "string") ";\n      string = Fcurrent_message ();\n      message3 (string, SBYTES (string),\n                " (span (|@| (class "negation-char") (id "F:261841")) "!") "NILP (current_buffer->enable_multibyte_characters));\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:261905")) "/* ") (span (|@| (class "comment") (id "F:261908")) "Make sure echo area buffers in `echo_buffers' are live.\n   If they aren't, make new ones.  ") (span (|@| (class "comment-delimiter") (id "F:261999")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:262003")) "static") " " (span (|@| (class "type") (id "F:262010")) "void") "\n" (span (|@| (class "function-name") (id "F:262015")) "ensure_echo_area_buffers") " ()\n{\n  " (span (|@| (class "type") (id "F:262047")) "int") " " (span (|@| (class "variable-name") (id "F:262051")) "i") ";\n\n  " (span (|@| (class "keyword") (id "F:262057")) "for") " (i = 0; i < 2; ++i)\n    " (span (|@| (class "keyword") (id "F:262085")) "if") " (" (span (|@| (class "negation-char") (id "F:262089")) "!") "BUFFERP (echo_buffer[i])\n        || NILP (XBUFFER (echo_buffer[i])->name))\n      {\n        " (span (|@| (class "type") (id "F:262167")) "char") " " (span (|@| (class "variable-name") (id "F:262172")) "name") "[30];\n        " (span (|@| (class "type") (id "F:262183")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:262195")) "old_buffer") ";\n        " (span (|@| (class "type") (id "F:262208")) "int") " " (span (|@| (class "variable-name") (id "F:262212")) "j") ";\n\n        old_buffer = echo_buffer[i];\n        sprintf (name, " (span (|@| (class "string") (id "F:262262")) "\" *Echo Area %d*\"") ", i);\n        echo_buffer[i] = Fget_buffer_create (build_string (name));\n        XBUFFER (echo_buffer[i])->truncate_lines = Qnil;\n        " (span (|@| (class "comment-delimiter") (id "F:262396")) "/* ") (span (|@| (class "comment") (id "F:262399")) "to force word wrap in echo area -\n           it was decided to postpone this") (span (|@| (class "comment-delimiter") (id "F:262468")) "*/") "\n        " (span (|@| (class "comment-delimiter") (id "F:262472")) "/* ") (span (|@| (class "comment") (id "F:262475")) "XBUFFER (echo_buffer[i])->word_wrap = Qt; ") (span (|@| (class "comment-delimiter") (id "F:262517")) "*/") "\n\n        " (span (|@| (class "keyword") (id "F:262522")) "for") " (j = 0; j < 2; ++j)\n          " (span (|@| (class "keyword") (id "F:262549")) "if") " (EQ (old_buffer, echo_area_buffer[j]))\n            echo_area_buffer[j] = echo_buffer[i];\n      }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:262646")) "/* ") (span (|@| (class "comment") (id "F:262649")) "Call FN with args A1..A4 with either the current or last displayed\n   echo_area_buffer as current buffer.\n\n   WHICH zero means use the current message buffer\n   echo_area_buffer[0].  If that is nil, choose a suitable buffer\n   from echo_buffer[] and clear it.\n\n   WHICH > 0 means use echo_area_buffer[1].  If that is nil, choose a\n   suitable buffer from echo_buffer[] and clear it.\n\n   If WHICH < 0, set echo_area_buffer[1] to echo_area_buffer[0], so\n   that the current message becomes the last displayed one, make\n   choose a suitable buffer for echo_area_buffer[0], and clear it.\n\n   Value is what FN returns.  ") (span (|@| (class "comment-delimiter") (id "F:263264")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:263268")) "static") " " (span (|@| (class "type") (id "F:263275")) "int") "\n" (span (|@| (class "function-name") (id "F:263279")) "with_echo_area_buffer") " (w, which, fn, a1, a2, a3, a4)\n     " (span (|@| (class "keyword") (id "F:263337")) "struct") " " (span (|@| (class "type") (id "F:263344")) "window") " *" (span (|@| (class "variable-name") (id "F:263352")) "w") ";\n     " (span (|@| (class "type") (id "F:263360")) "int") " " (span (|@| (class "variable-name") (id "F:263364")) "which") ";\n     " (span (|@| (class "type") (id "F:263376")) "int") " (*" (span (|@| (class "function-name") (id "F:263382")) "fn") ") P_ ((EMACS_INT, Lisp_Object, EMACS_INT, EMACS_INT));\n     " (span (|@| (class "type") (id "F:263444")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:263454")) "a1") ";\n     " (span (|@| (class "type") (id "F:263463")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:263475")) "a2") ";\n     " (span (|@| (class "type") (id "F:263484")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:263494")) "a3") ", " (span (|@| (class "variable-name") (id "F:263498")) "a4") ";\n{\n  " (span (|@| (class "type") (id "F:263506")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:263518")) "buffer") ";\n  " (span (|@| (class "type") (id "F:263528")) "int") " " (span (|@| (class "variable-name") (id "F:263532")) "this_one") ", " (span (|@| (class "variable-name") (id "F:263542")) "the_other") ", " (span (|@| (class "variable-name") (id "F:263553")) "clear_buffer_p") ", " (span (|@| (class "variable-name") (id "F:263569")) "rc") ";\n  " (span (|@| (class "type") (id "F:263575")) "int") " " (span (|@| (class "variable-name") (id "F:263579")) "count") " = SPECPDL_INDEX ();\n\n  " (span (|@| (class "comment-delimiter") (id "F:263608")) "/* ") (span (|@| (class "comment") (id "F:263611")) "If buffers aren't live, make new ones.  ") (span (|@| (class "comment-delimiter") (id "F:263651")) "*/") "\n  ensure_echo_area_buffers ();\n\n  clear_buffer_p = 0;\n\n  " (span (|@| (class "keyword") (id "F:263711")) "if") " (which == 0)\n    this_one = 0, the_other = 1;\n  " (span (|@| (class "keyword") (id "F:263762")) "else") " " (span (|@| (class "keyword") (id "F:263767")) "if") " (which > 0)\n    this_one = 1, the_other = 0;\n  " (span (|@| (class "keyword") (id "F:263817")) "else") "\n    {\n      this_one = 0, the_other = 1;\n      clear_buffer_p = 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:263896")) "/* ") (span (|@| (class "comment") (id "F:263899")) "We need a fresh one in case the current echo buffer equals\n         the one containing the last displayed echo area message.  ") (span (|@| (class "comment-delimiter") (id "F:264018")) "*/") "\n      " (span (|@| (class "keyword") (id "F:264027")) "if") " (" (span (|@| (class "negation-char") (id "F:264031")) "!") "NILP (echo_area_buffer[this_one])\n          && EQ (echo_area_buffer[this_one], echo_area_buffer[the_other]))\n        echo_area_buffer[this_one] = Qnil;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:264179")) "/* ") (span (|@| (class "comment") (id "F:264182")) "Choose a suitable buffer from echo_buffer[] is we don't\n     have one.  ") (span (|@| (class "comment-delimiter") (id "F:264254")) "*/") "\n  " (span (|@| (class "keyword") (id "F:264259")) "if") " (NILP (echo_area_buffer[this_one]))\n    {\n      echo_area_buffer[this_one]\n        = (EQ (echo_area_buffer[the_other], echo_buffer[this_one])\n           ? echo_buffer[the_other]\n           : echo_buffer[this_one]);\n      clear_buffer_p = 1;\n    }\n\n  buffer = echo_area_buffer[this_one];\n\n  " (span (|@| (class "comment-delimiter") (id "F:264531")) "/* ") (span (|@| (class "comment") (id "F:264534")) "Don't get confused by reusing the buffer used for echoing\n     for a different purpose.  ") (span (|@| (class "comment-delimiter") (id "F:264623")) "*/") "\n  " (span (|@| (class "keyword") (id "F:264628")) "if") " (echo_kboard == " (span (|@| (class "constant") (id "F:264647")) "NULL") " && EQ (buffer, echo_message_buffer))\n    cancel_echoing ();\n\n  record_unwind_protect (unwind_with_echo_area_buffer,\n                         with_echo_area_buffer_unwind_data (w));\n\n  " (span (|@| (class "comment-delimiter") (id "F:264815")) "/* ") (span (|@| (class "comment") (id "F:264818")) "Make the echo area buffer current.  Note that for display\n     purposes, it is not necessary that the displayed window's buffer\n     == current_buffer, except for text property lookup.  So, let's\n     only set that buffer temporarily here without doing a full\n     Fset_window_buffer.  We must also change w->pointm, though,\n     because otherwise an assertions in unshow_buffer fails, and Emacs\n     aborts.  ") (span (|@| (class "comment-delimiter") (id "F:265228")) "*/") "\n  set_buffer_internal_1 (XBUFFER (buffer));\n  " (span (|@| (class "keyword") (id "F:265277")) "if") " (w)\n    {\n      w->buffer = buffer;\n      set_marker_both (w->pointm, buffer, BEG, BEG_BYTE);\n    }\n\n  current_buffer->undo_list = Qt;\n  current_buffer->read_only = Qnil;\n  specbind (Qinhibit_read_only, Qt);\n  specbind (Qinhibit_modification_hooks, Qt);\n\n  " (span (|@| (class "keyword") (id "F:265537")) "if") " (clear_buffer_p && Z > BEG)\n    del_range (BEG, Z);\n\n  xassert (BEGV >= BEG);\n  xassert (ZV <= Z && ZV >= BEGV);\n\n  rc = fn (a1, a2, a3, a4);\n\n  xassert (BEGV >= BEG);\n  xassert (ZV <= Z && ZV >= BEGV);\n\n  unbind_to (count, Qnil);\n  " (span (|@| (class "keyword") (id "F:265773")) "return") " rc;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:265788")) "/* ") (span (|@| (class "comment") (id "F:265791")) "Save state that should be preserved around the call to the function\n   FN called in with_echo_area_buffer.  ") (span (|@| (class "comment-delimiter") (id "F:265899")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:265903")) "static") " " (span (|@| (class "type") (id "F:265910")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:265922")) "with_echo_area_buffer_unwind_data") " (w)\n     " (span (|@| (class "keyword") (id "F:265965")) "struct") " " (span (|@| (class "type") (id "F:265972")) "window") " *" (span (|@| (class "variable-name") (id "F:265980")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:265987")) "int") " " (span (|@| (class "variable-name") (id "F:265991")) "i") " = 0;\n  " (span (|@| (class "type") (id "F:266000")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:266012")) "vector") ", " (span (|@| (class "variable-name") (id "F:266020")) "tmp") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:266028")) "/* ") (span (|@| (class "comment") (id "F:266031")) "Reduce consing by keeping one vector in\n     Vwith_echo_area_save_vector.  ") (span (|@| (class "comment-delimiter") (id "F:266106")) "*/") "\n  vector = Vwith_echo_area_save_vector;\n  Vwith_echo_area_save_vector = Qnil;\n\n  " (span (|@| (class "keyword") (id "F:266190")) "if") " (NILP (vector))\n    vector = Fmake_vector (make_number (7), Qnil);\n\n  XSETBUFFER (tmp, current_buffer); ASET (vector, i, tmp); ++i;\n  ASET (vector, i, Vdeactivate_mark); ++i;\n  ASET (vector, i, make_number (windows_or_buffers_changed)); ++i;\n\n  " (span (|@| (class "keyword") (id "F:266438")) "if") " (w)\n    {\n      XSETWINDOW (tmp, w); ASET (vector, i, tmp); ++i;\n      ASET (vector, i, w->buffer); ++i;\n      ASET (vector, i, make_number (XMARKER (w->pointm)->charpos)); ++i;\n      ASET (vector, i, make_number (XMARKER (w->pointm)->bytepos)); ++i;\n    }\n  " (span (|@| (class "keyword") (id "F:266700")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:266717")) "int") " " (span (|@| (class "variable-name") (id "F:266721")) "end") " = i + 4;\n      " (span (|@| (class "keyword") (id "F:266740")) "for") " (; i < end; ++i)\n        ASET (vector, i, Qnil);\n    }\n\n  xassert (i == ASIZE (vector));\n  " (span (|@| (class "keyword") (id "F:266828")) "return") " vector;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:266847")) "/* ") (span (|@| (class "comment") (id "F:266850")) "Restore global state from VECTOR which was created by\n   with_echo_area_buffer_unwind_data.  ") (span (|@| (class "comment-delimiter") (id "F:266943")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:266947")) "static") " " (span (|@| (class "type") (id "F:266954")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:266966")) "unwind_with_echo_area_buffer") " (vector)\n     " (span (|@| (class "type") (id "F:267009")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:267021")) "vector") ";\n{\n  set_buffer_internal_1 (XBUFFER (AREF (vector, 0)));\n  Vdeactivate_mark = AREF (vector, 1);\n  windows_or_buffers_changed = XFASTINT (AREF (vector, 2));\n\n  " (span (|@| (class "keyword") (id "F:267187")) "if") " (WINDOWP (AREF (vector, 3)))\n    {\n      " (span (|@| (class "keyword") (id "F:267231")) "struct") " " (span (|@| (class "type") (id "F:267238")) "window") " *" (span (|@| (class "variable-name") (id "F:267246")) "w") ";\n      " (span (|@| (class "type") (id "F:267255")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:267267")) "buffer") ", " (span (|@| (class "variable-name") (id "F:267275")) "charpos") ", " (span (|@| (class "variable-name") (id "F:267284")) "bytepos") ";\n\n      w = XWINDOW (AREF (vector, 3));\n      buffer = AREF (vector, 4);\n      charpos = AREF (vector, 5);\n      bytepos = AREF (vector, 6);\n\n      w->buffer = buffer;\n      set_marker_both (w->pointm, buffer,\n                       XFASTINT (charpos), XFASTINT (bytepos));\n    }\n\n  Vwith_echo_area_save_vector = vector;\n  " (span (|@| (class "keyword") (id "F:267601")) "return") " Qnil;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:267618")) "/* ") (span (|@| (class "comment") (id "F:267621")) "Set up the echo area for use by print functions.  MULTIBYTE_P\n   non-zero means we will print multibyte.  ") (span (|@| (class "comment-delimiter") (id "F:267727")) "*/") "\n\n" (span (|@| (class "type") (id "F:267731")) "void") "\n" (span (|@| (class "function-name") (id "F:267736")) "setup_echo_area_for_printing") " (multibyte_p)\n     " (span (|@| (class "type") (id "F:267784")) "int") " " (span (|@| (class "variable-name") (id "F:267788")) "multibyte_p") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:267805")) "/* ") (span (|@| (class "comment") (id "F:267808")) "If we can't find an echo area any more, exit.  ") (span (|@| (class "comment-delimiter") (id "F:267855")) "*/") "\n  " (span (|@| (class "keyword") (id "F:267860")) "if") " (" (span (|@| (class "negation-char") (id "F:267864")) "!") " FRAME_LIVE_P (XFRAME (selected_frame)))\n    Fkill_emacs (Qnil);\n\n  ensure_echo_area_buffers ();\n\n  " (span (|@| (class "keyword") (id "F:267965")) "if") " (" (span (|@| (class "negation-char") (id "F:267969")) "!") "message_buf_print)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:268001")) "/* ") (span (|@| (class "comment") (id "F:268004")) "A message has been output since the last time we printed.\n         Choose a fresh echo area buffer.  ") (span (|@| (class "comment-delimiter") (id "F:268098")) "*/") "\n      " (span (|@| (class "keyword") (id "F:268107")) "if") " (EQ (echo_area_buffer[1], echo_buffer[0]))\n        echo_area_buffer[0] = echo_buffer[1];\n      " (span (|@| (class "keyword") (id "F:268198")) "else") "\n        echo_area_buffer[0] = echo_buffer[0];\n\n      " (span (|@| (class "comment-delimiter") (id "F:268249")) "/* ") (span (|@| (class "comment") (id "F:268252")) "Switch to that buffer and clear it.  ") (span (|@| (class "comment-delimiter") (id "F:268289")) "*/") "\n      set_buffer_internal (XBUFFER (echo_area_buffer[0]));\n      current_buffer->truncate_lines = Qnil;\n\n      " (span (|@| (class "keyword") (id "F:268403")) "if") " (Z > BEG)\n        {\n          " (span (|@| (class "type") (id "F:268422")) "int") " " (span (|@| (class "variable-name") (id "F:268426")) "count") " = SPECPDL_INDEX ();\n          specbind (Qinhibit_read_only, Qt);\n          " (span (|@| (class "comment-delimiter") (id "F:268493")) "/* ") (span (|@| (class "comment") (id "F:268496")) "Note that undo recording is always disabled.  ") (span (|@| (class "comment-delimiter") (id "F:268542")) "*/") "\n          del_range (BEG, Z);\n          unbind_to (count, Qnil);\n        }\n      TEMP_SET_PT_BOTH (BEG, BEG_BYTE);\n\n      " (span (|@| (class "comment-delimiter") (id "F:268646")) "/* ") (span (|@| (class "comment") (id "F:268649")) "Set up the buffer for the multibyteness we need.  ") (span (|@| (class "comment-delimiter") (id "F:268699")) "*/") "\n      " (span (|@| (class "keyword") (id "F:268708")) "if") " (multibyte_p\n          != " (span (|@| (class "negation-char") (id "F:268730")) "!") "NILP (current_buffer->enable_multibyte_characters))\n        Fset_buffer_multibyte (multibyte_p ? Qt : Qnil);\n\n      " (span (|@| (class "comment-delimiter") (id "F:268840")) "/* ") (span (|@| (class "comment") (id "F:268843")) "Raise the frame containing the echo area.  ") (span (|@| (class "comment-delimiter") (id "F:268886")) "*/") "\n      " (span (|@| (class "keyword") (id "F:268895")) "if") " (minibuffer_auto_raise)\n        {\n          " (span (|@| (class "keyword") (id "F:268928")) "struct") " " (span (|@| (class "type") (id "F:268935")) "frame") " *" (span (|@| (class "variable-name") (id "F:268942")) "sf") " = SELECTED_FRAME ();\n          " (span (|@| (class "type") (id "F:268969")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:268981")) "mini_window") ";\n          mini_window = FRAME_MINIBUF_WINDOW (sf);\n          Fraise_frame  (WINDOW_FRAME (XWINDOW (mini_window)));\n        }\n\n      message_log_maybe_newline ();\n      message_buf_print = 1;\n    }\n  " (span (|@| (class "keyword") (id "F:269172")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:269189")) "if") " (NILP (echo_area_buffer[0]))\n        {\n          " (span (|@| (class "keyword") (id "F:269227")) "if") " (EQ (echo_area_buffer[1], echo_buffer[0]))\n            echo_area_buffer[0] = echo_buffer[1];\n          " (span (|@| (class "keyword") (id "F:269319")) "else") "\n            echo_area_buffer[0] = echo_buffer[0];\n        }\n\n      " (span (|@| (class "keyword") (id "F:269377")) "if") " (current_buffer != XBUFFER (echo_area_buffer[0]))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:269436")) "/* ") (span (|@| (class "comment") (id "F:269439")) "Someone switched buffers between print requests.  ") (span (|@| (class "comment-delimiter") (id "F:269489")) "*/") "\n          set_buffer_internal (XBUFFER (echo_area_buffer[0]));\n          current_buffer->truncate_lines = Qnil;\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:269603")) "/* ") (span (|@| (class "comment") (id "F:269606")) "Display an echo area message in window W.  Value is non-zero if W's\n   height is changed.  If display_last_displayed_message_p is\n   non-zero, display the message that was last displayed, otherwise\n   display the current message.  ") (span (|@| (class "comment-delimiter") (id "F:269837")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:269841")) "static") " " (span (|@| (class "type") (id "F:269848")) "int") "\n" (span (|@| (class "function-name") (id "F:269852")) "display_echo_area") " (w)\n     " (span (|@| (class "keyword") (id "F:269879")) "struct") " " (span (|@| (class "type") (id "F:269886")) "window") " *" (span (|@| (class "variable-name") (id "F:269894")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:269901")) "int") " " (span (|@| (class "variable-name") (id "F:269905")) "i") ", " (span (|@| (class "variable-name") (id "F:269908")) "no_message_p") ", " (span (|@| (class "variable-name") (id "F:269922")) "window_height_changed_p") ", " (span (|@| (class "variable-name") (id "F:269947")) "count") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:269957")) "/* ") (span (|@| (class "comment") (id "F:269960")) "Temporarily disable garbage collections while displaying the echo\n     area.  This is done because a GC can print a message itself.\n     That message would modify the echo area buffer's contents while a\n     redisplay of the buffer is going on, and seriously confuse\n     redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:270244")) "*/") "\n  count = inhibit_garbage_collection ();\n\n  " (span (|@| (class "comment-delimiter") (id "F:270291")) "/* ") (span (|@| (class "comment") (id "F:270294")) "If there is no message, we must call display_echo_area_1\n     nevertheless because it resizes the window.  But we will have to\n     reset the echo_area_buffer in question to nil at the end because\n     with_echo_area_buffer will sets it to an empty buffer.  ") (span (|@| (class "comment-delimiter") (id "F:270552")) "*/") "\n  i = display_last_displayed_message_p ? 1 : 0;\n  no_message_p = NILP (echo_area_buffer[i]);\n\n  window_height_changed_p\n    = with_echo_area_buffer (w, display_last_displayed_message_p,\n                             display_echo_area_1,\n                             (" (span (|@| (class "type") (id "F:270779")) "EMACS_INT") ") w, Qnil, 0, 0);\n\n  " (span (|@| (class "keyword") (id "F:270809")) "if") " (no_message_p)\n    echo_area_buffer[i] = Qnil;\n\n  unbind_to (count, Qnil);\n  " (span (|@| (class "keyword") (id "F:270889")) "return") " window_height_changed_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:270925")) "/* ") (span (|@| (class "comment") (id "F:270928")) "Helper for display_echo_area.  Display the current buffer which\n   contains the current echo area message in window W, a mini-window,\n   a pointer to which is passed in A1.  A2..A4 are currently not used.\n   Change the height of W so that all of the message is displayed.\n   Value is non-zero if height of W was changed.  ") (span (|@| (class "comment-delimiter") (id "F:271250")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:271254")) "static") " " (span (|@| (class "type") (id "F:271261")) "int") "\n" (span (|@| (class "function-name") (id "F:271265")) "display_echo_area_1") " (a1, a2, a3, a4)\n     " (span (|@| (class "type") (id "F:271307")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:271317")) "a1") ";\n     " (span (|@| (class "type") (id "F:271326")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:271338")) "a2") ";\n     " (span (|@| (class "type") (id "F:271347")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:271357")) "a3") ", " (span (|@| (class "variable-name") (id "F:271361")) "a4") ";\n{\n  " (span (|@| (class "keyword") (id "F:271369")) "struct") " " (span (|@| (class "type") (id "F:271376")) "window") " *" (span (|@| (class "variable-name") (id "F:271384")) "w") " = (" (span (|@| (class "keyword") (id "F:271389")) "struct") " " (span (|@| (class "type") (id "F:271396")) "window") " *) a1;\n  " (span (|@| (class "type") (id "F:271412")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:271424")) "window") ";\n  " (span (|@| (class "keyword") (id "F:271434")) "struct") " " (span (|@| (class "type") (id "F:271441")) "text_pos") " " (span (|@| (class "variable-name") (id "F:271450")) "start") ";\n  " (span (|@| (class "type") (id "F:271459")) "int") " " (span (|@| (class "variable-name") (id "F:271463")) "window_height_changed_p") " = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:271495")) "/* ") (span (|@| (class "comment") (id "F:271498")) "Do this before displaying, so that we have a large enough glyph\n     matrix for the display.  If we can't get enough space for the\n     whole text, display the last N lines.  That works by setting w->start.  ") (span (|@| (class "comment-delimiter") (id "F:271706")) "*/") "\n  window_height_changed_p = resize_mini_window (w, 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:271767")) "/* ") (span (|@| (class "comment") (id "F:271770")) "Use the starting position chosen by resize_mini_window.  ") (span (|@| (class "comment-delimiter") (id "F:271827")) "*/") "\n  SET_TEXT_POS_FROM_MARKER (start, w->start);\n\n  " (span (|@| (class "comment-delimiter") (id "F:271879")) "/* ") (span (|@| (class "comment") (id "F:271882")) "Display.  ") (span (|@| (class "comment-delimiter") (id "F:271892")) "*/") "\n  clear_glyph_matrix (w->desired_matrix);\n  XSETWINDOW (window, w);\n  try_window (window, start, 0);\n\n  " (span (|@| (class "keyword") (id "F:271999")) "return") " window_height_changed_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:272035")) "/* ") (span (|@| (class "comment") (id "F:272038")) "Resize the echo area window to exactly the size needed for the\n   currently displayed message, if there is one.  If a mini-buffer\n   is active, don't shrink it.  ") (span (|@| (class "comment-delimiter") (id "F:272200")) "*/") "\n\n" (span (|@| (class "type") (id "F:272204")) "void") "\n" (span (|@| (class "function-name") (id "F:272209")) "resize_echo_area_exactly") " ()\n{\n  " (span (|@| (class "keyword") (id "F:272241")) "if") " (BUFFERP (echo_area_buffer[0])\n      && WINDOWP (echo_area_window))\n    {\n      " (span (|@| (class "keyword") (id "F:272324")) "struct") " " (span (|@| (class "type") (id "F:272331")) "window") " *" (span (|@| (class "variable-name") (id "F:272339")) "w") " = XWINDOW (echo_area_window);\n      " (span (|@| (class "type") (id "F:272377")) "int") " " (span (|@| (class "variable-name") (id "F:272381")) "resized_p") ";\n      " (span (|@| (class "type") (id "F:272398")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:272410")) "resize_exactly") ";\n\n      " (span (|@| (class "keyword") (id "F:272433")) "if") " (minibuf_level == 0)\n        resize_exactly = Qt;\n      " (span (|@| (class "keyword") (id "F:272485")) "else") "\n        resize_exactly = Qnil;\n\n      resized_p = with_echo_area_buffer (w, 0, resize_mini_window_1,\n                                         (" (span (|@| (class "type") (id "F:272591")) "EMACS_INT") ") w, resize_exactly, 0, 0);\n      " (span (|@| (class "keyword") (id "F:272634")) "if") " (resized_p)\n        {\n          ++windows_or_buffers_changed;\n          ++update_mode_lines;\n          redisplay_internal (0);\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:272749")) "/* ") (span (|@| (class "comment") (id "F:272752")) "Callback function for with_echo_area_buffer, when used from\n   resize_echo_area_exactly.  A1 contains a pointer to the window to\n   resize, EXACTLY non-nil means resize the mini-window exactly to the\n   size of the text displayed.  A3 and A4 are not used.  Value is what\n   resize_mini_window returns.  ") (span (|@| (class "comment-delimiter") (id "F:273055")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:273059")) "static") " " (span (|@| (class "type") (id "F:273066")) "int") "\n" (span (|@| (class "function-name") (id "F:273070")) "resize_mini_window_1") " (a1, exactly, a3, a4)\n     " (span (|@| (class "type") (id "F:273118")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:273128")) "a1") ";\n     " (span (|@| (class "type") (id "F:273137")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:273149")) "exactly") ";\n     " (span (|@| (class "type") (id "F:273163")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:273173")) "a3") ", " (span (|@| (class "variable-name") (id "F:273177")) "a4") ";\n{\n  " (span (|@| (class "keyword") (id "F:273185")) "return") " resize_mini_window ((" (span (|@| (class "keyword") (id "F:273213")) "struct") " " (span (|@| (class "type") (id "F:273220")) "window") " *) a1, " (span (|@| (class "negation-char") (id "F:273234")) "!") "NILP (exactly));\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:273256")) "/* ") (span (|@| (class "comment") (id "F:273259")) "Resize mini-window W to fit the size of its contents.  EXACT_P\n   means size the window exactly to the size needed.  Otherwise, it's\n   only enlarged until W's buffer is empty.\n\n   Set W->start to the right place to begin display.  If the whole\n   contents fit, start at the beginning.  Otherwise, start so as\n   to make the end of the contents appear.  This is particularly\n   important for y-or-n-p, but seems desirable generally.\n\n   Value is non-zero if the window height has been changed.  ") (span (|@| (class "comment-delimiter") (id "F:273754")) "*/") "\n\n" (span (|@| (class "type") (id "F:273758")) "int") "\n" (span (|@| (class "function-name") (id "F:273762")) "resize_mini_window") " (w, exact_p)\n     " (span (|@| (class "keyword") (id "F:273799")) "struct") " " (span (|@| (class "type") (id "F:273806")) "window") " *" (span (|@| (class "variable-name") (id "F:273814")) "w") ";\n     " (span (|@| (class "type") (id "F:273822")) "int") " " (span (|@| (class "variable-name") (id "F:273826")) "exact_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:273839")) "struct") " " (span (|@| (class "type") (id "F:273846")) "frame") " *" (span (|@| (class "variable-name") (id "F:273853")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:273878")) "int") " " (span (|@| (class "variable-name") (id "F:273882")) "window_height_changed_p") " = 0;\n\n  xassert (MINI_WINDOW_P (w));\n\n  " (span (|@| (class "comment-delimiter") (id "F:273946")) "/* ") (span (|@| (class "comment") (id "F:273949")) "By default, start display at the beginning.  ") (span (|@| (class "comment-delimiter") (id "F:273994")) "*/") "\n  set_marker_both (w->start, w->buffer,\n                   BUF_BEGV (XBUFFER (w->buffer)),\n                   BUF_BEGV_BYTE (XBUFFER (w->buffer)));\n\n  " (span (|@| (class "comment-delimiter") (id "F:274120")) "/* ") (span (|@| (class "comment") (id "F:274123")) "Don't resize windows while redisplaying a window; it would\n     confuse redisplay functions when the size of the window they are\n     displaying changes from under them.  Such a resizing can happen,\n     for instance, when which-func prints a long message while\n     we are running fontification-functions.  We're running these\n     functions with safe_call which binds inhibit-redisplay to t.  ") (span (|@| (class "comment-delimiter") (id "F:274518")) "*/") "\n  " (span (|@| (class "keyword") (id "F:274523")) "if") " (" (span (|@| (class "negation-char") (id "F:274527")) "!") "NILP (Vinhibit_redisplay))\n    " (span (|@| (class "keyword") (id "F:274559")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:274572")) "/* ") (span (|@| (class "comment") (id "F:274575")) "Nil means don't try to resize.  ") (span (|@| (class "comment-delimiter") (id "F:274607")) "*/") "\n  " (span (|@| (class "keyword") (id "F:274612")) "if") " (NILP (Vresize_mini_windows)\n      || (FRAME_X_P (f) && FRAME_X_OUTPUT (f) == " (span (|@| (class "constant") (id "F:274693")) "NULL") "))\n    " (span (|@| (class "keyword") (id "F:274704")) "return") " 0;\n\n  " (span (|@| (class "keyword") (id "F:274717")) "if") " (" (span (|@| (class "negation-char") (id "F:274721")) "!") "FRAME_MINIBUF_ONLY_P (f))\n    {\n      " (span (|@| (class "keyword") (id "F:274760")) "struct") " " (span (|@| (class "type") (id "F:274767")) "it") " " (span (|@| (class "variable-name") (id "F:274770")) "it") ";\n      " (span (|@| (class "keyword") (id "F:274780")) "struct") " " (span (|@| (class "type") (id "F:274787")) "window") " *" (span (|@| (class "variable-name") (id "F:274795")) "root") " = XWINDOW (FRAME_ROOT_WINDOW (f));\n      " (span (|@| (class "type") (id "F:274841")) "int") " " (span (|@| (class "variable-name") (id "F:274845")) "total_height") " = WINDOW_TOTAL_LINES (root) + WINDOW_TOTAL_LINES (w);\n      " (span (|@| (class "type") (id "F:274918")) "int") " " (span (|@| (class "variable-name") (id "F:274922")) "height") ", " (span (|@| (class "variable-name") (id "F:274930")) "max_height") ";\n      " (span (|@| (class "type") (id "F:274948")) "int") " " (span (|@| (class "variable-name") (id "F:274952")) "unit") " = FRAME_LINE_HEIGHT (f);\n      " (span (|@| (class "keyword") (id "F:274988")) "struct") " " (span (|@| (class "type") (id "F:274995")) "text_pos") " " (span (|@| (class "variable-name") (id "F:275004")) "start") ";\n      " (span (|@| (class "keyword") (id "F:275017")) "struct") " " (span (|@| (class "type") (id "F:275024")) "buffer") " *" (span (|@| (class "variable-name") (id "F:275032")) "old_current_buffer") " = " (span (|@| (class "constant") (id "F:275053")) "NULL") ";\n\n      " (span (|@| (class "keyword") (id "F:275066")) "if") " (current_buffer != XBUFFER (w->buffer))\n        {\n          old_current_buffer = current_buffer;\n          set_buffer_internal (XBUFFER (w->buffer));\n        }\n\n      init_iterator (&it, w, BEGV, BEGV_BYTE, " (span (|@| (class "constant") (id "F:275248")) "NULL") ", DEFAULT_FACE_ID);\n\n      " (span (|@| (class "comment-delimiter") (id "F:275279")) "/* ") (span (|@| (class "comment") (id "F:275282")) "Compute the max. number of lines specified by the user.  ") (span (|@| (class "comment-delimiter") (id "F:275339")) "*/") "\n      " (span (|@| (class "keyword") (id "F:275348")) "if") " (FLOATP (Vmax_mini_window_height))\n        max_height = XFLOATINT (Vmax_mini_window_height) * FRAME_LINES (f);\n      " (span (|@| (class "keyword") (id "F:275461")) "else") " " (span (|@| (class "keyword") (id "F:275466")) "if") " (INTEGERP (Vmax_mini_window_height))\n        max_height = XINT (Vmax_mini_window_height);\n      " (span (|@| (class "keyword") (id "F:275558")) "else") "\n        max_height = total_height / 4;\n\n      " (span (|@| (class "comment-delimiter") (id "F:275602")) "/* ") (span (|@| (class "comment") (id "F:275605")) "Correct that max. height if it's bogus.  ") (span (|@| (class "comment-delimiter") (id "F:275646")) "*/") "\n      max_height = max (1, max_height);\n      max_height = min (total_height, max_height);\n\n      " (span (|@| (class "comment-delimiter") (id "F:275747")) "/* ") (span (|@| (class "comment") (id "F:275750")) "Find out the height of the text in the window.  ") (span (|@| (class "comment-delimiter") (id "F:275798")) "*/") "\n      " (span (|@| (class "keyword") (id "F:275807")) "if") " (it.line_wrap == TRUNCATE)\n        height = 1;\n      " (span (|@| (class "keyword") (id "F:275856")) "else") "\n        {\n          last_height = 0;\n          move_it_to (&it, ZV, -1, -1, -1, MOVE_TO_POS);\n          " (span (|@| (class "keyword") (id "F:275937")) "if") " (it.max_ascent == 0 && it.max_descent == 0)\n            height = it.current_y + last_height;\n          " (span (|@| (class "keyword") (id "F:276029")) "else") "\n            height = it.current_y + it.max_ascent + it.max_descent;\n          height -= min (it.extra_line_spacing, it.max_extra_line_spacing);\n          height = (height + unit - 1) / unit;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:276214")) "/* ") (span (|@| (class "comment") (id "F:276217")) "Compute a suitable window start.  ") (span (|@| (class "comment-delimiter") (id "F:276251")) "*/") "\n      " (span (|@| (class "keyword") (id "F:276260")) "if") " (height > max_height)\n        {\n          height = max_height;\n          init_iterator (&it, w, ZV, ZV_BYTE, " (span (|@| (class "constant") (id "F:276351")) "NULL") ", DEFAULT_FACE_ID);\n          move_it_vertically_backward (&it, (height - 1) * unit);\n          start = it.current.pos;\n        }\n      " (span (|@| (class "keyword") (id "F:276470")) "else") "\n        SET_TEXT_POS (start, BEGV, BEGV_BYTE);\n      SET_MARKER_FROM_TEXT_POS (w->start, start);\n\n      " (span (|@| (class "keyword") (id "F:276572")) "if") " (EQ (Vresize_mini_windows, Qgrow_only))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:276621")) "/* ") (span (|@| (class "comment") (id "F:276624")) "Let it grow only, until we display an empty message, in which\n             case the window shrinks again.  ") (span (|@| (class "comment-delimiter") (id "F:276724")) "*/") "\n          " (span (|@| (class "keyword") (id "F:276730")) "if") " (height > WINDOW_TOTAL_LINES (w))\n            {\n              " (span (|@| (class "type") (id "F:276781")) "int") " " (span (|@| (class "variable-name") (id "F:276785")) "old_height") " = WINDOW_TOTAL_LINES (w);\n              freeze_window_starts (f, 1);\n              grow_mini_window (w, height - WINDOW_TOTAL_LINES (w));\n              window_height_changed_p = WINDOW_TOTAL_LINES (w) != old_height;\n            }\n          " (span (|@| (class "keyword") (id "F:277001")) "else") " " (span (|@| (class "keyword") (id "F:277006")) "if") " (height < WINDOW_TOTAL_LINES (w)\n                   && (exact_p || BEGV == ZV))\n            {\n              " (span (|@| (class "type") (id "F:277089")) "int") " " (span (|@| (class "variable-name") (id "F:277093")) "old_height") " = WINDOW_TOTAL_LINES (w);\n              freeze_window_starts (f, 0);\n              shrink_mini_window (w);\n              window_height_changed_p = WINDOW_TOTAL_LINES (w) != old_height;\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:277284")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:277295")) "/* ") (span (|@| (class "comment") (id "F:277298")) "Always resize to exact size needed.  ") (span (|@| (class "comment-delimiter") (id "F:277335")) "*/") "\n          " (span (|@| (class "keyword") (id "F:277341")) "if") " (height > WINDOW_TOTAL_LINES (w))\n            {\n              " (span (|@| (class "type") (id "F:277392")) "int") " " (span (|@| (class "variable-name") (id "F:277396")) "old_height") " = WINDOW_TOTAL_LINES (w);\n              freeze_window_starts (f, 1);\n              grow_mini_window (w, height - WINDOW_TOTAL_LINES (w));\n              window_height_changed_p = WINDOW_TOTAL_LINES (w) != old_height;\n            }\n          " (span (|@| (class "keyword") (id "F:277612")) "else") " " (span (|@| (class "keyword") (id "F:277617")) "if") " (height < WINDOW_TOTAL_LINES (w))\n            {\n              " (span (|@| (class "type") (id "F:277668")) "int") " " (span (|@| (class "variable-name") (id "F:277672")) "old_height") " = WINDOW_TOTAL_LINES (w);\n              freeze_window_starts (f, 0);\n              shrink_mini_window (w);\n\n              " (span (|@| (class "keyword") (id "F:277784")) "if") " (height)\n                {\n                  freeze_window_starts (f, 1);\n                  grow_mini_window (w, height - WINDOW_TOTAL_LINES (w));\n                }\n\n              window_height_changed_p = WINDOW_TOTAL_LINES (w) != old_height;\n            }\n        }\n\n      " (span (|@| (class "keyword") (id "F:277985")) "if") " (old_current_buffer)\n        set_buffer_internal (old_current_buffer);\n    }\n\n  " (span (|@| (class "keyword") (id "F:278061")) "return") " window_height_changed_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:278097")) "/* ") (span (|@| (class "comment") (id "F:278100")) "Value is the current message, a string, or nil if there is no\n   current message.  ") (span (|@| (class "comment-delimiter") (id "F:278183")) "*/") "\n\n" (span (|@| (class "type") (id "F:278187")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:278199")) "current_message") " ()\n{\n  " (span (|@| (class "type") (id "F:278222")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:278234")) "msg") ";\n\n  " (span (|@| (class "keyword") (id "F:278242")) "if") " (" (span (|@| (class "negation-char") (id "F:278246")) "!") "BUFFERP (echo_area_buffer[0]))\n    msg = Qnil;\n  " (span (|@| (class "keyword") (id "F:278296")) "else") "\n    {\n      with_echo_area_buffer (0, 0, current_message_1,\n                             (" (span (|@| (class "type") (id "F:278370")) "EMACS_INT") ") &msg, Qnil, 0, 0);\n      " (span (|@| (class "keyword") (id "F:278406")) "if") " (NILP (msg))\n        echo_area_buffer[0] = Qnil;\n    }\n\n  " (span (|@| (class "keyword") (id "F:278460")) "return") " msg;\n}\n\n\n" (span (|@| (class "keyword") (id "F:278476")) "static") " " (span (|@| (class "type") (id "F:278483")) "int") "\n" (span (|@| (class "function-name") (id "F:278487")) "current_message_1") " (a1, a2, a3, a4)\n     " (span (|@| (class "type") (id "F:278527")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:278537")) "a1") ";\n     " (span (|@| (class "type") (id "F:278546")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:278558")) "a2") ";\n     " (span (|@| (class "type") (id "F:278567")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:278577")) "a3") ", " (span (|@| (class "variable-name") (id "F:278581")) "a4") ";\n{\n  " (span (|@| (class "type") (id "F:278589")) "Lisp_Object") " *" (span (|@| (class "variable-name") (id "F:278602")) "msg") " = (" (span (|@| (class "type") (id "F:278609")) "Lisp_Object") " *) a1;\n\n  " (span (|@| (class "keyword") (id "F:278631")) "if") " (Z > BEG)\n    *msg = make_buffer_string (BEG, Z, 1);\n  " (span (|@| (class "keyword") (id "F:278689")) "else") "\n    *msg = Qnil;\n  " (span (|@| (class "keyword") (id "F:278713")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:278727")) "/* ") (span (|@| (class "comment") (id "F:278730")) "Push the current message on Vmessage_stack for later restauration\n   by restore_message.  Value is non-zero if the current message isn't\n   empty.  This is a relatively infrequent operation, so it's not\n   worth optimizing.  ") (span (|@| (class "comment-delimiter") (id "F:278955")) "*/") "\n\n" (span (|@| (class "type") (id "F:278959")) "int") "\n" (span (|@| (class "function-name") (id "F:278963")) "push_message") " ()\n{\n  " (span (|@| (class "type") (id "F:278983")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:278995")) "msg") ";\n  msg = current_message ();\n  Vmessage_stack = Fcons (msg, Vmessage_stack);\n  " (span (|@| (class "keyword") (id "F:279078")) "return") " STRINGP (msg);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:279104")) "/* ") (span (|@| (class "comment") (id "F:279107")) "Restore message display from the top of Vmessage_stack.  ") (span (|@| (class "comment-delimiter") (id "F:279164")) "*/") "\n\n" (span (|@| (class "type") (id "F:279168")) "void") "\n" (span (|@| (class "function-name") (id "F:279173")) "restore_message") " ()\n{\n  " (span (|@| (class "type") (id "F:279196")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:279208")) "msg") ";\n\n  xassert (CONSP (Vmessage_stack));\n  msg = XCAR (Vmessage_stack);\n  " (span (|@| (class "keyword") (id "F:279283")) "if") " (STRINGP (msg))\n    message3_nolog (msg, SBYTES (msg), STRING_MULTIBYTE (msg));\n  " (span (|@| (class "keyword") (id "F:279368")) "else") "\n    message3_nolog (msg, 0, 0);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:279409")) "/* ") (span (|@| (class "comment") (id "F:279412")) "Handler for record_unwind_protect calling pop_message.  ") (span (|@| (class "comment-delimiter") (id "F:279468")) "*/") "\n\n" (span (|@| (class "type") (id "F:279472")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:279484")) "pop_message_unwind") " (dummy)\n     " (span (|@| (class "type") (id "F:279516")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:279528")) "dummy") ";\n{\n  pop_message ();\n  " (span (|@| (class "keyword") (id "F:279557")) "return") " Qnil;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:279573")) "/* ") (span (|@| (class "comment") (id "F:279576")) "Pop the top-most entry off Vmessage_stack.  ") (span (|@| (class "comment-delimiter") (id "F:279620")) "*/") "\n\n" (span (|@| (class "type") (id "F:279624")) "void") "\n" (span (|@| (class "function-name") (id "F:279629")) "pop_message") " ()\n{\n  xassert (CONSP (Vmessage_stack));\n  Vmessage_stack = XCDR (Vmessage_stack);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:279728")) "/* ") (span (|@| (class "comment") (id "F:279731")) "Check that Vmessage_stack is nil.  Called from emacs.c when Emacs\n   exits.  If the stack is not empty, we have a missing pop_message\n   somewhere.  ") (span (|@| (class "comment-delimiter") (id "F:279880")) "*/") "\n\n" (span (|@| (class "type") (id "F:279884")) "void") "\n" (span (|@| (class "function-name") (id "F:279889")) "check_message_stack") " ()\n{\n  " (span (|@| (class "keyword") (id "F:279916")) "if") " (" (span (|@| (class "negation-char") (id "F:279920")) "!") "NILP (Vmessage_stack))\n    abort ();\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:279962")) "/* ") (span (|@| (class "comment") (id "F:279965")) "Truncate to NCHARS what will be displayed in the echo area the next\n   time we display it---but don't redisplay it now.  ") (span (|@| (class "comment-delimiter") (id "F:280086")) "*/") "\n\n" (span (|@| (class "type") (id "F:280090")) "void") "\n" (span (|@| (class "function-name") (id "F:280095")) "truncate_echo_area") " (nchars)\n     " (span (|@| (class "type") (id "F:280128")) "int") " " (span (|@| (class "variable-name") (id "F:280132")) "nchars") ";\n{\n  " (span (|@| (class "keyword") (id "F:280144")) "if") " (nchars == 0)\n    echo_area_buffer[0] = Qnil;\n  " (span (|@| (class "comment-delimiter") (id "F:280195")) "/* ") (span (|@| (class "comment") (id "F:280198")) "A null message buffer means that the frame hasn't really been\n     initialized yet.  Error messages get reported properly by\n     cmd_error, so this must be just an informative message; toss it.  ") (span (|@| (class "comment-delimiter") (id "F:280394")) "*/") "\n  " (span (|@| (class "keyword") (id "F:280399")) "else") " " (span (|@| (class "keyword") (id "F:280404")) "if") " (" (span (|@| (class "negation-char") (id "F:280408")) "!") "noninteractive\n           && INTERACTIVE\n           && " (span (|@| (class "negation-char") (id "F:280450")) "!") "NILP (echo_area_buffer[0]))\n    {\n      " (span (|@| (class "keyword") (id "F:280491")) "struct") " " (span (|@| (class "type") (id "F:280498")) "frame") " *" (span (|@| (class "variable-name") (id "F:280505")) "sf") " = SELECTED_FRAME ();\n      " (span (|@| (class "keyword") (id "F:280535")) "if") " (FRAME_MESSAGE_BUF (sf))\n        with_echo_area_buffer (0, 0, truncate_message_1, nchars, Qnil, 0, 0);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:280644")) "/* ") (span (|@| (class "comment") (id "F:280647")) "Helper function for truncate_echo_area.  Truncate the current\n   message to at most NCHARS characters.  ") (span (|@| (class "comment-delimiter") (id "F:280751")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:280755")) "static") " " (span (|@| (class "type") (id "F:280762")) "int") "\n" (span (|@| (class "function-name") (id "F:280766")) "truncate_message_1") " (nchars, a2, a3, a4)\n     " (span (|@| (class "type") (id "F:280811")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:280821")) "nchars") ";\n     " (span (|@| (class "type") (id "F:280834")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:280846")) "a2") ";\n     " (span (|@| (class "type") (id "F:280855")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:280865")) "a3") ", " (span (|@| (class "variable-name") (id "F:280869")) "a4") ";\n{\n  " (span (|@| (class "keyword") (id "F:280877")) "if") " (BEG + nchars < Z)\n    del_range (BEG + nchars, Z);\n  " (span (|@| (class "keyword") (id "F:280934")) "if") " (Z == BEG)\n    echo_area_buffer[0] = Qnil;\n  " (span (|@| (class "keyword") (id "F:280982")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:280996")) "/* ") (span (|@| (class "comment") (id "F:280999")) "Set the current message to a substring of S or STRING.\n\n   If STRING is a Lisp string, set the message to the first NBYTES\n   bytes from STRING.  NBYTES zero means use the whole string.  If\n   STRING is multibyte, the message will be displayed multibyte.\n\n   If S is not null, set the message to the first LEN bytes of S.  LEN\n   zero means use the whole string.  MULTIBYTE_P non-zero means S is\n   multibyte.  Display the message multibyte in that case.\n\n   Doesn't GC, as with_echo_area_buffer binds Qinhibit_modification_hooks\n   to t before calling set_message_1 (which calls insert).\n  ") (span (|@| (class "comment-delimiter") (id "F:281590")) "*/") "\n\n" (span (|@| (class "type") (id "F:281594")) "void") "\n" (span (|@| (class "function-name") (id "F:281599")) "set_message") " (s, string, nbytes, multibyte_p)\n     " (span (|@| (class "keyword") (id "F:281649")) "const") " " (span (|@| (class "type") (id "F:281655")) "char") " *" (span (|@| (class "variable-name") (id "F:281661")) "s") ";\n     " (span (|@| (class "type") (id "F:281669")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:281681")) "string") ";\n     " (span (|@| (class "type") (id "F:281694")) "int") " " (span (|@| (class "variable-name") (id "F:281698")) "nbytes") ", " (span (|@| (class "variable-name") (id "F:281706")) "multibyte_p") ";\n{\n  message_enable_multibyte\n    = ((s && multibyte_p)\n       || (STRINGP (string) && STRING_MULTIBYTE (string)));\n\n  with_echo_area_buffer (0, -1, set_message_1,\n                         (" (span (|@| (class "type") (id "F:281887")) "EMACS_INT") ") s, string, nbytes, multibyte_p);\n  message_buf_print = 0;\n  help_echo_showing_p = 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:281987")) "/* ") (span (|@| (class "comment") (id "F:281990")) "Helper function for set_message.  Arguments have the same meaning\n   as there, with A1 corresponding to S and A2 corresponding to STRING\n   This function is called with the echo area buffer being\n   current.  ") (span (|@| (class "comment-delimiter") (id "F:282199")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:282203")) "static") " " (span (|@| (class "type") (id "F:282210")) "int") "\n" (span (|@| (class "function-name") (id "F:282214")) "set_message_1") " (a1, a2, nbytes, multibyte_p)\n     " (span (|@| (class "type") (id "F:282263")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:282273")) "a1") ";\n     " (span (|@| (class "type") (id "F:282282")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:282294")) "a2") ";\n     " (span (|@| (class "type") (id "F:282303")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:282313")) "nbytes") ", " (span (|@| (class "variable-name") (id "F:282321")) "multibyte_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:282338")) "const") " " (span (|@| (class "type") (id "F:282344")) "char") " *" (span (|@| (class "variable-name") (id "F:282350")) "s") " = (" (span (|@| (class "keyword") (id "F:282355")) "const") " " (span (|@| (class "type") (id "F:282361")) "char") " *) a1;\n  " (span (|@| (class "type") (id "F:282375")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:282387")) "string") " = a2;\n\n  " (span (|@| (class "comment-delimiter") (id "F:282403")) "/* ") (span (|@| (class "comment") (id "F:282406")) "Change multibyteness of the echo buffer appropriately.  ") (span (|@| (class "comment-delimiter") (id "F:282462")) "*/") "\n  " (span (|@| (class "keyword") (id "F:282467")) "if") " (message_enable_multibyte\n      != " (span (|@| (class "negation-char") (id "F:282505")) "!") "NILP (current_buffer->enable_multibyte_characters))\n    Fset_buffer_multibyte (message_enable_multibyte ? Qt : Qnil);\n\n  current_buffer->truncate_lines = message_truncate_lines ? Qt : Qnil;\n\n  " (span (|@| (class "comment-delimiter") (id "F:282699")) "/* ") (span (|@| (class "comment") (id "F:282702")) "Insert new message at BEG.  ") (span (|@| (class "comment-delimiter") (id "F:282730")) "*/") "\n  TEMP_SET_PT_BOTH (BEG, BEG_BYTE);\n\n  " (span (|@| (class "keyword") (id "F:282772")) "if") " (STRINGP (string))\n    {\n      " (span (|@| (class "type") (id "F:282806")) "int") " " (span (|@| (class "variable-name") (id "F:282810")) "nchars") ";\n\n      " (span (|@| (class "keyword") (id "F:282825")) "if") " (nbytes == 0)\n        nbytes = SBYTES (string);\n      nchars = string_byte_to_char (string, nbytes);\n\n      " (span (|@| (class "comment-delimiter") (id "F:282929")) "/* ") (span (|@| (class "comment") (id "F:282932")) "This function takes care of single/multibyte conversion.  We\n         just have to ensure that the echo area buffer has the right\n         setting of enable_multibyte_characters.  ") (span (|@| (class "comment-delimiter") (id "F:283112")) "*/") "\n      insert_from_string (string, 0, 0, nchars, nbytes, 1);\n    }\n  " (span (|@| (class "keyword") (id "F:283183")) "else") " " (span (|@| (class "keyword") (id "F:283188")) "if") " (s)\n    {\n      " (span (|@| (class "keyword") (id "F:283207")) "if") " (nbytes == 0)\n        nbytes = strlen (s);\n\n      " (span (|@| (class "keyword") (id "F:283253")) "if") " (multibyte_p && NILP (current_buffer->enable_multibyte_characters))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:283330")) "/* ") (span (|@| (class "comment") (id "F:283333")) "Convert from multi-byte to single-byte.  ") (span (|@| (class "comment-delimiter") (id "F:283374")) "*/") "\n          " (span (|@| (class "type") (id "F:283380")) "int") " " (span (|@| (class "variable-name") (id "F:283384")) "i") ", " (span (|@| (class "variable-name") (id "F:283387")) "c") ", " (span (|@| (class "variable-name") (id "F:283390")) "n") ";\n          " (span (|@| (class "type") (id "F:283396")) "unsigned") " " (span (|@| (class "type") (id "F:283405")) "char") " " (span (|@| (class "variable-name") (id "F:283410")) "work") "[1];\n\n          " (span (|@| (class "comment-delimiter") (id "F:283423")) "/* ") (span (|@| (class "comment") (id "F:283426")) "Convert a multibyte string to single-byte.  ") (span (|@| (class "comment-delimiter") (id "F:283470")) "*/") "\n          " (span (|@| (class "keyword") (id "F:283476")) "for") " (i = 0; i < nbytes; i += n)\n            {\n              c = string_char_and_length (s + i, &n);\n              work[0] = (ASCII_CHAR_P (c)\n                         ? c\n                         : multibyte_char_to_unibyte (c, Qnil));\n              insert_1_both (work, 1, 1, 1, 0, 0);\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:283709")) "else") " " (span (|@| (class "keyword") (id "F:283714")) "if") " (" (span (|@| (class "negation-char") (id "F:283718")) "!") "multibyte_p\n               && " (span (|@| (class "negation-char") (id "F:283742")) "!") "NILP (current_buffer->enable_multibyte_characters))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:283801")) "/* ") (span (|@| (class "comment") (id "F:283804")) "Convert from single-byte to multi-byte.  ") (span (|@| (class "comment-delimiter") (id "F:283845")) "*/") "\n          " (span (|@| (class "type") (id "F:283851")) "int") " " (span (|@| (class "variable-name") (id "F:283855")) "i") ", " (span (|@| (class "variable-name") (id "F:283858")) "c") ", " (span (|@| (class "variable-name") (id "F:283861")) "n") ";\n          " (span (|@| (class "keyword") (id "F:283867")) "const") " " (span (|@| (class "type") (id "F:283873")) "unsigned") " " (span (|@| (class "type") (id "F:283882")) "char") " *" (span (|@| (class "variable-name") (id "F:283888")) "msg") " = (" (span (|@| (class "keyword") (id "F:283895")) "const") " " (span (|@| (class "type") (id "F:283901")) "unsigned") " " (span (|@| (class "type") (id "F:283910")) "char") " *) s;\n          " (span (|@| (class "type") (id "F:283924")) "unsigned") " " (span (|@| (class "type") (id "F:283933")) "char") " " (span (|@| (class "variable-name") (id "F:283938")) "str") "[MAX_MULTIBYTE_LENGTH];\n\n          " (span (|@| (class "comment-delimiter") (id "F:283969")) "/* ") (span (|@| (class "comment") (id "F:283972")) "Convert a single-byte string to multibyte.  ") (span (|@| (class "comment-delimiter") (id "F:284016")) "*/") "\n          " (span (|@| (class "keyword") (id "F:284022")) "for") " (i = 0; i < nbytes; i++)\n            {\n              c = msg[i];\n              MAKE_CHAR_MULTIBYTE (c);\n              n = CHAR_STRING (c, str);\n              insert_1_both (str, 1, n, 1, 0, 0);\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:284201")) "else") "\n        insert_1 (s, nbytes, 1, 0, 0);\n    }\n\n  " (span (|@| (class "keyword") (id "F:284247")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:284261")) "/* ") (span (|@| (class "comment") (id "F:284264")) "Clear messages.  CURRENT_P non-zero means clear the current\n   message.  LAST_DISPLAYED_P non-zero means clear the message\n   last displayed.  ") (span (|@| (class "comment-delimiter") (id "F:284407")) "*/") "\n\n" (span (|@| (class "type") (id "F:284411")) "void") "\n" (span (|@| (class "function-name") (id "F:284416")) "clear_message") " (current_p, last_displayed_p)\n     " (span (|@| (class "type") (id "F:284465")) "int") " " (span (|@| (class "variable-name") (id "F:284469")) "current_p") ", " (span (|@| (class "variable-name") (id "F:284480")) "last_displayed_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:284502")) "if") " (current_p)\n    {\n      echo_area_buffer[0] = Qnil;\n      message_cleared_p = 1;\n    }\n\n  " (span (|@| (class "keyword") (id "F:284595")) "if") " (last_displayed_p)\n    echo_area_buffer[1] = Qnil;\n\n  message_buf_print = 0;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:284678")) "/* ") (span (|@| (class "comment") (id "F:284681")) "Clear garbaged frames.\n\n   This function is used where the old redisplay called\n   redraw_garbaged_frames which in turn called redraw_frame which in\n   turn called clear_frame.  The call to clear_frame was a source of\n   flickering.  I believe a clear_frame is not necessary.  It should\n   suffice in the new redisplay to invalidate all current matrices,\n   and ensure a complete redisplay of all windows.  ") (span (|@| (class "comment-delimiter") (id "F:285088")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:285092")) "static") " " (span (|@| (class "type") (id "F:285099")) "void") "\n" (span (|@| (class "function-name") (id "F:285104")) "clear_garbaged_frames") " ()\n{\n  " (span (|@| (class "keyword") (id "F:285133")) "if") " (frame_garbaged)\n    {\n      " (span (|@| (class "type") (id "F:285165")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:285177")) "tail") ", " (span (|@| (class "variable-name") (id "F:285183")) "frame") ";\n      " (span (|@| (class "type") (id "F:285196")) "int") " " (span (|@| (class "variable-name") (id "F:285200")) "changed_count") " = 0;\n\n      " (span (|@| (class "variable-name") (id "F:285226")) "FOR_EACH_FRAME") " (tail, " (span (|@| (class "type") (id "F:285248")) "frame") ")\n        {\n          " (span (|@| (class "keyword") (id "F:285261")) "struct") " " (span (|@| (class "type") (id "F:285268")) "frame") " *" (span (|@| (class "variable-name") (id "F:285275")) "f") " = XFRAME (frame);\n\n          " (span (|@| (class "keyword") (id "F:285299")) "if") " (FRAME_VISIBLE_P (f) && FRAME_GARBAGED_P (f))\n            {\n              " (span (|@| (class "keyword") (id "F:285362")) "if") " (f->resized_p)\n                {\n                  Fredraw_frame (frame);\n                  f->force_flush_display_p = 1;\n                }\n              clear_current_matrices (f);\n              changed_count++;\n              f->garbaged = 0;\n              f->resized_p = 0;\n            }\n        }\n\n      frame_garbaged = 0;\n      " (span (|@| (class "keyword") (id "F:285600")) "if") " (changed_count)\n        ++windows_or_buffers_changed;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:285660")) "/* ") (span (|@| (class "comment") (id "F:285663")) "Redisplay the echo area of the selected frame.  If UPDATE_FRAME_P\n   is non-zero update selected_frame.  Value is non-zero if the\n   mini-windows height has been changed.  ") (span (|@| (class "comment-delimiter") (id "F:285835")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:285839")) "static") " " (span (|@| (class "type") (id "F:285846")) "int") "\n" (span (|@| (class "function-name") (id "F:285850")) "echo_area_display") " (update_frame_p)\n     " (span (|@| (class "type") (id "F:285890")) "int") " " (span (|@| (class "variable-name") (id "F:285894")) "update_frame_p") ";\n{\n  " (span (|@| (class "type") (id "F:285914")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:285926")) "mini_window") ";\n  " (span (|@| (class "keyword") (id "F:285941")) "struct") " " (span (|@| (class "type") (id "F:285948")) "window") " *" (span (|@| (class "variable-name") (id "F:285956")) "w") ";\n  " (span (|@| (class "keyword") (id "F:285961")) "struct") " " (span (|@| (class "type") (id "F:285968")) "frame") " *" (span (|@| (class "variable-name") (id "F:285975")) "f") ";\n  " (span (|@| (class "type") (id "F:285980")) "int") " " (span (|@| (class "variable-name") (id "F:285984")) "window_height_changed_p") " = 0;\n  " (span (|@| (class "keyword") (id "F:286015")) "struct") " " (span (|@| (class "type") (id "F:286022")) "frame") " *" (span (|@| (class "variable-name") (id "F:286029")) "sf") " = SELECTED_FRAME ();\n\n  mini_window = FRAME_MINIBUF_WINDOW (sf);\n  w = XWINDOW (mini_window);\n  f = XFRAME (WINDOW_FRAME (w));\n\n  " (span (|@| (class "comment-delimiter") (id "F:286162")) "/* ") (span (|@| (class "comment") (id "F:286165")) "Don't display if frame is invisible or not yet initialized.  ") (span (|@| (class "comment-delimiter") (id "F:286226")) "*/") "\n  " (span (|@| (class "keyword") (id "F:286231")) "if") " (" (span (|@| (class "negation-char") (id "F:286235")) "!") "FRAME_VISIBLE_P (f) || " (span (|@| (class "negation-char") (id "F:286259")) "!") "f->glyphs_initialized_p)\n    " (span (|@| (class "keyword") (id "F:286289")) "return") " 0;\n\n" (span (|@| (class "preprocessor") (id "F:286300")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "comment-delimiter") (id "F:286328")) "/* ") (span (|@| (class "comment") (id "F:286331")) "When Emacs starts, selected_frame may be the initial terminal\n     frame.  If we let this through, a message would be displayed on\n     the terminal.  ") (span (|@| (class "comment-delimiter") (id "F:286482")) "*/") "\n  " (span (|@| (class "keyword") (id "F:286487")) "if") " (FRAME_INITIAL_P (XFRAME (selected_frame)))\n    " (span (|@| (class "keyword") (id "F:286538")) "return") " 0;\n" (span (|@| (class "preprocessor") (id "F:286548")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:286555")) "/* ") (span (|@| (class "comment") (id "F:286558")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:286577")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:286583")) "/* ") (span (|@| (class "comment") (id "F:286586")) "Redraw garbaged frames.  ") (span (|@| (class "comment-delimiter") (id "F:286611")) "*/") "\n  " (span (|@| (class "keyword") (id "F:286616")) "if") " (frame_garbaged)\n    clear_garbaged_frames ();\n\n  " (span (|@| (class "keyword") (id "F:286669")) "if") " (" (span (|@| (class "negation-char") (id "F:286673")) "!") "NILP (echo_area_buffer[0]) || minibuf_level == 0)\n    {\n      echo_area_window = mini_window;\n      window_height_changed_p = display_echo_area (w);\n      w->must_be_updated_p = 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:286862")) "/* ") (span (|@| (class "comment") (id "F:286865")) "Update the display, unless called from redisplay_internal.\n         Also don't update the screen during redisplay itself.  The\n         update will happen at the end of redisplay, and an update\n         here could cause confusion.  ") (span (|@| (class "comment-delimiter") (id "F:287076")) "*/") "\n      " (span (|@| (class "keyword") (id "F:287085")) "if") " (update_frame_p && " (span (|@| (class "negation-char") (id "F:287107")) "!") "redisplaying_p)\n        {\n          " (span (|@| (class "type") (id "F:287130")) "int") " " (span (|@| (class "variable-name") (id "F:287134")) "n") " = 0;\n\n          " (span (|@| (class "comment-delimiter") (id "F:287145")) "/* ") (span (|@| (class "comment") (id "F:287148")) "If the display update has been interrupted by pending\n             input, update mode lines in the frame.  Due to the\n             pending input, it might have been that redisplay hasn't\n             been called, so that mode lines above the echo area are\n             garbaged.  This looks odd, so we prevent it here.  ") (span (|@| (class "comment-delimiter") (id "F:287440")) "*/") "\n          " (span (|@| (class "keyword") (id "F:287446")) "if") " (" (span (|@| (class "negation-char") (id "F:287450")) "!") "display_completed)\n            n = redisplay_mode_lines (FRAME_ROOT_WINDOW (f), 0);\n\n          " (span (|@| (class "keyword") (id "F:287532")) "if") " (window_height_changed_p\n              " (span (|@| (class "comment-delimiter") (id "F:287567")) "/* ") (span (|@| (class "comment") (id "F:287570")) "Don't do this if Emacs is shutting down.  Redisplay\n                 needs to run hooks.  ") (span (|@| (class "comment-delimiter") (id "F:287653")) "*/") "\n              && " (span (|@| (class "negation-char") (id "F:287666")) "!") "NILP (Vrun_hooks))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:287700")) "/* ") (span (|@| (class "comment") (id "F:287703")) "Must update other windows.  Likewise as in other\n                 cases, don't let this update be interrupted by\n                 pending input.  ") (span (|@| (class "comment-delimiter") (id "F:287821")) "*/") "\n              " (span (|@| (class "type") (id "F:287831")) "int") " " (span (|@| (class "variable-name") (id "F:287835")) "count") " = SPECPDL_INDEX ();\n              specbind (Qredisplay_dont_pause, Qt);\n              windows_or_buffers_changed = 1;\n              redisplay_internal (0);\n              unbind_to (count, Qnil);\n            }\n          " (span (|@| (class "keyword") (id "F:288018")) "else") " " (span (|@| (class "keyword") (id "F:288023")) "if") " (FRAME_WINDOW_P (f) && n == 0)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:288071")) "/* ") (span (|@| (class "comment") (id "F:288074")) "Window configuration is the same as before.\n                 Can do with a display update of the echo area,\n                 unless we displayed some mode lines.  ") (span (|@| (class "comment-delimiter") (id "F:288209")) "*/") "\n              update_single_window (w, 1);\n              FRAME_RIF (f)->flush_display (f);\n            }\n          " (span (|@| (class "keyword") (id "F:288299")) "else") "\n            update_frame (f, 1, 1);\n\n          " (span (|@| (class "comment-delimiter") (id "F:288337")) "/* ") (span (|@| (class "comment") (id "F:288340")) "If cursor is in the echo area, make sure that the next\n             redisplay displays the minibuffer, so that the cursor will\n             be replaced with what the minibuffer wants.  ") (span (|@| (class "comment-delimiter") (id "F:288511")) "*/") "\n          " (span (|@| (class "keyword") (id "F:288517")) "if") " (cursor_in_echo_area)\n            ++windows_or_buffers_changed;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:288588")) "else") " " (span (|@| (class "keyword") (id "F:288593")) "if") " (" (span (|@| (class "negation-char") (id "F:288597")) "!") "EQ (mini_window, selected_window))\n    windows_or_buffers_changed++;\n\n  " (span (|@| (class "comment-delimiter") (id "F:288670")) "/* ") (span (|@| (class "comment") (id "F:288673")) "Last displayed message is now the current message.  ") (span (|@| (class "comment-delimiter") (id "F:288725")) "*/") "\n  echo_area_buffer[1] = echo_area_buffer[0];\n  " (span (|@| (class "comment-delimiter") (id "F:288775")) "/* ") (span (|@| (class "comment") (id "F:288778")) "Inform read_char that we're not echoing.  ") (span (|@| (class "comment-delimiter") (id "F:288820")) "*/") "\n  echo_message_buffer = Qnil;\n\n  " (span (|@| (class "comment-delimiter") (id "F:288856")) "/* ") (span (|@| (class "comment") (id "F:288859")) "Prevent redisplay optimization in redisplay_internal by resetting\n     this_line_start_pos.  This is done because the mini-buffer now\n     displays the message instead of its buffer text.  ") (span (|@| (class "comment-delimiter") (id "F:289048")) "*/") "\n  " (span (|@| (class "keyword") (id "F:289053")) "if") " (EQ (mini_window, selected_window))\n    CHARPOS (this_line_start_pos) = 0;\n\n  " (span (|@| (class "keyword") (id "F:289134")) "return") " window_height_changed_p;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:289172")) "/***********************************************************************") (span (|@| (class "comment") (id "F:289244")) "\n                     Mode Lines and Frame Titles\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:289351")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:289355")) "/* ") (span (|@| (class "comment") (id "F:289358")) "A buffer for constructing non-propertized mode-line strings and\n   frame titles in it; allocated from the heap in init_xdisp and\n   resized as needed in store_mode_line_noprop_char.  ") (span (|@| (class "comment-delimiter") (id "F:289541")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:289545")) "static") " " (span (|@| (class "type") (id "F:289552")) "char") " *" (span (|@| (class "variable-name") (id "F:289558")) "mode_line_noprop_buf") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:289581")) "/* ") (span (|@| (class "comment") (id "F:289584")) "The buffer's end, and a current output position in it.  ") (span (|@| (class "comment-delimiter") (id "F:289640")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:289644")) "static") " " (span (|@| (class "type") (id "F:289651")) "char") " *" (span (|@| (class "variable-name") (id "F:289657")) "mode_line_noprop_buf_end") ";\n" (span (|@| (class "keyword") (id "F:289683")) "static") " " (span (|@| (class "type") (id "F:289690")) "char") " *" (span (|@| (class "variable-name") (id "F:289696")) "mode_line_noprop_ptr") ";\n\n" (span (|@| (class "preprocessor") (id "F:289719")) "#define") " " (span (|@| (class "function-name") (id "F:289727")) "MODE_LINE_NOPROP_LEN") "(" (span (|@| (class "variable-name") (id "F:289748")) "start") ") \\\n  ((mode_line_noprop_ptr - mode_line_noprop_buf) - start)\n\n" (span (|@| (class "keyword") (id "F:289816")) "static") " " (span (|@| (class "keyword") (id "F:289823")) "enum") " {\n  " (span (|@| (class "variable-name") (id "F:289832")) "MODE_LINE_DISPLAY") " = 0,\n  " (span (|@| (class "variable-name") (id "F:289857")) "MODE_LINE_TITLE") ",\n  " (span (|@| (class "variable-name") (id "F:289876")) "MODE_LINE_NOPROP") ",\n  " (span (|@| (class "variable-name") (id "F:289896")) "MODE_LINE_STRING") "\n} " (span (|@| (class "variable-name") (id "F:289915")) "mode_line_target") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:289934")) "/* ") (span (|@| (class "comment") (id "F:289937")) "Alist that caches the results of :propertize.\n   Each element is (PROPERTIZED-STRING . PROPERTY-LIST).  ") (span (|@| (class "comment-delimiter") (id "F:290041")) "*/") "\n" (span (|@| (class "keyword") (id "F:290044")) "static") " " (span (|@| (class "type") (id "F:290051")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:290063")) "mode_line_proptrans_alist") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:290091")) "/* ") (span (|@| (class "comment") (id "F:290094")) "List of strings making up the mode-line.  ") (span (|@| (class "comment-delimiter") (id "F:290136")) "*/") "\n" (span (|@| (class "keyword") (id "F:290139")) "static") " " (span (|@| (class "type") (id "F:290146")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:290158")) "mode_line_string_list") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:290182")) "/* ") (span (|@| (class "comment") (id "F:290185")) "Base face property when building propertized mode line string.  ") (span (|@| (class "comment-delimiter") (id "F:290249")) "*/") "\n" (span (|@| (class "keyword") (id "F:290252")) "static") " " (span (|@| (class "type") (id "F:290259")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:290271")) "mode_line_string_face") ";\n" (span (|@| (class "keyword") (id "F:290294")) "static") " " (span (|@| (class "type") (id "F:290301")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:290313")) "mode_line_string_face_prop") ";\n\n\n" (span (|@| (class "comment-delimiter") (id "F:290343")) "/* ") (span (|@| (class "comment") (id "F:290346")) "Unwind data for mode line strings ") (span (|@| (class "comment-delimiter") (id "F:290380")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:290384")) "static") " " (span (|@| (class "type") (id "F:290391")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:290403")) "Vmode_line_unwind_vector") ";\n\n" (span (|@| (class "keyword") (id "F:290430")) "static") " " (span (|@| (class "type") (id "F:290437")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:290449")) "format_mode_line_unwind_data") " (" (span (|@| (class "keyword") (id "F:290479")) "struct") " " (span (|@| (class "type") (id "F:290486")) "buffer") " *" (span (|@| (class "variable-name") (id "F:290494")) "obuf") ",\n                              " (span (|@| (class "type") (id "F:290509")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:290521")) "owin") ",\n                              " (span (|@| (class "type") (id "F:290536")) "int") " " (span (|@| (class "variable-name") (id "F:290540")) "save_proptrans") ")\n{\n  " (span (|@| (class "type") (id "F:290560")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:290572")) "vector") ", " (span (|@| (class "variable-name") (id "F:290580")) "tmp") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:290588")) "/* ") (span (|@| (class "comment") (id "F:290591")) "Reduce consing by keeping one vector in\n     Vwith_echo_area_save_vector.  ") (span (|@| (class "comment-delimiter") (id "F:290666")) "*/") "\n  vector = Vmode_line_unwind_vector;\n  Vmode_line_unwind_vector = Qnil;\n\n  " (span (|@| (class "keyword") (id "F:290744")) "if") " (NILP (vector))\n    vector = Fmake_vector (make_number (8), Qnil);\n\n  ASET (vector, 0, make_number (mode_line_target));\n  ASET (vector, 1, make_number (MODE_LINE_NOPROP_LEN (0)));\n  ASET (vector, 2, mode_line_string_list);\n  ASET (vector, 3, save_proptrans ? mode_line_proptrans_alist : Qt);\n  ASET (vector, 4, mode_line_string_face);\n  ASET (vector, 5, mode_line_string_face_prop);\n\n  " (span (|@| (class "keyword") (id "F:291133")) "if") " (obuf)\n    XSETBUFFER (tmp, obuf);\n  " (span (|@| (class "keyword") (id "F:291173")) "else") "\n    tmp = Qnil;\n  ASET (vector, 6, tmp);\n  ASET (vector, 7, owin);\n\n  " (span (|@| (class "keyword") (id "F:291248")) "return") " vector;\n}\n\n" (span (|@| (class "keyword") (id "F:291266")) "static") " " (span (|@| (class "type") (id "F:291273")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:291285")) "unwind_format_mode_line") " (vector)\n     " (span (|@| (class "type") (id "F:291323")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:291335")) "vector") ";\n{\n  mode_line_target = XINT (AREF (vector, 0));\n  mode_line_noprop_ptr = mode_line_noprop_buf + XINT (AREF (vector, 1));\n  mode_line_string_list = AREF (vector, 2);\n  " (span (|@| (class "keyword") (id "F:291510")) "if") " (" (span (|@| (class "negation-char") (id "F:291514")) "!") " EQ (AREF (vector, 3), Qt))\n    mode_line_proptrans_alist = AREF (vector, 3);\n  mode_line_string_face = AREF (vector, 4);\n  mode_line_string_face_prop = AREF (vector, 5);\n\n  " (span (|@| (class "keyword") (id "F:291689")) "if") " (" (span (|@| (class "negation-char") (id "F:291693")) "!") "NILP (AREF (vector, 7)))\n    " (span (|@| (class "comment-delimiter") (id "F:291723")) "/* ") (span (|@| (class "comment") (id "F:291726")) "Select window before buffer, since it may change the buffer.  ") (span (|@| (class "comment-delimiter") (id "F:291788")) "*/") "\n    Fselect_window (AREF (vector, 7), Qt);\n\n  " (span (|@| (class "keyword") (id "F:291837")) "if") " (" (span (|@| (class "negation-char") (id "F:291841")) "!") "NILP (AREF (vector, 6)))\n    {\n      set_buffer_internal_1 (XBUFFER (AREF (vector, 6)));\n      ASET (vector, 6, Qnil);\n    }\n\n  Vmode_line_unwind_vector = vector;\n  " (span (|@| (class "keyword") (id "F:292007")) "return") " Qnil;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:292024")) "/* ") (span (|@| (class "comment") (id "F:292027")) "Store a single character C for the frame title in mode_line_noprop_buf.\n   Re-allocate mode_line_noprop_buf if necessary.  ") (span (|@| (class "comment-delimiter") (id "F:292150")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:292154")) "static") " " (span (|@| (class "type") (id "F:292161")) "void") "\n" (span (|@| (class "preprocessor") (id "F:292166")) "#ifdef") " PROTOTYPES\n" (span (|@| (class "function-name") (id "F:292184")) "store_mode_line_noprop_char") " (" (span (|@| (class "type") (id "F:292213")) "char") " " (span (|@| (class "variable-name") (id "F:292218")) "c") ")\n" (span (|@| (class "preprocessor") (id "F:292221")) "#else") "\nstore_mode_line_noprop_char (c)\n    " (span (|@| (class "type") (id "F:292263")) "char") " " (span (|@| (class "variable-name") (id "F:292268")) "c") ";\n" (span (|@| (class "preprocessor") (id "F:292271")) "#endif") "\n{\n  " (span (|@| (class "comment-delimiter") (id "F:292282")) "/* ") (span (|@| (class "comment") (id "F:292285")) "If output position has reached the end of the allocated buffer,\n     double the buffer's size.  ") (span (|@| (class "comment-delimiter") (id "F:292381")) "*/") "\n  " (span (|@| (class "keyword") (id "F:292386")) "if") " (mode_line_noprop_ptr == mode_line_noprop_buf_end)\n    {\n      " (span (|@| (class "type") (id "F:292452")) "int") " " (span (|@| (class "variable-name") (id "F:292456")) "len") " = MODE_LINE_NOPROP_LEN (0);\n      " (span (|@| (class "type") (id "F:292494")) "int") " " (span (|@| (class "variable-name") (id "F:292498")) "new_size") " = 2 * len * " (span (|@| (class "keyword") (id "F:292519")) "sizeof") " *mode_line_noprop_buf;\n      mode_line_noprop_buf = (" (span (|@| (class "type") (id "F:292579")) "char") " *) xrealloc (mode_line_noprop_buf, new_size);\n      mode_line_noprop_buf_end = mode_line_noprop_buf + new_size;\n      mode_line_noprop_ptr = mode_line_noprop_buf + len;\n    }\n\n  *mode_line_noprop_ptr++ = c;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:292795")) "/* ") (span (|@| (class "comment") (id "F:292798")) "Store part of a frame title in mode_line_noprop_buf, beginning at\n   mode_line_noprop_ptr.  STR is the string to store.  Do not copy\n   characters that yield more columns than PRECISION; PRECISION <= 0\n   means copy the whole string.  Pad with spaces until FIELD_WIDTH\n   number of characters have been copied; FIELD_WIDTH <= 0 means don't\n   pad.  Called from display_mode_element when it is used to build a\n   frame title.  ") (span (|@| (class "comment-delimiter") (id "F:293224")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:293228")) "static") " " (span (|@| (class "type") (id "F:293235")) "int") "\n" (span (|@| (class "function-name") (id "F:293239")) "store_mode_line_noprop") " (str, field_width, precision)\n     " (span (|@| (class "keyword") (id "F:293297")) "const") " " (span (|@| (class "type") (id "F:293303")) "unsigned") " " (span (|@| (class "type") (id "F:293312")) "char") " *" (span (|@| (class "variable-name") (id "F:293318")) "str") ";\n     " (span (|@| (class "type") (id "F:293328")) "int") " " (span (|@| (class "variable-name") (id "F:293332")) "field_width") ", " (span (|@| (class "variable-name") (id "F:293345")) "precision") ";\n{\n  " (span (|@| (class "type") (id "F:293360")) "int") " " (span (|@| (class "variable-name") (id "F:293364")) "n") " = 0;\n  " (span (|@| (class "type") (id "F:293373")) "int") " " (span (|@| (class "variable-name") (id "F:293377")) "dummy") ", " (span (|@| (class "variable-name") (id "F:293384")) "nbytes") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:293395")) "/* ") (span (|@| (class "comment") (id "F:293398")) "Copy at most PRECISION chars from STR.  ") (span (|@| (class "comment-delimiter") (id "F:293438")) "*/") "\n  nbytes = strlen (str);\n  n += c_string_width (str, nbytes, precision, &dummy, &nbytes);\n  " (span (|@| (class "keyword") (id "F:293533")) "while") " (nbytes--)\n    store_mode_line_noprop_char (*str++);\n\n  " (span (|@| (class "comment-delimiter") (id "F:293595")) "/* ") (span (|@| (class "comment") (id "F:293598")) "Fill up with spaces until FIELD_WIDTH reached.  ") (span (|@| (class "comment-delimiter") (id "F:293646")) "*/") "\n  " (span (|@| (class "keyword") (id "F:293651")) "while") " (field_width > 0\n         && n < field_width)\n    {\n      store_mode_line_noprop_char (" (span (|@| (class "string") (id "F:293737")) "' '") ");\n      ++n;\n    }\n\n  " (span (|@| (class "keyword") (id "F:293763")) "return") " n;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:293776")) "/***********************************************************************") (span (|@| (class "comment") (id "F:293848")) "\n                             Frame Titles\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:293941")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:293945")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "comment-delimiter") (id "F:293972")) "/* ") (span (|@| (class "comment") (id "F:293975")) "Set the title of FRAME, if it has changed.  The title format is\n   Vicon_title_format if FRAME is iconified, otherwise it is\n   frame_title_format.  ") (span (|@| (class "comment-delimiter") (id "F:294124")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:294128")) "static") " " (span (|@| (class "type") (id "F:294135")) "void") "\n" (span (|@| (class "function-name") (id "F:294140")) "x_consider_frame_title") " (" (span (|@| (class "type") (id "F:294164")) "frame") ")\n     " (span (|@| (class "type") (id "F:294176")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:294188")) "frame") ";\n{\n  " (span (|@| (class "keyword") (id "F:294199")) "struct") " " (span (|@| (class "type") (id "F:294206")) "frame") " *" (span (|@| (class "variable-name") (id "F:294213")) "f") " = XFRAME (frame);\n\n  " (span (|@| (class "keyword") (id "F:294236")) "if") " (FRAME_WINDOW_P (f)\n      || FRAME_MINIBUF_ONLY_P (f)\n      || f->explicit_name)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:294332")) "/* ") (span (|@| (class "comment") (id "F:294335")) "Do we have more than one visible frame on this X display?  ") (span (|@| (class "comment-delimiter") (id "F:294394")) "*/") "\n      " (span (|@| (class "type") (id "F:294403")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:294415")) "tail") ";\n      " (span (|@| (class "type") (id "F:294427")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:294439")) "fmt") ";\n      " (span (|@| (class "type") (id "F:294450")) "int") " " (span (|@| (class "variable-name") (id "F:294454")) "title_start") ";\n      " (span (|@| (class "type") (id "F:294473")) "char") " *" (span (|@| (class "variable-name") (id "F:294479")) "title") ";\n      " (span (|@| (class "type") (id "F:294492")) "int") " " (span (|@| (class "variable-name") (id "F:294496")) "len") ";\n      " (span (|@| (class "keyword") (id "F:294507")) "struct") " " (span (|@| (class "type") (id "F:294514")) "it") " " (span (|@| (class "variable-name") (id "F:294517")) "it") ";\n      " (span (|@| (class "type") (id "F:294527")) "int") " " (span (|@| (class "variable-name") (id "F:294531")) "count") " = SPECPDL_INDEX ();\n\n      " (span (|@| (class "keyword") (id "F:294564")) "for") " (tail = Vframe_list; CONSP (tail); tail = XCDR (tail))\n        {\n          " (span (|@| (class "type") (id "F:294629")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:294641")) "other_frame") " = XCAR (tail);\n          " (span (|@| (class "keyword") (id "F:294671")) "struct") " " (span (|@| (class "type") (id "F:294678")) "frame") " *" (span (|@| (class "variable-name") (id "F:294685")) "tf") " = XFRAME (other_frame);\n\n          " (span (|@| (class "keyword") (id "F:294716")) "if") " (tf != f\n              && FRAME_KBOARD (tf) == FRAME_KBOARD (f)\n              && " (span (|@| (class "negation-char") (id "F:294786")) "!") "FRAME_MINIBUF_ONLY_P (tf)\n              && " (span (|@| (class "negation-char") (id "F:294823")) "!") "EQ (other_frame, tip_frame)\n              && (FRAME_VISIBLE_P (tf) || FRAME_ICONIFIED_P (tf)))\n            " (span (|@| (class "keyword") (id "F:294917")) "break") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:294934")) "/* ") (span (|@| (class "comment") (id "F:294937")) "Set global variable indicating that multiple frames exist.  ") (span (|@| (class "comment-delimiter") (id "F:294997")) "*/") "\n      multiple_frames = CONSP (tail);\n\n      " (span (|@| (class "comment-delimiter") (id "F:295045")) "/* ") (span (|@| (class "comment") (id "F:295048")) "Switch to the buffer of selected window of the frame.  Set up\n         mode_line_target so that display_mode_element will output into\n         mode_line_noprop_buf; then display the title.  ") (span (|@| (class "comment-delimiter") (id "F:295224")) "*/") "\n      record_unwind_protect (unwind_format_mode_line,\n                             format_mode_line_unwind_data\n                                (current_buffer, selected_window, 0));\n\n      Fselect_window (f->selected_window, Qt);\n      set_buffer_internal_1 (XBUFFER (XWINDOW (f->selected_window)->buffer));\n      fmt = FRAME_ICONIFIED_P (f) ? Vicon_title_format : Vframe_title_format;\n\n      mode_line_target = MODE_LINE_TITLE;\n      title_start = MODE_LINE_NOPROP_LEN (0);\n      init_iterator (&it, XWINDOW (f->selected_window), -1, -1,\n                     " (span (|@| (class "constant") (id "F:295732")) "NULL") ", DEFAULT_FACE_ID);\n      display_mode_element (&it, 0, -1, -1, fmt, Qnil, 0);\n      len = MODE_LINE_NOPROP_LEN (title_start);\n      title = mode_line_noprop_buf + title_start;\n      unbind_to (count, Qnil);\n\n      " (span (|@| (class "comment-delimiter") (id "F:295951")) "/* ") (span (|@| (class "comment") (id "F:295954")) "Set the title only if it's changed.  This avoids consing in\n         the common case where it hasn't.  (If it turns out that we've\n         already wasted too much time by walking through the list with\n         display_mode_element, then we might need to optimize at a\n         higher level than this.)  ") (span (|@| (class "comment-delimiter") (id "F:296230")) "*/") "\n      " (span (|@| (class "keyword") (id "F:296239")) "if") " (" (span (|@| (class "negation-char") (id "F:296243")) "!") " STRINGP (f->name)\n          || SBYTES (f->name) != len\n          || bcmp (title, SDATA (f->name), len) != 0)\n        x_implicitly_set_name (f, make_string (title, len), Qnil);\n    }\n}\n\n" (span (|@| (class "preprocessor") (id "F:296409")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:296416")) "/* ") (span (|@| (class "comment") (id "F:296419")) "not HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:296442")) "*/") "\n\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:296450")) "/***********************************************************************") (span (|@| (class "comment") (id "F:296522")) "\n                              Menu Bars\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:296613")) "*/") "\n\n\n" (span (|@| (class "comment-delimiter") (id "F:296618")) "/* ") (span (|@| (class "comment") (id "F:296621")) "Prepare for redisplay by updating menu-bar item lists when\n   appropriate.  This can call eval.  ") (span (|@| (class "comment-delimiter") (id "F:296718")) "*/") "\n\n" (span (|@| (class "type") (id "F:296722")) "void") "\n" (span (|@| (class "function-name") (id "F:296727")) "prepare_menu_bars") " ()\n{\n  " (span (|@| (class "type") (id "F:296752")) "int") " " (span (|@| (class "variable-name") (id "F:296756")) "all_windows") ";\n  " (span (|@| (class "keyword") (id "F:296771")) "struct") " " (span (|@| (class "type") (id "F:296778")) "gcpro") " " (span (|@| (class "variable-name") (id "F:296784")) "gcpro1") ", " (span (|@| (class "variable-name") (id "F:296792")) "gcpro2") ";\n  " (span (|@| (class "keyword") (id "F:296802")) "struct") " " (span (|@| (class "type") (id "F:296809")) "frame") " *" (span (|@| (class "variable-name") (id "F:296816")) "f") ";\n  " (span (|@| (class "type") (id "F:296821")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:296833")) "tooltip_frame") ";\n\n" (span (|@| (class "preprocessor") (id "F:296849")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  tooltip_frame = tip_frame;\n" (span (|@| (class "preprocessor") (id "F:296904")) "#else") "\n  tooltip_frame = Qnil;\n" (span (|@| (class "preprocessor") (id "F:296934")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:296944")) "/* ") (span (|@| (class "comment") (id "F:296947")) "Update all frame titles based on their buffer names, etc.  We do\n     this before the menu bars so that the buffer-menu will show the\n     up-to-date frame titles.  ") (span (|@| (class "comment-delimiter") (id "F:297112")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:297115")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "keyword") (id "F:297143")) "if") " (windows_or_buffers_changed || update_mode_lines)\n    {\n      " (span (|@| (class "type") (id "F:297208")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:297220")) "tail") ", " (span (|@| (class "variable-name") (id "F:297226")) "frame") ";\n\n      " (span (|@| (class "variable-name") (id "F:297240")) "FOR_EACH_FRAME") " (tail, " (span (|@| (class "type") (id "F:297262")) "frame") ")\n        {\n          f = XFRAME (frame);\n          " (span (|@| (class "keyword") (id "F:297298")) "if") " (" (span (|@| (class "negation-char") (id "F:297302")) "!") "EQ (frame, tooltip_frame)\n              && (FRAME_VISIBLE_P (f) || FRAME_ICONIFIED_P (f)))\n            x_consider_frame_title (frame);\n        }\n    }\n" (span (|@| (class "preprocessor") (id "F:297433")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:297440")) "/* ") (span (|@| (class "comment") (id "F:297443")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:297462")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:297468")) "/* ") (span (|@| (class "comment") (id "F:297471")) "Update the menu bar item lists, if appropriate.  This has to be\n     done before any actual redisplay or generation of display lines.  ") (span (|@| (class "comment-delimiter") (id "F:297606")) "*/") "\n  all_windows = (update_mode_lines\n                 || buffer_shared > 1\n                 || windows_or_buffers_changed);\n  " (span (|@| (class "keyword") (id "F:297705")) "if") " (all_windows)\n    {\n      " (span (|@| (class "type") (id "F:297734")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:297746")) "tail") ", " (span (|@| (class "variable-name") (id "F:297752")) "frame") ";\n      " (span (|@| (class "type") (id "F:297765")) "int") " " (span (|@| (class "variable-name") (id "F:297769")) "count") " = SPECPDL_INDEX ();\n      " (span (|@| (class "comment-delimiter") (id "F:297801")) "/* ") (span (|@| (class "comment") (id "F:297804")) "1 means that update_menu_bar has run its hooks\n         so any further calls to update_menu_bar shouldn't do so again.  ") (span (|@| (class "comment-delimiter") (id "F:297917")) "*/") "\n      " (span (|@| (class "type") (id "F:297926")) "int") " " (span (|@| (class "variable-name") (id "F:297930")) "menu_bar_hooks_run") " = 0;\n\n      record_unwind_save_match_data ();\n\n      " (span (|@| (class "variable-name") (id "F:298002")) "FOR_EACH_FRAME") " (tail, " (span (|@| (class "type") (id "F:298024")) "frame") ")\n        {\n          f = XFRAME (frame);\n\n          " (span (|@| (class "comment-delimiter") (id "F:298061")) "/* ") (span (|@| (class "comment") (id "F:298064")) "Ignore tooltip frame.  ") (span (|@| (class "comment-delimiter") (id "F:298087")) "*/") "\n          " (span (|@| (class "keyword") (id "F:298093")) "if") " (EQ (frame, tooltip_frame))\n            " (span (|@| (class "keyword") (id "F:298129")) "continue") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:298143")) "/* ") (span (|@| (class "comment") (id "F:298146")) "If a window on this frame changed size, report that to\n             the user and clear the size-change flag.  ") (span (|@| (class "comment-delimiter") (id "F:298249")) "*/") "\n          " (span (|@| (class "keyword") (id "F:298255")) "if") " (FRAME_WINDOW_SIZES_CHANGED (f))\n            {\n              " (span (|@| (class "type") (id "F:298305")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:298317")) "functions") ";\n\n              " (span (|@| (class "comment-delimiter") (id "F:298336")) "/* ") (span (|@| (class "comment") (id "F:298339")) "Clear flag first in case we get an error below.  ") (span (|@| (class "comment-delimiter") (id "F:298388")) "*/") "\n              FRAME_WINDOW_SIZES_CHANGED (f) = 0;\n              functions = Vwindow_size_change_functions;\n              GCPRO2 (tail, functions);\n\n              " (span (|@| (class "keyword") (id "F:298525")) "while") " (CONSP (functions))\n                {\n                  " (span (|@| (class "keyword") (id "F:298559")) "if") " (" (span (|@| (class "negation-char") (id "F:298563")) "!") "EQ (XCAR (functions), Qt))\n                    call1 (XCAR (functions), frame);\n                  functions = XCDR (functions);\n                }\n              UNGCPRO;\n            }\n\n          GCPRO1 (tail);\n          menu_bar_hooks_run = update_menu_bar (f, 0, menu_bar_hooks_run);\n" (span (|@| (class "preprocessor") (id "F:298778")) "#ifdef") " HAVE_WINDOW_SYSTEM\n          update_tool_bar (f, 0);\n" (span (|@| (class "preprocessor") (id "F:298831")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:298838")) "#ifdef") " HAVE_NS\n          " (span (|@| (class "keyword") (id "F:298863")) "if") " (windows_or_buffers_changed\n              && FRAME_NS_P (f))\n            ns_set_doc_edited (f, Fbuffer_modified_p\n                               (XWINDOW (f->selected_window)->buffer));\n" (span (|@| (class "preprocessor") (id "F:299024")) "#endif") "\n          UNGCPRO;\n        }\n\n      unbind_to (count, Qnil);\n    }\n  " (span (|@| (class "keyword") (id "F:299086")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:299103")) "struct") " " (span (|@| (class "type") (id "F:299110")) "frame") " *" (span (|@| (class "variable-name") (id "F:299117")) "sf") " = SELECTED_FRAME ();\n      update_menu_bar (sf, 1, 0);\n" (span (|@| (class "preprocessor") (id "F:299175")) "#ifdef") " HAVE_WINDOW_SYSTEM\n      update_tool_bar (sf, 1);\n" (span (|@| (class "preprocessor") (id "F:299232")) "#endif") "\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:299248")) "/* ") (span (|@| (class "comment") (id "F:299251")) "Motif needs this.  See comment in xmenu.c.  Turn it off when\n     pending_menu_activation is not defined.  ") (span (|@| (class "comment-delimiter") (id "F:299358")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:299361")) "#ifdef") " USE_X_TOOLKIT\n  pending_menu_activation = 0;\n" (span (|@| (class "preprocessor") (id "F:299413")) "#endif") "\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:299424")) "/* ") (span (|@| (class "comment") (id "F:299427")) "Update the menu bar item list for frame F.  This has to be done\n   before we start to fill in any display lines, because it can call\n   eval.\n\n   If SAVE_MATCH_DATA is non-zero, we must save and restore it here.\n\n   If HOOKS_RUN is 1, that means a previous call to update_menu_bar\n   already ran the menu bar hooks for this redisplay, so there\n   is no need to run them again.  The return value is the\n   updated value of this flag, to pass to the next call.  ") (span (|@| (class "comment-delimiter") (id "F:299887")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:299891")) "static") " " (span (|@| (class "type") (id "F:299898")) "int") "\n" (span (|@| (class "function-name") (id "F:299902")) "update_menu_bar") " (f, save_match_data, hooks_run)\n     " (span (|@| (class "keyword") (id "F:299955")) "struct") " " (span (|@| (class "type") (id "F:299962")) "frame") " *" (span (|@| (class "variable-name") (id "F:299969")) "f") ";\n     " (span (|@| (class "type") (id "F:299977")) "int") " " (span (|@| (class "variable-name") (id "F:299981")) "save_match_data") ";\n     " (span (|@| (class "type") (id "F:300003")) "int") " " (span (|@| (class "variable-name") (id "F:300007")) "hooks_run") ";\n{\n  " (span (|@| (class "type") (id "F:300022")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:300034")) "window") ";\n  " (span (|@| (class "keyword") (id "F:300044")) "register") " " (span (|@| (class "keyword") (id "F:300053")) "struct") " " (span (|@| (class "type") (id "F:300060")) "window") " *" (span (|@| (class "variable-name") (id "F:300068")) "w") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:300074")) "/* ") (span (|@| (class "comment") (id "F:300077")) "If called recursively during a menu update, do nothing.  This can\n     happen when, for instance, an activate-menubar-hook causes a\n     redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:300226")) "*/") "\n  " (span (|@| (class "keyword") (id "F:300231")) "if") " (inhibit_menubar_update)\n    " (span (|@| (class "keyword") (id "F:300263")) "return") " hooks_run;\n\n  window = FRAME_SELECTED_WINDOW (f);\n  w = XWINDOW (window);\n\n  " (span (|@| (class "keyword") (id "F:300347")) "if") " (FRAME_WINDOW_P (f)\n      ?\n" (span (|@| (class "preprocessor") (id "F:300378")) "#if") " " (span (|@| (class "preprocessor") (id "F:300382")) "defined") " (USE_X_TOOLKIT) || " (span (|@| (class "preprocessor") (id "F:300409")) "defined") " (HAVE_NTGUI) \\\n    || " (span (|@| (class "preprocessor") (id "F:300439")) "defined") " (HAVE_NS) || " (span (|@| (class "preprocessor") (id "F:300460")) "defined") " (USE_GTK)\n      FRAME_EXTERNAL_MENU_BAR (f)\n" (span (|@| (class "preprocessor") (id "F:300512")) "#else") "\n      FRAME_MENU_BAR_LINES (f) > 0\n" (span (|@| (class "preprocessor") (id "F:300553")) "#endif") "\n      : FRAME_MENU_BAR_LINES (f) > 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:300610")) "/* ") (span (|@| (class "comment") (id "F:300613")) "If the user has switched buffers or windows, we need to\n         recompute to reflect the new bindings.  But we'll\n         recompute when update_mode_lines is set too; that means\n         that people can use force-mode-line-update to request\n         that the menu bar be recomputed.  The adverse effect on\n         the rest of the redisplay algorithm is about the same as\n         windows_or_buffers_changed anyway.  ") (span (|@| (class "comment-delimiter") (id "F:300990")) "*/") "\n      " (span (|@| (class "keyword") (id "F:300999")) "if") " (windows_or_buffers_changed\n          " (span (|@| (class "comment-delimiter") (id "F:301033")) "/* ") (span (|@| (class "comment") (id "F:301036")) "This used to test w->update_mode_line, but we believe\n             there is no need to recompute the menu in that case.  ") (span (|@| (class "comment-delimiter") (id "F:301150")) "*/") "\n          || update_mode_lines\n          || ((BUF_SAVE_MODIFF (XBUFFER (w->buffer))\n               < BUF_MODIFF (XBUFFER (w->buffer)))\n              != " (span (|@| (class "negation-char") (id "F:301277")) "!") "NILP (w->last_had_star))\n          || ((" (span (|@| (class "negation-char") (id "F:301311")) "!") "NILP (Vtransient_mark_mode)\n               && " (span (|@| (class "negation-char") (id "F:301351")) "!") "NILP (XBUFFER (w->buffer)->mark_active))\n              != " (span (|@| (class "negation-char") (id "F:301403")) "!") "NILP (w->region_showing)))\n        {\n          " (span (|@| (class "keyword") (id "F:301437")) "struct") " " (span (|@| (class "type") (id "F:301444")) "buffer") " *" (span (|@| (class "variable-name") (id "F:301452")) "prev") " = current_buffer;\n          " (span (|@| (class "type") (id "F:301478")) "int") " " (span (|@| (class "variable-name") (id "F:301482")) "count") " = SPECPDL_INDEX ();\n\n          specbind (Qinhibit_menubar_update, Qt);\n\n          set_buffer_internal_1 (XBUFFER (w->buffer));\n          " (span (|@| (class "keyword") (id "F:301604")) "if") " (save_match_data)\n            record_unwind_save_match_data ();\n          " (span (|@| (class "keyword") (id "F:301667")) "if") " (NILP (Voverriding_local_map_menu_flag))\n            {\n              specbind (Qoverriding_terminal_local_map, Qnil);\n              specbind (Qoverriding_local_map, Qnil);\n            }\n\n          " (span (|@| (class "keyword") (id "F:301832")) "if") " (" (span (|@| (class "negation-char") (id "F:301836")) "!") "hooks_run)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:301862")) "/* ") (span (|@| (class "comment") (id "F:301865")) "Run the Lucid hook.  ") (span (|@| (class "comment-delimiter") (id "F:301886")) "*/") "\n              safe_run_hooks (Qactivate_menubar_hook);\n\n              " (span (|@| (class "comment-delimiter") (id "F:301945")) "/* ") (span (|@| (class "comment") (id "F:301948")) "If it has changed current-menubar from previous value,\n                 really recompute the menu-bar from the value.  ") (span (|@| (class "comment-delimiter") (id "F:302053")) "*/") "\n              " (span (|@| (class "keyword") (id "F:302063")) "if") " (" (span (|@| (class "negation-char") (id "F:302067")) "!") " NILP (Vlucid_menu_bar_dirty_flag))\n                call0 (Qrecompute_lucid_menubar);\n\n              safe_run_hooks (Qmenu_bar_update_hook);\n\n              hooks_run = 1;\n            }\n\n          XSETFRAME (Vmenu_updating_frame, f);\n          FRAME_MENU_BAR_ITEMS (f) = menu_bar_items (FRAME_MENU_BAR_ITEMS (f));\n\n          " (span (|@| (class "comment-delimiter") (id "F:302336")) "/* ") (span (|@| (class "comment") (id "F:302339")) "Redisplay the menu bar in case we changed it.  ") (span (|@| (class "comment-delimiter") (id "F:302386")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:302389")) "#if") " " (span (|@| (class "preprocessor") (id "F:302393")) "defined") " (USE_X_TOOLKIT) || " (span (|@| (class "preprocessor") (id "F:302420")) "defined") " (HAVE_NTGUI) \\\n    || " (span (|@| (class "preprocessor") (id "F:302450")) "defined") " (HAVE_NS) || " (span (|@| (class "preprocessor") (id "F:302471")) "defined") " (USE_GTK)\n          " (span (|@| (class "keyword") (id "F:302492")) "if") " (FRAME_WINDOW_P (f))\n            {\n" (span (|@| (class "preprocessor") (id "F:302530")) "#if") " " (span (|@| (class "preprocessor") (id "F:302534")) "defined") " (HAVE_NS)\n              " (span (|@| (class "comment-delimiter") (id "F:302566")) "/* ") (span (|@| (class "comment") (id "F:302569")) "All frames on Mac OS share the same menubar.  So only\n                 the selected frame should be allowed to set it.  ") (span (|@| (class "comment-delimiter") (id "F:302689")) "*/") "\n              " (span (|@| (class "keyword") (id "F:302706")) "if") " (f == SELECTED_FRAME ())\n" (span (|@| (class "preprocessor") (id "F:302734")) "#endif") "\n                set_frame_menubar (f, 0, 0);\n            }\n          " (span (|@| (class "keyword") (id "F:302782")) "else") "\n            " (span (|@| (class "comment-delimiter") (id "F:302792")) "/* ") (span (|@| (class "comment") (id "F:302795")) "On a terminal screen, the menu bar is an ordinary screen\n               line, and this makes it get updated.  ") (span (|@| (class "comment-delimiter") (id "F:302898")) "*/") "\n            w->update_mode_line = Qt;\n" (span (|@| (class "preprocessor") (id "F:302932")) "#else") " " (span (|@| (class "comment-delimiter") (id "F:302938")) "/* ") (span (|@| (class "comment") (id "F:302941")) "! (USE_X_TOOLKIT || HAVE_NTGUI || HAVE_NS || USE_GTK) ") (span (|@| (class "comment-delimiter") (id "F:302995")) "*/") "\n          " (span (|@| (class "comment-delimiter") (id "F:303001")) "/* ") (span (|@| (class "comment") (id "F:303004")) "In the non-toolkit version, the menu bar is an ordinary screen\n             line, and this makes it get updated.  ") (span (|@| (class "comment-delimiter") (id "F:303111")) "*/") "\n          w->update_mode_line = Qt;\n" (span (|@| (class "preprocessor") (id "F:303143")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:303150")) "/* ") (span (|@| (class "comment") (id "F:303153")) "! (USE_X_TOOLKIT || HAVE_NTGUI || HAVE_NS || USE_GTK) ") (span (|@| (class "comment-delimiter") (id "F:303207")) "*/") "\n\n          unbind_to (count, Qnil);\n          set_buffer_internal_1 (prev);\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:303284")) "return") " hooks_run;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:303308")) "/***********************************************************************") (span (|@| (class "comment") (id "F:303380")) "\n                            Output Cursor\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:303473")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:303477")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "comment-delimiter") (id "F:303504")) "/* ") (span (|@| (class "comment") (id "F:303507")) "EXPORT:\n   Nominal cursor position -- where to draw output.\n   HPOS and VPOS are window relative glyph matrix coordinates.\n   X and Y are window relative pixel coordinates.  ") (span (|@| (class "comment-delimiter") (id "F:303681")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:303685")) "struct") " " (span (|@| (class "type") (id "F:303692")) "cursor_pos") " " (span (|@| (class "variable-name") (id "F:303703")) "output_cursor") ";\n\n\n" (span (|@| (class "comment-delimiter") (id "F:303720")) "/* ") (span (|@| (class "comment") (id "F:303723")) "EXPORT:\n   Set the global variable output_cursor to CURSOR.  All cursor\n   positions are relative to updated_window.  ") (span (|@| (class "comment-delimiter") (id "F:303841")) "*/") "\n\n" (span (|@| (class "type") (id "F:303845")) "void") "\n" (span (|@| (class "function-name") (id "F:303850")) "set_output_cursor") " (cursor)\n    " (span (|@| (class "keyword") (id "F:303881")) "struct") " " (span (|@| (class "type") (id "F:303888")) "cursor_pos") " *" (span (|@| (class "variable-name") (id "F:303900")) "cursor") ";\n{\n  output_cursor.hpos = cursor->hpos;\n  output_cursor.vpos = cursor->vpos;\n  output_cursor.x = cursor->x;\n  output_cursor.y = cursor->y;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:304050")) "/* ") (span (|@| (class "comment") (id "F:304053")) "EXPORT for RIF:\n   Set a nominal cursor position.\n\n   HPOS and VPOS are column/row positions in a window glyph matrix.  X\n   and Y are window text area relative pixel positions.\n\n   If this is done during an update, updated_window will contain the\n   window that is being updated and the position is the future output\n   cursor position for that window.  If updated_window is null, use\n   selected_window and display the cursor at the given position.  ") (span (|@| (class "comment-delimiter") (id "F:304505")) "*/") "\n\n" (span (|@| (class "type") (id "F:304509")) "void") "\n" (span (|@| (class "function-name") (id "F:304514")) "x_cursor_to") " (vpos, hpos, y, x)\n     " (span (|@| (class "type") (id "F:304550")) "int") " " (span (|@| (class "variable-name") (id "F:304554")) "vpos") ", " (span (|@| (class "variable-name") (id "F:304560")) "hpos") ", " (span (|@| (class "variable-name") (id "F:304566")) "y") ", " (span (|@| (class "variable-name") (id "F:304569")) "x") ";\n{\n  " (span (|@| (class "keyword") (id "F:304576")) "struct") " " (span (|@| (class "type") (id "F:304583")) "window") " *" (span (|@| (class "variable-name") (id "F:304591")) "w") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:304597")) "/* ") (span (|@| (class "comment") (id "F:304600")) "If updated_window is not set, work on selected_window.  ") (span (|@| (class "comment-delimiter") (id "F:304656")) "*/") "\n  " (span (|@| (class "keyword") (id "F:304661")) "if") " (updated_window)\n    w = updated_window;\n  " (span (|@| (class "keyword") (id "F:304707")) "else") "\n    w = XWINDOW (selected_window);\n\n  " (span (|@| (class "comment-delimiter") (id "F:304750")) "/* ") (span (|@| (class "comment") (id "F:304753")) "Set the output cursor.  ") (span (|@| (class "comment-delimiter") (id "F:304777")) "*/") "\n  output_cursor.hpos = hpos;\n  output_cursor.vpos = vpos;\n  output_cursor.x = x;\n  output_cursor.y = y;\n\n  " (span (|@| (class "comment-delimiter") (id "F:304887")) "/* ") (span (|@| (class "comment") (id "F:304890")) "If not called as part of an update, really display the cursor.\n     This will also set the cursor position of W.  ") (span (|@| (class "comment-delimiter") (id "F:305004")) "*/") "\n  " (span (|@| (class "keyword") (id "F:305009")) "if") " (updated_window == " (span (|@| (class "constant") (id "F:305031")) "NULL") ")\n    {\n      BLOCK_INPUT;\n      display_and_set_cursor (w, 1, hpos, vpos, x, y);\n      " (span (|@| (class "keyword") (id "F:305123")) "if") " (FRAME_RIF (SELECTED_FRAME ())->flush_display_optional)\n        FRAME_RIF (SELECTED_FRAME ())->flush_display_optional (SELECTED_FRAME ());\n      UNBLOCK_INPUT;\n    }\n}\n\n" (span (|@| (class "preprocessor") (id "F:305288")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:305295")) "/* ") (span (|@| (class "comment") (id "F:305298")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:305317")) "*/") "\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:305323")) "/***********************************************************************") (span (|@| (class "comment") (id "F:305395")) "\n                               Tool-bars\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:305487")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:305491")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "comment-delimiter") (id "F:305518")) "/* ") (span (|@| (class "comment") (id "F:305521")) "Where the mouse was last time we reported a mouse event.  ") (span (|@| (class "comment-delimiter") (id "F:305579")) "*/") "\n\n" (span (|@| (class "type") (id "F:305583")) "FRAME_PTR") " " (span (|@| (class "variable-name") (id "F:305593")) "last_mouse_frame") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:305612")) "/* ") (span (|@| (class "comment") (id "F:305615")) "Tool-bar item index of the item on which a mouse button was pressed\n   or -1.  ") (span (|@| (class "comment-delimiter") (id "F:305694")) "*/") "\n\n" (span (|@| (class "type") (id "F:305698")) "int") " " (span (|@| (class "variable-name") (id "F:305702")) "last_tool_bar_item") ";\n\n\n" (span (|@| (class "keyword") (id "F:305724")) "static") " " (span (|@| (class "type") (id "F:305731")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:305743")) "update_tool_bar_unwind") " (" (span (|@| (class "type") (id "F:305767")) "frame") ")\n     " (span (|@| (class "type") (id "F:305779")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:305791")) "frame") ";\n{\n  selected_frame = frame;\n  " (span (|@| (class "keyword") (id "F:305828")) "return") " Qnil;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:305844")) "/* ") (span (|@| (class "comment") (id "F:305847")) "Update the tool-bar item list for frame F.  This has to be done\n   before we start to fill in any display lines.  Called from\n   prepare_menu_bars.  If SAVE_MATCH_DATA is non-zero, we must save\n   and restore it here.  ") (span (|@| (class "comment-delimiter") (id "F:306066")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:306070")) "static") " " (span (|@| (class "type") (id "F:306077")) "void") "\n" (span (|@| (class "function-name") (id "F:306082")) "update_tool_bar") " (f, save_match_data)\n     " (span (|@| (class "keyword") (id "F:306124")) "struct") " " (span (|@| (class "type") (id "F:306131")) "frame") " *" (span (|@| (class "variable-name") (id "F:306138")) "f") ";\n     " (span (|@| (class "type") (id "F:306146")) "int") " " (span (|@| (class "variable-name") (id "F:306150")) "save_match_data") ";\n{\n" (span (|@| (class "preprocessor") (id "F:306169")) "#if") " " (span (|@| (class "preprocessor") (id "F:306173")) "defined") " (USE_GTK) || " (span (|@| (class "preprocessor") (id "F:306194")) "defined") " (HAVE_NS)\n  " (span (|@| (class "type") (id "F:306214")) "int") " " (span (|@| (class "variable-name") (id "F:306218")) "do_update") " = FRAME_EXTERNAL_TOOL_BAR (f);\n" (span (|@| (class "preprocessor") (id "F:306259")) "#else") "\n  " (span (|@| (class "type") (id "F:306267")) "int") " " (span (|@| (class "variable-name") (id "F:306271")) "do_update") " = WINDOWP (f->tool_bar_window)\n    && WINDOW_TOTAL_LINES (XWINDOW (f->tool_bar_window)) > 0;\n" (span (|@| (class "preprocessor") (id "F:306374")) "#endif") "\n\n  " (span (|@| (class "keyword") (id "F:306384")) "if") " (do_update)\n    {\n      " (span (|@| (class "type") (id "F:306411")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:306423")) "window") ";\n      " (span (|@| (class "keyword") (id "F:306437")) "struct") " " (span (|@| (class "type") (id "F:306444")) "window") " *" (span (|@| (class "variable-name") (id "F:306452")) "w") ";\n\n      window = FRAME_SELECTED_WINDOW (f);\n      w = XWINDOW (window);\n\n      " (span (|@| (class "comment-delimiter") (id "F:306533")) "/* ") (span (|@| (class "comment") (id "F:306536")) "If the user has switched buffers or windows, we need to\n         recompute to reflect the new bindings.  But we'll\n         recompute when update_mode_lines is set too; that means\n         that people can use force-mode-line-update to request\n         that the menu bar be recomputed.  The adverse effect on\n         the rest of the redisplay algorithm is about the same as\n         windows_or_buffers_changed anyway.  ") (span (|@| (class "comment-delimiter") (id "F:306913")) "*/") "\n      " (span (|@| (class "keyword") (id "F:306922")) "if") " (windows_or_buffers_changed\n          || " (span (|@| (class "negation-char") (id "F:306959")) "!") "NILP (w->update_mode_line)\n          || update_mode_lines\n          || ((BUF_SAVE_MODIFF (XBUFFER (w->buffer))\n               < BUF_MODIFF (XBUFFER (w->buffer)))\n              != " (span (|@| (class "negation-char") (id "F:307111")) "!") "NILP (w->last_had_star))\n          || ((" (span (|@| (class "negation-char") (id "F:307145")) "!") "NILP (Vtransient_mark_mode)\n               && " (span (|@| (class "negation-char") (id "F:307185")) "!") "NILP (XBUFFER (w->buffer)->mark_active))\n              != " (span (|@| (class "negation-char") (id "F:307237")) "!") "NILP (w->region_showing)))\n        {\n          " (span (|@| (class "keyword") (id "F:307271")) "struct") " " (span (|@| (class "type") (id "F:307278")) "buffer") " *" (span (|@| (class "variable-name") (id "F:307286")) "prev") " = current_buffer;\n          " (span (|@| (class "type") (id "F:307312")) "int") " " (span (|@| (class "variable-name") (id "F:307316")) "count") " = SPECPDL_INDEX ();\n          " (span (|@| (class "type") (id "F:307345")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:307357")) "frame") ", " (span (|@| (class "variable-name") (id "F:307364")) "new_tool_bar") ";\n          " (span (|@| (class "type") (id "F:307388")) "int") " " (span (|@| (class "variable-name") (id "F:307392")) "new_n_tool_bar") ";\n          " (span (|@| (class "keyword") (id "F:307411")) "struct") " " (span (|@| (class "type") (id "F:307418")) "gcpro") " " (span (|@| (class "variable-name") (id "F:307424")) "gcpro1") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:307436")) "/* ") (span (|@| (class "comment") (id "F:307439")) "Set current_buffer to the buffer of the selected\n             window of the frame, so that we get the right local\n             keymaps.  ") (span (|@| (class "comment-delimiter") (id "F:307562")) "*/") "\n          set_buffer_internal_1 (XBUFFER (w->buffer));\n\n          " (span (|@| (class "comment-delimiter") (id "F:307617")) "/* ") (span (|@| (class "comment") (id "F:307620")) "Save match data, if we must.  ") (span (|@| (class "comment-delimiter") (id "F:307650")) "*/") "\n          " (span (|@| (class "keyword") (id "F:307656")) "if") " (save_match_data)\n            record_unwind_save_match_data ();\n\n          " (span (|@| (class "comment-delimiter") (id "F:307720")) "/* ") (span (|@| (class "comment") (id "F:307723")) "Make sure that we don't accidentally use bogus keymaps.  ") (span (|@| (class "comment-delimiter") (id "F:307780")) "*/") "\n          " (span (|@| (class "keyword") (id "F:307786")) "if") " (NILP (Voverriding_local_map_menu_flag))\n            {\n              specbind (Qoverriding_terminal_local_map, Qnil);\n              specbind (Qoverriding_local_map, Qnil);\n            }\n\n          GCPRO1 (new_tool_bar);\n\n          " (span (|@| (class "comment-delimiter") (id "F:307978")) "/* ") (span (|@| (class "comment") (id "F:307981")) "We must temporarily set the selected frame to this frame\n             before calling tool_bar_items, because the calculation of\n             the tool-bar keymap uses the selected frame (see\n             `tool-bar-make-keymap' in tool-bar.el).  ") (span (|@| (class "comment-delimiter") (id "F:308204")) "*/") "\n          record_unwind_protect (update_tool_bar_unwind, selected_frame);\n          XSETFRAME (frame, f);\n          selected_frame = frame;\n\n          " (span (|@| (class "comment-delimiter") (id "F:308330")) "/* ") (span (|@| (class "comment") (id "F:308333")) "Build desired tool-bar items from keymaps.  ") (span (|@| (class "comment-delimiter") (id "F:308377")) "*/") "\n          new_tool_bar = tool_bar_items (Fcopy_sequence (f->tool_bar_items),\n                                         &new_n_tool_bar);\n\n          " (span (|@| (class "comment-delimiter") (id "F:308520")) "/* ") (span (|@| (class "comment") (id "F:308523")) "Redisplay the tool-bar if we changed it.  ") (span (|@| (class "comment-delimiter") (id "F:308565")) "*/") "\n          " (span (|@| (class "keyword") (id "F:308571")) "if") " (new_n_tool_bar != f->n_tool_bar_items\n              || NILP (Fequal (new_tool_bar, f->tool_bar_items)))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:308700")) "/* ") (span (|@| (class "comment") (id "F:308703")) "Redisplay that happens asynchronously due to an expose event\n                 may access f->tool_bar_items.  Make sure we update both\n                 variables within BLOCK_INPUT so no such event interrupts.  ") (span (|@| (class "comment-delimiter") (id "F:308913")) "*/") "\n              BLOCK_INPUT;\n              f->tool_bar_items = new_tool_bar;\n              f->n_tool_bar_items = new_n_tool_bar;\n              w->update_mode_line = Qt;\n              UNBLOCK_INPUT;\n            }\n\n          UNGCPRO;\n\n          unbind_to (count, Qnil);\n          set_buffer_internal_1 (prev);\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:309214")) "/* ") (span (|@| (class "comment") (id "F:309217")) "Set F->desired_tool_bar_string to a Lisp string representing frame\n   F's desired tool-bar contents.  F->tool_bar_items must have\n   been set up previously by calling prepare_menu_bars.  ") (span (|@| (class "comment-delimiter") (id "F:309404")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:309408")) "static") " " (span (|@| (class "type") (id "F:309415")) "void") "\n" (span (|@| (class "function-name") (id "F:309420")) "build_desired_tool_bar_string") " (f)\n     " (span (|@| (class "keyword") (id "F:309459")) "struct") " " (span (|@| (class "type") (id "F:309466")) "frame") " *" (span (|@| (class "variable-name") (id "F:309473")) "f") ";\n{\n  " (span (|@| (class "type") (id "F:309480")) "int") " " (span (|@| (class "variable-name") (id "F:309484")) "i") ", " (span (|@| (class "variable-name") (id "F:309487")) "size") ", " (span (|@| (class "variable-name") (id "F:309493")) "size_needed") ";\n  " (span (|@| (class "keyword") (id "F:309508")) "struct") " " (span (|@| (class "type") (id "F:309515")) "gcpro") " " (span (|@| (class "variable-name") (id "F:309521")) "gcpro1") ", " (span (|@| (class "variable-name") (id "F:309529")) "gcpro2") ", " (span (|@| (class "variable-name") (id "F:309537")) "gcpro3") ";\n  " (span (|@| (class "type") (id "F:309547")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:309559")) "image") ", " (span (|@| (class "variable-name") (id "F:309566")) "plist") ", " (span (|@| (class "variable-name") (id "F:309573")) "props") ";\n\n  image = plist = props = Qnil;\n  GCPRO3 (image, plist, props);\n\n  " (span (|@| (class "comment-delimiter") (id "F:309648")) "/* ") (span (|@| (class "comment") (id "F:309651")) "Prepare F->desired_tool_bar_string.  If we can reuse it, do so.\n     Otherwise, make a new string.  ") (span (|@| (class "comment-delimiter") (id "F:309751")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:309757")) "/* ") (span (|@| (class "comment") (id "F:309760")) "The size of the string we might be able to reuse.  ") (span (|@| (class "comment-delimiter") (id "F:309811")) "*/") "\n  size = (STRINGP (f->desired_tool_bar_string)\n          ? SCHARS (f->desired_tool_bar_string)\n          : 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:309914")) "/* ") (span (|@| (class "comment") (id "F:309917")) "We need one space in the string for each image.  ") (span (|@| (class "comment-delimiter") (id "F:309966")) "*/") "\n  size_needed = f->n_tool_bar_items;\n\n  " (span (|@| (class "comment-delimiter") (id "F:310009")) "/* ") (span (|@| (class "comment") (id "F:310012")) "Reuse f->desired_tool_bar_string, if possible.  ") (span (|@| (class "comment-delimiter") (id "F:310060")) "*/") "\n  " (span (|@| (class "keyword") (id "F:310065")) "if") " (size < size_needed || NILP (f->desired_tool_bar_string))\n    f->desired_tool_bar_string = Fmake_string (make_number (size_needed),\n                                               make_number (" (span (|@| (class "string") (id "F:310225")) "' '") "));\n  " (span (|@| (class "keyword") (id "F:310234")) "else") "\n    {\n      props = list4 (Qdisplay, Qnil, Qmenu_item, Qnil);\n      Fremove_text_properties (make_number (0), make_number (size),\n                               props, f->desired_tool_bar_string);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:310424")) "/* ") (span (|@| (class "comment") (id "F:310427")) "Put a `display' property on the string for the images to display,\n     put a `menu_item' property on tool-bar items with a value that\n     is the index of the item in F's tool-bar item vector.  ") (span (|@| (class "comment-delimiter") (id "F:310621")) "*/") "\n  " (span (|@| (class "keyword") (id "F:310626")) "for") " (i = 0; i < f->n_tool_bar_items; ++i)\n    {\n" (span (|@| (class "preprocessor") (id "F:310674")) "#define") " " (span (|@| (class "function-name") (id "F:310682")) "PROP") "(" (span (|@| (class "variable-name") (id "F:310687")) "IDX") ") AREF (f->tool_bar_items, i * TOOL_BAR_ITEM_NSLOTS + (IDX))\n\n      " (span (|@| (class "type") (id "F:310758")) "int") " " (span (|@| (class "variable-name") (id "F:310762")) "enabled_p") " = " (span (|@| (class "negation-char") (id "F:310774")) "!") "NILP (PROP (TOOL_BAR_ITEM_ENABLED_P));\n      " (span (|@| (class "type") (id "F:310820")) "int") " " (span (|@| (class "variable-name") (id "F:310824")) "selected_p") " = " (span (|@| (class "negation-char") (id "F:310837")) "!") "NILP (PROP (TOOL_BAR_ITEM_SELECTED_P));\n      " (span (|@| (class "type") (id "F:310884")) "int") " " (span (|@| (class "variable-name") (id "F:310888")) "hmargin") ", " (span (|@| (class "variable-name") (id "F:310897")) "vmargin") ", " (span (|@| (class "variable-name") (id "F:310906")) "relief") ", " (span (|@| (class "variable-name") (id "F:310914")) "idx") ", " (span (|@| (class "variable-name") (id "F:310919")) "end") ";\n      " (span (|@| (class "keyword") (id "F:310930")) "extern") " " (span (|@| (class "type") (id "F:310937")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:310949")) "QCrelief") ", " (span (|@| (class "variable-name") (id "F:310959")) "QCmargin") ", " (span (|@| (class "variable-name") (id "F:310969")) "QCconversion") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:310990")) "/* ") (span (|@| (class "comment") (id "F:310993")) "If image is a vector, choose the image according to the\n         button state.  ") (span (|@| (class "comment-delimiter") (id "F:311066")) "*/") "\n      image = PROP (TOOL_BAR_ITEM_IMAGES);\n      " (span (|@| (class "keyword") (id "F:311118")) "if") " (VECTORP (image))\n        {\n          " (span (|@| (class "keyword") (id "F:311145")) "if") " (enabled_p)\n            idx = (selected_p\n                   ? TOOL_BAR_IMAGE_ENABLED_SELECTED\n                   : TOOL_BAR_IMAGE_ENABLED_DESELECTED);\n          " (span (|@| (class "keyword") (id "F:311268")) "else") "\n            idx = (selected_p\n                   ? TOOL_BAR_IMAGE_DISABLED_SELECTED\n                   : TOOL_BAR_IMAGE_DISABLED_DESELECTED);\n\n          xassert (ASIZE (image) >= idx);\n          image = AREF (image, idx);\n        }\n      " (span (|@| (class "keyword") (id "F:311455")) "else") "\n        idx = -1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:311478")) "/* ") (span (|@| (class "comment") (id "F:311481")) "Ignore invalid image specifications.  ") (span (|@| (class "comment-delimiter") (id "F:311519")) "*/") "\n      " (span (|@| (class "keyword") (id "F:311528")) "if") " (" (span (|@| (class "negation-char") (id "F:311532")) "!") "valid_image_p (image))\n        " (span (|@| (class "keyword") (id "F:311557")) "continue") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:311574")) "/* ") (span (|@| (class "comment") (id "F:311577")) "Display the tool-bar button pressed, or depressed.  ") (span (|@| (class "comment-delimiter") (id "F:311629")) "*/") "\n      plist = Fcopy_sequence (XCDR (image));\n\n      " (span (|@| (class "comment-delimiter") (id "F:311684")) "/* ") (span (|@| (class "comment") (id "F:311687")) "Compute margin and relief to draw.  ") (span (|@| (class "comment-delimiter") (id "F:311723")) "*/") "\n      relief = (tool_bar_button_relief >= 0\n                ? tool_bar_button_relief\n                : DEFAULT_TOOL_BAR_BUTTON_RELIEF);\n      hmargin = vmargin = relief;\n\n      " (span (|@| (class "keyword") (id "F:311875")) "if") " (INTEGERP (Vtool_bar_button_margin)\n          && XINT (Vtool_bar_button_margin) > 0)\n        {\n          hmargin += XFASTINT (Vtool_bar_button_margin);\n          vmargin += XFASTINT (Vtool_bar_button_margin);\n        }\n      " (span (|@| (class "keyword") (id "F:312068")) "else") " " (span (|@| (class "keyword") (id "F:312073")) "if") " (CONSP (Vtool_bar_button_margin))\n        {\n          " (span (|@| (class "keyword") (id "F:312116")) "if") " (INTEGERP (XCAR (Vtool_bar_button_margin))\n              && XINT (XCAR (Vtool_bar_button_margin)) > 0)\n            hmargin += XFASTINT (XCAR (Vtool_bar_button_margin));\n\n          " (span (|@| (class "keyword") (id "F:312278")) "if") " (INTEGERP (XCDR (Vtool_bar_button_margin))\n              && XINT (XCDR (Vtool_bar_button_margin)) > 0)\n            vmargin += XFASTINT (XCDR (Vtool_bar_button_margin));\n        }\n\n      " (span (|@| (class "keyword") (id "F:312446")) "if") " (auto_raise_tool_bar_buttons_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:312487")) "/* ") (span (|@| (class "comment") (id "F:312490")) "Add a `:relief' property to the image spec if the item is\n             selected.  ") (span (|@| (class "comment-delimiter") (id "F:312565")) "*/") "\n          " (span (|@| (class "keyword") (id "F:312571")) "if") " (selected_p)\n            {\n              plist = Fplist_put (plist, QCrelief, make_number (-relief));\n              hmargin -= relief;\n              vmargin -= relief;\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:312730")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:312741")) "/* ") (span (|@| (class "comment") (id "F:312744")) "If image is selected, display it pressed, i.e. with a\n             negative relief.  If it's not selected, display it with a\n             raised relief.  ") (span (|@| (class "comment-delimiter") (id "F:312884")) "*/") "\n          plist = Fplist_put (plist, QCrelief,\n                              (selected_p\n                               ? make_number (-relief)\n                               : make_number (relief)));\n          hmargin -= relief;\n          vmargin -= relief;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:313072")) "/* ") (span (|@| (class "comment") (id "F:313075")) "Put a margin around the image.  ") (span (|@| (class "comment-delimiter") (id "F:313107")) "*/") "\n      " (span (|@| (class "keyword") (id "F:313116")) "if") " (hmargin || vmargin)\n        {\n          " (span (|@| (class "keyword") (id "F:313146")) "if") " (hmargin == vmargin)\n            plist = Fplist_put (plist, QCmargin, make_number (hmargin));\n          " (span (|@| (class "keyword") (id "F:313239")) "else") "\n            plist = Fplist_put (plist, QCmargin,\n                                Fcons (make_number (hmargin),\n                                       make_number (vmargin)));\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:313366")) "/* ") (span (|@| (class "comment") (id "F:313369")) "If button is not enabled, and we don't have special images\n         for the disabled state, make the image appear disabled by\n         applying an appropriate algorithm to it.  ") (span (|@| (class "comment-delimiter") (id "F:313532")) "*/") "\n      " (span (|@| (class "keyword") (id "F:313541")) "if") " (" (span (|@| (class "negation-char") (id "F:313545")) "!") "enabled_p && idx < 0)\n        plist = Fplist_put (plist, QCconversion, Qdisabled);\n\n      " (span (|@| (class "comment-delimiter") (id "F:313629")) "/* ") (span (|@| (class "comment") (id "F:313632")) "Put a `display' text property on the string for the image to\n         display.  Put a `menu-item' property on the string that gives\n         the start of this item's properties in the tool-bar items\n         vector.  ") (span (|@| (class "comment-delimiter") (id "F:313828")) "*/") "\n      image = Fcons (Qimage, plist);\n      props = list4 (Qdisplay, image,\n                     Qmenu_item, make_number (i * TOOL_BAR_ITEM_NSLOTS));\n\n      " (span (|@| (class "comment-delimiter") (id "F:313973")) "/* ") (span (|@| (class "comment") (id "F:313976")) "Let the last image hide all remaining spaces in the tool bar\n         string.  The string can be longer than needed when we reuse a\n         previous string.  ") (span (|@| (class "comment-delimiter") (id "F:314135")) "*/") "\n      " (span (|@| (class "keyword") (id "F:314144")) "if") " (i + 1 == f->n_tool_bar_items)\n        end = SCHARS (f->desired_tool_bar_string);\n      " (span (|@| (class "keyword") (id "F:314228")) "else") "\n        end = i + 1;\n      Fadd_text_properties (make_number (i), make_number (end),\n                            props, f->desired_tool_bar_string);\n" (span (|@| (class "preprocessor") (id "F:314354")) "#undef") " PROP\n    }\n\n  UNGCPRO;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:314388")) "/* ") (span (|@| (class "comment") (id "F:314391")) "Display one line of the tool-bar of frame IT->f.\n\n   HEIGHT specifies the desired height of the tool-bar line.\n   If the actual height of the glyph row is less than HEIGHT, the\n   row's height is increased to HEIGHT, and the icons are centered\n   vertically in the new height.\n\n   If HEIGHT is -1, we are counting needed tool-bar lines, so don't\n   count a final empty row in case the tool-bar width exactly matches\n   the window width.\n") (span (|@| (class "comment-delimiter") (id "F:314828")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:314832")) "static") " " (span (|@| (class "type") (id "F:314839")) "void") "\n" (span (|@| (class "function-name") (id "F:314844")) "display_tool_bar_line") " (" (span (|@| (class "type") (id "F:314867")) "it") ", height)\n     " (span (|@| (class "keyword") (id "F:314884")) "struct") " " (span (|@| (class "type") (id "F:314891")) "it") " *" (span (|@| (class "variable-name") (id "F:314895")) "it") ";\n     " (span (|@| (class "type") (id "F:314904")) "int") " " (span (|@| (class "variable-name") (id "F:314908")) "height") ";\n{\n  " (span (|@| (class "keyword") (id "F:314920")) "struct") " " (span (|@| (class "type") (id "F:314927")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:314938")) "row") " = it->glyph_row;\n  " (span (|@| (class "type") (id "F:314961")) "int") " " (span (|@| (class "variable-name") (id "F:314965")) "max_x") " = it->last_visible_x;\n  " (span (|@| (class "keyword") (id "F:314995")) "struct") " " (span (|@| (class "type") (id "F:315002")) "glyph") " *" (span (|@| (class "variable-name") (id "F:315009")) "last") ";\n\n  prepare_desired_row (row);\n  row->y = it->current_y;\n\n  " (span (|@| (class "comment-delimiter") (id "F:315074")) "/* ") (span (|@| (class "comment") (id "F:315077")) "Note that this isn't made use of if the face hasn't a box,\n     so there's no need to check the face here.  ") (span (|@| (class "comment-delimiter") (id "F:315185")) "*/") "\n  it->start_of_box_run_p = 1;\n\n  " (span (|@| (class "keyword") (id "F:315221")) "while") " (it->current_x < max_x)\n    {\n      " (span (|@| (class "type") (id "F:315263")) "int") " " (span (|@| (class "variable-name") (id "F:315267")) "x") ", " (span (|@| (class "variable-name") (id "F:315270")) "n_glyphs_before") ", " (span (|@| (class "variable-name") (id "F:315287")) "i") ", " (span (|@| (class "variable-name") (id "F:315290")) "nglyphs") ";\n      " (span (|@| (class "keyword") (id "F:315305")) "struct") " " (span (|@| (class "type") (id "F:315312")) "it") " " (span (|@| (class "variable-name") (id "F:315315")) "it_before") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:315333")) "/* ") (span (|@| (class "comment") (id "F:315336")) "Get the next display element.  ") (span (|@| (class "comment-delimiter") (id "F:315367")) "*/") "\n      " (span (|@| (class "keyword") (id "F:315376")) "if") " (" (span (|@| (class "negation-char") (id "F:315380")) "!") "get_next_display_element (it))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:315418")) "/* ") (span (|@| (class "comment") (id "F:315421")) "Don't count empty row if we are counting needed tool-bar lines.  ") (span (|@| (class "comment-delimiter") (id "F:315486")) "*/") "\n          " (span (|@| (class "keyword") (id "F:315492")) "if") " (height < 0 && " (span (|@| (class "negation-char") (id "F:315510")) "!") "it->hpos)\n            " (span (|@| (class "keyword") (id "F:315526")) "return") ";\n          " (span (|@| (class "keyword") (id "F:315537")) "break") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:315554")) "/* ") (span (|@| (class "comment") (id "F:315557")) "Produce glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:315574")) "*/") "\n      n_glyphs_before = row->used[TEXT_AREA];\n      it_before = *it;\n\n      PRODUCE_GLYPHS (it);\n\n      nglyphs = row->used[TEXT_AREA] - n_glyphs_before;\n      i = 0;\n      x = it_before.current_x;\n      " (span (|@| (class "keyword") (id "F:315781")) "while") " (i < nglyphs)\n        {\n          " (span (|@| (class "keyword") (id "F:315807")) "struct") " " (span (|@| (class "type") (id "F:315814")) "glyph") " *" (span (|@| (class "variable-name") (id "F:315821")) "glyph") " = row->glyphs[TEXT_AREA] + n_glyphs_before + i;\n\n          " (span (|@| (class "keyword") (id "F:315879")) "if") " (x + glyph->pixel_width > max_x)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:315929")) "/* ") (span (|@| (class "comment") (id "F:315932")) "Glyph doesn't fit on line.  Backtrack.  ") (span (|@| (class "comment-delimiter") (id "F:315972")) "*/") "\n              row->used[TEXT_AREA] = n_glyphs_before;\n              *it = it_before;\n              " (span (|@| (class "comment-delimiter") (id "F:316053")) "/* ") (span (|@| (class "comment") (id "F:316056")) "If this is the only glyph on this line, it will never fit on the\n                 toolbar, so skip it.  But ensure there is at least one glyph,\n                 so we don't accidentally disable the tool-bar.  ") (span (|@| (class "comment-delimiter") (id "F:316237")) "*/") "\n              " (span (|@| (class "keyword") (id "F:316247")) "if") " (n_glyphs_before == 0\n                  && (it->vpos > 0 || IT_STRING_CHARPOS (*it) < it->end_charpos-1))\n                " (span (|@| (class "keyword") (id "F:316344")) "break") ";\n              " (span (|@| (class "keyword") (id "F:316358")) "goto") " " (span (|@| (class "constant") (id "F:316363")) "out") ";\n            }\n\n          ++it->hpos;\n          x += glyph->pixel_width;\n          ++i;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:316437")) "/* ") (span (|@| (class "comment") (id "F:316440")) "Stop at line ends.  ") (span (|@| (class "comment-delimiter") (id "F:316460")) "*/") "\n      " (span (|@| (class "keyword") (id "F:316469")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n        " (span (|@| (class "keyword") (id "F:316506")) "break") ";\n\n      set_iterator_to_next (it, 1);\n    }\n\n " (span (|@| (class "constant") (id "F:316558")) "out") ":;\n\n  row->displays_text_p = row->used[TEXT_AREA] != 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:316620")) "/* ") (span (|@| (class "comment") (id "F:316623")) "Use default face for the border below the tool bar.\n\n     FIXME: When auto-resize-tool-bars is grow-only, there is\n     no additional border below the possibly empty tool-bar lines.\n     So to make the extra empty lines look \"normal\", we have to\n     use the tool-bar face for the border too.  ") (span (|@| (class "comment-delimiter") (id "F:316917")) "*/") "\n  " (span (|@| (class "keyword") (id "F:316922")) "if") " (" (span (|@| (class "negation-char") (id "F:316926")) "!") "row->displays_text_p && " (span (|@| (class "negation-char") (id "F:316951")) "!") "EQ (Vauto_resize_tool_bars, Qgrow_only))\n    it->face_id = DEFAULT_FACE_ID;\n\n  extend_face_to_end_of_line (it);\n  last = row->glyphs[TEXT_AREA] + row->used[TEXT_AREA] - 1;\n  last->right_box_line_p = 1;\n  " (span (|@| (class "keyword") (id "F:317156")) "if") " (last == row->glyphs[TEXT_AREA])\n    last->left_box_line_p = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:317226")) "/* ") (span (|@| (class "comment") (id "F:317229")) "Make line the desired height and center it vertically.  ") (span (|@| (class "comment-delimiter") (id "F:317285")) "*/") "\n  " (span (|@| (class "keyword") (id "F:317290")) "if") " ((height -= it->max_ascent + it->max_descent) > 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:317356")) "/* ") (span (|@| (class "comment") (id "F:317359")) "Don't add more than one line height.  ") (span (|@| (class "comment-delimiter") (id "F:317397")) "*/") "\n      height %= FRAME_LINE_HEIGHT (it->f);\n      it->max_ascent += height / 2;\n      it->max_descent += (height + 1) / 2;\n    }\n\n  compute_line_metrics (it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:317561")) "/* ") (span (|@| (class "comment") (id "F:317564")) "If line is empty, make it occupy the rest of the tool-bar.  ") (span (|@| (class "comment-delimiter") (id "F:317624")) "*/") "\n  " (span (|@| (class "keyword") (id "F:317629")) "if") " (" (span (|@| (class "negation-char") (id "F:317633")) "!") "row->displays_text_p)\n    {\n      row->height = row->phys_height = it->last_visible_y - row->y;\n      row->visible_height = row->height;\n      row->ascent = row->phys_ascent = 0;\n      row->extra_line_spacing = 0;\n    }\n\n  row->full_width_p = 1;\n  row->continued_p = 0;\n  row->truncated_on_left_p = 0;\n  row->truncated_on_right_p = 0;\n\n  it->current_x = it->hpos = 0;\n  it->current_y += row->height;\n  ++it->vpos;\n  ++it->glyph_row;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:318071")) "/* ") (span (|@| (class "comment") (id "F:318074")) "Max tool-bar height.  ") (span (|@| (class "comment-delimiter") (id "F:318096")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:318100")) "#define") " " (span (|@| (class "function-name") (id "F:318108")) "MAX_FRAME_TOOL_BAR_HEIGHT") "(" (span (|@| (class "variable-name") (id "F:318134")) "f") ") \\\n  ((FRAME_LINE_HEIGHT (f) * FRAME_LINES (f)))\n\n" (span (|@| (class "comment-delimiter") (id "F:318186")) "/* ") (span (|@| (class "comment") (id "F:318189")) "Value is the number of screen lines needed to make all tool-bar\n   items of frame F visible.  The number of actual rows needed is\n   returned in *N_ROWS if non-NULL.  ") (span (|@| (class "comment-delimiter") (id "F:318356")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:318360")) "static") " " (span (|@| (class "type") (id "F:318367")) "int") "\n" (span (|@| (class "function-name") (id "F:318371")) "tool_bar_lines_needed") " (f, n_rows)\n     " (span (|@| (class "keyword") (id "F:318410")) "struct") " " (span (|@| (class "type") (id "F:318417")) "frame") " *" (span (|@| (class "variable-name") (id "F:318424")) "f") ";\n     " (span (|@| (class "type") (id "F:318432")) "int") " *" (span (|@| (class "variable-name") (id "F:318437")) "n_rows") ";\n{\n  " (span (|@| (class "keyword") (id "F:318449")) "struct") " " (span (|@| (class "type") (id "F:318456")) "window") " *" (span (|@| (class "variable-name") (id "F:318464")) "w") " = XWINDOW (f->tool_bar_window);\n  " (span (|@| (class "keyword") (id "F:318500")) "struct") " " (span (|@| (class "type") (id "F:318507")) "it") " " (span (|@| (class "variable-name") (id "F:318510")) "it") ";\n  " (span (|@| (class "comment-delimiter") (id "F:318516")) "/* ") (span (|@| (class "comment") (id "F:318519")) "tool_bar_lines_needed is called from redisplay_tool_bar after building\n     the desired matrix, so use (unused) mode-line row as temporary row to\n     avoid destroying the first tool-bar row.  ") (span (|@| (class "comment-delimiter") (id "F:318712")) "*/") "\n  " (span (|@| (class "keyword") (id "F:318717")) "struct") " " (span (|@| (class "type") (id "F:318724")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:318735")) "temp_row") " = MATRIX_MODE_LINE_ROW (w->desired_matrix);\n\n  " (span (|@| (class "comment-delimiter") (id "F:318791")) "/* ") (span (|@| (class "comment") (id "F:318794")) "Initialize an iterator for iteration over\n     F->desired_tool_bar_string in the tool-bar window of frame F.  ") (span (|@| (class "comment-delimiter") (id "F:318904")) "*/") "\n  init_iterator (&it, w, -1, -1, temp_row, TOOL_BAR_FACE_ID);\n  it.first_visible_x = 0;\n  it.last_visible_x = FRAME_TOTAL_COLS (f) * FRAME_COLUMN_WIDTH (f);\n  reseat_to_string (&it, " (span (|@| (class "constant") (id "F:319089")) "NULL") ", f->desired_tool_bar_string, 0, 0, 0, -1);\n\n  " (span (|@| (class "keyword") (id "F:319140")) "while") " (" (span (|@| (class "negation-char") (id "F:319147")) "!") "ITERATOR_AT_END_P (&it))\n    {\n      clear_glyph_row (temp_row);\n      it.glyph_row = temp_row;\n      display_tool_bar_line (&it, -1);\n    }\n  clear_glyph_row (temp_row);\n\n  " (span (|@| (class "comment-delimiter") (id "F:319322")) "/* ") (span (|@| (class "comment") (id "F:319325")) "f->n_tool_bar_rows == 0 means \"unknown\"; -1 means no tool-bar.  ") (span (|@| (class "comment-delimiter") (id "F:319389")) "*/") "\n  " (span (|@| (class "keyword") (id "F:319394")) "if") " (n_rows)\n    *n_rows = it.vpos > 0 ? it.vpos : -1;\n\n  " (span (|@| (class "keyword") (id "F:319451")) "return") " (it.current_y + FRAME_LINE_HEIGHT (f) - 1) / FRAME_LINE_HEIGHT (f);\n}\n\n\nDEFUN (" (span (|@| (class "string") (id "F:319537")) "\"tool-bar-lines-needed\"") ", Ftool_bar_lines_needed, Stool_bar_lines_needed,\n       0, 1, 0,\n       doc: " (span (|@| (class "comment-delimiter") (id "F:319638")) "/* ") (span (|@| (class "comment") (id "F:319641")) "Return the number of lines occupied by the tool bar of FRAME.  ") (span (|@| (class "comment-delimiter") (id "F:319704")) "*/") ")\n     (frame)\n     " (span (|@| (class "type") (id "F:319726")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:319738")) "frame") ";\n{\n  " (span (|@| (class "keyword") (id "F:319749")) "struct") " " (span (|@| (class "type") (id "F:319756")) "frame") " *" (span (|@| (class "variable-name") (id "F:319763")) "f") ";\n  " (span (|@| (class "keyword") (id "F:319768")) "struct") " " (span (|@| (class "type") (id "F:319775")) "window") " *" (span (|@| (class "variable-name") (id "F:319783")) "w") ";\n  " (span (|@| (class "type") (id "F:319788")) "int") " " (span (|@| (class "variable-name") (id "F:319792")) "nlines") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:319807")) "if") " (NILP (frame))\n    frame = selected_frame;\n  " (span (|@| (class "keyword") (id "F:319855")) "else") "\n    CHECK_FRAME (frame);\n  f = XFRAME (frame);\n\n  " (span (|@| (class "keyword") (id "F:319910")) "if") " (WINDOWP (f->tool_bar_window)\n      || (w = XWINDOW (f->tool_bar_window),\n          WINDOW_TOTAL_LINES (w) > 0))\n    {\n      update_tool_bar (f, 1);\n      " (span (|@| (class "keyword") (id "F:320061")) "if") " (f->n_tool_bar_items)\n        {\n          build_desired_tool_bar_string (f);\n          nlines = tool_bar_lines_needed (f, " (span (|@| (class "constant") (id "F:320165")) "NULL") ");\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:320184")) "return") " make_number (nlines);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:320217")) "/* ") (span (|@| (class "comment") (id "F:320220")) "Display the tool-bar of frame F.  Value is non-zero if tool-bar's\n   height should be changed.  ") (span (|@| (class "comment-delimiter") (id "F:320316")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:320320")) "static") " " (span (|@| (class "type") (id "F:320327")) "int") "\n" (span (|@| (class "function-name") (id "F:320331")) "redisplay_tool_bar") " (f)\n     " (span (|@| (class "keyword") (id "F:320359")) "struct") " " (span (|@| (class "type") (id "F:320366")) "frame") " *" (span (|@| (class "variable-name") (id "F:320373")) "f") ";\n{\n  " (span (|@| (class "keyword") (id "F:320380")) "struct") " " (span (|@| (class "type") (id "F:320387")) "window") " *" (span (|@| (class "variable-name") (id "F:320395")) "w") ";\n  " (span (|@| (class "keyword") (id "F:320400")) "struct") " " (span (|@| (class "type") (id "F:320407")) "it") " " (span (|@| (class "variable-name") (id "F:320410")) "it") ";\n  " (span (|@| (class "keyword") (id "F:320416")) "struct") " " (span (|@| (class "type") (id "F:320423")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:320434")) "row") ";\n\n" (span (|@| (class "preprocessor") (id "F:320440")) "#if") " " (span (|@| (class "preprocessor") (id "F:320444")) "defined") " (USE_GTK) || " (span (|@| (class "preprocessor") (id "F:320465")) "defined") " (HAVE_NS)\n  " (span (|@| (class "keyword") (id "F:320485")) "if") " (FRAME_EXTERNAL_TOOL_BAR (f))\n    update_frame_tool_bar (f);\n  " (span (|@| (class "keyword") (id "F:320551")) "return") " 0;\n" (span (|@| (class "preprocessor") (id "F:320561")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:320571")) "/* ") (span (|@| (class "comment") (id "F:320574")) "If frame hasn't a tool-bar window or if it is zero-height, don't\n     do anything.  This means you must start with tool-bar-lines\n     non-zero to get the auto-sizing effect.  Or in other words, you\n     can turn off tool-bars by specifying tool-bar-lines zero.  ") (span (|@| (class "comment-delimiter") (id "F:320837")) "*/") "\n  " (span (|@| (class "keyword") (id "F:320842")) "if") " (" (span (|@| (class "negation-char") (id "F:320846")) "!") "WINDOWP (f->tool_bar_window)\n      || (w = XWINDOW (f->tool_bar_window),\n          WINDOW_TOTAL_LINES (w) == 0))\n    " (span (|@| (class "keyword") (id "F:320964")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:320977")) "/* ") (span (|@| (class "comment") (id "F:320980")) "Set up an iterator for the tool-bar window.  ") (span (|@| (class "comment-delimiter") (id "F:321025")) "*/") "\n  init_iterator (&it, w, -1, -1, w->desired_matrix->rows, TOOL_BAR_FACE_ID);\n  it.first_visible_x = 0;\n  it.last_visible_x = FRAME_TOTAL_COLS (f) * FRAME_COLUMN_WIDTH (f);\n  row = it.glyph_row;\n\n  " (span (|@| (class "comment-delimiter") (id "F:321225")) "/* ") (span (|@| (class "comment") (id "F:321228")) "Build a string that represents the contents of the tool-bar.  ") (span (|@| (class "comment-delimiter") (id "F:321290")) "*/") "\n  build_desired_tool_bar_string (f);\n  reseat_to_string (&it, " (span (|@| (class "constant") (id "F:321355")) "NULL") ", f->desired_tool_bar_string, 0, 0, 0, -1);\n\n  " (span (|@| (class "keyword") (id "F:321406")) "if") " (f->n_tool_bar_rows == 0)\n    {\n      " (span (|@| (class "type") (id "F:321447")) "int") " " (span (|@| (class "variable-name") (id "F:321451")) "nlines") ";\n\n      " (span (|@| (class "keyword") (id "F:321466")) "if") " ((nlines = tool_bar_lines_needed (f, &f->n_tool_bar_rows),\n           nlines != WINDOW_TOTAL_LINES (w)))\n        {\n          " (span (|@| (class "keyword") (id "F:321573")) "extern") " " (span (|@| (class "type") (id "F:321580")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:321592")) "Qtool_bar_lines") ";\n          " (span (|@| (class "type") (id "F:321612")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:321624")) "frame") ";\n          " (span (|@| (class "type") (id "F:321634")) "int") " " (span (|@| (class "variable-name") (id "F:321638")) "old_height") " = WINDOW_TOTAL_LINES (w);\n\n          XSETFRAME (frame, f);\n          Fmodify_frame_parameters (frame,\n                                    Fcons (Fcons (Qtool_bar_lines,\n                                                  make_number (nlines)),\n                                           Qnil));\n          " (span (|@| (class "keyword") (id "F:321826")) "if") " (WINDOW_TOTAL_LINES (w) != old_height)\n            {\n              clear_glyph_matrix (w->desired_matrix);\n              fonts_changed_p = 1;\n              " (span (|@| (class "keyword") (id "F:321957")) "return") " 1;\n            }\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:321986")) "/* ") (span (|@| (class "comment") (id "F:321989")) "Display as many lines as needed to display all tool-bar items.  ") (span (|@| (class "comment-delimiter") (id "F:322053")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:322059")) "if") " (f->n_tool_bar_rows > 0)\n    {\n      " (span (|@| (class "type") (id "F:322099")) "int") " " (span (|@| (class "variable-name") (id "F:322103")) "border") ", " (span (|@| (class "variable-name") (id "F:322111")) "rows") ", " (span (|@| (class "variable-name") (id "F:322117")) "height") ", " (span (|@| (class "variable-name") (id "F:322125")) "extra") ";\n\n      " (span (|@| (class "keyword") (id "F:322139")) "if") " (INTEGERP (Vtool_bar_border))\n        border = XINT (Vtool_bar_border);\n      " (span (|@| (class "keyword") (id "F:322213")) "else") " " (span (|@| (class "keyword") (id "F:322218")) "if") " (EQ (Vtool_bar_border, Qinternal_border_width))\n        border = FRAME_INTERNAL_BORDER_WIDTH (f);\n      " (span (|@| (class "keyword") (id "F:322318")) "else") " " (span (|@| (class "keyword") (id "F:322323")) "if") " (EQ (Vtool_bar_border, Qborder_width))\n        border = f->border_width;\n      " (span (|@| (class "keyword") (id "F:322398")) "else") "\n        border = 0;\n      " (span (|@| (class "keyword") (id "F:322422")) "if") " (border < 0)\n        border = 0;\n\n      rows = f->n_tool_bar_rows;\n      height = max (1, (it.last_visible_y - border) / rows);\n      extra = it.last_visible_y - border - height * rows;\n\n      " (span (|@| (class "keyword") (id "F:322611")) "while") " (it.current_y < it.last_visible_y)\n        {\n          " (span (|@| (class "type") (id "F:322658")) "int") " " (span (|@| (class "variable-name") (id "F:322662")) "h") " = 0;\n          " (span (|@| (class "keyword") (id "F:322672")) "if") " (extra > 0 && rows-- > 0)\n            {\n              h = (extra + rows - 1) / rows;\n              extra -= h;\n            }\n          display_tool_bar_line (&it, height + h);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:322827")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:322844")) "while") " (it.current_y < it.last_visible_y)\n        display_tool_bar_line (&it, 0);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:322927")) "/* ") (span (|@| (class "comment") (id "F:322930")) "It doesn't make much sense to try scrolling in the tool-bar\n     window, so don't do it.  ") (span (|@| (class "comment-delimiter") (id "F:323020")) "*/") "\n  w->desired_matrix->no_scrolling_p = 1;\n  w->must_be_updated_p = 1;\n\n  " (span (|@| (class "keyword") (id "F:323095")) "if") " (" (span (|@| (class "negation-char") (id "F:323099")) "!") "NILP (Vauto_resize_tool_bars))\n    {\n      " (span (|@| (class "type") (id "F:323143")) "int") " " (span (|@| (class "variable-name") (id "F:323147")) "max_tool_bar_height") " = MAX_FRAME_TOOL_BAR_HEIGHT (f);\n      " (span (|@| (class "type") (id "F:323206")) "int") " " (span (|@| (class "variable-name") (id "F:323210")) "change_height_p") " = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:323238")) "/* ") (span (|@| (class "comment") (id "F:323241")) "If we couldn't display everything, change the tool-bar's\n         height if there is room for more.  ") (span (|@| (class "comment-delimiter") (id "F:323335")) "*/") "\n      " (span (|@| (class "keyword") (id "F:323344")) "if") " (IT_STRING_CHARPOS (it) < it.end_charpos\n          && it.current_y < max_tool_bar_height)\n        change_height_p = 1;\n\n      row = it.glyph_row - 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:323490")) "/* ") (span (|@| (class "comment") (id "F:323493")) "If there are blank lines at the end, except for a partially\n         visible blank line at the end that is smaller than\n         FRAME_LINE_HEIGHT, change the tool-bar's height.  ") (span (|@| (class "comment-delimiter") (id "F:323658")) "*/") "\n      " (span (|@| (class "keyword") (id "F:323667")) "if") " (" (span (|@| (class "negation-char") (id "F:323671")) "!") "row->displays_text_p\n          && row->height >= FRAME_LINE_HEIGHT (f))\n        change_height_p = 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:323766")) "/* ") (span (|@| (class "comment") (id "F:323769")) "If row displays tool-bar items, but is partially visible,\n         change the tool-bar's height.  ") (span (|@| (class "comment-delimiter") (id "F:323860")) "*/") "\n      " (span (|@| (class "keyword") (id "F:323869")) "if") " (row->displays_text_p\n          && MATRIX_ROW_BOTTOM_Y (row) > it.last_visible_y\n          && MATRIX_ROW_BOTTOM_Y (row) < max_tool_bar_height)\n        change_height_p = 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:324030")) "/* ") (span (|@| (class "comment") (id "F:324033")) "Resize windows as needed by changing the `tool-bar-lines'\n         frame parameter.  ") (span (|@| (class "comment-delimiter") (id "F:324111")) "*/") "\n      " (span (|@| (class "keyword") (id "F:324120")) "if") " (change_height_p)\n        {\n          " (span (|@| (class "keyword") (id "F:324147")) "extern") " " (span (|@| (class "type") (id "F:324154")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:324166")) "Qtool_bar_lines") ";\n          " (span (|@| (class "type") (id "F:324186")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:324198")) "frame") ";\n          " (span (|@| (class "type") (id "F:324208")) "int") " " (span (|@| (class "variable-name") (id "F:324212")) "old_height") " = WINDOW_TOTAL_LINES (w);\n          " (span (|@| (class "type") (id "F:324252")) "int") " " (span (|@| (class "variable-name") (id "F:324256")) "nrows") ";\n          " (span (|@| (class "type") (id "F:324266")) "int") " " (span (|@| (class "variable-name") (id "F:324270")) "nlines") " = tool_bar_lines_needed (f, &nrows);\n\n          change_height_p = ((EQ (Vauto_resize_tool_bars, Qgrow_only)\n                              && " (span (|@| (class "negation-char") (id "F:324390")) "!") "f->minimize_tool_bar_window_p)\n                             ? (nlines > old_height)\n                             : (nlines != old_height));\n          f->minimize_tool_bar_window_p = 0;\n\n          " (span (|@| (class "keyword") (id "F:324531")) "if") " (change_height_p)\n            {\n              XSETFRAME (frame, f);\n              Fmodify_frame_parameters (frame,\n                                        Fcons (Fcons (Qtool_bar_lines,\n                                                      make_number (nlines)),\n                                               Qnil));\n              " (span (|@| (class "keyword") (id "F:324726")) "if") " (WINDOW_TOTAL_LINES (w) != old_height)\n                {\n                  clear_glyph_matrix (w->desired_matrix);\n                  f->n_tool_bar_rows = nrows;\n                  fonts_changed_p = 1;\n                  " (span (|@| (class "keyword") (id "F:324877")) "return") " 1;\n                }\n            }\n        }\n    }\n\n  f->minimize_tool_bar_window_p = 0;\n  " (span (|@| (class "keyword") (id "F:324947")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:324961")) "/* ") (span (|@| (class "comment") (id "F:324964")) "Get information about the tool-bar item which is displayed in GLYPH\n   on frame F.  Return in *PROP_IDX the index where tool-bar item\n   properties start in F->tool_bar_items.  Value is zero if\n   GLYPH doesn't display a tool-bar item.  ") (span (|@| (class "comment-delimiter") (id "F:325201")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:325205")) "static") " " (span (|@| (class "type") (id "F:325212")) "int") "\n" (span (|@| (class "function-name") (id "F:325216")) "tool_bar_item_info") " (f, " (span (|@| (class "type") (id "F:325239")) "glyph") ", " (span (|@| (class "type") (id "F:325246")) "prop_idx") ")\n     " (span (|@| (class "keyword") (id "F:325261")) "struct") " " (span (|@| (class "type") (id "F:325268")) "frame") " *" (span (|@| (class "variable-name") (id "F:325275")) "f") ";\n     " (span (|@| (class "keyword") (id "F:325283")) "struct") " " (span (|@| (class "type") (id "F:325290")) "glyph") " *" (span (|@| (class "variable-name") (id "F:325297")) "glyph") ";\n     " (span (|@| (class "type") (id "F:325309")) "int") " *" (span (|@| (class "variable-name") (id "F:325314")) "prop_idx") ";\n{\n  " (span (|@| (class "type") (id "F:325328")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:325340")) "prop") ";\n  " (span (|@| (class "type") (id "F:325348")) "int") " " (span (|@| (class "variable-name") (id "F:325352")) "success_p") ";\n  " (span (|@| (class "type") (id "F:325365")) "int") " " (span (|@| (class "variable-name") (id "F:325369")) "charpos") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:325381")) "/* ") (span (|@| (class "comment") (id "F:325384")) "This function can be called asynchronously, which means we must\n     exclude any possibility that Fget_text_property signals an\n     error.  ") (span (|@| (class "comment-delimiter") (id "F:325525")) "*/") "\n  charpos = min (SCHARS (f->current_tool_bar_string), glyph->charpos);\n  charpos = max (0, charpos);\n\n  " (span (|@| (class "comment-delimiter") (id "F:325632")) "/* ") (span (|@| (class "comment") (id "F:325635")) "Get the text property `menu-item' at pos. The value of that\n     property is the start index of this item's properties in\n     F->tool_bar_items.  ") (span (|@| (class "comment-delimiter") (id "F:325782")) "*/") "\n  prop = Fget_text_property (make_number (charpos),\n                             Qmenu_item, f->current_tool_bar_string);\n  " (span (|@| (class "keyword") (id "F:325888")) "if") " (INTEGERP (prop))\n    {\n      *prop_idx = XINT (prop);\n      success_p = 1;\n    }\n  " (span (|@| (class "keyword") (id "F:325975")) "else") "\n    success_p = 0;\n\n  " (span (|@| (class "keyword") (id "F:326002")) "return") " success_p;\n}\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:326025")) "/* ") (span (|@| (class "comment") (id "F:326028")) "Get information about the tool-bar item at position X/Y on frame F.\n   Return in *GLYPH a pointer to the glyph of the tool-bar item in\n   the current matrix of the tool-bar window of F, or NULL if not\n   on a tool-bar item.  Return in *PROP_IDX the index of the tool-bar\n   item in F->tool_bar_items.  Value is\n\n   -1   if X/Y is not on a tool-bar item\n   0    if X/Y is on the same item that was highlighted before.\n   1    otherwise.  ") (span (|@| (class "comment-delimiter") (id "F:326457")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:326461")) "static") " " (span (|@| (class "type") (id "F:326468")) "int") "\n" (span (|@| (class "function-name") (id "F:326472")) "get_tool_bar_item") " (f, x, y, " (span (|@| (class "type") (id "F:326500")) "glyph") ", hpos, vpos, " (span (|@| (class "type") (id "F:326519")) "prop_idx") ")\n     " (span (|@| (class "keyword") (id "F:326534")) "struct") " " (span (|@| (class "type") (id "F:326541")) "frame") " *" (span (|@| (class "variable-name") (id "F:326548")) "f") ";\n     " (span (|@| (class "type") (id "F:326556")) "int") " " (span (|@| (class "variable-name") (id "F:326560")) "x") ", " (span (|@| (class "variable-name") (id "F:326563")) "y") ";\n     " (span (|@| (class "keyword") (id "F:326571")) "struct") " " (span (|@| (class "type") (id "F:326578")) "glyph") " **" (span (|@| (class "variable-name") (id "F:326586")) "glyph") ";\n     " (span (|@| (class "type") (id "F:326598")) "int") " *" (span (|@| (class "variable-name") (id "F:326603")) "hpos") ", *" (span (|@| (class "variable-name") (id "F:326610")) "vpos") ", *" (span (|@| (class "variable-name") (id "F:326617")) "prop_idx") ";\n{\n  " (span (|@| (class "type") (id "F:326631")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:326645")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n  " (span (|@| (class "keyword") (id "F:326683")) "struct") " " (span (|@| (class "type") (id "F:326690")) "window") " *" (span (|@| (class "variable-name") (id "F:326698")) "w") " = XWINDOW (f->tool_bar_window);\n  " (span (|@| (class "type") (id "F:326734")) "int") " " (span (|@| (class "variable-name") (id "F:326738")) "area") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:326747")) "/* ") (span (|@| (class "comment") (id "F:326750")) "Find the glyph under X/Y.  ") (span (|@| (class "comment-delimiter") (id "F:326777")) "*/") "\n  *glyph = x_y_to_hpos_vpos (w, x, y, hpos, vpos, 0, 0, &area);\n  " (span (|@| (class "keyword") (id "F:326846")) "if") " (*glyph == " (span (|@| (class "constant") (id "F:326860")) "NULL") ")\n    " (span (|@| (class "keyword") (id "F:326870")) "return") " -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:326884")) "/* ") (span (|@| (class "comment") (id "F:326887")) "Get the start of this tool-bar item's properties in\n     f->tool_bar_items.  ") (span (|@| (class "comment-delimiter") (id "F:326964")) "*/") "\n  " (span (|@| (class "keyword") (id "F:326969")) "if") " (" (span (|@| (class "negation-char") (id "F:326973")) "!") "tool_bar_item_info (f, *glyph, prop_idx))\n    " (span (|@| (class "keyword") (id "F:327020")) "return") " -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:327034")) "/* ") (span (|@| (class "comment") (id "F:327037")) "Is mouse on the highlighted item?  ") (span (|@| (class "comment-delimiter") (id "F:327072")) "*/") "\n  " (span (|@| (class "keyword") (id "F:327077")) "if") " (EQ (f->tool_bar_window, dpyinfo->mouse_face_window)\n      && *vpos >= dpyinfo->mouse_face_beg_row\n      && *vpos <= dpyinfo->mouse_face_end_row\n      && (*vpos > dpyinfo->mouse_face_beg_row\n          || *hpos >= dpyinfo->mouse_face_beg_col)\n      && (*vpos < dpyinfo->mouse_face_end_row\n          || *hpos < dpyinfo->mouse_face_end_col\n          || dpyinfo->mouse_face_past_end))\n    " (span (|@| (class "keyword") (id "F:327444")) "return") " 0;\n\n  " (span (|@| (class "keyword") (id "F:327457")) "return") " 1;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:327471")) "/* ") (span (|@| (class "comment") (id "F:327474")) "EXPORT:\n   Handle mouse button event on the tool-bar of frame F, at\n   frame-relative coordinates X/Y.  DOWN_P is 1 for a button press,\n   0 for button release.  MODIFIERS is event modifiers for button\n   release.  ") (span (|@| (class "comment-delimiter") (id "F:327689")) "*/") "\n\n" (span (|@| (class "type") (id "F:327693")) "void") "\n" (span (|@| (class "function-name") (id "F:327698")) "handle_tool_bar_click") " (f, x, y, down_p, modifiers)\n     " (span (|@| (class "keyword") (id "F:327754")) "struct") " " (span (|@| (class "type") (id "F:327761")) "frame") " *" (span (|@| (class "variable-name") (id "F:327768")) "f") ";\n     " (span (|@| (class "type") (id "F:327776")) "int") " " (span (|@| (class "variable-name") (id "F:327780")) "x") ", " (span (|@| (class "variable-name") (id "F:327783")) "y") ", " (span (|@| (class "variable-name") (id "F:327786")) "down_p") ";\n     " (span (|@| (class "type") (id "F:327799")) "unsigned") " " (span (|@| (class "type") (id "F:327808")) "int") " " (span (|@| (class "variable-name") (id "F:327812")) "modifiers") ";\n{\n  " (span (|@| (class "type") (id "F:327827")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:327841")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n  " (span (|@| (class "keyword") (id "F:327879")) "struct") " " (span (|@| (class "type") (id "F:327886")) "window") " *" (span (|@| (class "variable-name") (id "F:327894")) "w") " = XWINDOW (f->tool_bar_window);\n  " (span (|@| (class "type") (id "F:327930")) "int") " " (span (|@| (class "variable-name") (id "F:327934")) "hpos") ", " (span (|@| (class "variable-name") (id "F:327940")) "vpos") ", " (span (|@| (class "variable-name") (id "F:327946")) "prop_idx") ";\n  " (span (|@| (class "keyword") (id "F:327958")) "struct") " " (span (|@| (class "type") (id "F:327965")) "glyph") " *" (span (|@| (class "variable-name") (id "F:327972")) "glyph") ";\n  " (span (|@| (class "type") (id "F:327981")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:327993")) "enabled_p") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:328007")) "/* ") (span (|@| (class "comment") (id "F:328010")) "If not on the highlighted tool-bar item, return.  ") (span (|@| (class "comment-delimiter") (id "F:328060")) "*/") "\n  frame_to_window_pixel_xy (w, &x, &y);\n  " (span (|@| (class "keyword") (id "F:328105")) "if") " (get_tool_bar_item (f, x, y, &glyph, &hpos, &vpos, &prop_idx) != 0)\n    " (span (|@| (class "keyword") (id "F:328180")) "return") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:328191")) "/* ") (span (|@| (class "comment") (id "F:328194")) "If item is disabled, do nothing.  ") (span (|@| (class "comment-delimiter") (id "F:328228")) "*/") "\n  enabled_p = AREF (f->tool_bar_items, prop_idx + TOOL_BAR_ITEM_ENABLED_P);\n  " (span (|@| (class "keyword") (id "F:328309")) "if") " (NILP (enabled_p))\n    " (span (|@| (class "keyword") (id "F:328335")) "return") ";\n\n  " (span (|@| (class "keyword") (id "F:328346")) "if") " (down_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:328370")) "/* ") (span (|@| (class "comment") (id "F:328373")) "Show item in pressed state.  ") (span (|@| (class "comment-delimiter") (id "F:328402")) "*/") "\n      show_mouse_face (dpyinfo, DRAW_IMAGE_SUNKEN);\n      dpyinfo->mouse_face_image_state = DRAW_IMAGE_SUNKEN;\n      last_tool_bar_item = prop_idx;\n    }\n  " (span (|@| (class "keyword") (id "F:328561")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:328578")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:328590")) "key") ", " (span (|@| (class "variable-name") (id "F:328595")) "frame") ";\n      " (span (|@| (class "keyword") (id "F:328608")) "struct") " " (span (|@| (class "type") (id "F:328615")) "input_event") " " (span (|@| (class "variable-name") (id "F:328627")) "event") ";\n      EVENT_INIT (event);\n\n      " (span (|@| (class "comment-delimiter") (id "F:328667")) "/* ") (span (|@| (class "comment") (id "F:328670")) "Show item in released state.  ") (span (|@| (class "comment-delimiter") (id "F:328700")) "*/") "\n      show_mouse_face (dpyinfo, DRAW_IMAGE_RAISED);\n      dpyinfo->mouse_face_image_state = DRAW_IMAGE_RAISED;\n\n      key = AREF (f->tool_bar_items, prop_idx + TOOL_BAR_ITEM_KEY);\n\n      XSETFRAME (frame, f);\n      event.kind = TOOL_BAR_EVENT;\n      event.frame_or_window = frame;\n      event.arg = frame;\n      kbd_buffer_store_event (&event);\n\n      event.kind = TOOL_BAR_EVENT;\n      event.frame_or_window = frame;\n      event.arg = key;\n      event.modifiers = modifiers;\n      kbd_buffer_store_event (&event);\n      last_tool_bar_item = -1;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:329259")) "/* ") (span (|@| (class "comment") (id "F:329262")) "Possibly highlight a tool-bar item on frame F when mouse moves to\n   tool-bar window-relative coordinates X/Y.  Called from\n   note_mouse_highlight.  ") (span (|@| (class "comment-delimiter") (id "F:329412")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:329416")) "static") " " (span (|@| (class "type") (id "F:329423")) "void") "\n" (span (|@| (class "function-name") (id "F:329428")) "note_tool_bar_highlight") " (f, x, y)\n     " (span (|@| (class "keyword") (id "F:329467")) "struct") " " (span (|@| (class "type") (id "F:329474")) "frame") " *" (span (|@| (class "variable-name") (id "F:329481")) "f") ";\n     " (span (|@| (class "type") (id "F:329489")) "int") " " (span (|@| (class "variable-name") (id "F:329493")) "x") ", " (span (|@| (class "variable-name") (id "F:329496")) "y") ";\n{\n  " (span (|@| (class "type") (id "F:329503")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:329515")) "window") " = f->tool_bar_window;\n  " (span (|@| (class "keyword") (id "F:329546")) "struct") " " (span (|@| (class "type") (id "F:329553")) "window") " *" (span (|@| (class "variable-name") (id "F:329561")) "w") " = XWINDOW (window);\n  " (span (|@| (class "type") (id "F:329585")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:329599")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n  " (span (|@| (class "type") (id "F:329637")) "int") " " (span (|@| (class "variable-name") (id "F:329641")) "hpos") ", " (span (|@| (class "variable-name") (id "F:329647")) "vpos") ";\n  " (span (|@| (class "keyword") (id "F:329655")) "struct") " " (span (|@| (class "type") (id "F:329662")) "glyph") " *" (span (|@| (class "variable-name") (id "F:329669")) "glyph") ";\n  " (span (|@| (class "keyword") (id "F:329678")) "struct") " " (span (|@| (class "type") (id "F:329685")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:329696")) "row") ";\n  " (span (|@| (class "type") (id "F:329703")) "int") " " (span (|@| (class "variable-name") (id "F:329707")) "i") ";\n  " (span (|@| (class "type") (id "F:329712")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:329724")) "enabled_p") ";\n  " (span (|@| (class "type") (id "F:329737")) "int") " " (span (|@| (class "variable-name") (id "F:329741")) "prop_idx") ";\n  " (span (|@| (class "keyword") (id "F:329753")) "enum") " " (span (|@| (class "type") (id "F:329758")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:329775")) "draw") " = DRAW_IMAGE_RAISED;\n  " (span (|@| (class "type") (id "F:329803")) "int") " " (span (|@| (class "variable-name") (id "F:329807")) "mouse_down_p") ", " (span (|@| (class "variable-name") (id "F:329821")) "rc") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:329828")) "/* ") (span (|@| (class "comment") (id "F:329831")) "Function note_mouse_highlight is called with negative x(y\n     values when mouse moves outside of the frame.  ") (span (|@| (class "comment-delimiter") (id "F:329941")) "*/") "\n  " (span (|@| (class "keyword") (id "F:329946")) "if") " (x <= 0 || y <= 0)\n    {\n      clear_mouse_face (dpyinfo);\n      " (span (|@| (class "keyword") (id "F:330014")) "return") ";\n    }\n\n  rc = get_tool_bar_item (f, x, y, &glyph, &hpos, &vpos, &prop_idx);\n  " (span (|@| (class "keyword") (id "F:330100")) "if") " (rc < 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:330124")) "/* ") (span (|@| (class "comment") (id "F:330127")) "Not on tool-bar item.  ") (span (|@| (class "comment-delimiter") (id "F:330150")) "*/") "\n      clear_mouse_face (dpyinfo);\n      " (span (|@| (class "keyword") (id "F:330193")) "return") ";\n    }\n  " (span (|@| (class "keyword") (id "F:330209")) "else") " " (span (|@| (class "keyword") (id "F:330214")) "if") " (rc == 0)\n    " (span (|@| (class "comment-delimiter") (id "F:330231")) "/* ") (span (|@| (class "comment") (id "F:330234")) "On same tool-bar item as before.  ") (span (|@| (class "comment-delimiter") (id "F:330268")) "*/") "\n    " (span (|@| (class "keyword") (id "F:330275")) "goto") " " (span (|@| (class "constant") (id "F:330280")) "set_help_echo") ";\n\n  clear_mouse_face (dpyinfo);\n\n  " (span (|@| (class "comment-delimiter") (id "F:330329")) "/* ") (span (|@| (class "comment") (id "F:330332")) "Mouse is down, but on different tool-bar item?  ") (span (|@| (class "comment-delimiter") (id "F:330380")) "*/") "\n  mouse_down_p = (dpyinfo->grabbed\n                  && f == last_mouse_frame\n                  && FRAME_LIVE_P (f));\n  " (span (|@| (class "keyword") (id "F:330475")) "if") " (mouse_down_p\n      && last_tool_bar_item != prop_idx)\n    " (span (|@| (class "keyword") (id "F:330537")) "return") ";\n\n  dpyinfo->mouse_face_image_state = DRAW_NORMAL_TEXT;\n  draw = mouse_down_p ? DRAW_IMAGE_SUNKEN : DRAW_IMAGE_RAISED;\n\n  " (span (|@| (class "comment-delimiter") (id "F:330666")) "/* ") (span (|@| (class "comment") (id "F:330669")) "If tool-bar item is not enabled, don't highlight it.  ") (span (|@| (class "comment-delimiter") (id "F:330723")) "*/") "\n  enabled_p = AREF (f->tool_bar_items, prop_idx + TOOL_BAR_ITEM_ENABLED_P);\n  " (span (|@| (class "keyword") (id "F:330804")) "if") " (" (span (|@| (class "negation-char") (id "F:330808")) "!") "NILP (enabled_p))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:330839")) "/* ") (span (|@| (class "comment") (id "F:330842")) "Compute the x-position of the glyph.  In front and past the\n         image is a space.  We include this in the highlighted area.  ") (span (|@| (class "comment-delimiter") (id "F:330965")) "*/") "\n      row = MATRIX_ROW (w->current_matrix, vpos);\n      " (span (|@| (class "keyword") (id "F:331024")) "for") " (i = x = 0; i < hpos; ++i)\n        x += row->glyphs[TEXT_AREA][i].pixel_width;\n\n      " (span (|@| (class "comment-delimiter") (id "F:331107")) "/* ") (span (|@| (class "comment") (id "F:331110")) "Record this as the current active region.  ") (span (|@| (class "comment-delimiter") (id "F:331153")) "*/") "\n      dpyinfo->mouse_face_beg_col = hpos;\n      dpyinfo->mouse_face_beg_row = vpos;\n      dpyinfo->mouse_face_beg_x = x;\n      dpyinfo->mouse_face_beg_y = row->y;\n      dpyinfo->mouse_face_past_end = 0;\n\n      dpyinfo->mouse_face_end_col = hpos + 1;\n      dpyinfo->mouse_face_end_row = vpos;\n      dpyinfo->mouse_face_end_x = x + glyph->pixel_width;\n      dpyinfo->mouse_face_end_y = row->y;\n      dpyinfo->mouse_face_window = window;\n      dpyinfo->mouse_face_face_id = TOOL_BAR_FACE_ID;\n\n      " (span (|@| (class "comment-delimiter") (id "F:331652")) "/* ") (span (|@| (class "comment") (id "F:331655")) "Display it as active.  ") (span (|@| (class "comment-delimiter") (id "F:331678")) "*/") "\n      show_mouse_face (dpyinfo, draw);\n      dpyinfo->mouse_face_image_state = draw;\n    }\n\n " (span (|@| (class "constant") (id "F:331774")) "set_help_echo") ":\n\n  " (span (|@| (class "comment-delimiter") (id "F:331792")) "/* ") (span (|@| (class "comment") (id "F:331795")) "Set help_echo_string to a help string to display for this tool-bar item.\n     XTread_socket does the rest.  ") (span (|@| (class "comment-delimiter") (id "F:331903")) "*/") "\n  help_echo_object = help_echo_window = Qnil;\n  help_echo_pos = -1;\n  help_echo_string = AREF (f->tool_bar_items, prop_idx + TOOL_BAR_ITEM_HELP);\n  " (span (|@| (class "keyword") (id "F:332054")) "if") " (NILP (help_echo_string))\n    help_echo_string = AREF (f->tool_bar_items, prop_idx + TOOL_BAR_ITEM_CAPTION);\n}\n\n" (span (|@| (class "preprocessor") (id "F:332169")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:332176")) "/* ") (span (|@| (class "comment") (id "F:332179")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:332198")) "*/") "\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:332205")) "/************************************************************************") (span (|@| (class "comment") (id "F:332278")) "\n                         Horizontal scrolling\n ***********************************************************************") (span (|@| (class "comment-delimiter") (id "F:332376")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:332380")) "static") " " (span (|@| (class "type") (id "F:332387")) "int") " " (span (|@| (class "function-name") (id "F:332391")) "hscroll_window_tree") " P_ ((Lisp_Object));\n" (span (|@| (class "keyword") (id "F:332431")) "static") " " (span (|@| (class "type") (id "F:332438")) "int") " " (span (|@| (class "function-name") (id "F:332442")) "hscroll_windows") " P_ ((Lisp_Object));\n\n" (span (|@| (class "comment-delimiter") (id "F:332479")) "/* ") (span (|@| (class "comment") (id "F:332482")) "For all leaf windows in the window tree rooted at WINDOW, set their\n   hscroll value so that PT is (i) visible in the window, and (ii) so\n   that it is not within a certain margin at the window's left and\n   right border.  Value is non-zero if any window's hscroll has been\n   changed.  ") (span (|@| (class "comment-delimiter") (id "F:332769")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:332773")) "static") " " (span (|@| (class "type") (id "F:332780")) "int") "\n" (span (|@| (class "function-name") (id "F:332784")) "hscroll_window_tree") " (" (span (|@| (class "type") (id "F:332805")) "window") ")\n     " (span (|@| (class "type") (id "F:332818")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:332830")) "window") ";\n{\n  " (span (|@| (class "type") (id "F:332842")) "int") " " (span (|@| (class "variable-name") (id "F:332846")) "hscrolled_p") " = 0;\n  " (span (|@| (class "type") (id "F:332865")) "int") " " (span (|@| (class "variable-name") (id "F:332869")) "hscroll_relative_p") " = FLOATP (Vhscroll_step);\n  " (span (|@| (class "type") (id "F:332916")) "int") " " (span (|@| (class "variable-name") (id "F:332920")) "hscroll_step_abs") " = 0;\n  " (span (|@| (class "type") (id "F:332944")) "double") " " (span (|@| (class "variable-name") (id "F:332951")) "hscroll_step_rel") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:332976")) "if") " (hscroll_relative_p)\n    {\n      hscroll_step_rel = XFLOAT_DATA (Vhscroll_step);\n      " (span (|@| (class "keyword") (id "F:333066")) "if") " (hscroll_step_rel < 0)\n        {\n          hscroll_relative_p = 0;\n          hscroll_step_abs = 0;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:333158")) "else") " " (span (|@| (class "keyword") (id "F:333163")) "if") " (INTEGERP (Vhscroll_step))\n    {\n      hscroll_step_abs = XINT (Vhscroll_step);\n      " (span (|@| (class "keyword") (id "F:333252")) "if") " (hscroll_step_abs < 0)\n        hscroll_step_abs = 0;\n    }\n  " (span (|@| (class "keyword") (id "F:333309")) "else") "\n    hscroll_step_abs = 0;\n\n  " (span (|@| (class "keyword") (id "F:333343")) "while") " (WINDOWP (window))\n    {\n      " (span (|@| (class "keyword") (id "F:333380")) "struct") " " (span (|@| (class "type") (id "F:333387")) "window") " *" (span (|@| (class "variable-name") (id "F:333395")) "w") " = XWINDOW (window);\n\n      " (span (|@| (class "keyword") (id "F:333424")) "if") " (WINDOWP (w->hchild))\n        hscrolled_p |= hscroll_window_tree (w->hchild);\n      " (span (|@| (class "keyword") (id "F:333504")) "else") " " (span (|@| (class "keyword") (id "F:333509")) "if") " (WINDOWP (w->vchild))\n        hscrolled_p |= hscroll_window_tree (w->vchild);\n      " (span (|@| (class "keyword") (id "F:333589")) "else") " " (span (|@| (class "keyword") (id "F:333594")) "if") " (w->cursor.vpos >= 0)\n        {\n          " (span (|@| (class "type") (id "F:333625")) "int") " " (span (|@| (class "variable-name") (id "F:333629")) "h_margin") ";\n          " (span (|@| (class "type") (id "F:333642")) "int") " " (span (|@| (class "variable-name") (id "F:333646")) "text_area_width") ";\n          " (span (|@| (class "keyword") (id "F:333666")) "struct") " " (span (|@| (class "type") (id "F:333673")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:333684")) "current_cursor_row") "\n            = MATRIX_ROW (w->current_matrix, w->cursor.vpos);\n          " (span (|@| (class "keyword") (id "F:333761")) "struct") " " (span (|@| (class "type") (id "F:333768")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:333779")) "desired_cursor_row") "\n            = MATRIX_ROW (w->desired_matrix, w->cursor.vpos);\n          " (span (|@| (class "keyword") (id "F:333856")) "struct") " " (span (|@| (class "type") (id "F:333863")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:333874")) "cursor_row") "\n            = (desired_cursor_row->enabled_p\n               ? desired_cursor_row\n               : current_cursor_row);\n\n          text_area_width = window_box_width (w, TEXT_AREA);\n\n          " (span (|@| (class "comment-delimiter") (id "F:334042")) "/* ") (span (|@| (class "comment") (id "F:334045")) "Scroll when cursor is inside this scroll margin.  ") (span (|@| (class "comment-delimiter") (id "F:334095")) "*/") "\n          h_margin = hscroll_margin * WINDOW_FRAME_COLUMN_WIDTH (w);\n\n          " (span (|@| (class "keyword") (id "F:334164")) "if") " (" (span (|@| (class "negation-char") (id "F:334168")) "!") "NILP (Fbuffer_local_value (Qauto_hscroll_mode, w->buffer))\n              && ((XFASTINT (w->hscroll)\n                   && w->cursor.x <= h_margin)\n                  || (cursor_row->enabled_p\n                      && cursor_row->truncated_on_right_p\n                      && (w->cursor.x >= text_area_width - h_margin))))\n            {\n              " (span (|@| (class "keyword") (id "F:334441")) "struct") " " (span (|@| (class "type") (id "F:334448")) "it") " " (span (|@| (class "variable-name") (id "F:334451")) "it") ";\n              " (span (|@| (class "type") (id "F:334462")) "int") " " (span (|@| (class "variable-name") (id "F:334466")) "hscroll") ";\n              " (span (|@| (class "keyword") (id "F:334482")) "struct") " " (span (|@| (class "type") (id "F:334489")) "buffer") " *" (span (|@| (class "variable-name") (id "F:334497")) "saved_current_buffer") ";\n              " (span (|@| (class "type") (id "F:334526")) "int") " " (span (|@| (class "variable-name") (id "F:334530")) "pt") ";\n              " (span (|@| (class "type") (id "F:334541")) "int") " " (span (|@| (class "variable-name") (id "F:334545")) "wanted_x") ";\n\n              " (span (|@| (class "comment-delimiter") (id "F:334563")) "/* ") (span (|@| (class "comment") (id "F:334566")) "Find point in a display of infinite width.  ") (span (|@| (class "comment-delimiter") (id "F:334610")) "*/") "\n              saved_current_buffer = current_buffer;\n              current_buffer = XBUFFER (w->buffer);\n\n              " (span (|@| (class "keyword") (id "F:334712")) "if") " (w == XWINDOW (selected_window))\n                pt = BUF_PT (current_buffer);\n              " (span (|@| (class "keyword") (id "F:334787")) "else") "\n                {\n                  pt = marker_position (w->pointm);\n                  pt = max (BEGV, pt);\n                  pt = min (ZV, pt);\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:334894")) "/* ") (span (|@| (class "comment") (id "F:334897")) "Move iterator to pt starting at cursor_row->start in\n                 a line with infinite width.  ") (span (|@| (class "comment-delimiter") (id "F:334982")) "*/") "\n              init_to_row_start (&it, w, cursor_row);\n              it.last_visible_x = INFINITY;\n              move_it_in_display_line_to (&it, pt, -1, MOVE_TO_POS);\n              current_buffer = saved_current_buffer;\n\n              " (span (|@| (class "comment-delimiter") (id "F:335185")) "/* ") (span (|@| (class "comment") (id "F:335188")) "Position cursor in window.  ") (span (|@| (class "comment-delimiter") (id "F:335216")) "*/") "\n              " (span (|@| (class "keyword") (id "F:335226")) "if") " (" (span (|@| (class "negation-char") (id "F:335230")) "!") "hscroll_relative_p && hscroll_step_abs == 0)\n                hscroll = max (0, (it.current_x\n                                   - (ITERATOR_AT_END_OF_LINE_P (&it)\n                                      ? (text_area_width - 4 * FRAME_COLUMN_WIDTH (it.f))\n                                      : (text_area_width / 2))))\n                          / FRAME_COLUMN_WIDTH (it.f);\n              " (span (|@| (class "keyword") (id "F:335496")) "else") " " (span (|@| (class "keyword") (id "F:335501")) "if") " (w->cursor.x >= text_area_width - h_margin)\n                {\n                  " (span (|@| (class "keyword") (id "F:335556")) "if") " (hscroll_relative_p)\n                    wanted_x = text_area_width * (1 - hscroll_step_rel)\n                               - h_margin;\n                  " (span (|@| (class "keyword") (id "F:335670")) "else") "\n                    wanted_x = text_area_width\n                               - hscroll_step_abs * FRAME_COLUMN_WIDTH (it.f)\n                               - h_margin;\n                  hscroll\n                    = max (0, it.current_x - wanted_x) / FRAME_COLUMN_WIDTH (it.f);\n                }\n              " (span (|@| (class "keyword") (id "F:335892")) "else") "\n                {\n                  " (span (|@| (class "keyword") (id "F:335905")) "if") " (hscroll_relative_p)\n                    wanted_x = text_area_width * hscroll_step_rel\n                               + h_margin;\n                  " (span (|@| (class "keyword") (id "F:336013")) "else") "\n                    wanted_x = hscroll_step_abs * FRAME_COLUMN_WIDTH (it.f)\n                               + h_margin;\n                  hscroll\n                    = max (0, it.current_x - wanted_x) / FRAME_COLUMN_WIDTH (it.f);\n                }\n              hscroll = max (hscroll, XFASTINT (w->min_hscroll));\n\n              " (span (|@| (class "comment-delimiter") (id "F:336261")) "/* ") (span (|@| (class "comment") (id "F:336264")) "Don't call Fset_window_hscroll if value hasn't\n                 changed because it will prevent redisplay\n                 optimizations.  ") (span (|@| (class "comment-delimiter") (id "F:336375")) "*/") "\n              " (span (|@| (class "keyword") (id "F:336385")) "if") " (XFASTINT (w->hscroll) != hscroll)\n                {\n                  XBUFFER (w->buffer)->prevent_redisplay_optimizations_p = 1;\n                  w->hscroll = make_number (hscroll);\n                  hscrolled_p = 1;\n                }\n            }\n        }\n\n      window = w->next;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:336600")) "/* ") (span (|@| (class "comment") (id "F:336603")) "Value is non-zero if hscroll of any leaf window has been changed.  ") (span (|@| (class "comment-delimiter") (id "F:336670")) "*/") "\n  " (span (|@| (class "keyword") (id "F:336675")) "return") " hscrolled_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:336699")) "/* ") (span (|@| (class "comment") (id "F:336702")) "Set hscroll so that cursor is visible and not inside horizontal\n   scroll margins for all windows in the tree rooted at WINDOW.  See\n   also hscroll_window_tree above.  Value is non-zero if any window's\n   hscroll has been changed.  If it has, desired matrices on the frame\n   of WINDOW are cleared.  ") (span (|@| (class "comment-delimiter") (id "F:337003")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:337007")) "static") " " (span (|@| (class "type") (id "F:337014")) "int") "\n" (span (|@| (class "function-name") (id "F:337018")) "hscroll_windows") " (" (span (|@| (class "type") (id "F:337035")) "window") ")\n     " (span (|@| (class "type") (id "F:337048")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:337060")) "window") ";\n{\n  " (span (|@| (class "type") (id "F:337072")) "int") " " (span (|@| (class "variable-name") (id "F:337076")) "hscrolled_p") " = hscroll_window_tree (window);\n  " (span (|@| (class "keyword") (id "F:337122")) "if") " (hscrolled_p)\n    clear_desired_matrices (XFRAME (WINDOW_FRAME (XWINDOW (window))));\n  " (span (|@| (class "keyword") (id "F:337212")) "return") " hscrolled_p;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:337238")) "/************************************************************************") (span (|@| (class "comment") (id "F:337311")) "\n                                Redisplay\n ***********************************************************************") (span (|@| (class "comment-delimiter") (id "F:337398")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:337402")) "/* ") (span (|@| (class "comment") (id "F:337405")) "Variables holding some state of redisplay if GLYPH_DEBUG is defined\n   to a non-zero value.  This is sometimes handy to have in a debugger\n   session.  ") (span (|@| (class "comment-delimiter") (id "F:337557")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:337561")) "#if") " GLYPH_DEBUG\n\n" (span (|@| (class "comment-delimiter") (id "F:337578")) "/* ") (span (|@| (class "comment") (id "F:337581")) "First and last unchanged row for try_window_id.  ") (span (|@| (class "comment-delimiter") (id "F:337630")) "*/") "\n\n" (span (|@| (class "type") (id "F:337634")) "int") " " (span (|@| (class "variable-name") (id "F:337638")) "debug_first_unchanged_at_end_vpos") ";\n" (span (|@| (class "type") (id "F:337673")) "int") " " (span (|@| (class "variable-name") (id "F:337677")) "debug_last_unchanged_at_beg_vpos") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:337712")) "/* ") (span (|@| (class "comment") (id "F:337715")) "Delta vpos and y.  ") (span (|@| (class "comment-delimiter") (id "F:337734")) "*/") "\n\n" (span (|@| (class "type") (id "F:337738")) "int") " " (span (|@| (class "variable-name") (id "F:337742")) "debug_dvpos") ", " (span (|@| (class "variable-name") (id "F:337755")) "debug_dy") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:337766")) "/* ") (span (|@| (class "comment") (id "F:337769")) "Delta in characters and bytes for try_window_id.  ") (span (|@| (class "comment-delimiter") (id "F:337819")) "*/") "\n\n" (span (|@| (class "type") (id "F:337823")) "int") " " (span (|@| (class "variable-name") (id "F:337827")) "debug_delta") ", " (span (|@| (class "variable-name") (id "F:337840")) "debug_delta_bytes") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:337860")) "/* ") (span (|@| (class "comment") (id "F:337863")) "Values of window_end_pos and window_end_vpos at the end of\n   try_window_id.  ") (span (|@| (class "comment-delimiter") (id "F:337941")) "*/") "\n\n" (span (|@| (class "type") (id "F:337945")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:337955")) "debug_end_pos") ", " (span (|@| (class "variable-name") (id "F:337970")) "debug_end_vpos") ";\n\n" (span (|@| (class "comment-delimiter") (id "F:337987")) "/* ") (span (|@| (class "comment") (id "F:337990")) "Append a string to W->desired_matrix->method.  FMT is a printf\n   format string.  A1...A9 are a supplement for a variable-length\n   argument list.  If trace_redisplay_p is non-zero also printf the\n   resulting string to stderr.  ") (span (|@| (class "comment-delimiter") (id "F:338219")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:338223")) "static") " " (span (|@| (class "type") (id "F:338230")) "void") "\n" (span (|@| (class "function-name") (id "F:338235")) "debug_method_add") " (w, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9)\n     " (span (|@| (class "keyword") (id "F:338302")) "struct") " " (span (|@| (class "type") (id "F:338309")) "window") " *" (span (|@| (class "variable-name") (id "F:338317")) "w") ";\n     " (span (|@| (class "type") (id "F:338325")) "char") " *" (span (|@| (class "variable-name") (id "F:338331")) "fmt") ";\n     " (span (|@| (class "type") (id "F:338341")) "int") " " (span (|@| (class "variable-name") (id "F:338345")) "a1") ", " (span (|@| (class "variable-name") (id "F:338349")) "a2") ", " (span (|@| (class "variable-name") (id "F:338353")) "a3") ", " (span (|@| (class "variable-name") (id "F:338357")) "a4") ", " (span (|@| (class "variable-name") (id "F:338361")) "a5") ", " (span (|@| (class "variable-name") (id "F:338365")) "a6") ", " (span (|@| (class "variable-name") (id "F:338369")) "a7") ", " (span (|@| (class "variable-name") (id "F:338373")) "a8") ", " (span (|@| (class "variable-name") (id "F:338377")) "a9") ";\n{\n  " (span (|@| (class "type") (id "F:338385")) "char") " " (span (|@| (class "variable-name") (id "F:338390")) "buffer") "[512];\n  " (span (|@| (class "type") (id "F:338405")) "char") " *" (span (|@| (class "variable-name") (id "F:338411")) "method") " = w->desired_matrix->method;\n  " (span (|@| (class "type") (id "F:338449")) "int") " " (span (|@| (class "variable-name") (id "F:338453")) "len") " = strlen (method);\n  " (span (|@| (class "type") (id "F:338478")) "int") " " (span (|@| (class "variable-name") (id "F:338482")) "size") " = " (span (|@| (class "keyword") (id "F:338489")) "sizeof") " w->desired_matrix->method;\n  " (span (|@| (class "type") (id "F:338525")) "int") " " (span (|@| (class "variable-name") (id "F:338529")) "remaining") " = size - len - 1;\n\n  sprintf (buffer, fmt, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n  " (span (|@| (class "keyword") (id "F:338621")) "if") " (len && remaining)\n    {\n      method[len] = " (span (|@| (class "string") (id "F:338669")) "'|'") ";\n      --remaining, ++len;\n    }\n\n  strncpy (method + len, buffer, remaining);\n\n  " (span (|@| (class "keyword") (id "F:338755")) "if") " (trace_redisplay_p)\n    fprintf (stderr, " (span (|@| (class "string") (id "F:338799")) "\"%p (%s): %s\\n\"") ",\n             w,\n             ((BUFFERP (w->buffer)\n               && STRINGP (XBUFFER (w->buffer)->name))\n              ? (" (span (|@| (class "type") (id "F:338911")) "char") " *) SDATA (XBUFFER (w->buffer)->name)\n              : " (span (|@| (class "string") (id "F:338962")) "\"no buffer\"") "),\n             buffer);\n}\n\n" (span (|@| (class "preprocessor") (id "F:338994")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:339001")) "/* ") (span (|@| (class "comment") (id "F:339004")) "GLYPH_DEBUG ") (span (|@| (class "comment-delimiter") (id "F:339016")) "*/") "\n\n\n" (span (|@| (class "comment-delimiter") (id "F:339021")) "/* ") (span (|@| (class "comment") (id "F:339024")) "Value is non-zero if all changes in window W, which displays\n   current_buffer, are in the text between START and END.  START is a\n   buffer position, END is given as a distance from Z.  Used in\n   redisplay_internal for display optimization.  ") (span (|@| (class "comment-delimiter") (id "F:339268")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:339272")) "static") " INLINE " (span (|@| (class "type") (id "F:339286")) "int") "\n" (span (|@| (class "function-name") (id "F:339290")) "text_outside_line_unchanged_p") " (w, start, end)\n     " (span (|@| (class "keyword") (id "F:339341")) "struct") " " (span (|@| (class "type") (id "F:339348")) "window") " *" (span (|@| (class "variable-name") (id "F:339356")) "w") ";\n     " (span (|@| (class "type") (id "F:339364")) "int") " " (span (|@| (class "variable-name") (id "F:339368")) "start") ", " (span (|@| (class "variable-name") (id "F:339375")) "end") ";\n{\n  " (span (|@| (class "type") (id "F:339384")) "int") " " (span (|@| (class "variable-name") (id "F:339388")) "unchanged_p") " = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:339408")) "/* ") (span (|@| (class "comment") (id "F:339411")) "If text or overlays have changed, see where.  ") (span (|@| (class "comment-delimiter") (id "F:339457")) "*/") "\n  " (span (|@| (class "keyword") (id "F:339462")) "if") " (XFASTINT (w->last_modified) < MODIFF\n      || XFASTINT (w->last_overlay_modified) < OVERLAY_MODIFF)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:339578")) "/* ") (span (|@| (class "comment") (id "F:339581")) "Gap in the line?  ") (span (|@| (class "comment-delimiter") (id "F:339599")) "*/") "\n      " (span (|@| (class "keyword") (id "F:339608")) "if") " (GPT < start || Z - GPT < end)\n        unchanged_p = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:339667")) "/* ") (span (|@| (class "comment") (id "F:339670")) "Changes start in front of the line, or end after it?  ") (span (|@| (class "comment-delimiter") (id "F:339724")) "*/") "\n      " (span (|@| (class "keyword") (id "F:339733")) "if") " (unchanged_p\n          && (BEG_UNCHANGED < start - 1\n              || END_UNCHANGED < end))\n        unchanged_p = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:339839")) "/* ") (span (|@| (class "comment") (id "F:339842")) "If selective display, can't optimize if changes start at the\n         beginning of the line.  ") (span (|@| (class "comment-delimiter") (id "F:339929")) "*/") "\n      " (span (|@| (class "keyword") (id "F:339938")) "if") " (unchanged_p\n          && INTEGERP (current_buffer->selective_display)\n          && XINT (current_buffer->selective_display) > 0\n          && (BEG_UNCHANGED < start || GPT <= start))\n        unchanged_p = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:340128")) "/* ") (span (|@| (class "comment") (id "F:340131")) "If there are overlays at the start or end of the line, these\n         may have overlay strings with newlines in them.  A change at\n         START, for instance, may actually concern the display of such\n         overlay strings as well, and they are displayed on different\n         lines.  So, quickly rule out this case.  (For the future, it\n         might be desirable to implement something more telling than\n         just BEG/END_UNCHANGED.)  ") (span (|@| (class "comment-delimiter") (id "F:340535")) "*/") "\n      " (span (|@| (class "keyword") (id "F:340544")) "if") " (unchanged_p)\n        {\n          " (span (|@| (class "keyword") (id "F:340567")) "if") " (BEG + BEG_UNCHANGED == start\n              && overlay_touches_p (start))\n            unchanged_p = 0;\n          " (span (|@| (class "keyword") (id "F:340662")) "if") " (END_UNCHANGED == end\n              && overlay_touches_p (Z - end))\n            unchanged_p = 0;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:340758")) "/* ") (span (|@| (class "comment") (id "F:340761")) "Under bidi reordering, adding or deleting a character in the\n         beginning of a paragraph, before the first strong directional\n         character, can change the base direction of the paragraph (unless\n         the buffer specifies a fixed paragraph direction), which will\n         require to redisplay the whole paragraph.  It might be worthwhile\n         to find the paragraph limits and widen the range of redisplayed\n         lines to that, but for now just give up this optimization.  ") (span (|@| (class "comment-delimiter") (id "F:341214")) "*/") "\n      " (span (|@| (class "keyword") (id "F:341223")) "if") " (" (span (|@| (class "negation-char") (id "F:341227")) "!") "NILP (XBUFFER (w->buffer)->bidi_display_reordering)\n          && NILP (XBUFFER (w->buffer)->bidi_paragraph_direction))\n        unchanged_p = 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:341367")) "return") " unchanged_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:341391")) "/* ") (span (|@| (class "comment") (id "F:341394")) "Do a frame update, taking possible shortcuts into account.  This is\n   the main external entry point for redisplay.\n\n   If the last redisplay displayed an echo area message and that message\n   is no longer requested, we clear the echo area or bring back the\n   mini-buffer if that is in use.  ") (span (|@| (class "comment-delimiter") (id "F:341687")) "*/") "\n\n" (span (|@| (class "type") (id "F:341691")) "void") "\n" (span (|@| (class "function-name") (id "F:341696")) "redisplay") " ()\n{\n  redisplay_internal (0);\n}\n\n\n" (span (|@| (class "keyword") (id "F:341741")) "static") " " (span (|@| (class "type") (id "F:341748")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:341760")) "overlay_arrow_string_or_property") " (var)\n     " (span (|@| (class "type") (id "F:341804")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:341816")) "var") ";\n{\n  " (span (|@| (class "type") (id "F:341825")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:341837")) "val") ";\n\n  " (span (|@| (class "keyword") (id "F:341845")) "if") " (val = Fget (var, Qoverlay_arrow_string), STRINGP (val))\n    " (span (|@| (class "keyword") (id "F:341909")) "return") " val;\n\n  " (span (|@| (class "keyword") (id "F:341924")) "return") " Voverlay_arrow_string;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:341957")) "/* ") (span (|@| (class "comment") (id "F:341960")) "Return 1 if there are any overlay-arrows in current_buffer.  ") (span (|@| (class "comment-delimiter") (id "F:342021")) "*/") "\n" (span (|@| (class "keyword") (id "F:342024")) "static") " " (span (|@| (class "type") (id "F:342031")) "int") "\n" (span (|@| (class "function-name") (id "F:342035")) "overlay_arrow_in_current_buffer_p") " ()\n{\n  " (span (|@| (class "type") (id "F:342076")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:342088")) "vlist") ";\n\n  " (span (|@| (class "keyword") (id "F:342098")) "for") " (vlist = Voverlay_arrow_variable_list;\n       CONSP (vlist);\n       vlist = XCDR (vlist))\n    {\n      " (span (|@| (class "type") (id "F:342204")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:342216")) "var") " = XCAR (vlist);\n      " (span (|@| (class "type") (id "F:342242")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:342254")) "val") ";\n\n      " (span (|@| (class "keyword") (id "F:342266")) "if") " (" (span (|@| (class "negation-char") (id "F:342270")) "!") "SYMBOLP (var))\n        " (span (|@| (class "keyword") (id "F:342287")) "continue") ";\n      val = find_symbol_value (var);\n      " (span (|@| (class "keyword") (id "F:342340")) "if") " (MARKERP (val)\n          && current_buffer == XMARKER (val)->buffer)\n        " (span (|@| (class "keyword") (id "F:342406")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:342424")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:342438")) "/* ") (span (|@| (class "comment") (id "F:342441")) "Return 1 if any overlay_arrows have moved or overlay-arrow-string\n   has changed.  ") (span (|@| (class "comment-delimiter") (id "F:342524")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:342528")) "static") " " (span (|@| (class "type") (id "F:342535")) "int") "\n" (span (|@| (class "function-name") (id "F:342539")) "overlay_arrows_changed_p") " ()\n{\n  " (span (|@| (class "type") (id "F:342571")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:342583")) "vlist") ";\n\n  " (span (|@| (class "keyword") (id "F:342593")) "for") " (vlist = Voverlay_arrow_variable_list;\n       CONSP (vlist);\n       vlist = XCDR (vlist))\n    {\n      " (span (|@| (class "type") (id "F:342699")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:342711")) "var") " = XCAR (vlist);\n      " (span (|@| (class "type") (id "F:342737")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:342749")) "val") ", " (span (|@| (class "variable-name") (id "F:342754")) "pstr") ";\n\n      " (span (|@| (class "keyword") (id "F:342767")) "if") " (" (span (|@| (class "negation-char") (id "F:342771")) "!") "SYMBOLP (var))\n        " (span (|@| (class "keyword") (id "F:342788")) "continue") ";\n      val = find_symbol_value (var);\n      " (span (|@| (class "keyword") (id "F:342841")) "if") " (" (span (|@| (class "negation-char") (id "F:342845")) "!") "MARKERP (val))\n        " (span (|@| (class "keyword") (id "F:342862")) "continue") ";\n      " (span (|@| (class "keyword") (id "F:342878")) "if") " (" (span (|@| (class "negation-char") (id "F:342882")) "!") " EQ (COERCE_MARKER (val),\n                Fget (var, Qlast_arrow_position))\n          || " (span (|@| (class "negation-char") (id "F:342951")) "!") " (pstr = overlay_arrow_string_or_property (var),\n                EQ (pstr, Fget (var, Qlast_arrow_string))))\n        " (span (|@| (class "keyword") (id "F:343048")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:343066")) "return") " 0;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:343079")) "/* ") (span (|@| (class "comment") (id "F:343082")) "Mark overlay arrows to be updated on next redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:343136")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:343140")) "static") " " (span (|@| (class "type") (id "F:343147")) "void") "\n" (span (|@| (class "function-name") (id "F:343152")) "update_overlay_arrows") " (up_to_date)\n     " (span (|@| (class "type") (id "F:343192")) "int") " " (span (|@| (class "variable-name") (id "F:343196")) "up_to_date") ";\n{\n  " (span (|@| (class "type") (id "F:343212")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:343224")) "vlist") ";\n\n  " (span (|@| (class "keyword") (id "F:343234")) "for") " (vlist = Voverlay_arrow_variable_list;\n       CONSP (vlist);\n       vlist = XCDR (vlist))\n    {\n      " (span (|@| (class "type") (id "F:343340")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:343352")) "var") " = XCAR (vlist);\n\n      " (span (|@| (class "keyword") (id "F:343379")) "if") " (" (span (|@| (class "negation-char") (id "F:343383")) "!") "SYMBOLP (var))\n        " (span (|@| (class "keyword") (id "F:343400")) "continue") ";\n\n      " (span (|@| (class "keyword") (id "F:343417")) "if") " (up_to_date > 0)\n        {\n          " (span (|@| (class "type") (id "F:343443")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:343455")) "val") " = find_symbol_value (var);\n          Fput (var, Qlast_arrow_position,\n                COERCE_MARKER (val));\n          Fput (var, Qlast_arrow_string,\n                overlay_arrow_string_or_property (var));\n        }\n      " (span (|@| (class "keyword") (id "F:343632")) "else") " " (span (|@| (class "keyword") (id "F:343637")) "if") " (up_to_date < 0\n               || " (span (|@| (class "negation-char") (id "F:343667")) "!") "NILP (Fget (var, Qlast_arrow_position)))\n        {\n          Fput (var, Qlast_arrow_position, Qt);\n          Fput (var, Qlast_arrow_string, Qt);\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:343805")) "/* ") (span (|@| (class "comment") (id "F:343808")) "Return overlay arrow string to display at row.\n   Return integer (bitmap number) for arrow bitmap in left fringe.\n   Return nil if no overlay arrow.  ") (span (|@| (class "comment-delimiter") (id "F:343958")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:343962")) "static") " " (span (|@| (class "type") (id "F:343969")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:343981")) "overlay_arrow_at_row") " (" (span (|@| (class "type") (id "F:344003")) "it") ", row)\n     " (span (|@| (class "keyword") (id "F:344017")) "struct") " " (span (|@| (class "type") (id "F:344024")) "it") " *" (span (|@| (class "variable-name") (id "F:344028")) "it") ";\n     " (span (|@| (class "keyword") (id "F:344037")) "struct") " " (span (|@| (class "type") (id "F:344044")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:344055")) "row") ";\n{\n  " (span (|@| (class "type") (id "F:344064")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:344076")) "vlist") ";\n\n  " (span (|@| (class "keyword") (id "F:344086")) "for") " (vlist = Voverlay_arrow_variable_list;\n       CONSP (vlist);\n       vlist = XCDR (vlist))\n    {\n      " (span (|@| (class "type") (id "F:344192")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:344204")) "var") " = XCAR (vlist);\n      " (span (|@| (class "type") (id "F:344230")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:344242")) "val") ";\n\n      " (span (|@| (class "keyword") (id "F:344254")) "if") " (" (span (|@| (class "negation-char") (id "F:344258")) "!") "SYMBOLP (var))\n        " (span (|@| (class "keyword") (id "F:344275")) "continue") ";\n\n      val = find_symbol_value (var);\n\n      " (span (|@| (class "keyword") (id "F:344330")) "if") " (MARKERP (val)\n          && current_buffer == XMARKER (val)->buffer\n          && (MATRIX_ROW_START_CHARPOS (row) == marker_position (val)))\n        {\n          " (span (|@| (class "keyword") (id "F:344465")) "if") " (FRAME_WINDOW_P (it->f)\n              && WINDOW_LEFT_FRINGE_WIDTH (it->w) > 0)\n            {\n" (span (|@| (class "preprocessor") (id "F:344547")) "#ifdef") " HAVE_WINDOW_SYSTEM\n              " (span (|@| (class "keyword") (id "F:344580")) "if") " (val = Fget (var, Qoverlay_arrow_bitmap), SYMBOLP (val))\n                {\n                  " (span (|@| (class "type") (id "F:344648")) "int") " " (span (|@| (class "variable-name") (id "F:344652")) "fringe_bitmap") ";\n                  " (span (|@| (class "keyword") (id "F:344671")) "if") " ((fringe_bitmap = lookup_fringe_bitmap (val)) != 0)\n                    " (span (|@| (class "keyword") (id "F:344732")) "return") " make_number (fringe_bitmap);\n                }\n" (span (|@| (class "preprocessor") (id "F:344772")) "#endif") "\n              " (span (|@| (class "keyword") (id "F:344786")) "return") " make_number (-1); " (span (|@| (class "comment-delimiter") (id "F:344811")) "/* ") (span (|@| (class "comment") (id "F:344814")) "Use default arrow bitmap ") (span (|@| (class "comment-delimiter") (id "F:344839")) "*/") "\n            }\n          " (span (|@| (class "keyword") (id "F:344852")) "return") " overlay_arrow_string_or_property (var);\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:344911")) "return") " Qnil;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:344927")) "/* ") (span (|@| (class "comment") (id "F:344930")) "Return 1 if point moved out of or into a composition.  Otherwise\n   return 0.  PREV_BUF and PREV_PT are the last point buffer and\n   position.  BUF and PT are the current point buffer and position.  ") (span (|@| (class "comment-delimiter") (id "F:345129")) "*/") "\n\n" (span (|@| (class "type") (id "F:345133")) "int") "\n" (span (|@| (class "function-name") (id "F:345137")) "check_point_in_composition") " (prev_buf, prev_pt, buf, pt)\n     " (span (|@| (class "keyword") (id "F:345198")) "struct") " " (span (|@| (class "type") (id "F:345205")) "buffer") " *" (span (|@| (class "variable-name") (id "F:345213")) "prev_buf") ", *" (span (|@| (class "variable-name") (id "F:345224")) "buf") ";\n     " (span (|@| (class "type") (id "F:345234")) "int") " " (span (|@| (class "variable-name") (id "F:345238")) "prev_pt") ", " (span (|@| (class "variable-name") (id "F:345247")) "pt") ";\n{\n  " (span (|@| (class "type") (id "F:345255")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:345265")) "start") ", " (span (|@| (class "variable-name") (id "F:345272")) "end") ";\n  " (span (|@| (class "type") (id "F:345279")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:345291")) "prop") ";\n  " (span (|@| (class "type") (id "F:345299")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:345311")) "buffer") ";\n\n  XSETBUFFER (buffer, buf);\n  " (span (|@| (class "comment-delimiter") (id "F:345350")) "/* ") (span (|@| (class "comment") (id "F:345353")) "Check a composition at the last point if point moved within the\n     same buffer.  ") (span (|@| (class "comment-delimiter") (id "F:345436")) "*/") "\n  " (span (|@| (class "keyword") (id "F:345441")) "if") " (prev_buf == buf)\n    {\n      " (span (|@| (class "keyword") (id "F:345474")) "if") " (prev_pt == pt)\n        " (span (|@| (class "comment-delimiter") (id "F:345494")) "/* ") (span (|@| (class "comment") (id "F:345497")) "Point didn't move.  ") (span (|@| (class "comment-delimiter") (id "F:345517")) "*/") "\n        " (span (|@| (class "keyword") (id "F:345521")) "return") " 0;\n\n      " (span (|@| (class "keyword") (id "F:345538")) "if") " (prev_pt > BUF_BEGV (buf) && prev_pt < BUF_ZV (buf)\n          && find_composition (prev_pt, -1, &start, &end, &prop, buffer)\n          && COMPOSITION_VALID_P (start, end, prop)\n          && start < prev_pt && end > prev_pt)\n        " (span (|@| (class "comment-delimiter") (id "F:345745")) "/* ") (span (|@| (class "comment") (id "F:345748")) "The last point was within the composition.  Return 1 iff\n            point moved out of the composition.  ") (span (|@| (class "comment-delimiter") (id "F:345854")) "*/") "\n        " (span (|@| (class "keyword") (id "F:345858")) "return") " (pt <= start || pt >= end);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:345902")) "/* ") (span (|@| (class "comment") (id "F:345905")) "Check a composition at the current point.  ") (span (|@| (class "comment-delimiter") (id "F:345948")) "*/") "\n  " (span (|@| (class "keyword") (id "F:345953")) "return") " (pt > BUF_BEGV (buf) && pt < BUF_ZV (buf)\n          && find_composition (pt, -1, &start, &end, &prop, buffer)\n          && COMPOSITION_VALID_P (start, end, prop)\n          && start < pt && end > pt);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:346143")) "/* ") (span (|@| (class "comment") (id "F:346146")) "Reconsider the setting of B->clip_changed which is displayed\n   in window W.  ") (span (|@| (class "comment-delimiter") (id "F:346224")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:346228")) "static") " INLINE " (span (|@| (class "type") (id "F:346242")) "void") "\n" (span (|@| (class "function-name") (id "F:346247")) "reconsider_clip_changes") " (w, b)\n     " (span (|@| (class "keyword") (id "F:346283")) "struct") " " (span (|@| (class "type") (id "F:346290")) "window") " *" (span (|@| (class "variable-name") (id "F:346298")) "w") ";\n     " (span (|@| (class "keyword") (id "F:346306")) "struct") " " (span (|@| (class "type") (id "F:346313")) "buffer") " *" (span (|@| (class "variable-name") (id "F:346321")) "b") ";\n{\n  " (span (|@| (class "keyword") (id "F:346328")) "if") " (b->clip_changed\n           && " (span (|@| (class "negation-char") (id "F:346355")) "!") "NILP (w->window_end_valid)\n           && w->current_matrix->buffer == b\n           && w->current_matrix->zv == BUF_ZV (b)\n           && w->current_matrix->begv == BUF_BEGV (b))\n    b->clip_changed = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:346540")) "/* ") (span (|@| (class "comment") (id "F:346543")) "If display wasn't paused, and W is not a tool bar window, see if\n     point has been moved into or out of a composition.  In that case,\n     we set b->clip_changed to 1 to force updating the screen.  If\n     b->clip_changed has already been set to 1, we can skip this\n     check.  ") (span (|@| (class "comment-delimiter") (id "F:346824")) "*/") "\n  " (span (|@| (class "keyword") (id "F:346829")) "if") " (" (span (|@| (class "negation-char") (id "F:346833")) "!") "b->clip_changed\n      && BUFFERP (w->buffer) && " (span (|@| (class "negation-char") (id "F:346882")) "!") "NILP (w->window_end_valid))\n    {\n      " (span (|@| (class "type") (id "F:346923")) "int") " " (span (|@| (class "variable-name") (id "F:346927")) "pt") ";\n\n      " (span (|@| (class "keyword") (id "F:346938")) "if") " (w == XWINDOW (selected_window))\n        pt = BUF_PT (current_buffer);\n      " (span (|@| (class "keyword") (id "F:347011")) "else") "\n        pt = marker_position (w->pointm);\n\n      " (span (|@| (class "keyword") (id "F:347058")) "if") " ((w->current_matrix->buffer != XBUFFER (w->buffer)\n           || pt != XINT (w->last_point))\n          && check_point_in_composition (w->current_matrix->buffer,\n                                         XINT (w->last_point),\n                                         XBUFFER (w->buffer), pt))\n        b->clip_changed = 1;\n    }\n}\n\f\n\n" (span (|@| (class "comment-delimiter") (id "F:347301")) "/* ") (span (|@| (class "comment") (id "F:347304")) "Select FRAME to forward the values of frame-local variables into C\n   variables so that the redisplay routines can access those values\n   directly.  ") (span (|@| (class "comment-delimiter") (id "F:347453")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:347457")) "static") " " (span (|@| (class "type") (id "F:347464")) "void") "\n" (span (|@| (class "function-name") (id "F:347469")) "select_frame_for_redisplay") " (" (span (|@| (class "type") (id "F:347497")) "frame") ")\n     " (span (|@| (class "type") (id "F:347509")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:347521")) "frame") ";\n{\n  " (span (|@| (class "type") (id "F:347532")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:347544")) "tail") ", " (span (|@| (class "variable-name") (id "F:347550")) "tem") ";\n  " (span (|@| (class "type") (id "F:347557")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:347569")) "old") " = selected_frame;\n  " (span (|@| (class "keyword") (id "F:347593")) "struct") " " (span (|@| (class "type") (id "F:347600")) "Lisp_Symbol") " *" (span (|@| (class "variable-name") (id "F:347613")) "sym") ";\n\n  xassert (FRAMEP (frame) && FRAME_LIVE_P (XFRAME (frame)));\n\n  selected_frame = frame;\n\n  " (span (|@| (class "keyword") (id "F:347710")) "do") " {\n    " (span (|@| (class "keyword") (id "F:347719")) "for") " (tail = XFRAME (frame)->param_alist; CONSP (tail); tail = XCDR (tail))\n      " (span (|@| (class "keyword") (id "F:347800")) "if") " (CONSP (XCAR (tail))\n          && (tem = XCAR (XCAR (tail)),\n              SYMBOLP (tem))\n          && (sym = indirect_variable (XSYMBOL (tem)),\n              sym->redirect == SYMBOL_LOCALIZED)\n          && sym->val.blv->frame_local)\n        " (span (|@| (class "comment-delimiter") (id "F:348003")) "/* ") (span (|@| (class "comment") (id "F:348006")) "Use find_symbol_value rather than Fsymbol_value\n           to avoid an error if it is void.  ") (span (|@| (class "comment-delimiter") (id "F:348092")) "*/") "\n        find_symbol_value (tem);\n  } " (span (|@| (class "keyword") (id "F:348125")) "while") " (" (span (|@| (class "negation-char") (id "F:348132")) "!") "EQ (frame, old) && (frame = old, 1));\n}\n\n\n" (span (|@| (class "preprocessor") (id "F:348175")) "#define") " " (span (|@| (class "variable-name") (id "F:348183")) "STOP_POLLING") "                                    \\\n" (span (|@| (class "keyword") (id "F:348202")) "do") " { " (span (|@| (class "keyword") (id "F:348207")) "if") " (" (span (|@| (class "negation-char") (id "F:348211")) "!") " polling_stopped_here) stop_polling ();       \\\n       polling_stopped_here = 1; } " (span (|@| (class "keyword") (id "F:348289")) "while") " (0)\n\n" (span (|@| (class "preprocessor") (id "F:348300")) "#define") " " (span (|@| (class "variable-name") (id "F:348308")) "RESUME_POLLING") "                                  \\\n" (span (|@| (class "keyword") (id "F:348329")) "do") " { " (span (|@| (class "keyword") (id "F:348334")) "if") " (polling_stopped_here) start_polling ();        \\\n       polling_stopped_here = 0; } " (span (|@| (class "keyword") (id "F:348415")) "while") " (0)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:348427")) "/* ") (span (|@| (class "comment") (id "F:348430")) "If PRESERVE_ECHO_AREA is nonzero, it means this redisplay is not in\n   response to any user action; therefore, we should preserve the echo\n   area.  (Actually, our caller does that job.)  Perhaps in the future\n   avoid recentering windows if it is not necessary; currently that\n   causes some problems.  ") (span (|@| (class "comment-delimiter") (id "F:348734")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:348738")) "static") " " (span (|@| (class "type") (id "F:348745")) "void") "\n" (span (|@| (class "function-name") (id "F:348750")) "redisplay_internal") " (preserve_echo_area)\n     " (span (|@| (class "type") (id "F:348795")) "int") " " (span (|@| (class "variable-name") (id "F:348799")) "preserve_echo_area") ";\n{\n  " (span (|@| (class "keyword") (id "F:348823")) "struct") " " (span (|@| (class "type") (id "F:348830")) "window") " *" (span (|@| (class "variable-name") (id "F:348838")) "w") " = XWINDOW (selected_window);\n  " (span (|@| (class "keyword") (id "F:348871")) "struct") " " (span (|@| (class "type") (id "F:348878")) "frame") " *" (span (|@| (class "variable-name") (id "F:348885")) "f") ";\n  " (span (|@| (class "type") (id "F:348890")) "int") " " (span (|@| (class "variable-name") (id "F:348894")) "pause") ";\n  " (span (|@| (class "type") (id "F:348903")) "int") " " (span (|@| (class "variable-name") (id "F:348907")) "must_finish") " = 0;\n  " (span (|@| (class "keyword") (id "F:348926")) "struct") " " (span (|@| (class "type") (id "F:348933")) "text_pos") " " (span (|@| (class "variable-name") (id "F:348942")) "tlbufpos") ", " (span (|@| (class "variable-name") (id "F:348952")) "tlendpos") ";\n  " (span (|@| (class "type") (id "F:348964")) "int") " " (span (|@| (class "variable-name") (id "F:348968")) "number_of_visible_frames") ";\n  " (span (|@| (class "type") (id "F:348996")) "int") " " (span (|@| (class "variable-name") (id "F:349000")) "count") ", " (span (|@| (class "variable-name") (id "F:349007")) "count1") ";\n  " (span (|@| (class "keyword") (id "F:349017")) "struct") " " (span (|@| (class "type") (id "F:349024")) "frame") " *" (span (|@| (class "variable-name") (id "F:349031")) "sf") ";\n  " (span (|@| (class "type") (id "F:349037")) "int") " " (span (|@| (class "variable-name") (id "F:349041")) "polling_stopped_here") " = 0;\n  " (span (|@| (class "type") (id "F:349069")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:349081")) "old_frame") " = selected_frame;\n\n  " (span (|@| (class "comment-delimiter") (id "F:349112")) "/* ") (span (|@| (class "comment") (id "F:349115")) "Non-zero means redisplay has to consider all windows on all\n     frames.  Zero means, only selected_window is considered.  ") (span (|@| (class "comment-delimiter") (id "F:349238")) "*/") "\n  " (span (|@| (class "type") (id "F:349243")) "int") " " (span (|@| (class "variable-name") (id "F:349247")) "consider_all_windows_p") ";\n\n  TRACE ((stderr, " (span (|@| (class "string") (id "F:349290")) "\"redisplay_internal %d\\n\"") ", redisplaying_p));\n\n  " (span (|@| (class "comment-delimiter") (id "F:349338")) "/* ") (span (|@| (class "comment") (id "F:349341")) "No redisplay if running in batch mode or frame is not yet fully\n     initialized, or redisplay is explicitly turned off by setting\n     Vinhibit_redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:349498")) "*/") "\n  " (span (|@| (class "keyword") (id "F:349503")) "if") " (FRAME_INITIAL_P (SELECTED_FRAME ())\n      || " (span (|@| (class "negation-char") (id "F:349552")) "!") "NILP (Vinhibit_redisplay))\n    " (span (|@| (class "keyword") (id "F:349584")) "return") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:349595")) "/* ") (span (|@| (class "comment") (id "F:349598")) "Don't examine these until after testing Vinhibit_redisplay.\n     When Emacs is shutting down, perhaps because its connection to\n     X has dropped, we should not look at them at all.  ") (span (|@| (class "comment-delimiter") (id "F:349782")) "*/") "\n  f = XFRAME (w->frame);\n  sf = SELECTED_FRAME ();\n\n  " (span (|@| (class "keyword") (id "F:349839")) "if") " (" (span (|@| (class "negation-char") (id "F:349843")) "!") "f->glyphs_initialized_p)\n    " (span (|@| (class "keyword") (id "F:349873")) "return") ";\n\n" (span (|@| (class "preprocessor") (id "F:349882")) "#if") " " (span (|@| (class "preprocessor") (id "F:349886")) "defined") " (USE_X_TOOLKIT) || " (span (|@| (class "preprocessor") (id "F:349913")) "defined") " (USE_GTK) || " (span (|@| (class "preprocessor") (id "F:349934")) "defined") " (HAVE_NS)\n  " (span (|@| (class "keyword") (id "F:349954")) "if") " (popup_activated ())\n    " (span (|@| (class "keyword") (id "F:349982")) "return") ";\n" (span (|@| (class "preprocessor") (id "F:349990")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:350000")) "/* ") (span (|@| (class "comment") (id "F:350003")) "I don't think this happens but let's be paranoid.  ") (span (|@| (class "comment-delimiter") (id "F:350054")) "*/") "\n  " (span (|@| (class "keyword") (id "F:350059")) "if") " (redisplaying_p)\n    " (span (|@| (class "keyword") (id "F:350083")) "return") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:350094")) "/* ") (span (|@| (class "comment") (id "F:350097")) "Record a function that resets redisplaying_p to its old value\n     when we leave this function.  ") (span (|@| (class "comment-delimiter") (id "F:350194")) "*/") "\n  count = SPECPDL_INDEX ();\n  record_unwind_protect (unwind_redisplay,\n                         Fcons (make_number (redisplaying_p), selected_frame));\n  ++redisplaying_p;\n  specbind (Qinhibit_free_realized_faces, Qnil);\n\n  {\n    " (span (|@| (class "type") (id "F:350405")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:350417")) "tail") ", " (span (|@| (class "variable-name") (id "F:350423")) "frame") ";\n\n    " (span (|@| (class "variable-name") (id "F:350435")) "FOR_EACH_FRAME") " (tail, " (span (|@| (class "type") (id "F:350457")) "frame") ")\n      {\n        " (span (|@| (class "keyword") (id "F:350473")) "struct") " " (span (|@| (class "type") (id "F:350480")) "frame") " *" (span (|@| (class "variable-name") (id "F:350487")) "f") " = XFRAME (frame);\n        f->already_hscrolled_p = 0;\n      }\n  }\n\n " (span (|@| (class "constant") (id "F:350550")) "retry") ":\n  " (span (|@| (class "keyword") (id "F:350559")) "if") " (" (span (|@| (class "negation-char") (id "F:350563")) "!") "EQ (old_frame, selected_frame)\n      && FRAME_LIVE_P (XFRAME (old_frame)))\n    " (span (|@| (class "comment-delimiter") (id "F:350643")) "/* ") (span (|@| (class "comment") (id "F:350646")) "When running redisplay, we play a bit fast-and-loose and allow e.g.\n       selected_frame and selected_window to be temporarily out-of-sync so\n       when we come back here via `goto retry', we need to resync because we\n       may need to run Elisp code (via prepare_menu_bars).  ") (span (|@| (class "comment-delimiter") (id "F:350926")) "*/") "\n    select_frame_for_redisplay (old_frame);\n\n  pause = 0;\n  reconsider_clip_changes (w, current_buffer);\n  last_escape_glyph_frame = " (span (|@| (class "constant") (id "F:351062")) "NULL") ";\n  last_escape_glyph_face_id = (1 << FACE_ID_BITS);\n\n  " (span (|@| (class "comment-delimiter") (id "F:351122")) "/* ") (span (|@| (class "comment") (id "F:351125")) "If new fonts have been loaded that make a glyph matrix adjustment\n     necessary, do it.  ") (span (|@| (class "comment-delimiter") (id "F:351215")) "*/") "\n  " (span (|@| (class "keyword") (id "F:351220")) "if") " (fonts_changed_p)\n    {\n      adjust_glyphs (" (span (|@| (class "constant") (id "F:351268")) "NULL") ");\n      ++windows_or_buffers_changed;\n      fonts_changed_p = 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:351347")) "/* ") (span (|@| (class "comment") (id "F:351350")) "If face_change_count is non-zero, init_iterator will free all\n     realized faces, which includes the faces referenced from current\n     matrices.  So, we can't reuse current matrices in this case.  ") (span (|@| (class "comment-delimiter") (id "F:351549")) "*/") "\n  " (span (|@| (class "keyword") (id "F:351554")) "if") " (face_change_count)\n    ++windows_or_buffers_changed;\n\n  " (span (|@| (class "keyword") (id "F:351614")) "if") " ((FRAME_TERMCAP_P (sf) || FRAME_MSDOS_P (sf))\n      && FRAME_TTY (sf)->previous_frame != sf)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:351722")) "/* ") (span (|@| (class "comment") (id "F:351725")) "Since frames on a single ASCII terminal share the same\n         display area, displaying a different frame means redisplay\n         the whole thing.  ") (span (|@| (class "comment-delimiter") (id "F:351861")) "*/") "\n      windows_or_buffers_changed++;\n      SET_FRAME_GARBAGED (sf);\n" (span (|@| (class "preprocessor") (id "F:351931")) "#if") (span (|@| (class "negation-char") (id "F:351934")) (span (|@| (class "preprocessor") (id "F:351934")) "n")) (span (|@| (class "preprocessor") (id "F:351935")) "def") " DOS_NT\n      set_tty_color_mode (FRAME_TTY (sf), sf);\n" (span (|@| (class "preprocessor") (id "F:351993")) "#endif") "\n      FRAME_TTY (sf)->previous_frame = sf;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:352052")) "/* ") (span (|@| (class "comment") (id "F:352055")) "Set the visible flags for all frames.  Do this before checking\n     for resized or garbaged frames; they want to know if their frames\n     are visible.  See the comment in frame.h for\n     FRAME_SAMPLE_VISIBILITY.  ") (span (|@| (class "comment-delimiter") (id "F:352270")) "*/") "\n  {\n    " (span (|@| (class "type") (id "F:352281")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:352293")) "tail") ", " (span (|@| (class "variable-name") (id "F:352299")) "frame") ";\n\n    number_of_visible_frames = 0;\n\n    " (span (|@| (class "variable-name") (id "F:352346")) "FOR_EACH_FRAME") " (tail, " (span (|@| (class "type") (id "F:352368")) "frame") ")\n      {\n        " (span (|@| (class "keyword") (id "F:352384")) "struct") " " (span (|@| (class "type") (id "F:352391")) "frame") " *" (span (|@| (class "variable-name") (id "F:352398")) "f") " = XFRAME (frame);\n\n        FRAME_SAMPLE_VISIBILITY (f);\n        " (span (|@| (class "keyword") (id "F:352450")) "if") " (FRAME_VISIBLE_P (f))\n          ++number_of_visible_frames;\n        clear_desired_matrices (f);\n      }\n  }\n\n  " (span (|@| (class "comment-delimiter") (id "F:352550")) "/* ") (span (|@| (class "comment") (id "F:352553")) "Notice any pending interrupt request to change frame size.  ") (span (|@| (class "comment-delimiter") (id "F:352613")) "*/") "\n  do_pending_window_change (1);\n\n  " (span (|@| (class "comment-delimiter") (id "F:352651")) "/* ") (span (|@| (class "comment") (id "F:352654")) "Clear frames marked as garbaged.  ") (span (|@| (class "comment-delimiter") (id "F:352688")) "*/") "\n  " (span (|@| (class "keyword") (id "F:352693")) "if") " (frame_garbaged)\n    clear_garbaged_frames ();\n\n  " (span (|@| (class "comment-delimiter") (id "F:352746")) "/* ") (span (|@| (class "comment") (id "F:352749")) "Build menubar and tool-bar items.  ") (span (|@| (class "comment-delimiter") (id "F:352784")) "*/") "\n  " (span (|@| (class "keyword") (id "F:352789")) "if") " (NILP (Vmemory_full))\n    prepare_menu_bars ();\n\n  " (span (|@| (class "keyword") (id "F:352843")) "if") " (windows_or_buffers_changed)\n    update_mode_lines++;\n\n  " (span (|@| (class "comment-delimiter") (id "F:352903")) "/* ") (span (|@| (class "comment") (id "F:352906")) "Detect case that we need to write or remove a star in the mode line.  ") (span (|@| (class "comment-delimiter") (id "F:352976")) "*/") "\n  " (span (|@| (class "keyword") (id "F:352981")) "if") " ((SAVE_MODIFF < MODIFF) != " (span (|@| (class "negation-char") (id "F:353011")) "!") "NILP (w->last_had_star))\n    {\n      w->update_mode_line = Qt;\n      " (span (|@| (class "keyword") (id "F:353081")) "if") " (buffer_shared > 1)\n        update_mode_lines++;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:353135")) "/* ") (span (|@| (class "comment") (id "F:353138")) "Avoid invocation of point motion hooks by `current_column' below.  ") (span (|@| (class "comment-delimiter") (id "F:353205")) "*/") "\n  count1 = SPECPDL_INDEX ();\n  specbind (Qinhibit_point_motion_hooks, Qt);\n\n  " (span (|@| (class "comment-delimiter") (id "F:353286")) "/* ") (span (|@| (class "comment") (id "F:353289")) "If %c is in the mode line, update it if needed.  ") (span (|@| (class "comment-delimiter") (id "F:353338")) "*/") "\n  " (span (|@| (class "keyword") (id "F:353343")) "if") " (" (span (|@| (class "negation-char") (id "F:353347")) "!") "NILP (w->column_number_displayed)\n      " (span (|@| (class "comment-delimiter") (id "F:353388")) "/* ") (span (|@| (class "comment") (id "F:353391")) "This alternative quickly identifies a common case\n         where no change is needed.  ") (span (|@| (class "comment-delimiter") (id "F:353471")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:353483")) "!") "(PT == XFASTINT (w->last_point)\n           && XFASTINT (w->last_modified) >= MODIFF\n           && XFASTINT (w->last_overlay_modified) >= OVERLAY_MODIFF)\n      && (XFASTINT (w->column_number_displayed)\n          != (" (span (|@| (class "type") (id "F:353685")) "int") ") current_column ()))  " (span (|@| (class "comment-delimiter") (id "F:353711")) "/* ") (span (|@| (class "comment") (id "F:353714")) "iftc ") (span (|@| (class "comment-delimiter") (id "F:353719")) "*/") "\n    w->update_mode_line = Qt;\n\n  unbind_to (count1, Qnil);\n\n  FRAME_SCROLL_BOTTOM_VPOS (XFRAME (w->frame)) = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:353838")) "/* ") (span (|@| (class "comment") (id "F:353841")) "The variable buffer_shared is set in redisplay_window and\n     indicates that we redisplay a buffer in different windows.  See\n     there.  ") (span (|@| (class "comment-delimiter") (id "F:353981")) "*/") "\n  consider_all_windows_p = (update_mode_lines || buffer_shared > 1\n                            || cursor_type_changed);\n\n  " (span (|@| (class "comment-delimiter") (id "F:354086")) "/* ") (span (|@| (class "comment") (id "F:354089")) "If specs for an arrow have changed, do thorough redisplay\n     to ensure we remove any arrow that should no longer exist.  ") (span (|@| (class "comment-delimiter") (id "F:354212")) "*/") "\n  " (span (|@| (class "keyword") (id "F:354217")) "if") " (overlay_arrows_changed_p ())\n    consider_all_windows_p = windows_or_buffers_changed = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:354314")) "/* ") (span (|@| (class "comment") (id "F:354317")) "Normally the message* functions will have already displayed and\n     updated the echo area, but the frame may have been trashed, or\n     the update may have been preempted, so display the echo area\n     again here.  Checking message_cleared_p captures the case that\n     the echo area should be cleared.  ") (span (|@| (class "comment-delimiter") (id "F:354622")) "*/") "\n  " (span (|@| (class "keyword") (id "F:354627")) "if") " ((" (span (|@| (class "negation-char") (id "F:354632")) "!") "NILP (echo_area_buffer[0]) && " (span (|@| (class "negation-char") (id "F:354663")) "!") "display_last_displayed_message_p)\n      || (" (span (|@| (class "negation-char") (id "F:354708")) "!") "NILP (echo_area_buffer[1]) && display_last_displayed_message_p)\n      || (message_cleared_p\n          && minibuf_level == 0\n          " (span (|@| (class "comment-delimiter") (id "F:354829")) "/* ") (span (|@| (class "comment") (id "F:354832")) "If the mini-window is currently selected, this means the\n             echo-area doesn't show through.  ") (span (|@| (class "comment-delimiter") (id "F:354928")) "*/") "\n          && " (span (|@| (class "negation-char") (id "F:354937")) "!") "MINI_WINDOW_P (XWINDOW (selected_window))))\n    {\n      " (span (|@| (class "type") (id "F:354994")) "int") " " (span (|@| (class "variable-name") (id "F:354998")) "window_height_changed_p") " = echo_area_display (0);\n      must_finish = 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:355077")) "/* ") (span (|@| (class "comment") (id "F:355080")) "If we don't display the current message, don't clear the\n         message_cleared_p flag, because, if we did, we wouldn't clear\n         the echo area in the next redisplay which doesn't preserve\n         the echo area.  ") (span (|@| (class "comment-delimiter") (id "F:355280")) "*/") "\n      " (span (|@| (class "keyword") (id "F:355289")) "if") " (" (span (|@| (class "negation-char") (id "F:355293")) "!") "display_last_displayed_message_p)\n        message_cleared_p = 0;\n\n      " (span (|@| (class "keyword") (id "F:355359")) "if") " (fonts_changed_p)\n        " (span (|@| (class "keyword") (id "F:355381")) "goto") " " (span (|@| (class "constant") (id "F:355386")) "retry") ";\n      " (span (|@| (class "keyword") (id "F:355399")) "else") " " (span (|@| (class "keyword") (id "F:355404")) "if") " (window_height_changed_p)\n        {\n          consider_all_windows_p = 1;\n          ++update_mode_lines;\n          ++windows_or_buffers_changed;\n\n          " (span (|@| (class "comment-delimiter") (id "F:355528")) "/* ") (span (|@| (class "comment") (id "F:355531")) "If window configuration was changed, frames may have been\n             marked garbaged.  Clear them or we will experience\n             surprises wrt scrolling.  ") (span (|@| (class "comment-delimiter") (id "F:355678")) "*/") "\n          " (span (|@| (class "keyword") (id "F:355684")) "if") " (frame_garbaged)\n            clear_garbaged_frames ();\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:355746")) "else") " " (span (|@| (class "keyword") (id "F:355751")) "if") " (EQ (selected_window, minibuf_window)\n           && (current_buffer->clip_changed\n               || XFASTINT (w->last_modified) < MODIFF\n               || XFASTINT (w->last_overlay_modified) < OVERLAY_MODIFF)\n           && resize_mini_window (w, 0))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:355988")) "/* ") (span (|@| (class "comment") (id "F:355991")) "Resized active mini-window to fit the size of what it is\n         showing if its contents might have changed.  ") (span (|@| (class "comment-delimiter") (id "F:356102")) "*/") "\n      must_finish = 1;\n" (span (|@| (class "comment-delimiter") (id "F:356128")) "/* ") (span (|@| (class "comment") (id "F:356131")) "FIXME: this causes all frames to be updated, which seems unnecessary\n   since only the current frame needs to be considered.  This function needs\n   to be rewritten with two variables, consider_all_windows and\n   consider_all_frames. ") (span (|@| (class "comment-delimiter") (id "F:356365")) "*/") "\n      consider_all_windows_p = 1;\n      ++windows_or_buffers_changed;\n      ++update_mode_lines;\n\n      " (span (|@| (class "comment-delimiter") (id "F:356472")) "/* ") (span (|@| (class "comment") (id "F:356475")) "If window configuration was changed, frames may have been\n         marked garbaged.  Clear them or we will experience\n         surprises wrt scrolling.  ") (span (|@| (class "comment-delimiter") (id "F:356614")) "*/") "\n      " (span (|@| (class "keyword") (id "F:356623")) "if") " (frame_garbaged)\n        clear_garbaged_frames ();\n    }\n\n\n  " (span (|@| (class "comment-delimiter") (id "F:356680")) "/* ") (span (|@| (class "comment") (id "F:356683")) "If showing the region, and mark has changed, we must redisplay\n     the whole window.  The assignment to this_line_start_pos prevents\n     the optimization directly below this if-statement.  ") (span (|@| (class "comment-delimiter") (id "F:356874")) "*/") "\n  " (span (|@| (class "keyword") (id "F:356879")) "if") " (((" (span (|@| (class "negation-char") (id "F:356885")) "!") "NILP (Vtransient_mark_mode)\n        && " (span (|@| (class "negation-char") (id "F:356918")) "!") "NILP (XBUFFER (w->buffer)->mark_active))\n       != " (span (|@| (class "negation-char") (id "F:356970")) "!") "NILP (w->region_showing))\n      || (" (span (|@| (class "negation-char") (id "F:357007")) "!") "NILP (w->region_showing)\n          && " (span (|@| (class "negation-char") (id "F:357039")) "!") "EQ (w->region_showing,\n                  Fmarker_position (XBUFFER (w->buffer)->mark))))\n    CHARPOS (this_line_start_pos) = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:357157")) "/* ") (span (|@| (class "comment") (id "F:357160")) "Optimize the case that only the line containing the cursor in the\n     selected window has changed.  Variables starting with this_ are\n     set in display_line and record information about the line\n     containing the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:357387")) "*/") "\n  tlbufpos = this_line_start_pos;\n  tlendpos = this_line_end_pos;\n  " (span (|@| (class "keyword") (id "F:357458")) "if") " (" (span (|@| (class "negation-char") (id "F:357462")) "!") "consider_all_windows_p\n      && CHARPOS (tlbufpos) > 0\n      && NILP (w->update_mode_line)\n      && " (span (|@| (class "negation-char") (id "F:357563")) "!") "current_buffer->clip_changed\n      && " (span (|@| (class "negation-char") (id "F:357602")) "!") "current_buffer->prevent_redisplay_optimizations_p\n      && FRAME_VISIBLE_P (XFRAME (w->frame))\n      && " (span (|@| (class "negation-char") (id "F:357707")) "!") "FRAME_OBSCURED_P (XFRAME (w->frame))\n      " (span (|@| (class "comment-delimiter") (id "F:357751")) "/* ") (span (|@| (class "comment") (id "F:357754")) "Make sure recorded data applies to current buffer, etc.  ") (span (|@| (class "comment-delimiter") (id "F:357811")) "*/") "\n      && this_line_buffer == current_buffer\n      && current_buffer == XBUFFER (w->buffer)\n      && NILP (w->force_start)\n      && NILP (w->optional_new_start)\n      " (span (|@| (class "comment-delimiter") (id "F:357980")) "/* ") (span (|@| (class "comment") (id "F:357983")) "Point must be on the line that we have info recorded about.  ") (span (|@| (class "comment-delimiter") (id "F:358044")) "*/") "\n      && PT >= CHARPOS (tlbufpos)\n      && PT <= Z - CHARPOS (tlendpos)\n      " (span (|@| (class "comment-delimiter") (id "F:358125")) "/* ") (span (|@| (class "comment") (id "F:358128")) "All text outside that line, including its final newline,\n         must be unchanged.  ") (span (|@| (class "comment-delimiter") (id "F:358207")) "*/") "\n      && text_outside_line_unchanged_p (w, CHARPOS (tlbufpos),\n                                        CHARPOS (tlendpos)))\n    {\n      " (span (|@| (class "keyword") (id "F:358311")) "if") " (CHARPOS (tlbufpos) > BEGV\n          && FETCH_BYTE (BYTEPOS (tlbufpos) - 1) != " (span (|@| (class "string") (id "F:358386")) "'\\n'") "\n          && (CHARPOS (tlbufpos) == ZV\n              || FETCH_BYTE (BYTEPOS (tlbufpos)) == " (span (|@| (class "string") (id "F:358468")) "'\\n'") "))\n        " (span (|@| (class "comment-delimiter") (id "F:358476")) "/* ") (span (|@| (class "comment") (id "F:358479")) "Former continuation line has disappeared by becoming empty.  ") (span (|@| (class "comment-delimiter") (id "F:358540")) "*/") "\n        " (span (|@| (class "keyword") (id "F:358544")) "goto") " " (span (|@| (class "constant") (id "F:358549")) "cancel") ";\n      " (span (|@| (class "keyword") (id "F:358563")) "else") " " (span (|@| (class "keyword") (id "F:358568")) "if") " (XFASTINT (w->last_modified) < MODIFF\n               || XFASTINT (w->last_overlay_modified) < OVERLAY_MODIFF\n               || MINI_WINDOW_P (w))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:358709")) "/* ") (span (|@| (class "comment") (id "F:358712")) "We have to handle the case of continuation around a\n             wide-column character (see the comment in indent.c around\n             line 1340).\n\n             For instance, in the following case:\n\n             --------  Insert  --------\n             K_A_N_\\\\   `a'    K_A_N_a\\         `X_' are wide-column chars.\n             J_I_       ==>    J_I_             `^^' are cursors.\n             ^^                ^^\n             --------          --------\n\n             As we have to redraw the line above, we cannot use this\n             optimization.  ") (span (|@| (class "comment-delimiter") (id "F:359178")) "*/") "\n\n          " (span (|@| (class "keyword") (id "F:359185")) "struct") " " (span (|@| (class "type") (id "F:359192")) "it") " " (span (|@| (class "variable-name") (id "F:359195")) "it") ";\n          " (span (|@| (class "type") (id "F:359202")) "int") " " (span (|@| (class "variable-name") (id "F:359206")) "line_height_before") " = this_line_pixel_height;\n\n          " (span (|@| (class "comment-delimiter") (id "F:359255")) "/* ") (span (|@| (class "comment") (id "F:359258")) "Note that start_display will handle the case that the\n             line starting at tlbufpos is a continuation line.  ") (span (|@| (class "comment-delimiter") (id "F:359369")) "*/") "\n          start_display (&it, w, tlbufpos);\n\n          " (span (|@| (class "comment-delimiter") (id "F:359413")) "/* ") (span (|@| (class "comment") (id "F:359416")) "Implementation note: It this still necessary?  ") (span (|@| (class "comment-delimiter") (id "F:359463")) "*/") "\n          " (span (|@| (class "keyword") (id "F:359469")) "if") " (it.current_x != this_line_start_x)\n            " (span (|@| (class "keyword") (id "F:359513")) "goto") " " (span (|@| (class "constant") (id "F:359518")) "cancel") ";\n\n          TRACE ((stderr, " (span (|@| (class "string") (id "F:359546")) "\"trying display optimization 1\\n\"") "));\n          w->cursor.vpos = -1;\n          overlay_arrow_seen = 0;\n          it.vpos = this_line_vpos;\n          it.current_y = this_line_y;\n          it.glyph_row = MATRIX_ROW (w->desired_matrix, this_line_vpos);\n          display_line (&it);\n\n          " (span (|@| (class "comment-delimiter") (id "F:359787")) "/* ") (span (|@| (class "comment") (id "F:359790")) "If line contains point, is not continued,\n             and ends at same distance from eob as before, we win.  ") (span (|@| (class "comment-delimiter") (id "F:359900")) "*/") "\n          " (span (|@| (class "keyword") (id "F:359906")) "if") " (w->cursor.vpos >= 0\n              " (span (|@| (class "comment-delimiter") (id "F:359944")) "/* ") (span (|@| (class "comment") (id "F:359947")) "Line is not continued, otherwise this_line_start_pos\n                 would have been set to 0 in display_line.  ") (span (|@| (class "comment-delimiter") (id "F:360060")) "*/") "\n              && CHARPOS (this_line_start_pos)\n              " (span (|@| (class "comment-delimiter") (id "F:360110")) "/* ") (span (|@| (class "comment") (id "F:360113")) "Line ends as before.  ") (span (|@| (class "comment-delimiter") (id "F:360135")) "*/") "\n              && CHARPOS (this_line_end_pos) == CHARPOS (tlendpos)\n              " (span (|@| (class "comment-delimiter") (id "F:360212")) "/* ") (span (|@| (class "comment") (id "F:360215")) "Line has same height as before.  Otherwise other lines\n                 would have to be shifted up or down.  ") (span (|@| (class "comment-delimiter") (id "F:360325")) "*/") "\n              && this_line_pixel_height == line_height_before)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:360399")) "/* ") (span (|@| (class "comment") (id "F:360402")) "If this is not the window's last line, we must adjust\n                 the charstarts of the lines below.  ") (span (|@| (class "comment-delimiter") (id "F:360496")) "*/") "\n              " (span (|@| (class "keyword") (id "F:360507")) "if") " (it.current_y < it.last_visible_y)\n                {\n                  " (span (|@| (class "keyword") (id "F:360556")) "struct") " " (span (|@| (class "type") (id "F:360563")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:360574")) "row") "\n                    = MATRIX_ROW (w->current_matrix, this_line_vpos + 1);\n                  " (span (|@| (class "type") (id "F:360645")) "int") " " (span (|@| (class "variable-name") (id "F:360649")) "delta") ", " (span (|@| (class "variable-name") (id "F:360656")) "delta_bytes") ";\n\n                  " (span (|@| (class "comment-delimiter") (id "F:360674")) "/* ") (span (|@| (class "comment") (id "F:360677")) "We used to distinguish between two cases here,\n                     conditioned by Z - CHARPOS (tlendpos) == ZV, for\n                     when the line ends in a newline or the end of the\n                     buffer's accessible portion.  But both cases did\n                     the same, so they were collapsed.  ") (span (|@| (class "comment-delimiter") (id "F:360935")) "*/") "\n                  delta = (Z\n                           - CHARPOS (tlendpos)\n                           - MATRIX_ROW_START_CHARPOS (row));\n                  delta_bytes = (Z_BYTE\n                                 - BYTEPOS (tlendpos)\n                                 - MATRIX_ROW_START_BYTEPOS (row));\n\n                  increment_matrix_positions (w->current_matrix,\n                                              this_line_vpos + 1,\n                                              w->current_matrix->nrows,\n                                              delta, delta_bytes);\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:361279")) "/* ") (span (|@| (class "comment") (id "F:361282")) "If this row displays text now but previously didn't,\n                 or vice versa, w->window_end_vpos may have to be\n                 adjusted.  ") (span (|@| (class "comment-delimiter") (id "F:361401")) "*/") "\n              " (span (|@| (class "keyword") (id "F:361411")) "if") " ((it.glyph_row - 1)->displays_text_p)\n                {\n                  " (span (|@| (class "keyword") (id "F:361460")) "if") " (XFASTINT (w->window_end_vpos) < this_line_vpos)\n                    XSETINT (w->window_end_vpos, this_line_vpos);\n                }\n              " (span (|@| (class "keyword") (id "F:361575")) "else") " " (span (|@| (class "keyword") (id "F:361580")) "if") " (XFASTINT (w->window_end_vpos) == this_line_vpos\n                       && this_line_vpos > 0)\n                XSETINT (w->window_end_vpos, this_line_vpos - 1);\n              w->window_end_valid = Qnil;\n\n              " (span (|@| (class "comment-delimiter") (id "F:361759")) "/* ") (span (|@| (class "comment") (id "F:361762")) "Update hint: No need to try to scroll in update_window.  ") (span (|@| (class "comment-delimiter") (id "F:361819")) "*/") "\n              w->desired_matrix->no_scrolling_p = 1;\n\n" (span (|@| (class "preprocessor") (id "F:361869")) "#if") " GLYPH_DEBUG\n              *w->desired_matrix->method = 0;\n              debug_method_add (w, " (span (|@| (class "string") (id "F:361952")) "\"optimization 1\"") ");\n" (span (|@| (class "preprocessor") (id "F:361971")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:361978")) "#ifdef") " HAVE_WINDOW_SYSTEM\n              update_window_fringes (w, 0);\n" (span (|@| (class "preprocessor") (id "F:362041")) "#endif") "\n              " (span (|@| (class "keyword") (id "F:362055")) "goto") " " (span (|@| (class "constant") (id "F:362060")) "update") ";\n            }\n          " (span (|@| (class "keyword") (id "F:362078")) "else") "\n            " (span (|@| (class "keyword") (id "F:362088")) "goto") " " (span (|@| (class "constant") (id "F:362093")) "cancel") ";\n        }\n      " (span (|@| (class "keyword") (id "F:362110")) "else") " " (span (|@| (class "keyword") (id "F:362115")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:362119")) "/* ") (span (|@| (class "comment") (id "F:362122")) "Cursor position hasn't changed.  ") (span (|@| (class "comment-delimiter") (id "F:362155")) "*/") "\n               PT == XFASTINT (w->last_point)\n               " (span (|@| (class "comment-delimiter") (id "F:362205")) "/* ") (span (|@| (class "comment") (id "F:362208")) "Make sure the cursor was last displayed\n                  in this window.  Otherwise we have to reposition it.  ") (span (|@| (class "comment-delimiter") (id "F:362306")) "*/") "\n               && 0 <= w->cursor.vpos\n               && WINDOW_TOTAL_LINES (w) > w->cursor.vpos)\n        {\n          " (span (|@| (class "keyword") (id "F:362398")) "if") " (" (span (|@| (class "negation-char") (id "F:362402")) "!") "must_finish)\n            {\n              do_pending_window_change (1);\n\n              " (span (|@| (class "comment-delimiter") (id "F:362468")) "/* ") (span (|@| (class "comment") (id "F:362471")) "We used to always goto end_of_redisplay here, but this\n                 isn't enough if we have a blinking cursor.  ") (span (|@| (class "comment-delimiter") (id "F:362573")) "*/") "\n              " (span (|@| (class "keyword") (id "F:362583")) "if") " (w->cursor_off_p == w->last_cursor_off_p)\n                " (span (|@| (class "keyword") (id "F:362630")) "goto") " " (span (|@| (class "constant") (id "F:362635")) "end_of_redisplay") ";\n            }\n          " (span (|@| (class "keyword") (id "F:362663")) "goto") " " (span (|@| (class "constant") (id "F:362668")) "update") ";\n        }\n      " (span (|@| (class "comment-delimiter") (id "F:362685")) "/* ") (span (|@| (class "comment") (id "F:362688")) "If highlighting the region, or if the cursor is in the echo area,\n         then we can't just move the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:362793")) "*/") "\n      " (span (|@| (class "keyword") (id "F:362802")) "else") " " (span (|@| (class "keyword") (id "F:362807")) "if") " (" (span (|@| (class "negation-char") (id "F:362811")) "!") " (" (span (|@| (class "negation-char") (id "F:362814")) "!") "NILP (Vtransient_mark_mode)\n                  && " (span (|@| (class "negation-char") (id "F:362850")) "!") "NILP (current_buffer->mark_active))\n               && (EQ (selected_window, current_buffer->last_selected_window)\n                   || highlight_nonselected_windows)\n               && NILP (w->region_showing)\n               && NILP (Vshow_trailing_whitespace)\n               && " (span (|@| (class "negation-char") (id "F:363088")) "!") "cursor_in_echo_area)\n        {\n          " (span (|@| (class "keyword") (id "F:363116")) "struct") " " (span (|@| (class "type") (id "F:363123")) "it") " " (span (|@| (class "variable-name") (id "F:363126")) "it") ";\n          " (span (|@| (class "keyword") (id "F:363133")) "struct") " " (span (|@| (class "type") (id "F:363140")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:363151")) "row") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:363160")) "/* ") (span (|@| (class "comment") (id "F:363163")) "Skip from tlbufpos to PT and see where it is.  Note that\n             PT may be in invisible text.  If so, we will end at the\n             next visible position.  ") (span (|@| (class "comment-delimiter") (id "F:363312")) "*/") "\n          init_iterator (&it, w, CHARPOS (tlbufpos), BYTEPOS (tlbufpos),\n                         " (span (|@| (class "constant") (id "F:363385")) "NULL") ", DEFAULT_FACE_ID);\n          it.current_x = this_line_start_x;\n          it.current_y = this_line_y;\n          it.vpos = this_line_vpos;\n\n          " (span (|@| (class "comment-delimiter") (id "F:363510")) "/* ") (span (|@| (class "comment") (id "F:363513")) "The call to move_it_to stops in front of PT, but\n             moves over before-strings.  ") (span (|@| (class "comment-delimiter") (id "F:363596")) "*/") "\n          move_it_to (&it, PT, -1, -1, -1, MOVE_TO_POS);\n\n          " (span (|@| (class "keyword") (id "F:363653")) "if") " (it.vpos == this_line_vpos\n              && (row = MATRIX_ROW (w->current_matrix, this_line_vpos),\n                  row->enabled_p))\n            {\n              xassert (this_line_vpos == it.vpos);\n              xassert (this_line_y == it.current_y);\n              set_cursor_from_row (w, row, w->current_matrix, 0, 0, 0, 0);\n" (span (|@| (class "preprocessor") (id "F:363934")) "#if") " GLYPH_DEBUG\n              *w->desired_matrix->method = 0;\n              debug_method_add (w, " (span (|@| (class "string") (id "F:364017")) "\"optimization 3\"") ");\n" (span (|@| (class "preprocessor") (id "F:364036")) "#endif") "\n              " (span (|@| (class "keyword") (id "F:364050")) "goto") " " (span (|@| (class "constant") (id "F:364055")) "update") ";\n            }\n          " (span (|@| (class "keyword") (id "F:364073")) "else") "\n            " (span (|@| (class "keyword") (id "F:364083")) "goto") " " (span (|@| (class "constant") (id "F:364088")) "cancel") ";\n        }\n\n    " (span (|@| (class "constant") (id "F:364104")) "cancel") ":\n      " (span (|@| (class "comment-delimiter") (id "F:364118")) "/* ") (span (|@| (class "comment") (id "F:364121")) "Text changed drastically or point moved off of line.  ") (span (|@| (class "comment-delimiter") (id "F:364175")) "*/") "\n      SET_MATRIX_ROW_ENABLED_P (w->desired_matrix, this_line_vpos, 0);\n    }\n\n  CHARPOS (this_line_start_pos) = 0;\n  consider_all_windows_p |= buffer_shared > 1;\n  ++clear_face_cache_count;\n" (span (|@| (class "preprocessor") (id "F:364368")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  ++clear_image_cache_count;\n" (span (|@| (class "preprocessor") (id "F:364423")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:364433")) "/* ") (span (|@| (class "comment") (id "F:364436")) "Build desired matrices, and update the display.  If\n     consider_all_windows_p is non-zero, do it for all windows on all\n     frames.  Otherwise do it for selected_window, only.  ") (span (|@| (class "comment-delimiter") (id "F:364616")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:364622")) "if") " (consider_all_windows_p)\n    {\n      " (span (|@| (class "type") (id "F:364662")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:364674")) "tail") ", " (span (|@| (class "variable-name") (id "F:364680")) "frame") ";\n\n      FOR_EACH_FRAME (tail, frame)\n        XFRAME (frame)->updated_p = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:364762")) "/* ") (span (|@| (class "comment") (id "F:364765")) "Recompute # windows showing selected buffer.  This will be\n         incremented each time such a window is displayed.  ") (span (|@| (class "comment-delimiter") (id "F:364877")) "*/") "\n      buffer_shared = 0;\n\n      " (span (|@| (class "variable-name") (id "F:364912")) "FOR_EACH_FRAME") " (tail, " (span (|@| (class "type") (id "F:364934")) "frame") ")\n        {\n          " (span (|@| (class "keyword") (id "F:364947")) "struct") " " (span (|@| (class "type") (id "F:364954")) "frame") " *" (span (|@| (class "variable-name") (id "F:364961")) "f") " = XFRAME (frame);\n\n          " (span (|@| (class "keyword") (id "F:364985")) "if") " (FRAME_WINDOW_P (f) || FRAME_TERMCAP_P (f) || f == sf)\n            {\n              " (span (|@| (class "keyword") (id "F:365057")) "if") " (" (span (|@| (class "negation-char") (id "F:365061")) "!") " EQ (frame, selected_frame))\n                " (span (|@| (class "comment-delimiter") (id "F:365093")) "/* ") (span (|@| (class "comment") (id "F:365096")) "Select the frame, for the sake of frame-local\n                   variables.  ") (span (|@| (class "comment-delimiter") (id "F:365159")) "*/") "\n                select_frame_for_redisplay (frame);\n\n              " (span (|@| (class "comment-delimiter") (id "F:365208")) "/* ") (span (|@| (class "comment") (id "F:365211")) "Mark all the scroll bars to be removed; we'll redeem\n                 the ones we want when we redisplay their windows.  ") (span (|@| (class "comment-delimiter") (id "F:365318")) "*/") "\n              " (span (|@| (class "keyword") (id "F:365328")) "if") " (FRAME_TERMINAL (f)->condemn_scroll_bars_hook)\n                FRAME_TERMINAL (f)->condemn_scroll_bars_hook (f);\n\n              " (span (|@| (class "keyword") (id "F:365438")) "if") " (FRAME_VISIBLE_P (f) && " (span (|@| (class "negation-char") (id "F:365465")) "!") "FRAME_OBSCURED_P (f))\n                redisplay_windows (FRAME_ROOT_WINDOW (f));\n\n              " (span (|@| (class "comment-delimiter") (id "F:365541")) "/* ") (span (|@| (class "comment") (id "F:365544")) "The X error handler may have deleted that frame.  ") (span (|@| (class "comment-delimiter") (id "F:365594")) "*/") "\n              " (span (|@| (class "keyword") (id "F:365604")) "if") " (" (span (|@| (class "negation-char") (id "F:365608")) "!") "FRAME_LIVE_P (f))\n                " (span (|@| (class "keyword") (id "F:365629")) "continue") ";\n\n              " (span (|@| (class "comment-delimiter") (id "F:365647")) "/* ") (span (|@| (class "comment") (id "F:365650")) "Any scroll bars which redisplay_windows should have\n                 nuked should now go away.  ") (span (|@| (class "comment-delimiter") (id "F:365732")) "*/") "\n              " (span (|@| (class "keyword") (id "F:365742")) "if") " (FRAME_TERMINAL (f)->judge_scroll_bars_hook)\n                FRAME_TERMINAL (f)->judge_scroll_bars_hook (f);\n\n              " (span (|@| (class "comment-delimiter") (id "F:365848")) "/* ") (span (|@| (class "comment") (id "F:365851")) "If fonts changed, display again.  ") (span (|@| (class "comment-delimiter") (id "F:365885")) "*/") "\n              " (span (|@| (class "comment-delimiter") (id "F:365895")) "/* ") (span (|@| (class "comment") (id "F:365898")) "??? rms: I suspect it is a mistake to jump all the way\n                 back to retry here.  It should just retry this frame.  ") (span (|@| (class "comment-delimiter") (id "F:366011")) "*/") "\n              " (span (|@| (class "keyword") (id "F:366021")) "if") " (fonts_changed_p)\n                " (span (|@| (class "keyword") (id "F:366044")) "goto") " " (span (|@| (class "constant") (id "F:366049")) "retry") ";\n\n              " (span (|@| (class "keyword") (id "F:366064")) "if") " (FRAME_VISIBLE_P (f) && " (span (|@| (class "negation-char") (id "F:366091")) "!") "FRAME_OBSCURED_P (f))\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:366122")) "/* ") (span (|@| (class "comment") (id "F:366125")) "See if we have to hscroll.  ") (span (|@| (class "comment-delimiter") (id "F:366153")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:366160")) "if") " (" (span (|@| (class "negation-char") (id "F:366164")) "!") "f->already_hscrolled_p)\n                    {\n                      f->already_hscrolled_p = 1;\n                      " (span (|@| (class "keyword") (id "F:366241")) "if") " (hscroll_windows (f->root_window))\n                        " (span (|@| (class "keyword") (id "F:366282")) "goto") " " (span (|@| (class "constant") (id "F:366287")) "retry") ";\n                    }\n\n                  " (span (|@| (class "comment-delimiter") (id "F:366307")) "/* ") (span (|@| (class "comment") (id "F:366310")) "Prevent various kinds of signals during display\n                     update.  stdio is not robust about handling\n                     signals, which can cause an apparent I/O\n                     error.  ") (span (|@| (class "comment-delimiter") (id "F:366472")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:366479")) "if") " (interrupt_input)\n                    unrequest_sigio ();\n                  STOP_POLLING;\n\n                  " (span (|@| (class "comment-delimiter") (id "F:366549")) "/* ") (span (|@| (class "comment") (id "F:366552")) "Update the display.  ") (span (|@| (class "comment-delimiter") (id "F:366573")) "*/") "\n                  set_window_update_flags (XWINDOW (f->root_window), 1);\n                  pause |= update_frame (f, 0, 0);\n                  f->updated_p = 1;\n                }\n            }\n        }\n\n      " (span (|@| (class "keyword") (id "F:366715")) "if") " (" (span (|@| (class "negation-char") (id "F:366719")) "!") "EQ (old_frame, selected_frame)\n          && FRAME_LIVE_P (XFRAME (old_frame)))\n        " (span (|@| (class "comment-delimiter") (id "F:366793")) "/* ") (span (|@| (class "comment") (id "F:366796")) "We played a bit fast-and-loose above and allowed selected_frame\n           and selected_window to be temporarily out-of-sync but let's make\n           sure this stays contained.  ") (span (|@| (class "comment-delimiter") (id "F:366961")) "*/") "\n        select_frame_for_redisplay (old_frame);\n      eassert (EQ (XFRAME (selected_frame)->selected_window, selected_window));\n\n      " (span (|@| (class "keyword") (id "F:367092")) "if") " (" (span (|@| (class "negation-char") (id "F:367096")) "!") "pause)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:367110")) "/* ") (span (|@| (class "comment") (id "F:367113")) "Do the mark_window_display_accurate after all windows have\n             been redisplayed because this call resets flags in buffers\n             which are needed for proper redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:367283")) "*/") "\n          " (span (|@| (class "variable-name") (id "F:367289")) "FOR_EACH_FRAME") " (tail, " (span (|@| (class "type") (id "F:367311")) "frame") ")\n            {\n              " (span (|@| (class "keyword") (id "F:367332")) "struct") " " (span (|@| (class "type") (id "F:367339")) "frame") " *" (span (|@| (class "variable-name") (id "F:367346")) "f") " = XFRAME (frame);\n              " (span (|@| (class "keyword") (id "F:367380")) "if") " (f->updated_p)\n                {\n                  mark_window_display_accurate (f->root_window, 1);\n                  " (span (|@| (class "keyword") (id "F:367502")) "if") " (FRAME_TERMINAL (f)->frame_up_to_date_hook)\n                    FRAME_TERMINAL (f)->frame_up_to_date_hook (f);\n                }\n            }\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:367652")) "else") " " (span (|@| (class "keyword") (id "F:367657")) "if") " (FRAME_VISIBLE_P (sf) && " (span (|@| (class "negation-char") (id "F:367685")) "!") "FRAME_OBSCURED_P (sf))\n    {\n      " (span (|@| (class "type") (id "F:367721")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:367733")) "mini_window") ";\n      " (span (|@| (class "keyword") (id "F:367752")) "struct") " " (span (|@| (class "type") (id "F:367759")) "frame") " *" (span (|@| (class "variable-name") (id "F:367766")) "mini_frame") ";\n\n      displayed_buffer = XBUFFER (XWINDOW (selected_window)->buffer);\n      " (span (|@| (class "comment-delimiter") (id "F:367855")) "/* ") (span (|@| (class "comment") (id "F:367858")) "Use list_of_error, not Qerror, so that\n         we catch only errors and don't run the debugger.  ") (span (|@| (class "comment-delimiter") (id "F:367949")) "*/") "\n      internal_condition_case_1 (redisplay_window_1, selected_window,\n                                 list_of_error,\n                                 redisplay_window_error);\n\n      " (span (|@| (class "comment-delimiter") (id "F:368079")) "/* ") (span (|@| (class "comment") (id "F:368082")) "Compare desired and current matrices, perform output.  ") (span (|@| (class "comment-delimiter") (id "F:368137")) "*/") "\n\n    " (span (|@| (class "constant") (id "F:368145")) "update") ":\n      " (span (|@| (class "comment-delimiter") (id "F:368159")) "/* ") (span (|@| (class "comment") (id "F:368162")) "If fonts changed, display again.  ") (span (|@| (class "comment-delimiter") (id "F:368196")) "*/") "\n      " (span (|@| (class "keyword") (id "F:368205")) "if") " (fonts_changed_p)\n        " (span (|@| (class "keyword") (id "F:368227")) "goto") " " (span (|@| (class "constant") (id "F:368232")) "retry") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:368246")) "/* ") (span (|@| (class "comment") (id "F:368249")) "Prevent various kinds of signals during display update.\n         stdio is not robust about handling signals,\n         which can cause an apparent I/O error.  ") (span (|@| (class "comment-delimiter") (id "F:368393")) "*/") "\n      " (span (|@| (class "keyword") (id "F:368402")) "if") " (interrupt_input)\n        unrequest_sigio ();\n      STOP_POLLING;\n\n      " (span (|@| (class "keyword") (id "F:368471")) "if") " (FRAME_VISIBLE_P (sf) && " (span (|@| (class "negation-char") (id "F:368499")) "!") "FRAME_OBSCURED_P (sf))\n        {\n          " (span (|@| (class "keyword") (id "F:368529")) "if") " (hscroll_windows (selected_window))\n            " (span (|@| (class "keyword") (id "F:368573")) "goto") " " (span (|@| (class "constant") (id "F:368578")) "retry") ";\n\n          XWINDOW (selected_window)->must_be_updated_p = 1;\n          pause = update_frame (sf, 0, 0);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:368685")) "/* ") (span (|@| (class "comment") (id "F:368688")) "We may have called echo_area_display at the top of this\n         function.  If the echo area is on another frame, that may\n         have put text on a frame other than the selected one, so the\n         above call to update_frame would not have caught it.  Catch\n         it here.  ") (span (|@| (class "comment-delimiter") (id "F:368941")) "*/") "\n      mini_window = FRAME_MINIBUF_WINDOW (sf);\n      mini_frame = XFRAME (WINDOW_FRAME (XWINDOW (mini_window)));\n\n      " (span (|@| (class "keyword") (id "F:369064")) "if") " (mini_frame != sf && FRAME_WINDOW_P (mini_frame))\n        {\n          XWINDOW (mini_window)->must_be_updated_p = 1;\n          pause |= update_frame (mini_frame, 0, 0);\n          " (span (|@| (class "keyword") (id "F:369217")) "if") " (" (span (|@| (class "negation-char") (id "F:369221")) "!") "pause && hscroll_windows (mini_window))\n            " (span (|@| (class "keyword") (id "F:369267")) "goto") " " (span (|@| (class "constant") (id "F:369272")) "retry") ";\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:369291")) "/* ") (span (|@| (class "comment") (id "F:369294")) "If display was paused because of pending input, make sure we do a\n     thorough update the next time.  ") (span (|@| (class "comment-delimiter") (id "F:369397")) "*/") "\n  " (span (|@| (class "keyword") (id "F:369402")) "if") " (pause)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:369425")) "/* ") (span (|@| (class "comment") (id "F:369428")) "Prevent the optimization at the beginning of\n         redisplay_internal that tries a single-line update of the\n         line containing the cursor in the selected window.  ") (span (|@| (class "comment-delimiter") (id "F:369587")) "*/") "\n      CHARPOS (this_line_start_pos) = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:369638")) "/* ") (span (|@| (class "comment") (id "F:369641")) "Let the overlay arrow be updated the next time.  ") (span (|@| (class "comment-delimiter") (id "F:369690")) "*/") "\n      update_overlay_arrows (0);\n\n      " (span (|@| (class "comment-delimiter") (id "F:369733")) "/* ") (span (|@| (class "comment") (id "F:369736")) "If we pause after scrolling, some rows in the current\n         matrices of some windows are not valid.  ") (span (|@| (class "comment-delimiter") (id "F:369833")) "*/") "\n      " (span (|@| (class "keyword") (id "F:369842")) "if") " (" (span (|@| (class "negation-char") (id "F:369846")) "!") "WINDOW_FULL_WIDTH_P (w)\n          && " (span (|@| (class "negation-char") (id "F:369877")) "!") "FRAME_WINDOW_P (XFRAME (w->frame)))\n        update_mode_lines = 1;\n    }\n  " (span (|@| (class "keyword") (id "F:369946")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:369963")) "if") " (" (span (|@| (class "negation-char") (id "F:369967")) "!") "consider_all_windows_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:369998")) "/* ") (span (|@| (class "comment") (id "F:370001")) "This has already been done above if\n             consider_all_windows_p is set.  ") (span (|@| (class "comment-delimiter") (id "F:370075")) "*/") "\n          mark_window_display_accurate_1 (w, 1);\n\n          " (span (|@| (class "comment-delimiter") (id "F:370124")) "/* ") (span (|@| (class "comment") (id "F:370127")) "Say overlay arrows are up to date.  ") (span (|@| (class "comment-delimiter") (id "F:370163")) "*/") "\n          update_overlay_arrows (1);\n\n          " (span (|@| (class "keyword") (id "F:370200")) "if") " (FRAME_TERMINAL (sf)->frame_up_to_date_hook != 0)\n            FRAME_TERMINAL (sf)->frame_up_to_date_hook (sf);\n        }\n\n      update_mode_lines = 0;\n      windows_or_buffers_changed = 0;\n      cursor_type_changed = 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:370418")) "/* ") (span (|@| (class "comment") (id "F:370421")) "Start SIGIO interrupts coming again.  Having them off during the\n     code above makes it less likely one will discard output, but not\n     impossible, since there might be stuff in the system buffer here.\n     But it is much hairier to try to do anything about that.  ") (span (|@| (class "comment-delimiter") (id "F:370690")) "*/") "\n  " (span (|@| (class "keyword") (id "F:370695")) "if") " (interrupt_input)\n    request_sigio ();\n  RESUME_POLLING;\n\n  " (span (|@| (class "comment-delimiter") (id "F:370759")) "/* ") (span (|@| (class "comment") (id "F:370762")) "If a frame has become visible which was not before, redisplay\n     again, so that we display it.  Expose events for such a frame\n     (which it gets when becoming visible) don't call the parts of\n     redisplay constructing glyphs, so simply exposing a frame won't\n     display anything in this case.  So, we have to display these\n     frames here explicitly.  ") (span (|@| (class "comment-delimiter") (id "F:371123")) "*/") "\n  " (span (|@| (class "keyword") (id "F:371128")) "if") " (" (span (|@| (class "negation-char") (id "F:371132")) "!") "pause)\n    {\n      " (span (|@| (class "type") (id "F:371152")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:371164")) "tail") ", " (span (|@| (class "variable-name") (id "F:371170")) "frame") ";\n      " (span (|@| (class "type") (id "F:371183")) "int") " " (span (|@| (class "variable-name") (id "F:371187")) "new_count") " = 0;\n\n      " (span (|@| (class "variable-name") (id "F:371209")) "FOR_EACH_FRAME") " (tail, " (span (|@| (class "type") (id "F:371231")) "frame") ")\n        {\n          " (span (|@| (class "type") (id "F:371244")) "int") " " (span (|@| (class "variable-name") (id "F:371248")) "this_is_visible") " = 0;\n\n          " (span (|@| (class "keyword") (id "F:371273")) "if") " (XFRAME (frame)->visible)\n            this_is_visible = 1;\n          FRAME_SAMPLE_VISIBILITY (XFRAME (frame));\n          " (span (|@| (class "keyword") (id "F:371376")) "if") " (XFRAME (frame)->visible)\n            this_is_visible = 1;\n\n          " (span (|@| (class "keyword") (id "F:371435")) "if") " (this_is_visible)\n            new_count++;\n        }\n\n      " (span (|@| (class "keyword") (id "F:371484")) "if") " (new_count != number_of_visible_frames)\n        windows_or_buffers_changed++;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:371567")) "/* ") (span (|@| (class "comment") (id "F:371570")) "Change frame size now if a change is pending.  ") (span (|@| (class "comment-delimiter") (id "F:371617")) "*/") "\n  do_pending_window_change (1);\n\n  " (span (|@| (class "comment-delimiter") (id "F:371655")) "/* ") (span (|@| (class "comment") (id "F:371658")) "If we just did a pending size change, or have additional\n     visible frames, redisplay again.  ") (span (|@| (class "comment-delimiter") (id "F:371754")) "*/") "\n  " (span (|@| (class "keyword") (id "F:371759")) "if") " (windows_or_buffers_changed && " (span (|@| (class "negation-char") (id "F:371793")) "!") "pause)\n    " (span (|@| (class "keyword") (id "F:371805")) "goto") " " (span (|@| (class "constant") (id "F:371810")) "retry") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:371820")) "/* ") (span (|@| (class "comment") (id "F:371823")) "Clear the face and image caches.\n\n     We used to do this only if consider_all_windows_p.  But the cache\n     needs to be cleared if a timer creates images in the current\n     buffer (e.g. the test case in Bug#6230).  ") (span (|@| (class "comment-delimiter") (id "F:372041")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:372047")) "if") " (clear_face_cache_count > CLEAR_FACE_CACHE_COUNT)\n    {\n      clear_face_cache (0);\n      clear_face_cache_count = 0;\n    }\n\n" (span (|@| (class "preprocessor") (id "F:372175")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "keyword") (id "F:372203")) "if") " (clear_image_cache_count > CLEAR_IMAGE_CACHE_COUNT)\n    {\n      clear_image_caches (Qnil);\n      clear_image_cache_count = 0;\n    }\n" (span (|@| (class "preprocessor") (id "F:372338")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:372345")) "/* ") (span (|@| (class "comment") (id "F:372348")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:372367")) "*/") "\n\n " (span (|@| (class "constant") (id "F:372372")) "end_of_redisplay") ":\n  unbind_to (count, Qnil);\n  RESUME_POLLING;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:372439")) "/* ") (span (|@| (class "comment") (id "F:372442")) "Redisplay, but leave alone any recent echo area message unless\n   another message has been requested in its place.\n\n   This is useful in situations where you need to redisplay but no\n   user action has occurred, making it inappropriate for the message\n   area to be cleared.  See tracking_off and\n   wait_reading_process_output for examples of these situations.\n\n   FROM_WHERE is an integer saying from where this function was\n   called.  This is useful for debugging.  ") (span (|@| (class "comment-delimiter") (id "F:372912")) "*/") "\n\n" (span (|@| (class "type") (id "F:372916")) "void") "\n" (span (|@| (class "function-name") (id "F:372921")) "redisplay_preserve_echo_area") " (from_where)\n     " (span (|@| (class "type") (id "F:372968")) "int") " " (span (|@| (class "variable-name") (id "F:372972")) "from_where") ";\n{\n  TRACE ((stderr, " (span (|@| (class "string") (id "F:373004")) "\"redisplay_preserve_echo_area (%d)\\n\"") ", from_where));\n\n  " (span (|@| (class "keyword") (id "F:373060")) "if") " (" (span (|@| (class "negation-char") (id "F:373064")) "!") "NILP (echo_area_buffer[1]))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:373105")) "/* ") (span (|@| (class "comment") (id "F:373108")) "We have a previously displayed message, but no current\n         message.  Redisplay the previous message.  ") (span (|@| (class "comment-delimiter") (id "F:373208")) "*/") "\n      display_last_displayed_message_p = 1;\n      redisplay_internal (1);\n      display_last_displayed_message_p = 0;\n    }\n  " (span (|@| (class "keyword") (id "F:373337")) "else") "\n    redisplay_internal (1);\n\n  " (span (|@| (class "keyword") (id "F:373373")) "if") " (FRAME_RIF (SELECTED_FRAME ()) != " (span (|@| (class "constant") (id "F:373410")) "NULL") "\n      && FRAME_RIF (SELECTED_FRAME ())->flush_display_optional)\n    FRAME_RIF (SELECTED_FRAME ())->flush_display_optional (" (span (|@| (class "constant") (id "F:373538")) "NULL") ");\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:373549")) "/* ") (span (|@| (class "comment") (id "F:373552")) "Function registered with record_unwind_protect in\n   redisplay_internal.  Reset redisplaying_p to the value it had\n   before redisplay_internal was called, and clear\n   prevent_freeing_realized_faces_p.  It also selects the previously\n   selected frame, unless it has been deleted (by an X connection\n   failure during redisplay, for example).  ") (span (|@| (class "comment-delimiter") (id "F:373897")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:373901")) "static") " " (span (|@| (class "type") (id "F:373908")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:373920")) "unwind_redisplay") " (val)\n     " (span (|@| (class "type") (id "F:373948")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:373960")) "val") ";\n{\n  " (span (|@| (class "type") (id "F:373969")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:373981")) "old_redisplaying_p") ", " (span (|@| (class "variable-name") (id "F:374001")) "old_frame") ";\n\n  old_redisplaying_p = XCAR (val);\n  redisplaying_p = XFASTINT (old_redisplaying_p);\n  old_frame = XCDR (val);\n  " (span (|@| (class "keyword") (id "F:374126")) "if") " (" (span (|@| (class "negation-char") (id "F:374130")) "!") " EQ (old_frame, selected_frame)\n      && FRAME_LIVE_P (XFRAME (old_frame)))\n    select_frame_for_redisplay (old_frame);\n  " (span (|@| (class "keyword") (id "F:374253")) "return") " Qnil;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:374270")) "/* ") (span (|@| (class "comment") (id "F:374273")) "Mark the display of window W as accurate or inaccurate.  If\n   ACCURATE_P is non-zero mark display of W as accurate.  If\n   ACCURATE_P is zero, arrange for W to be redisplayed the next time\n   redisplay_internal is called.  ") (span (|@| (class "comment-delimiter") (id "F:374497")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:374501")) "static") " " (span (|@| (class "type") (id "F:374508")) "void") "\n" (span (|@| (class "function-name") (id "F:374513")) "mark_window_display_accurate_1") " (w, accurate_p)\n     " (span (|@| (class "keyword") (id "F:374565")) "struct") " " (span (|@| (class "type") (id "F:374572")) "window") " *" (span (|@| (class "variable-name") (id "F:374580")) "w") ";\n     " (span (|@| (class "type") (id "F:374588")) "int") " " (span (|@| (class "variable-name") (id "F:374592")) "accurate_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:374608")) "if") " (BUFFERP (w->buffer))\n    {\n      " (span (|@| (class "keyword") (id "F:374645")) "struct") " " (span (|@| (class "type") (id "F:374652")) "buffer") " *" (span (|@| (class "variable-name") (id "F:374660")) "b") " = XBUFFER (w->buffer);\n\n      w->last_modified\n        = make_number (accurate_p ? BUF_MODIFF (b) : 0);\n      w->last_overlay_modified\n        = make_number (accurate_p ? BUF_OVERLAY_MODIFF (b) : 0);\n      w->last_had_star\n        = BUF_MODIFF (b) > BUF_SAVE_MODIFF (b) ? Qt : Qnil;\n\n      " (span (|@| (class "keyword") (id "F:374931")) "if") " (accurate_p)\n        {\n          b->clip_changed = 0;\n          b->prevent_redisplay_optimizations_p = 0;\n\n          BUF_UNCHANGED_MODIFIED (b) = BUF_MODIFF (b);\n          BUF_OVERLAY_UNCHANGED_MODIFIED (b) = BUF_OVERLAY_MODIFF (b);\n          BUF_BEG_UNCHANGED (b) = BUF_GPT (b) - BUF_BEG (b);\n          BUF_END_UNCHANGED (b) = BUF_Z (b) - BUF_GPT (b);\n\n          w->current_matrix->buffer = b;\n          w->current_matrix->begv = BUF_BEGV (b);\n          w->current_matrix->zv = BUF_ZV (b);\n\n          w->last_cursor = w->cursor;\n          w->last_cursor_off_p = w->cursor_off_p;\n\n          " (span (|@| (class "keyword") (id "F:375434")) "if") " (w == XWINDOW (selected_window))\n            w->last_point = make_number (BUF_PT (b));\n          " (span (|@| (class "keyword") (id "F:375520")) "else") "\n            w->last_point = make_number (XMARKER (w->pointm)->charpos);\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:375602")) "if") " (accurate_p)\n    {\n      w->window_end_valid = w->buffer;\n      w->update_mode_line = Qnil;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:375707")) "/* ") (span (|@| (class "comment") (id "F:375710")) "Mark the display of windows in the window tree rooted at WINDOW as\n   accurate or inaccurate.  If ACCURATE_P is non-zero mark display of\n   windows as accurate.  If ACCURATE_P is zero, arrange for windows to\n   be redisplayed the next time redisplay_internal is called.  ") (span (|@| (class "comment-delimiter") (id "F:375981")) "*/") "\n\n" (span (|@| (class "type") (id "F:375985")) "void") "\n" (span (|@| (class "function-name") (id "F:375990")) "mark_window_display_accurate") " (" (span (|@| (class "type") (id "F:376020")) "window") ", accurate_p)\n     " (span (|@| (class "type") (id "F:376045")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:376057")) "window") ";\n     " (span (|@| (class "type") (id "F:376070")) "int") " " (span (|@| (class "variable-name") (id "F:376074")) "accurate_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:376090")) "struct") " " (span (|@| (class "type") (id "F:376097")) "window") " *" (span (|@| (class "variable-name") (id "F:376105")) "w") ";\n\n  " (span (|@| (class "keyword") (id "F:376111")) "for") " (; " (span (|@| (class "negation-char") (id "F:376118")) "!") "NILP (window); window = w->next)\n    {\n      w = XWINDOW (window);\n      mark_window_display_accurate_1 (w, accurate_p);\n\n      " (span (|@| (class "keyword") (id "F:376247")) "if") " (" (span (|@| (class "negation-char") (id "F:376251")) "!") "NILP (w->vchild))\n        mark_window_display_accurate (w->vchild, accurate_p);\n      " (span (|@| (class "keyword") (id "F:376331")) "if") " (" (span (|@| (class "negation-char") (id "F:376335")) "!") "NILP (w->hchild))\n        mark_window_display_accurate (w->hchild, accurate_p);\n    }\n\n  " (span (|@| (class "keyword") (id "F:376418")) "if") " (accurate_p)\n    {\n      update_overlay_arrows (1);\n    }\n  " (span (|@| (class "keyword") (id "F:376481")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:376498")) "/* ") (span (|@| (class "comment") (id "F:376501")) "Force a thorough redisplay the next time by setting\n         last_arrow_position and last_arrow_string to t, which is\n         unequal to any useful value of Voverlay_arrow_...  ") (span (|@| (class "comment-delimiter") (id "F:376665")) "*/") "\n      update_overlay_arrows (-1);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:376712")) "/* ") (span (|@| (class "comment") (id "F:376715")) "Return value in display table DP (Lisp_Char_Table *) for character\n   C.  Since a display table doesn't have any parent, we don't have to\n   follow parent.  Do not call this function directly but use the\n   macro DISP_CHAR_VECTOR.  ") (span (|@| (class "comment-delimiter") (id "F:376947")) "*/") "\n\n" (span (|@| (class "type") (id "F:376951")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:376963")) "disp_char_vector") " (dp, c)\n     " (span (|@| (class "keyword") (id "F:376993")) "struct") " " (span (|@| (class "type") (id "F:377000")) "Lisp_Char_Table") " *" (span (|@| (class "variable-name") (id "F:377017")) "dp") ";\n     " (span (|@| (class "type") (id "F:377026")) "int") " " (span (|@| (class "variable-name") (id "F:377030")) "c") ";\n{\n  " (span (|@| (class "type") (id "F:377037")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:377049")) "val") ";\n\n  " (span (|@| (class "keyword") (id "F:377057")) "if") " (ASCII_CHAR_P (c))\n    {\n      val = dp->ascii;\n      " (span (|@| (class "keyword") (id "F:377114")) "if") " (SUB_CHAR_TABLE_P (val))\n        val = XSUB_CHAR_TABLE (val)->contents[c];\n    }\n  " (span (|@| (class "keyword") (id "F:377193")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:377210")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:377222")) "table") ";\n\n      XSETCHAR_TABLE (table, dp);\n      val = char_table_ref (table, c);\n    }\n  " (span (|@| (class "keyword") (id "F:377311")) "if") " (NILP (val))\n    val = dp->defalt;\n  " (span (|@| (class "keyword") (id "F:377351")) "return") " val;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:377369")) "/***********************************************************************") (span (|@| (class "comment") (id "F:377441")) "\n                           Window Redisplay\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:377536")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:377540")) "/* ") (span (|@| (class "comment") (id "F:377543")) "Redisplay all leaf windows in the window tree rooted at WINDOW.  ") (span (|@| (class "comment-delimiter") (id "F:377608")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:377612")) "static") " " (span (|@| (class "type") (id "F:377619")) "void") "\n" (span (|@| (class "function-name") (id "F:377624")) "redisplay_windows") " (" (span (|@| (class "type") (id "F:377643")) "window") ")\n     " (span (|@| (class "type") (id "F:377656")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:377668")) "window") ";\n{\n  " (span (|@| (class "keyword") (id "F:377680")) "while") " (" (span (|@| (class "negation-char") (id "F:377687")) "!") "NILP (window))\n    {\n      " (span (|@| (class "keyword") (id "F:377715")) "struct") " " (span (|@| (class "type") (id "F:377722")) "window") " *" (span (|@| (class "variable-name") (id "F:377730")) "w") " = XWINDOW (window);\n\n      " (span (|@| (class "keyword") (id "F:377759")) "if") " (" (span (|@| (class "negation-char") (id "F:377763")) "!") "NILP (w->hchild))\n        redisplay_windows (w->hchild);\n      " (span (|@| (class "keyword") (id "F:377820")) "else") " " (span (|@| (class "keyword") (id "F:377825")) "if") " (" (span (|@| (class "negation-char") (id "F:377829")) "!") "NILP (w->vchild))\n        redisplay_windows (w->vchild);\n      " (span (|@| (class "keyword") (id "F:377886")) "else") " " (span (|@| (class "keyword") (id "F:377891")) "if") " (" (span (|@| (class "negation-char") (id "F:377895")) "!") "NILP (w->buffer))\n        {\n          displayed_buffer = XBUFFER (w->buffer);\n          " (span (|@| (class "comment-delimiter") (id "F:377963")) "/* ") (span (|@| (class "comment") (id "F:377966")) "Use list_of_error, not Qerror, so that\n             we catch only errors and don't run the debugger.  ") (span (|@| (class "comment-delimiter") (id "F:378061")) "*/") "\n          internal_condition_case_1 (redisplay_window_0, window,\n                                     list_of_error,\n                                     redisplay_window_error);\n        }\n\n      window = w->next;\n    }\n}\n\n" (span (|@| (class "keyword") (id "F:378217")) "static") " " (span (|@| (class "type") (id "F:378224")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:378236")) "redisplay_window_error") " ()\n{\n  displayed_buffer->display_error_modiff = BUF_MODIFF (displayed_buffer);\n  " (span (|@| (class "keyword") (id "F:378340")) "return") " Qnil;\n}\n\n" (span (|@| (class "keyword") (id "F:378356")) "static") " " (span (|@| (class "type") (id "F:378363")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:378375")) "redisplay_window_0") " (" (span (|@| (class "type") (id "F:378395")) "window") ")\n     " (span (|@| (class "type") (id "F:378408")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:378420")) "window") ";\n{\n  " (span (|@| (class "keyword") (id "F:378432")) "if") " (displayed_buffer->display_error_modiff < BUF_MODIFF (displayed_buffer))\n    redisplay_window (window, 0);\n  " (span (|@| (class "keyword") (id "F:378544")) "return") " Qnil;\n}\n\n" (span (|@| (class "keyword") (id "F:378560")) "static") " " (span (|@| (class "type") (id "F:378567")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:378579")) "redisplay_window_1") " (" (span (|@| (class "type") (id "F:378599")) "window") ")\n     " (span (|@| (class "type") (id "F:378612")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:378624")) "window") ";\n{\n  " (span (|@| (class "keyword") (id "F:378636")) "if") " (displayed_buffer->display_error_modiff < BUF_MODIFF (displayed_buffer))\n    redisplay_window (window, 1);\n  " (span (|@| (class "keyword") (id "F:378748")) "return") " Qnil;\n}\n\f\n\n" (span (|@| (class "comment-delimiter") (id "F:378766")) "/* ") (span (|@| (class "comment") (id "F:378769")) "Increment GLYPH until it reaches END or CONDITION fails while\n   adding (GLYPH)->pixel_width to X. ") (span (|@| (class "comment-delimiter") (id "F:378868")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:378872")) "#define") " " (span (|@| (class "function-name") (id "F:378880")) "SKIP_GLYPHS") "(" (span (|@| (class "variable-name") (id "F:378892")) "glyph") ", " (span (|@| (class "variable-name") (id "F:378899")) "end") ", " (span (|@| (class "variable-name") (id "F:378904")) "x") ", " (span (|@| (class "variable-name") (id "F:378907")) "condition") ")   \\\n  " (span (|@| (class "keyword") (id "F:378922")) "do") "                                            \\\n    {                                           \\\n      (x) += (glyph)->pixel_width;              \\\n      ++(glyph);                                \\\n    }                                           \\\n  " (span (|@| (class "keyword") (id "F:379020")) "while") " ((glyph) < (end) && (condition))\n\n\n" (span (|@| (class "comment-delimiter") (id "F:379061")) "/* ") (span (|@| (class "comment") (id "F:379064")) "Set cursor position of W.  PT is assumed to be displayed in ROW.\n   DELTA and DELTA_BYTES are the numbers of characters and bytes by\n   which positions recorded in ROW differ from current buffer\n   positions.\n\n   Return 0 if cursor is not on this row, 1 otherwise.  ") (span (|@| (class "comment-delimiter") (id "F:379330")) "*/") "\n\n" (span (|@| (class "type") (id "F:379334")) "int") "\n" (span (|@| (class "function-name") (id "F:379338")) "set_cursor_from_row") " (w, row, matrix, delta, delta_bytes, dy, dvpos)\n     " (span (|@| (class "keyword") (id "F:379411")) "struct") " " (span (|@| (class "type") (id "F:379418")) "window") " *" (span (|@| (class "variable-name") (id "F:379426")) "w") ";\n     " (span (|@| (class "keyword") (id "F:379434")) "struct") " " (span (|@| (class "type") (id "F:379441")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:379452")) "row") ";\n     " (span (|@| (class "keyword") (id "F:379462")) "struct") " " (span (|@| (class "type") (id "F:379469")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:379483")) "matrix") ";\n     " (span (|@| (class "type") (id "F:379496")) "int") " " (span (|@| (class "variable-name") (id "F:379500")) "delta") ", " (span (|@| (class "variable-name") (id "F:379507")) "delta_bytes") ", " (span (|@| (class "variable-name") (id "F:379520")) "dy") ", " (span (|@| (class "variable-name") (id "F:379524")) "dvpos") ";\n{\n  " (span (|@| (class "keyword") (id "F:379535")) "struct") " " (span (|@| (class "type") (id "F:379542")) "glyph") " *" (span (|@| (class "variable-name") (id "F:379549")) "glyph") " = row->glyphs[TEXT_AREA];\n  " (span (|@| (class "keyword") (id "F:379583")) "struct") " " (span (|@| (class "type") (id "F:379590")) "glyph") " *" (span (|@| (class "variable-name") (id "F:379597")) "end") " = glyph + row->used[TEXT_AREA];\n  " (span (|@| (class "keyword") (id "F:379635")) "struct") " " (span (|@| (class "type") (id "F:379642")) "glyph") " *" (span (|@| (class "variable-name") (id "F:379649")) "cursor") " = " (span (|@| (class "constant") (id "F:379658")) "NULL") ";\n  " (span (|@| (class "comment-delimiter") (id "F:379666")) "/* ") (span (|@| (class "comment") (id "F:379669")) "The last known character position in row.  ") (span (|@| (class "comment-delimiter") (id "F:379712")) "*/") "\n  " (span (|@| (class "type") (id "F:379717")) "int") " " (span (|@| (class "variable-name") (id "F:379721")) "last_pos") " = MATRIX_ROW_START_CHARPOS (row) + delta;\n  " (span (|@| (class "type") (id "F:379774")) "int") " " (span (|@| (class "variable-name") (id "F:379778")) "x") " = row->x;\n  " (span (|@| (class "type") (id "F:379792")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:379802")) "pt_old") " = PT - delta;\n  " (span (|@| (class "type") (id "F:379825")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:379835")) "pos_before") " = MATRIX_ROW_START_CHARPOS (row) + delta;\n  " (span (|@| (class "type") (id "F:379890")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:379900")) "pos_after") " = MATRIX_ROW_END_CHARPOS (row) + delta;\n  " (span (|@| (class "keyword") (id "F:379952")) "struct") " " (span (|@| (class "type") (id "F:379959")) "glyph") " *" (span (|@| (class "variable-name") (id "F:379966")) "glyph_before") " = glyph - 1, *" (span (|@| (class "variable-name") (id "F:379993")) "glyph_after") " = end;\n  " (span (|@| (class "comment-delimiter") (id "F:380014")) "/* ") (span (|@| (class "comment") (id "F:380017")) "A glyph beyond the edge of TEXT_AREA which we should never\n     touch.  ") (span (|@| (class "comment-delimiter") (id "F:380089")) "*/") "\n  " (span (|@| (class "keyword") (id "F:380094")) "struct") " " (span (|@| (class "type") (id "F:380101")) "glyph") " *" (span (|@| (class "variable-name") (id "F:380108")) "glyphs_end") " = end;\n  " (span (|@| (class "comment-delimiter") (id "F:380128")) "/* ") (span (|@| (class "comment") (id "F:380131")) "Non-zero means we've found a match for cursor position, but that\n     glyph has the avoid_cursor_p flag set.  ") (span (|@| (class "comment-delimiter") (id "F:380241")) "*/") "\n  " (span (|@| (class "type") (id "F:380246")) "int") " " (span (|@| (class "variable-name") (id "F:380250")) "match_with_avoid_cursor") " = 0;\n  " (span (|@| (class "comment-delimiter") (id "F:380281")) "/* ") (span (|@| (class "comment") (id "F:380284")) "Non-zero means we've seen at least one glyph that came from a\n     display string.  ") (span (|@| (class "comment-delimiter") (id "F:380368")) "*/") "\n  " (span (|@| (class "type") (id "F:380373")) "int") " " (span (|@| (class "variable-name") (id "F:380377")) "string_seen") " = 0;\n  " (span (|@| (class "comment-delimiter") (id "F:380396")) "/* ") (span (|@| (class "comment") (id "F:380399")) "Largest buffer position seen so far during scan of glyph row.  ") (span (|@| (class "comment-delimiter") (id "F:380462")) "*/") "\n  " (span (|@| (class "type") (id "F:380467")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:380477")) "bpos_max") " = last_pos;\n  " (span (|@| (class "comment-delimiter") (id "F:380500")) "/* ") (span (|@| (class "comment") (id "F:380503")) "Last buffer position covered by an overlay string with an integer\n     `cursor' property.  ") (span (|@| (class "comment-delimiter") (id "F:380594")) "*/") "\n  " (span (|@| (class "type") (id "F:380599")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:380609")) "bpos_covered") " = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:380630")) "/* ") (span (|@| (class "comment") (id "F:380633")) "Skip over glyphs not having an object at the start and the end of\n     the row.  These are special glyphs like truncation marks on\n     terminal frames.  ") (span (|@| (class "comment-delimiter") (id "F:380787")) "*/") "\n  " (span (|@| (class "keyword") (id "F:380792")) "if") " (row->displays_text_p)\n    {\n      " (span (|@| (class "keyword") (id "F:380830")) "if") " (" (span (|@| (class "negation-char") (id "F:380834")) "!") "row->reversed_p)\n        {\n          " (span (|@| (class "keyword") (id "F:380858")) "while") " (glyph < end\n                 && INTEGERP (glyph->object)\n                 && glyph->charpos < 0)\n            {\n              x += glyph->pixel_width;\n              ++glyph;\n            }\n          " (span (|@| (class "keyword") (id "F:380999")) "while") " (end > glyph\n                 && INTEGERP ((end - 1)->object)\n                 " (span (|@| (class "comment-delimiter") (id "F:381056")) "/* ") (span (|@| (class "comment") (id "F:381059")) "CHARPOS is zero for blanks and stretch glyphs\n                    inserted by extend_face_to_end_of_line.  ") (span (|@| (class "comment-delimiter") (id "F:381152")) "*/") "\n                 && (end - 1)->charpos <= 0)\n            --end;\n          glyph_before = glyph - 1;\n          glyph_after = end;\n        }\n      " (span (|@| (class "keyword") (id "F:381258")) "else") "\n        {\n          " (span (|@| (class "keyword") (id "F:381269")) "struct") " " (span (|@| (class "type") (id "F:381276")) "glyph") " *" (span (|@| (class "variable-name") (id "F:381283")) "g") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:381290")) "/* ") (span (|@| (class "comment") (id "F:381293")) "If the glyph row is reversed, we need to process it from back\n             to front, so swap the edge pointers.  ") (span (|@| (class "comment-delimiter") (id "F:381399")) "*/") "\n          glyphs_end = end = glyph - 1;\n          glyph += row->used[TEXT_AREA] - 1;\n\n          " (span (|@| (class "keyword") (id "F:381477")) "while") " (glyph > end + 1\n                 && INTEGERP (glyph->object)\n                 && glyph->charpos < 0)\n            {\n              --glyph;\n              x -= glyph->pixel_width;\n            }\n          " (span (|@| (class "keyword") (id "F:381622")) "if") " (INTEGERP (glyph->object) && glyph->charpos < 0)\n            --glyph;\n          " (span (|@| (class "comment-delimiter") (id "F:381691")) "/* ") (span (|@| (class "comment") (id "F:381694")) "By default, in reversed rows we put the cursor on the\n             rightmost (first in the reading order) glyph.  ") (span (|@| (class "comment-delimiter") (id "F:381801")) "*/") "\n          " (span (|@| (class "keyword") (id "F:381807")) "for") " (g = end + 1; g < glyph; g++)\n            x += g->pixel_width;\n          " (span (|@| (class "keyword") (id "F:381870")) "while") " (end < glyph\n                 && INTEGERP ((end + 1)->object)\n                 && (end + 1)->charpos <= 0)\n            ++end;\n          glyph_before = glyph + 1;\n          glyph_after = end;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:382029")) "else") " " (span (|@| (class "keyword") (id "F:382034")) "if") " (row->reversed_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:382067")) "/* ") (span (|@| (class "comment") (id "F:382070")) "In R2L rows that don't display text, put the cursor on the\n         rightmost glyph.  Case in point: an empty last line that is\n         part of an R2L paragraph.  ") (span (|@| (class "comment-delimiter") (id "F:382220")) "*/") "\n      cursor = end - 1;\n      " (span (|@| (class "comment-delimiter") (id "F:382253")) "/* ") (span (|@| (class "comment") (id "F:382256")) "Avoid placing the cursor on the last glyph of the row, where\n         on terminal frames we hold the vertical border between\n         adjacent windows.  ") (span (|@| (class "comment-delimiter") (id "F:382395")) "*/") "\n      " (span (|@| (class "keyword") (id "F:382404")) "if") " (" (span (|@| (class "negation-char") (id "F:382408")) "!") "FRAME_WINDOW_P (WINDOW_XFRAME (w))\n          && " (span (|@| (class "negation-char") (id "F:382450")) "!") "WINDOW_RIGHTMOST_P (w)\n          && cursor == row->glyphs[LAST_AREA] - 1)\n        cursor--;\n      x = -1;   " (span (|@| (class "comment-delimiter") (id "F:382543")) "/* ") (span (|@| (class "comment") (id "F:382546")) "will be computed below, at label compute_x ") (span (|@| (class "comment-delimiter") (id "F:382589")) "*/") "\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:382601")) "/* ") (span (|@| (class "comment") (id "F:382604")) "Step 1: Try to find the glyph whose character position\n     corresponds to point.  If that's not possible, find 2 glyphs\n     whose character positions are the closest to point, one before\n     point, the other after it.  ") (span (|@| (class "comment-delimiter") (id "F:382826")) "*/") "\n  " (span (|@| (class "keyword") (id "F:382831")) "if") " (" (span (|@| (class "negation-char") (id "F:382835")) "!") "row->reversed_p)\n    " (span (|@| (class "keyword") (id "F:382857")) "while") " (" (span (|@| (class "comment-delimiter") (id "F:382864")) "/* ") (span (|@| (class "comment") (id "F:382867")) "not marched to end of glyph row ") (span (|@| (class "comment-delimiter") (id "F:382899")) "*/") "\n           glyph < end\n           " (span (|@| (class "comment-delimiter") (id "F:382922")) "/* ") (span (|@| (class "comment") (id "F:382925")) "glyph was not inserted by redisplay for internal purposes ") (span (|@| (class "comment-delimiter") (id "F:382983")) "*/") "\n           && " (span (|@| (class "negation-char") (id "F:382993")) "!") "INTEGERP (glyph->object))\n      {\n        " (span (|@| (class "keyword") (id "F:383029")) "if") " (BUFFERP (glyph->object))\n          {\n            " (span (|@| (class "type") (id "F:383068")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:383078")) "dpos") " = glyph->charpos - pt_old;\n\n            " (span (|@| (class "keyword") (id "F:383116")) "if") " (glyph->charpos > bpos_max)\n              bpos_max = glyph->charpos;\n            " (span (|@| (class "keyword") (id "F:383186")) "if") " (" (span (|@| (class "negation-char") (id "F:383190")) "!") "glyph->avoid_cursor_p)\n              {\n                " (span (|@| (class "comment-delimiter") (id "F:383225")) "/* ") (span (|@| (class "comment") (id "F:383228")) "If we hit point, we've found the glyph on which to\n                   display the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:383305")) "*/") "\n                " (span (|@| (class "keyword") (id "F:383310")) "if") " (dpos == 0)\n                  {\n                    match_with_avoid_cursor = 0;\n                    " (span (|@| (class "keyword") (id "F:383372")) "break") ";\n                  }\n                " (span (|@| (class "comment-delimiter") (id "F:383387")) "/* ") (span (|@| (class "comment") (id "F:383390")) "See if we've found a better approximation to\n                   POS_BEFORE or to POS_AFTER.  Note that we want the\n                   first (leftmost) glyph of all those that are the\n                   closest from below, and the last (rightmost) of all\n                   those from above.  ") (span (|@| (class "comment-delimiter") (id "F:383626")) "*/") "\n                " (span (|@| (class "keyword") (id "F:383631")) "if") " (0 > dpos && dpos > pos_before - pt_old)\n                  {\n                    pos_before = glyph->charpos;\n                    glyph_before = glyph;\n                  }\n                " (span (|@| (class "keyword") (id "F:383752")) "else") " " (span (|@| (class "keyword") (id "F:383757")) "if") " (0 < dpos && dpos <= pos_after - pt_old)\n                  {\n                    pos_after = glyph->charpos;\n                    glyph_after = glyph;\n                  }\n              }\n            " (span (|@| (class "keyword") (id "F:383888")) "else") " " (span (|@| (class "keyword") (id "F:383893")) "if") " (dpos == 0)\n              match_with_avoid_cursor = 1;\n          }\n        " (span (|@| (class "keyword") (id "F:383950")) "else") " " (span (|@| (class "keyword") (id "F:383955")) "if") " (STRINGP (glyph->object))\n          {\n            " (span (|@| (class "type") (id "F:383994")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:384006")) "chprop") ";\n            " (span (|@| (class "type") (id "F:384019")) "int") " " (span (|@| (class "variable-name") (id "F:384023")) "glyph_pos") " = glyph->charpos;\n\n            chprop = Fget_char_property (make_number (glyph_pos), Qcursor,\n                                         glyph->object);\n            " (span (|@| (class "keyword") (id "F:384147")) "if") " (INTEGERP (chprop))\n              {\n                bpos_covered = bpos_max + XINT (chprop);\n                " (span (|@| (class "comment-delimiter") (id "F:384224")) "/* ") (span (|@| (class "comment") (id "F:384227")) "If the `cursor' property covers buffer positions up\n                   to and including point, we should display cursor on\n                   this glyph.  Note that overlays and text properties\n                   with string values stop bidi reordering, so every\n                   buffer position to the left of the string is always\n                   smaller than any position to the right of the\n                   string.  Therefore, if a `cursor' property on one\n                   of the string's characters has an integer value, we\n                   will break out of the loop below _before_ we get to\n                   the position match above.  IOW, integer values of\n                   the `cursor' property override the \"exact match for\n                   point\" strategy of positioning the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:384886")) "*/") "\n                " (span (|@| (class "comment-delimiter") (id "F:384891")) "/* ") (span (|@| (class "comment") (id "F:384894")) "Implementation note: bpos_max == pt_old when, e.g.,\n                   we are in an empty line, where bpos_max is set to\n                   MATRIX_ROW_START_CHARPOS, see above.  ") (span (|@| (class "comment-delimiter") (id "F:385044")) "*/") "\n                " (span (|@| (class "keyword") (id "F:385049")) "if") " (bpos_max <= pt_old && bpos_covered >= pt_old)\n                  {\n                    cursor = glyph;\n                    " (span (|@| (class "keyword") (id "F:385133")) "break") ";\n                  }\n              }\n\n            string_seen = 1;\n          }\n        x += glyph->pixel_width;\n        ++glyph;\n      }\n  " (span (|@| (class "keyword") (id "F:385229")) "else") " " (span (|@| (class "keyword") (id "F:385234")) "if") " (glyph > end) " (span (|@| (class "comment-delimiter") (id "F:385251")) "/* ") (span (|@| (class "comment") (id "F:385254")) "row is reversed ") (span (|@| (class "comment-delimiter") (id "F:385270")) "*/") "\n    " (span (|@| (class "keyword") (id "F:385277")) "while") " (" (span (|@| (class "negation-char") (id "F:385284")) "!") "INTEGERP (glyph->object))\n      {\n        " (span (|@| (class "keyword") (id "F:385320")) "if") " (BUFFERP (glyph->object))\n          {\n            " (span (|@| (class "type") (id "F:385359")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:385369")) "dpos") " = glyph->charpos - pt_old;\n\n            " (span (|@| (class "keyword") (id "F:385407")) "if") " (glyph->charpos > bpos_max)\n              bpos_max = glyph->charpos;\n            " (span (|@| (class "keyword") (id "F:385477")) "if") " (" (span (|@| (class "negation-char") (id "F:385481")) "!") "glyph->avoid_cursor_p)\n              {\n                " (span (|@| (class "keyword") (id "F:385516")) "if") " (dpos == 0)\n                  {\n                    match_with_avoid_cursor = 0;\n                    " (span (|@| (class "keyword") (id "F:385578")) "break") ";\n                  }\n                " (span (|@| (class "keyword") (id "F:385593")) "if") " (0 > dpos && dpos > pos_before - pt_old)\n                  {\n                    pos_before = glyph->charpos;\n                    glyph_before = glyph;\n                  }\n                " (span (|@| (class "keyword") (id "F:385714")) "else") " " (span (|@| (class "keyword") (id "F:385719")) "if") " (0 < dpos && dpos <= pos_after - pt_old)\n                  {\n                    pos_after = glyph->charpos;\n                    glyph_after = glyph;\n                  }\n              }\n            " (span (|@| (class "keyword") (id "F:385850")) "else") " " (span (|@| (class "keyword") (id "F:385855")) "if") " (dpos == 0)\n              match_with_avoid_cursor = 1;\n          }\n        " (span (|@| (class "keyword") (id "F:385912")) "else") " " (span (|@| (class "keyword") (id "F:385917")) "if") " (STRINGP (glyph->object))\n          {\n            " (span (|@| (class "type") (id "F:385956")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:385968")) "chprop") ";\n            " (span (|@| (class "type") (id "F:385981")) "int") " " (span (|@| (class "variable-name") (id "F:385985")) "glyph_pos") " = glyph->charpos;\n\n            chprop = Fget_char_property (make_number (glyph_pos), Qcursor,\n                                         glyph->object);\n            " (span (|@| (class "keyword") (id "F:386109")) "if") " (INTEGERP (chprop))\n              {\n                bpos_covered = bpos_max + XINT (chprop);\n                " (span (|@| (class "comment-delimiter") (id "F:386186")) "/* ") (span (|@| (class "comment") (id "F:386189")) "If the `cursor' property covers buffer positions up\n                   to and including point, we should display cursor on\n                   this glyph.  ") (span (|@| (class "comment-delimiter") (id "F:386316")) "*/") "\n                " (span (|@| (class "keyword") (id "F:386321")) "if") " (bpos_max <= pt_old && bpos_covered >= pt_old)\n                  {\n                    cursor = glyph;\n                    " (span (|@| (class "keyword") (id "F:386405")) "break") ";\n                  }\n              }\n            string_seen = 1;\n          }\n        --glyph;\n        " (span (|@| (class "keyword") (id "F:386465")) "if") " (glyph == glyphs_end) " (span (|@| (class "comment-delimiter") (id "F:386490")) "/* ") (span (|@| (class "comment") (id "F:386493")) "don't dereference outside TEXT_AREA ") (span (|@| (class "comment-delimiter") (id "F:386529")) "*/") "\n          {\n            x--;                " (span (|@| (class "comment-delimiter") (id "F:386548")) "/* ") (span (|@| (class "comment") (id "F:386551")) "can't use any pixel_width ") (span (|@| (class "comment-delimiter") (id "F:386577")) "*/") "\n            " (span (|@| (class "keyword") (id "F:386585")) "break") ";\n          }\n        x -= glyph->pixel_width;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:386632")) "/* ") (span (|@| (class "comment") (id "F:386635")) "Step 2: If we didn't find an exact match for point, we need to\n     look for a proper place to put the cursor among glyphs between\n     GLYPH_BEFORE and GLYPH_AFTER.  ") (span (|@| (class "comment-delimiter") (id "F:386802")) "*/") "\n  " (span (|@| (class "keyword") (id "F:386807")) "if") " (" (span (|@| (class "negation-char") (id "F:386811")) "!") "((row->reversed_p ? glyph > glyphs_end : glyph < glyphs_end)\n        && BUFFERP (glyph->object) && glyph->charpos == pt_old)\n      && bpos_covered < pt_old)\n    {\n      " (span (|@| (class "keyword") (id "F:386974")) "if") " (row->ends_in_ellipsis_p && pos_after == last_pos)\n        {\n          " (span (|@| (class "type") (id "F:387034")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:387044")) "ellipsis_pos") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:387062")) "/* ") (span (|@| (class "comment") (id "F:387065")) "Scan back over the ellipsis glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:387102")) "*/") "\n          " (span (|@| (class "keyword") (id "F:387108")) "if") " (" (span (|@| (class "negation-char") (id "F:387112")) "!") "row->reversed_p)\n            {\n              ellipsis_pos = (glyph - 1)->charpos;\n              " (span (|@| (class "keyword") (id "F:387188")) "while") " (glyph > row->glyphs[TEXT_AREA]\n                     && (glyph - 1)->charpos == ellipsis_pos)\n                glyph--, x -= glyph->pixel_width;\n              " (span (|@| (class "comment-delimiter") (id "F:387317")) "/* ") (span (|@| (class "comment") (id "F:387320")) "That loop always goes one position too far, including\n                 the glyph before the ellipsis.  So scan forward over\n                 that one.  ") (span (|@| (class "comment-delimiter") (id "F:387444")) "*/") "\n              x += glyph->pixel_width;\n              glyph++;\n            }\n          " (span (|@| (class "keyword") (id "F:387505")) "else") "  " (span (|@| (class "comment-delimiter") (id "F:387510")) "/* ") (span (|@| (class "comment") (id "F:387513")) "row is reversed ") (span (|@| (class "comment-delimiter") (id "F:387529")) "*/") "\n            {\n              ellipsis_pos = (glyph + 1)->charpos;\n              " (span (|@| (class "keyword") (id "F:387590")) "while") " (glyph < row->glyphs[TEXT_AREA] + row->used[TEXT_AREA] - 1\n                     && (glyph + 1)->charpos == ellipsis_pos)\n                glyph++, x += glyph->pixel_width;\n              x -= glyph->pixel_width;\n              glyph--;\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:387803")) "else") " " (span (|@| (class "keyword") (id "F:387808")) "if") " (match_with_avoid_cursor\n               " (span (|@| (class "comment-delimiter") (id "F:387844")) "/* ") (span (|@| (class "comment") (id "F:387847")) "zero-width characters produce no glyphs ") (span (|@| (class "comment-delimiter") (id "F:387887")) "*/") "\n               || ((row->reversed_p\n                    ? glyph_after > glyphs_end\n                    : glyph_after < glyphs_end)\n                   && eabs (glyph_after - glyph_before) == 1))\n        {\n          cursor = glyph_after;\n          x = -1;\n        }\n      " (span (|@| (class "keyword") (id "F:388083")) "else") " " (span (|@| (class "keyword") (id "F:388088")) "if") " (string_seen)\n        {\n          " (span (|@| (class "type") (id "F:388111")) "int") " " (span (|@| (class "variable-name") (id "F:388115")) "incr") " = row->reversed_p ? -1 : +1;\n\n          " (span (|@| (class "comment-delimiter") (id "F:388153")) "/* ") (span (|@| (class "comment") (id "F:388156")) "Need to find the glyph that came out of a string which is\n             present at point.  That glyph is somewhere between\n             GLYPH_BEFORE and GLYPH_AFTER, and it came from a string\n             positioned between POS_BEFORE and POS_AFTER in the\n             buffer.  ") (span (|@| (class "comment-delimiter") (id "F:388405")) "*/") "\n          " (span (|@| (class "keyword") (id "F:388411")) "struct") " " (span (|@| (class "type") (id "F:388418")) "glyph") " *" (span (|@| (class "variable-name") (id "F:388425")) "stop") " = glyph_after;\n          " (span (|@| (class "type") (id "F:388448")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:388458")) "pos") " = pos_before;\n\n          x = -1;\n          " (span (|@| (class "keyword") (id "F:388491")) "for") " (glyph = glyph_before + incr;\n               row->reversed_p ? glyph > stop : glyph < stop; )\n            {\n\n              " (span (|@| (class "comment-delimiter") (id "F:388597")) "/* ") (span (|@| (class "comment") (id "F:388600")) "Any glyphs that come from the buffer are here because\n                 of bidi reordering.  Skip them, and only pay\n                 attention to glyphs that came from some string.  ") (span (|@| (class "comment-delimiter") (id "F:388754")) "*/") "\n              " (span (|@| (class "keyword") (id "F:388764")) "if") " (STRINGP (glyph->object))\n                {\n                  " (span (|@| (class "type") (id "F:388801")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:388813")) "str") ";\n                  " (span (|@| (class "type") (id "F:388822")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:388832")) "tem") ";\n\n                  str = glyph->object;\n                  tem = string_buffer_position_lim (w, str, pos, pos_after, 0);\n                  " (span (|@| (class "keyword") (id "F:388933")) "if") " (tem == 0  " (span (|@| (class "comment-delimiter") (id "F:388946")) "/* ") (span (|@| (class "comment") (id "F:388949")) "from overlay ") (span (|@| (class "comment-delimiter") (id "F:388962")) "*/") "\n                      || pos <= tem)\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:389004")) "/* ") (span (|@| (class "comment") (id "F:389007")) "If the string from which this glyph came is\n                         found in the buffer at point, then we've\n                         found the glyph we've been looking for.  If\n                         it comes from an overlay (tem == 0), and it\n                         has the `cursor' property on one of its\n                         glyphs, record that glyph as a candidate for\n                         displaying the cursor.  (As in the\n                         unidirectional version, we will display the\n                         cursor on the last candidate we find.)  ") (span (|@| (class "comment-delimiter") (id "F:389416")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:389427")) "if") " (tem == 0 || tem == pt_old)\n                        {\n                          " (span (|@| (class "comment-delimiter") (id "F:389468")) "/* ") (span (|@| (class "comment") (id "F:389471")) "The glyphs from this string could have\n                             been reordered.  Find the one with the\n                             smallest string position.  Or there could\n                             be a character in the string with the\n                             `cursor' property, which means display\n                             cursor on that character's glyph.  ") (span (|@| (class "comment-delimiter") (id "F:389743")) "*/") "\n                          " (span (|@| (class "type") (id "F:389751")) "int") " " (span (|@| (class "variable-name") (id "F:389755")) "strpos") " = glyph->charpos;\n\n                          cursor = glyph;\n                          " (span (|@| (class "keyword") (id "F:389807")) "for") " (glyph += incr;\n                               (row->reversed_p ? glyph > stop : glyph < stop)\n                                 && EQ (glyph->object, str);\n                               glyph += incr)\n                            {\n                              " (span (|@| (class "type") (id "F:389961")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:389973")) "cprop") ";\n                              " (span (|@| (class "type") (id "F:389989")) "int") " " (span (|@| (class "variable-name") (id "F:389993")) "gpos") " = glyph->charpos;\n\n                              cprop = Fget_char_property (make_number (gpos),\n                                                          Qcursor,\n                                                          glyph->object);\n                              " (span (|@| (class "keyword") (id "F:390126")) "if") " (" (span (|@| (class "negation-char") (id "F:390130")) "!") "NILP (cprop))\n                                {\n                                  cursor = glyph;\n                                  " (span (|@| (class "keyword") (id "F:390179")) "break") ";\n                                }\n                              " (span (|@| (class "keyword") (id "F:390201")) "if") " (glyph->charpos < strpos)\n                                {\n                                  strpos = glyph->charpos;\n                                  cursor = glyph;\n                                }\n                            }\n\n                          " (span (|@| (class "keyword") (id "F:390310")) "if") " (tem == pt_old)\n                            " (span (|@| (class "keyword") (id "F:390336")) "goto") " " (span (|@| (class "constant") (id "F:390341")) "compute_x") ";\n                        }\n                      " (span (|@| (class "keyword") (id "F:390365")) "if") " (tem)\n                        pos = tem + 1; " (span (|@| (class "comment-delimiter") (id "F:390392")) "/* ") (span (|@| (class "comment") (id "F:390395")) "don't find previous instances ") (span (|@| (class "comment-delimiter") (id "F:390425")) "*/") "\n                    }\n                  " (span (|@| (class "comment-delimiter") (id "F:390440")) "/* ") (span (|@| (class "comment") (id "F:390443")) "This string is not what we want; skip all of the\n                     glyphs that came from it.  ") (span (|@| (class "comment-delimiter") (id "F:390526")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:390533")) "do") "\n                    glyph += incr;\n                  " (span (|@| (class "keyword") (id "F:390561")) "while") " ((row->reversed_p ? glyph > stop : glyph < stop)\n                         && EQ (glyph->object, str));\n                }\n              " (span (|@| (class "keyword") (id "F:390660")) "else") "\n                glyph += incr;\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:390693")) "/* ") (span (|@| (class "comment") (id "F:390696")) "If we reached the end of the line, and END was from a string,\n             the cursor is not on this line.  ") (span (|@| (class "comment-delimiter") (id "F:390797")) "*/") "\n          " (span (|@| (class "keyword") (id "F:390803")) "if") " (cursor == " (span (|@| (class "constant") (id "F:390817")) "NULL") "\n              && (row->reversed_p ? glyph <= end : glyph >= end)\n              && STRINGP (end->object)\n              && row->continued_p)\n            " (span (|@| (class "keyword") (id "F:390945")) "return") " 0;\n        }\n    }\n\n " (span (|@| (class "constant") (id "F:390966")) "compute_x") ":\n  " (span (|@| (class "keyword") (id "F:390979")) "if") " (cursor != " (span (|@| (class "constant") (id "F:390993")) "NULL") ")\n    glyph = cursor;\n  " (span (|@| (class "keyword") (id "F:391021")) "if") " (x < 0)\n    {\n      " (span (|@| (class "keyword") (id "F:391044")) "struct") " " (span (|@| (class "type") (id "F:391051")) "glyph") " *" (span (|@| (class "variable-name") (id "F:391058")) "g") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:391068")) "/* ") (span (|@| (class "comment") (id "F:391071")) "Need to compute x that corresponds to GLYPH.  ") (span (|@| (class "comment-delimiter") (id "F:391117")) "*/") "\n      " (span (|@| (class "keyword") (id "F:391126")) "for") " (g = row->glyphs[TEXT_AREA], x = row->x; g < glyph; g++)\n        {\n          " (span (|@| (class "keyword") (id "F:391193")) "if") " (g >= row->glyphs[TEXT_AREA] + row->used[TEXT_AREA])\n            abort ();\n          x += g->pixel_width;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:391300")) "/* ") (span (|@| (class "comment") (id "F:391303")) "ROW could be part of a continued line, which, under bidi\n     reordering, might have other rows whose start and end charpos\n     occlude point.  Only set w->cursor if we found a better\n     approximation to the cursor position than we have from previously\n     examined candidate rows belonging to the same continued line.  ") (span (|@| (class "comment-delimiter") (id "F:391627")) "*/") "\n  " (span (|@| (class "keyword") (id "F:391632")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:391636")) "/* ") (span (|@| (class "comment") (id "F:391639")) "we already have a candidate row ") (span (|@| (class "comment-delimiter") (id "F:391671")) "*/") "\n      w->cursor.vpos >= 0\n      " (span (|@| (class "comment-delimiter") (id "F:391706")) "/* ") (span (|@| (class "comment") (id "F:391709")) "that candidate is not the row we are processing ") (span (|@| (class "comment-delimiter") (id "F:391757")) "*/") "\n      && MATRIX_ROW (matrix, w->cursor.vpos) != row\n      " (span (|@| (class "comment-delimiter") (id "F:391818")) "/* ") (span (|@| (class "comment") (id "F:391821")) "the row we are processing is part of a continued line ") (span (|@| (class "comment-delimiter") (id "F:391875")) "*/") "\n      && (row->continued_p || MATRIX_ROW_CONTINUATION_LINE_P (row))\n      " (span (|@| (class "comment-delimiter") (id "F:391952")) "/* ") (span (|@| (class "comment") (id "F:391955")) "Make sure cursor.vpos specifies a row whose start and end\n         charpos occlude point.  This is because some callers of this\n         function leave cursor.vpos at the row where the cursor was\n         displayed during the last redisplay cycle.  ") (span (|@| (class "comment-delimiter") (id "F:392183")) "*/") "\n      && MATRIX_ROW_START_CHARPOS (MATRIX_ROW (matrix, w->cursor.vpos)) <= pt_old\n      && pt_old < MATRIX_ROW_END_CHARPOS (MATRIX_ROW (matrix, w->cursor.vpos)))\n    {\n      " (span (|@| (class "keyword") (id "F:392360")) "struct") " " (span (|@| (class "type") (id "F:392367")) "glyph") " *" (span (|@| (class "variable-name") (id "F:392374")) "g1") " =\n        MATRIX_ROW_GLYPH_START (matrix, w->cursor.vpos) + w->cursor.hpos;\n\n      " (span (|@| (class "comment-delimiter") (id "F:392453")) "/* ") (span (|@| (class "comment") (id "F:392456")) "Don't consider glyphs that are outside TEXT_AREA.  ") (span (|@| (class "comment-delimiter") (id "F:392507")) "*/") "\n      " (span (|@| (class "keyword") (id "F:392516")) "if") " (" (span (|@| (class "negation-char") (id "F:392520")) "!") "(row->reversed_p ? glyph > glyphs_end : glyph < glyphs_end))\n        " (span (|@| (class "keyword") (id "F:392583")) "return") " 0;\n      " (span (|@| (class "comment-delimiter") (id "F:392599")) "/* ") (span (|@| (class "comment") (id "F:392602")) "Keep the candidate whose buffer position is the closest to\n         point.  ") (span (|@| (class "comment-delimiter") (id "F:392671")) "*/") "\n      " (span (|@| (class "keyword") (id "F:392680")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:392684")) "/* ") (span (|@| (class "comment") (id "F:392687")) "previous candidate is a glyph in TEXT_AREA of that row ") (span (|@| (class "comment-delimiter") (id "F:392742")) "*/") "\n          w->cursor.hpos >= 0\n          && w->cursor.hpos < MATRIX_ROW_USED(matrix, w->cursor.vpos)\n          && BUFFERP (g1->object)\n          && (g1->charpos == pt_old " (span (|@| (class "comment-delimiter") (id "F:392887")) "/* ") (span (|@| (class "comment") (id "F:392890")) "an exact match always wins ") (span (|@| (class "comment-delimiter") (id "F:392917")) "*/") "\n              || (BUFFERP (glyph->object)\n                  && eabs (g1->charpos - pt_old)\n                   < eabs (glyph->charpos - pt_old))))\n        " (span (|@| (class "keyword") (id "F:393032")) "return") " 0;\n      " (span (|@| (class "comment-delimiter") (id "F:393048")) "/* ") (span (|@| (class "comment") (id "F:393051")) "If this candidate gives an exact match, use that.  ") (span (|@| (class "comment-delimiter") (id "F:393102")) "*/") "\n      " (span (|@| (class "keyword") (id "F:393111")) "if") " (" (span (|@| (class "negation-char") (id "F:393115")) "!") "(BUFFERP (glyph->object) && glyph->charpos == pt_old)\n          " (span (|@| (class "comment-delimiter") (id "F:393173")) "/* ") (span (|@| (class "comment") (id "F:393176")) "Otherwise, keep the candidate that comes from a row\n             spanning less buffer positions.  This may win when one or\n             both candidate positions are on glyphs that came from\n             display strings, for which we cannot compare buffer\n             positions.  ") (span (|@| (class "comment-delimiter") (id "F:393428")) "*/") "\n          && MATRIX_ROW_END_CHARPOS (MATRIX_ROW (matrix, w->cursor.vpos))\n             - MATRIX_ROW_START_CHARPOS (MATRIX_ROW (matrix, w->cursor.vpos))\n             < MATRIX_ROW_END_CHARPOS (row) - MATRIX_ROW_START_CHARPOS (row))\n        " (span (|@| (class "keyword") (id "F:393641")) "return") " 0;\n    }\n  w->cursor.hpos = glyph - row->glyphs[TEXT_AREA];\n  w->cursor.x = x;\n  w->cursor.vpos = MATRIX_ROW_VPOS (row, matrix) + dvpos;\n  w->cursor.y = row->y + dy;\n\n  " (span (|@| (class "keyword") (id "F:393817")) "if") " (w == XWINDOW (selected_window))\n    {\n      " (span (|@| (class "keyword") (id "F:393865")) "if") " (" (span (|@| (class "negation-char") (id "F:393869")) "!") "row->continued_p\n          && " (span (|@| (class "negation-char") (id "F:393893")) "!") "MATRIX_ROW_CONTINUATION_LINE_P (row)\n          && row->x == 0)\n        {\n          this_line_buffer = XBUFFER (w->buffer);\n\n          CHARPOS (this_line_start_pos)\n            = MATRIX_ROW_START_CHARPOS (row) + delta;\n          BYTEPOS (this_line_start_pos)\n            = MATRIX_ROW_START_BYTEPOS (row) + delta_bytes;\n\n          CHARPOS (this_line_end_pos)\n            = Z - (MATRIX_ROW_END_CHARPOS (row) + delta);\n          BYTEPOS (this_line_end_pos)\n            = Z_BYTE - (MATRIX_ROW_END_BYTEPOS (row) + delta_bytes);\n\n          this_line_y = w->cursor.y;\n          this_line_pixel_height = row->height;\n          this_line_vpos = w->cursor.vpos;\n          this_line_start_x = row->x;\n        }\n      " (span (|@| (class "keyword") (id "F:394487")) "else") "\n        CHARPOS (this_line_start_pos) = 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:394537")) "return") " 1;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:394551")) "/* ") (span (|@| (class "comment") (id "F:394554")) "Run window scroll functions, if any, for WINDOW with new window\n   start STARTP.  Sets the window start of WINDOW to that position.\n\n   We assume that the window's buffer is really current.  ") (span (|@| (class "comment-delimiter") (id "F:394745")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:394749")) "static") " INLINE " (span (|@| (class "keyword") (id "F:394763")) "struct") " " (span (|@| (class "type") (id "F:394770")) "text_pos") "\n" (span (|@| (class "function-name") (id "F:394779")) "run_window_scroll_functions") " (" (span (|@| (class "type") (id "F:394808")) "window") ", startp)\n     " (span (|@| (class "type") (id "F:394829")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:394841")) "window") ";\n     " (span (|@| (class "keyword") (id "F:394854")) "struct") " " (span (|@| (class "type") (id "F:394861")) "text_pos") " " (span (|@| (class "variable-name") (id "F:394870")) "startp") ";\n{\n  " (span (|@| (class "keyword") (id "F:394882")) "struct") " " (span (|@| (class "type") (id "F:394889")) "window") " *" (span (|@| (class "variable-name") (id "F:394897")) "w") " = XWINDOW (window);\n  SET_MARKER_FROM_TEXT_POS (w->start, startp);\n\n  " (span (|@| (class "keyword") (id "F:394969")) "if") " (current_buffer != XBUFFER (w->buffer))\n    abort ();\n\n  " (span (|@| (class "keyword") (id "F:395029")) "if") " (" (span (|@| (class "negation-char") (id "F:395033")) "!") "NILP (Vwindow_scroll_functions))\n    {\n      run_hook_with_args_2 (Qwindow_scroll_functions, window,\n                            make_number (CHARPOS (startp)));\n      SET_TEXT_POS_FROM_MARKER (startp, w->start);\n      " (span (|@| (class "comment-delimiter") (id "F:395232")) "/* ") (span (|@| (class "comment") (id "F:395235")) "In case the hook functions switch buffers.  ") (span (|@| (class "comment-delimiter") (id "F:395279")) "*/") "\n      " (span (|@| (class "keyword") (id "F:395288")) "if") " (current_buffer != XBUFFER (w->buffer))\n        set_buffer_internal_1 (XBUFFER (w->buffer));\n    }\n\n  " (span (|@| (class "keyword") (id "F:395386")) "return") " startp;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:395405")) "/* ") (span (|@| (class "comment") (id "F:395408")) "Make sure the line containing the cursor is fully visible.\n   A value of 1 means there is nothing to be done.\n   (Either the line is fully visible, or it cannot be made so,\n   or we cannot tell.)\n\n   If FORCE_P is non-zero, return 0 even if partial visible cursor row\n   is higher than window.\n\n   A value of 0 means the caller should do scrolling\n   as if point had gone off the screen.  ") (span (|@| (class "comment-delimiter") (id "F:395797")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:395801")) "static") " " (span (|@| (class "type") (id "F:395808")) "int") "\n" (span (|@| (class "function-name") (id "F:395812")) "cursor_row_fully_visible_p") " (w, force_p, current_matrix_p)\n     " (span (|@| (class "keyword") (id "F:395875")) "struct") " " (span (|@| (class "type") (id "F:395882")) "window") " *" (span (|@| (class "variable-name") (id "F:395890")) "w") ";\n     " (span (|@| (class "type") (id "F:395898")) "int") " " (span (|@| (class "variable-name") (id "F:395902")) "force_p") ";\n     " (span (|@| (class "type") (id "F:395916")) "int") " " (span (|@| (class "variable-name") (id "F:395920")) "current_matrix_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:395942")) "struct") " " (span (|@| (class "type") (id "F:395949")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:395963")) "matrix") ";\n  " (span (|@| (class "keyword") (id "F:395973")) "struct") " " (span (|@| (class "type") (id "F:395980")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:395991")) "row") ";\n  " (span (|@| (class "type") (id "F:395998")) "int") " " (span (|@| (class "variable-name") (id "F:396002")) "window_height") ";\n\n  " (span (|@| (class "keyword") (id "F:396020")) "if") " (" (span (|@| (class "negation-char") (id "F:396024")) "!") "make_cursor_line_fully_visible_p)\n    " (span (|@| (class "keyword") (id "F:396063")) "return") " 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:396076")) "/* ") (span (|@| (class "comment") (id "F:396079")) "It's not always possible to find the cursor, e.g, when a window\n     is full of overlay strings.  Don't do anything in that case.  ") (span (|@| (class "comment-delimiter") (id "F:396210")) "*/") "\n  " (span (|@| (class "keyword") (id "F:396215")) "if") " (w->cursor.vpos < 0)\n    " (span (|@| (class "keyword") (id "F:396243")) "return") " 1;\n\n  matrix = current_matrix_p ? w->current_matrix : w->desired_matrix;\n  row = MATRIX_ROW (matrix, w->cursor.vpos);\n\n  " (span (|@| (class "comment-delimiter") (id "F:396371")) "/* ") (span (|@| (class "comment") (id "F:396374")) "If the cursor row is not partially visible, there's nothing to do.  ") (span (|@| (class "comment-delimiter") (id "F:396442")) "*/") "\n  " (span (|@| (class "keyword") (id "F:396447")) "if") " (" (span (|@| (class "negation-char") (id "F:396451")) "!") "MATRIX_ROW_PARTIALLY_VISIBLE_P (w, row))\n    " (span (|@| (class "keyword") (id "F:396497")) "return") " 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:396510")) "/* ") (span (|@| (class "comment") (id "F:396513")) "If the row the cursor is in is taller than the window's height,\n     it's not clear what to do, so do nothing.  ") (span (|@| (class "comment-delimiter") (id "F:396625")) "*/") "\n  window_height = window_box_height (w);\n  " (span (|@| (class "keyword") (id "F:396671")) "if") " (row->height >= window_height)\n    {\n      " (span (|@| (class "keyword") (id "F:396717")) "if") " (" (span (|@| (class "negation-char") (id "F:396721")) "!") "force_p || MINI_WINDOW_P (w)\n          || w->vscroll || w->cursor.vpos == 0)\n        " (span (|@| (class "keyword") (id "F:396793")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:396811")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:396825")) "/* ") (span (|@| (class "comment") (id "F:396828")) "Try scrolling PT into view in window WINDOW.  JUST_THIS_ONE_P\n   non-zero means only WINDOW is redisplayed in redisplay_internal.\n   TEMP_SCROLL_STEP has the same meaning as scroll_step, and is used\n   in redisplay_window to bring a partially visible line into view in\n   the case that only the cursor has moved.\n\n   LAST_LINE_MISFIT should be nonzero if we're scrolling because the\n   last screen line's vertical height extends past the end of the screen.\n\n   Value is\n\n   1    if scrolling succeeded\n\n   0    if scrolling didn't find point.\n\n   -1   if new fonts have been loaded so that we must interrupt\n   redisplay, adjust glyph matrices, and try again.  ") (span (|@| (class "comment-delimiter") (id "F:397481")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:397485")) "enum") "\n{\n  " (span (|@| (class "variable-name") (id "F:397494")) "SCROLLING_SUCCESS") ",\n  " (span (|@| (class "variable-name") (id "F:397515")) "SCROLLING_FAILED") ",\n  " (span (|@| (class "variable-name") (id "F:397535")) "SCROLLING_NEED_LARGER_MATRICES") "\n};\n\n" (span (|@| (class "keyword") (id "F:397570")) "static") " " (span (|@| (class "type") (id "F:397577")) "int") "\n" (span (|@| (class "function-name") (id "F:397581")) "try_scrolling") " (" (span (|@| (class "type") (id "F:397596")) "window") ", just_this_one_p, scroll_conservatively,\n               scroll_step, temp_scroll_step, last_line_misfit)\n     " (span (|@| (class "type") (id "F:397706")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:397718")) "window") ";\n     " (span (|@| (class "type") (id "F:397731")) "int") " " (span (|@| (class "variable-name") (id "F:397735")) "just_this_one_p") ";\n     " (span (|@| (class "type") (id "F:397757")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:397767")) "scroll_conservatively") ", " (span (|@| (class "variable-name") (id "F:397790")) "scroll_step") ";\n     " (span (|@| (class "type") (id "F:397808")) "int") " " (span (|@| (class "variable-name") (id "F:397812")) "temp_scroll_step") ";\n     " (span (|@| (class "type") (id "F:397835")) "int") " " (span (|@| (class "variable-name") (id "F:397839")) "last_line_misfit") ";\n{\n  " (span (|@| (class "keyword") (id "F:397861")) "struct") " " (span (|@| (class "type") (id "F:397868")) "window") " *" (span (|@| (class "variable-name") (id "F:397876")) "w") " = XWINDOW (window);\n  " (span (|@| (class "keyword") (id "F:397900")) "struct") " " (span (|@| (class "type") (id "F:397907")) "frame") " *" (span (|@| (class "variable-name") (id "F:397914")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "keyword") (id "F:397939")) "struct") " " (span (|@| (class "type") (id "F:397946")) "text_pos") " " (span (|@| (class "variable-name") (id "F:397955")) "pos") ", " (span (|@| (class "variable-name") (id "F:397960")) "startp") ";\n  " (span (|@| (class "keyword") (id "F:397970")) "struct") " " (span (|@| (class "type") (id "F:397977")) "it") " " (span (|@| (class "variable-name") (id "F:397980")) "it") ";\n  " (span (|@| (class "type") (id "F:397986")) "int") " " (span (|@| (class "variable-name") (id "F:397990")) "this_scroll_margin") ", " (span (|@| (class "variable-name") (id "F:398010")) "scroll_max") ", " (span (|@| (class "variable-name") (id "F:398022")) "rc") ", " (span (|@| (class "variable-name") (id "F:398026")) "height") ";\n  " (span (|@| (class "type") (id "F:398036")) "int") " " (span (|@| (class "variable-name") (id "F:398040")) "dy") " = 0, " (span (|@| (class "variable-name") (id "F:398048")) "amount_to_scroll") " = 0, " (span (|@| (class "variable-name") (id "F:398070")) "scroll_down_p") " = 0;\n  " (span (|@| (class "type") (id "F:398091")) "int") " " (span (|@| (class "variable-name") (id "F:398095")) "extra_scroll_margin_lines") " = last_line_misfit ? 1 : 0;\n  " (span (|@| (class "type") (id "F:398151")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:398163")) "aggressive") ";\n  " (span (|@| (class "type") (id "F:398177")) "int") " " (span (|@| (class "variable-name") (id "F:398181")) "scroll_limit") " = INT_MAX / FRAME_LINE_HEIGHT (f);\n\n" (span (|@| (class "preprocessor") (id "F:398230")) "#if") " GLYPH_DEBUG\n  debug_method_add (w, " (span (|@| (class "string") (id "F:398269")) "\"try_scrolling\"") ");\n" (span (|@| (class "preprocessor") (id "F:398287")) "#endif") "\n\n  SET_TEXT_POS_FROM_MARKER (startp, w->start);\n\n  " (span (|@| (class "comment-delimiter") (id "F:398345")) "/* ") (span (|@| (class "comment") (id "F:398348")) "Compute scroll margin height in pixels.  We scroll when point is\n     within this distance from the top or bottom of the window.  ") (span (|@| (class "comment-delimiter") (id "F:398478")) "*/") "\n  " (span (|@| (class "keyword") (id "F:398483")) "if") " (scroll_margin > 0)\n    this_scroll_margin = min (scroll_margin, WINDOW_TOTAL_LINES (w) / 4)\n      * FRAME_LINE_HEIGHT (f);\n  " (span (|@| (class "keyword") (id "F:398612")) "else") "\n    this_scroll_margin = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:398648")) "/* ") (span (|@| (class "comment") (id "F:398651")) "Force scroll_conservatively to have a reasonable value, to avoid\n     overflow while computing how much to scroll.  Note that the user\n     can supply scroll-conservatively equal to `most-positive-fixnum',\n     which can be larger than INT_MAX.  ") (span (|@| (class "comment-delimiter") (id "F:398897")) "*/") "\n  " (span (|@| (class "keyword") (id "F:398902")) "if") " (scroll_conservatively > scroll_limit)\n    {\n      scroll_conservatively = scroll_limit;\n      scroll_max = INT_MAX;\n    }\n  " (span (|@| (class "keyword") (id "F:399030")) "else") " " (span (|@| (class "keyword") (id "F:399035")) "if") " (scroll_step || scroll_conservatively || temp_scroll_step)\n    " (span (|@| (class "comment-delimiter") (id "F:399101")) "/* ") (span (|@| (class "comment") (id "F:399104")) "Compute how much we should try to scroll maximally to bring\n       point into view.  ") (span (|@| (class "comment-delimiter") (id "F:399189")) "*/") "\n    scroll_max = (max (scroll_step,\n                       max (scroll_conservatively, temp_scroll_step))\n                  * FRAME_LINE_HEIGHT (f));\n  " (span (|@| (class "keyword") (id "F:399316")) "else") " " (span (|@| (class "keyword") (id "F:399321")) "if") " (NUMBERP (current_buffer->scroll_down_aggressively)\n           || NUMBERP (current_buffer->scroll_up_aggressively))\n    " (span (|@| (class "comment-delimiter") (id "F:399437")) "/* ") (span (|@| (class "comment") (id "F:399440")) "We're trying to scroll because of aggressive scrolling but no\n       scroll_step is set.  Choose an arbitrary one.  ") (span (|@| (class "comment-delimiter") (id "F:399556")) "*/") "\n    scroll_max = 10 * FRAME_LINE_HEIGHT (f);\n  " (span (|@| (class "keyword") (id "F:399606")) "else") "\n    scroll_max = 0;\n\n " (span (|@| (class "constant") (id "F:399633")) "too_near_end") ":\n\n  " (span (|@| (class "comment-delimiter") (id "F:399650")) "/* ") (span (|@| (class "comment") (id "F:399653")) "Decide whether to scroll down.  ") (span (|@| (class "comment-delimiter") (id "F:399685")) "*/") "\n  " (span (|@| (class "keyword") (id "F:399690")) "if") " (PT > CHARPOS (startp))\n    {\n      " (span (|@| (class "type") (id "F:399729")) "int") " " (span (|@| (class "variable-name") (id "F:399733")) "scroll_margin_y") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:399757")) "/* ") (span (|@| (class "comment") (id "F:399760")) "Compute the pixel ypos of the scroll margin, then move it to\n         either that ypos or PT, whichever comes first.  ") (span (|@| (class "comment-delimiter") (id "F:399871")) "*/") "\n      start_display (&it, w, startp);\n      scroll_margin_y = it.last_visible_y - this_scroll_margin\n        - FRAME_LINE_HEIGHT (f) * extra_scroll_margin_lines;\n      move_it_to (&it, PT, -1, scroll_margin_y - 1, -1,\n                  (MOVE_TO_POS | MOVE_TO_Y));\n\n      " (span (|@| (class "keyword") (id "F:400124")) "if") " (PT > CHARPOS (it.current.pos))\n        {\n          " (span (|@| (class "type") (id "F:400165")) "int") " " (span (|@| (class "variable-name") (id "F:400169")) "y0") " = line_bottom_y (&it);\n          " (span (|@| (class "comment-delimiter") (id "F:400198")) "/* ") (span (|@| (class "comment") (id "F:400201")) "Compute how many pixels below window bottom to stop searching\n             for PT.  This avoids costly search for PT that is far away if\n             the user limited scrolling by a small number of lines, but\n             always finds PT if scroll_conservatively is set to a large\n             number, such as most-positive-fixnum.  ") (span (|@| (class "comment-delimiter") (id "F:400506")) "*/") "\n          " (span (|@| (class "type") (id "F:400512")) "int") " " (span (|@| (class "variable-name") (id "F:400516")) "slack") " = max (scroll_max, 10 * FRAME_LINE_HEIGHT (f));\n          " (span (|@| (class "type") (id "F:400573")) "int") " " (span (|@| (class "variable-name") (id "F:400577")) "y_to_move") " =\n            slack >= INT_MAX - it.last_visible_y\n            ? INT_MAX\n            : it.last_visible_y + slack;\n\n          " (span (|@| (class "comment-delimiter") (id "F:400684")) "/* ") (span (|@| (class "comment") (id "F:400687")) "Compute the distance from the scroll margin to PT or to\n             the scroll limit, whichever comes first.  This should\n             include the height of the cursor line, to make that line\n             fully visible.  ") (span (|@| (class "comment-delimiter") (id "F:400888")) "*/") "\n          move_it_to (&it, PT, -1, y_to_move,\n                      -1, MOVE_TO_POS | MOVE_TO_Y);\n          dy = line_bottom_y (&it) - y0;\n\n          " (span (|@| (class "keyword") (id "F:401008")) "if") " (dy > scroll_max)\n            " (span (|@| (class "keyword") (id "F:401034")) "return") " SCROLLING_FAILED;\n\n          scroll_down_p = 1;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:401094")) "if") " (scroll_down_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:401125")) "/* ") (span (|@| (class "comment") (id "F:401128")) "Point is in or below the bottom scroll margin, so move the\n         window start down.  If scrolling conservatively, move it just\n         enough down to make point visible.  If scroll_step is set,\n         move it down by scroll_step.  ") (span (|@| (class "comment-delimiter") (id "F:401344")) "*/") "\n      " (span (|@| (class "keyword") (id "F:401353")) "if") " (scroll_conservatively)\n        amount_to_scroll\n          = min (max (dy, FRAME_LINE_HEIGHT (f)),\n                 FRAME_LINE_HEIGHT (f) * scroll_conservatively);\n      " (span (|@| (class "keyword") (id "F:401498")) "else") " " (span (|@| (class "keyword") (id "F:401503")) "if") " (scroll_step || temp_scroll_step)\n        amount_to_scroll = scroll_max;\n      " (span (|@| (class "keyword") (id "F:401578")) "else") "\n        {\n          aggressive = current_buffer->scroll_up_aggressively;\n          height = WINDOW_BOX_TEXT_HEIGHT (w);\n          " (span (|@| (class "keyword") (id "F:401685")) "if") " (NUMBERP (aggressive))\n            {\n              " (span (|@| (class "type") (id "F:401725")) "double") " " (span (|@| (class "variable-name") (id "F:401732")) "float_amount") " = XFLOATINT (aggressive) * height;\n              amount_to_scroll = float_amount;\n              " (span (|@| (class "keyword") (id "F:401827")) "if") " (amount_to_scroll == 0 && float_amount > 0)\n                amount_to_scroll = 1;\n            }\n        }\n\n      " (span (|@| (class "keyword") (id "F:401915")) "if") " (amount_to_scroll <= 0)\n        " (span (|@| (class "keyword") (id "F:401943")) "return") " SCROLLING_FAILED;\n\n      start_display (&it, w, startp);\n      " (span (|@| (class "keyword") (id "F:402013")) "if") " (scroll_max < INT_MAX)\n        move_it_vertically (&it, amount_to_scroll);\n      " (span (|@| (class "keyword") (id "F:402090")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:402101")) "/* ") (span (|@| (class "comment") (id "F:402104")) "Extra precision for users who set scroll-conservatively\n             to most-positive-fixnum: make sure the amount we scroll\n             the window start is never less than amount_to_scroll,\n             which was computed as distance from window bottom to\n             point.  This matters when lines at window top and lines\n             below window bottom have different height.  ") (span (|@| (class "comment-delimiter") (id "F:402453")) "*/") "\n          " (span (|@| (class "keyword") (id "F:402459")) "struct") " " (span (|@| (class "type") (id "F:402466")) "it") " " (span (|@| (class "variable-name") (id "F:402469")) "it1") " = it;\n          " (span (|@| (class "comment-delimiter") (id "F:402482")) "/* ") (span (|@| (class "comment") (id "F:402485")) "We use a temporary it1 because line_bottom_y can modify\n             its argument, if it moves one line down; see there.  ") (span (|@| (class "comment-delimiter") (id "F:402600")) "*/") "\n          " (span (|@| (class "type") (id "F:402606")) "int") " " (span (|@| (class "variable-name") (id "F:402610")) "start_y") " = line_bottom_y (&it1);\n\n          " (span (|@| (class "keyword") (id "F:402646")) "do") " {\n            move_it_by_lines (&it, 1, 1);\n            it1 = it;\n          } " (span (|@| (class "keyword") (id "F:402706")) "while") " (line_bottom_y (&it1) - start_y < amount_to_scroll);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:402775")) "/* ") (span (|@| (class "comment") (id "F:402778")) "If STARTP is unchanged, move it down another screen line.  ") (span (|@| (class "comment-delimiter") (id "F:402837")) "*/") "\n      " (span (|@| (class "keyword") (id "F:402846")) "if") " (CHARPOS (it.current.pos) == CHARPOS (startp))\n        move_it_by_lines (&it, 1, 1);\n      startp = it.current.pos;\n    }\n  " (span (|@| (class "keyword") (id "F:402966")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:402983")) "struct") " " (span (|@| (class "type") (id "F:402990")) "text_pos") " " (span (|@| (class "variable-name") (id "F:402999")) "scroll_margin_pos") " = startp;\n\n      " (span (|@| (class "comment-delimiter") (id "F:403034")) "/* ") (span (|@| (class "comment") (id "F:403037")) "See if point is inside the scroll margin at the top of the\n         window.  ") (span (|@| (class "comment-delimiter") (id "F:403114")) "*/") "\n      " (span (|@| (class "keyword") (id "F:403123")) "if") " (this_scroll_margin)\n        {\n          start_display (&it, w, startp);\n          move_it_vertically (&it, this_scroll_margin);\n          scroll_margin_pos = it.current.pos;\n        }\n\n      " (span (|@| (class "keyword") (id "F:403283")) "if") " (PT < CHARPOS (scroll_margin_pos))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:403327")) "/* ") (span (|@| (class "comment") (id "F:403330")) "Point is in the scroll margin at the top of the window or\n             above what is displayed in the window.  ") (span (|@| (class "comment-delimiter") (id "F:403434")) "*/") "\n          " (span (|@| (class "type") (id "F:403440")) "int") " " (span (|@| (class "variable-name") (id "F:403444")) "y0") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:403452")) "/* ") (span (|@| (class "comment") (id "F:403455")) "Compute the vertical distance from PT to the scroll\n             margin position.  Give up if distance is greater than\n             scroll_max.  ") (span (|@| (class "comment-delimiter") (id "F:403586")) "*/") "\n          SET_TEXT_POS (pos, PT, PT_BYTE);\n          start_display (&it, w, pos);\n          y0 = it.current_y;\n          move_it_to (&it, CHARPOS (scroll_margin_pos), 0,\n                      it.last_visible_y, -1,\n                      MOVE_TO_POS | MOVE_TO_X | MOVE_TO_Y);\n          dy = it.current_y - y0;\n          " (span (|@| (class "keyword") (id "F:403838")) "if") " (dy > scroll_max)\n            " (span (|@| (class "keyword") (id "F:403864")) "return") " SCROLLING_FAILED;\n\n          " (span (|@| (class "comment-delimiter") (id "F:403893")) "/* ") (span (|@| (class "comment") (id "F:403896")) "Compute new window start.  ") (span (|@| (class "comment-delimiter") (id "F:403923")) "*/") "\n          start_display (&it, w, startp);\n\n          " (span (|@| (class "keyword") (id "F:403965")) "if") " (scroll_conservatively)\n            amount_to_scroll\n              = max (dy, FRAME_LINE_HEIGHT (f) * max (scroll_step, temp_scroll_step));\n          " (span (|@| (class "keyword") (id "F:404097")) "else") " " (span (|@| (class "keyword") (id "F:404102")) "if") " (scroll_step || temp_scroll_step)\n            amount_to_scroll = scroll_max;\n          " (span (|@| (class "keyword") (id "F:404178")) "else") "\n            {\n              aggressive = current_buffer->scroll_down_aggressively;\n              height = WINDOW_BOX_TEXT_HEIGHT (w);\n              " (span (|@| (class "keyword") (id "F:404303")) "if") " (NUMBERP (aggressive))\n                {\n                  " (span (|@| (class "type") (id "F:404337")) "double") " " (span (|@| (class "variable-name") (id "F:404344")) "float_amount") " = XFLOATINT (aggressive) * height;\n                  amount_to_scroll = float_amount;\n                  " (span (|@| (class "keyword") (id "F:404433")) "if") " (amount_to_scroll == 0 && float_amount > 0)\n                    amount_to_scroll = 1;\n                }\n            }\n\n          " (span (|@| (class "keyword") (id "F:404523")) "if") " (amount_to_scroll <= 0)\n            " (span (|@| (class "keyword") (id "F:404555")) "return") " SCROLLING_FAILED;\n\n          move_it_vertically_backward (&it, amount_to_scroll);\n          startp = it.current.pos;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:404677")) "/* ") (span (|@| (class "comment") (id "F:404680")) "Run window scroll functions.  ") (span (|@| (class "comment-delimiter") (id "F:404710")) "*/") "\n  startp = run_window_scroll_functions (window, startp);\n\n  " (span (|@| (class "comment-delimiter") (id "F:404773")) "/* ") (span (|@| (class "comment") (id "F:404776")) "Display the window.  Give up if new fonts are loaded, or if point\n     doesn't appear.  ") (span (|@| (class "comment-delimiter") (id "F:404864")) "*/") "\n  " (span (|@| (class "keyword") (id "F:404869")) "if") " (" (span (|@| (class "negation-char") (id "F:404873")) "!") "try_window (window, startp, 0))\n    rc = SCROLLING_NEED_LARGER_MATRICES;\n  " (span (|@| (class "keyword") (id "F:404949")) "else") " " (span (|@| (class "keyword") (id "F:404954")) "if") " (w->cursor.vpos < 0)\n    {\n      clear_glyph_matrix (w->desired_matrix);\n      rc = SCROLLING_FAILED;\n    }\n  " (span (|@| (class "keyword") (id "F:405067")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:405084")) "/* ") (span (|@| (class "comment") (id "F:405087")) "Maybe forget recorded base line for line number display.  ") (span (|@| (class "comment-delimiter") (id "F:405145")) "*/") "\n      " (span (|@| (class "keyword") (id "F:405154")) "if") " (" (span (|@| (class "negation-char") (id "F:405158")) "!") "just_this_one_p\n          || current_buffer->clip_changed\n          || BEG_UNCHANGED < CHARPOS (startp))\n        w->base_line_number = Qnil;\n\n      " (span (|@| (class "comment-delimiter") (id "F:405286")) "/* ") (span (|@| (class "comment") (id "F:405289")) "If cursor ends up on a partially visible line,\n         treat that as being off the bottom of the screen.  ") (span (|@| (class "comment-delimiter") (id "F:405389")) "*/") "\n      " (span (|@| (class "keyword") (id "F:405398")) "if") " (" (span (|@| (class "negation-char") (id "F:405402")) "!") " cursor_row_fully_visible_p (w, extra_scroll_margin_lines <= 1, 0))\n        {\n          clear_glyph_matrix (w->desired_matrix);\n          ++extra_scroll_margin_lines;\n          " (span (|@| (class "keyword") (id "F:405552")) "goto") " " (span (|@| (class "constant") (id "F:405557")) "too_near_end") ";\n        }\n      rc = SCROLLING_SUCCESS;\n    }\n\n  " (span (|@| (class "keyword") (id "F:405613")) "return") " rc;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:405628")) "/* ") (span (|@| (class "comment") (id "F:405631")) "Compute a suitable window start for window W if display of W starts\n   on a continuation line.  Value is non-zero if a new window start\n   was computed.\n\n   The new window start will be computed, based on W's width, starting\n   from the start of the continued line.  It is the start of the\n   screen line with the minimum distance from the old start W->start.  ") (span (|@| (class "comment-delimiter") (id "F:405992")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:405996")) "static") " " (span (|@| (class "type") (id "F:406003")) "int") "\n" (span (|@| (class "function-name") (id "F:406007")) "compute_window_start_on_continuation_line") " (w)\n     " (span (|@| (class "keyword") (id "F:406058")) "struct") " " (span (|@| (class "type") (id "F:406065")) "window") " *" (span (|@| (class "variable-name") (id "F:406073")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:406080")) "struct") " " (span (|@| (class "type") (id "F:406087")) "text_pos") " " (span (|@| (class "variable-name") (id "F:406096")) "pos") ", " (span (|@| (class "variable-name") (id "F:406101")) "start_pos") ";\n  " (span (|@| (class "type") (id "F:406114")) "int") " " (span (|@| (class "variable-name") (id "F:406118")) "window_start_changed_p") " = 0;\n\n  SET_TEXT_POS_FROM_MARKER (start_pos, w->start);\n\n  " (span (|@| (class "comment-delimiter") (id "F:406200")) "/* ") (span (|@| (class "comment") (id "F:406203")) "If window start is on a continuation line...  Window start may be\n     < BEGV in case there's invisible text at the start of the\n     buffer (M-x rmail, for example).  ") (span (|@| (class "comment-delimiter") (id "F:406371")) "*/") "\n  " (span (|@| (class "keyword") (id "F:406376")) "if") " (CHARPOS (start_pos) > BEGV\n      && FETCH_BYTE (BYTEPOS (start_pos) - 1) != " (span (|@| (class "string") (id "F:406456")) "'\\n'") ")\n    {\n      " (span (|@| (class "keyword") (id "F:406474")) "struct") " " (span (|@| (class "type") (id "F:406481")) "it") " " (span (|@| (class "variable-name") (id "F:406484")) "it") ";\n      " (span (|@| (class "keyword") (id "F:406494")) "struct") " " (span (|@| (class "type") (id "F:406501")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:406512")) "row") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:406524")) "/* ") (span (|@| (class "comment") (id "F:406527")) "Handle the case that the window start is out of range.  ") (span (|@| (class "comment-delimiter") (id "F:406583")) "*/") "\n      " (span (|@| (class "keyword") (id "F:406592")) "if") " (CHARPOS (start_pos) < BEGV)\n        SET_TEXT_POS (start_pos, BEGV, BEGV_BYTE);\n      " (span (|@| (class "keyword") (id "F:406674")) "else") " " (span (|@| (class "keyword") (id "F:406679")) "if") " (CHARPOS (start_pos) > ZV)\n        SET_TEXT_POS (start_pos, ZV, ZV_BYTE);\n\n      " (span (|@| (class "comment-delimiter") (id "F:406756")) "/* ") (span (|@| (class "comment") (id "F:406759")) "Find the start of the continued line.  This should be fast\n         because scan_buffer is fast (newline cache).  ") (span (|@| (class "comment-delimiter") (id "F:406866")) "*/") "\n      row = w->desired_matrix->rows + (WINDOW_WANTS_HEADER_LINE_P (w) ? 1 : 0);\n      init_iterator (&it, w, CHARPOS (start_pos), BYTEPOS (start_pos),\n                     row, DEFAULT_FACE_ID);\n      reseat_at_previous_visible_line_start (&it);\n\n      " (span (|@| (class "comment-delimiter") (id "F:407108")) "/* ") (span (|@| (class "comment") (id "F:407111")) "If the line start is \"too far\" away from the window start,\n         say it takes too much time to compute a new window start.  ") (span (|@| (class "comment-delimiter") (id "F:407238")) "*/") "\n      " (span (|@| (class "keyword") (id "F:407247")) "if") " (CHARPOS (start_pos) - IT_CHARPOS (it)\n          < WINDOW_TOTAL_LINES (w) * WINDOW_TOTAL_COLS (w))\n        {\n          " (span (|@| (class "type") (id "F:407348")) "int") " " (span (|@| (class "variable-name") (id "F:407352")) "min_distance") ", " (span (|@| (class "variable-name") (id "F:407366")) "distance") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:407380")) "/* ") (span (|@| (class "comment") (id "F:407383")) "Move forward by display lines to find the new window\n             start.  If window width was enlarged, the new start can\n             be expected to be > the old start.  If window width was\n             decreased, the new window start will be < the old start.\n             So, we're looking for the display line start with the\n             minimum distance from the old window start.  ") (span (|@| (class "comment-delimiter") (id "F:407734")) "*/") "\n          pos = it.current.pos;\n          min_distance = INFINITY;\n          " (span (|@| (class "keyword") (id "F:407793")) "while") " ((distance = eabs (CHARPOS (start_pos) - IT_CHARPOS (it))),\n                 distance < min_distance)\n            {\n              min_distance = distance;\n              pos = it.current.pos;\n              move_it_by_lines (&it, 1, 0);\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:408003")) "/* ") (span (|@| (class "comment") (id "F:408006")) "Set the window start there.  ") (span (|@| (class "comment-delimiter") (id "F:408035")) "*/") "\n          SET_MARKER_FROM_TEXT_POS (w->start, pos);\n          window_start_changed_p = 1;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:408126")) "return") " window_start_changed_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:408161")) "/* ") (span (|@| (class "comment") (id "F:408164")) "Try cursor movement in case text has not changed in window WINDOW,\n   with window start STARTP.  Value is\n\n   CURSOR_MOVEMENT_SUCCESS if successful\n\n   CURSOR_MOVEMENT_CANNOT_BE_USED if this method cannot be used\n\n   CURSOR_MOVEMENT_MUST_SCROLL if we know we have to scroll the\n   display.  *SCROLL_STEP is set to 1, under certain circumstances, if\n   we want to scroll as if scroll-step were set to 1.  See the code.\n\n   CURSOR_MOVEMENT_NEED_LARGER_MATRICES if we need larger matrices, in\n   which case we have to abort this redisplay, and adjust matrices\n   first.  ") (span (|@| (class "comment-delimiter") (id "F:408732")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:408736")) "enum") "\n{\n  " (span (|@| (class "variable-name") (id "F:408745")) "CURSOR_MOVEMENT_SUCCESS") ",\n  " (span (|@| (class "variable-name") (id "F:408772")) "CURSOR_MOVEMENT_CANNOT_BE_USED") ",\n  " (span (|@| (class "variable-name") (id "F:408806")) "CURSOR_MOVEMENT_MUST_SCROLL") ",\n  " (span (|@| (class "variable-name") (id "F:408837")) "CURSOR_MOVEMENT_NEED_LARGER_MATRICES") "\n};\n\n" (span (|@| (class "keyword") (id "F:408878")) "static") " " (span (|@| (class "type") (id "F:408885")) "int") "\n" (span (|@| (class "function-name") (id "F:408889")) "try_cursor_movement") " (" (span (|@| (class "type") (id "F:408910")) "window") ", startp, scroll_step)\n     " (span (|@| (class "type") (id "F:408944")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:408956")) "window") ";\n     " (span (|@| (class "keyword") (id "F:408969")) "struct") " " (span (|@| (class "type") (id "F:408976")) "text_pos") " " (span (|@| (class "variable-name") (id "F:408985")) "startp") ";\n     " (span (|@| (class "type") (id "F:408998")) "int") " *" (span (|@| (class "variable-name") (id "F:409003")) "scroll_step") ";\n{\n  " (span (|@| (class "keyword") (id "F:409020")) "struct") " " (span (|@| (class "type") (id "F:409027")) "window") " *" (span (|@| (class "variable-name") (id "F:409035")) "w") " = XWINDOW (window);\n  " (span (|@| (class "keyword") (id "F:409059")) "struct") " " (span (|@| (class "type") (id "F:409066")) "frame") " *" (span (|@| (class "variable-name") (id "F:409073")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:409098")) "int") " " (span (|@| (class "variable-name") (id "F:409102")) "rc") " = CURSOR_MOVEMENT_CANNOT_BE_USED;\n\n" (span (|@| (class "preprocessor") (id "F:409140")) "#if") " GLYPH_DEBUG\n  " (span (|@| (class "keyword") (id "F:409158")) "if") " (inhibit_try_cursor_movement)\n    " (span (|@| (class "keyword") (id "F:409195")) "return") " rc;\n" (span (|@| (class "preprocessor") (id "F:409206")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:409216")) "/* ") (span (|@| (class "comment") (id "F:409219")) "Handle case where text has not changed, only point, and it has\n     not moved off the frame.  ") (span (|@| (class "comment-delimiter") (id "F:409313")) "*/") "\n  " (span (|@| (class "keyword") (id "F:409318")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:409322")) "/* ") (span (|@| (class "comment") (id "F:409325")) "Point may be in this window.  ") (span (|@| (class "comment-delimiter") (id "F:409355")) "*/") "\n      PT >= CHARPOS (startp)\n      " (span (|@| (class "comment-delimiter") (id "F:409393")) "/* ") (span (|@| (class "comment") (id "F:409396")) "Selective display hasn't changed.  ") (span (|@| (class "comment-delimiter") (id "F:409431")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:409443")) "!") "current_buffer->clip_changed\n      " (span (|@| (class "comment-delimiter") (id "F:409479")) "/* ") (span (|@| (class "comment") (id "F:409482")) "Function force-mode-line-update is used to force a thorough\n         redisplay.  It sets either windows_or_buffers_changed or\n         update_mode_lines.  So don't take a shortcut here for these\n         cases.  ") (span (|@| (class "comment-delimiter") (id "F:409673")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:409685")) "!") "update_mode_lines\n      && " (span (|@| (class "negation-char") (id "F:409713")) "!") "windows_or_buffers_changed\n      && " (span (|@| (class "negation-char") (id "F:409750")) "!") "cursor_type_changed\n      " (span (|@| (class "comment-delimiter") (id "F:409777")) "/* ") (span (|@| (class "comment") (id "F:409780")) "Can't use this case if highlighting a region.  When a\n         region exists, cursor movement has to do more than just\n         set the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:409925")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:409937")) "!") "(" (span (|@| (class "negation-char") (id "F:409939")) "!") "NILP (Vtransient_mark_mode)\n           && " (span (|@| (class "negation-char") (id "F:409975")) "!") "NILP (current_buffer->mark_active))\n      && NILP (w->region_showing)\n      && NILP (Vshow_trailing_whitespace)\n      " (span (|@| (class "comment-delimiter") (id "F:410094")) "/* ") (span (|@| (class "comment") (id "F:410097")) "Right after splitting windows, last_point may be nil.  ") (span (|@| (class "comment-delimiter") (id "F:410152")) "*/") "\n      && INTEGERP (w->last_point)\n      " (span (|@| (class "comment-delimiter") (id "F:410195")) "/* ") (span (|@| (class "comment") (id "F:410198")) "This code is not used for mini-buffer for the sake of the case\n         of redisplaying to replace an echo area message; since in\n         that case the mini-buffer contents per se are usually\n         unchanged.  This code is of no real use in the mini-buffer\n         since the handling of this_line_start_pos, etc., in redisplay\n         handles the same cases.  ") (span (|@| (class "comment-delimiter") (id "F:410529")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:410541")) "!") "EQ (window, minibuf_window)\n      " (span (|@| (class "comment-delimiter") (id "F:410576")) "/* ") (span (|@| (class "comment") (id "F:410579")) "When splitting windows or for new windows, it happens that\n         redisplay is called with a nil window_end_vpos or one being\n         larger than the window.  This should really be fixed in\n         window.c.  I don't have this on my list, now, so we do\n         approximately the same as the old redisplay code.  --gerd.  ") (span (|@| (class "comment-delimiter") (id "F:410877")) "*/") "\n      && INTEGERP (w->window_end_vpos)\n      && XFASTINT (w->window_end_vpos) < w->current_matrix->nrows\n      && (FRAME_WINDOW_P (f)\n          || " (span (|@| (class "negation-char") (id "F:411020")) "!") "overlay_arrow_in_current_buffer_p ()))\n    {\n      " (span (|@| (class "type") (id "F:411072")) "int") " " (span (|@| (class "variable-name") (id "F:411076")) "this_scroll_margin") ", " (span (|@| (class "variable-name") (id "F:411096")) "top_scroll_margin") ";\n      " (span (|@| (class "keyword") (id "F:411121")) "struct") " " (span (|@| (class "type") (id "F:411128")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:411139")) "row") " = " (span (|@| (class "constant") (id "F:411145")) "NULL") ";\n\n" (span (|@| (class "preprocessor") (id "F:411152")) "#if") " GLYPH_DEBUG\n      debug_method_add (w, " (span (|@| (class "string") (id "F:411195")) "\"cursor movement\"") ");\n" (span (|@| (class "preprocessor") (id "F:411215")) "#endif") "\n\n      " (span (|@| (class "comment-delimiter") (id "F:411229")) "/* ") (span (|@| (class "comment") (id "F:411232")) "Scroll if point within this distance from the top or bottom\n         of the window.  This is a pixel value.  ") (span (|@| (class "comment-delimiter") (id "F:411334")) "*/") "\n      " (span (|@| (class "keyword") (id "F:411343")) "if") " (scroll_margin > 0)\n        {\n          this_scroll_margin = min (scroll_margin, WINDOW_TOTAL_LINES (w) / 4);\n          this_scroll_margin *= FRAME_LINE_HEIGHT (f);\n        }\n      " (span (|@| (class "keyword") (id "F:411499")) "else") "\n        this_scroll_margin = 0;\n\n      top_scroll_margin = this_scroll_margin;\n      " (span (|@| (class "keyword") (id "F:411582")) "if") " (WINDOW_WANTS_HEADER_LINE_P (w))\n        top_scroll_margin += CURRENT_HEADER_LINE_HEIGHT (w);\n\n      " (span (|@| (class "comment-delimiter") (id "F:411679")) "/* ") (span (|@| (class "comment") (id "F:411682")) "Start with the row the cursor was displayed during the last\n         not paused redisplay.  Give up if that row is not valid.  ") (span (|@| (class "comment-delimiter") (id "F:411802")) "*/") "\n      " (span (|@| (class "keyword") (id "F:411811")) "if") " (w->last_cursor.vpos < 0\n          || w->last_cursor.vpos >= w->current_matrix->nrows)\n        rc = CURSOR_MOVEMENT_MUST_SCROLL;\n      " (span (|@| (class "keyword") (id "F:411935")) "else") "\n        {\n          row = MATRIX_ROW (w->current_matrix, w->last_cursor.vpos);\n          " (span (|@| (class "keyword") (id "F:412008")) "if") " (row->mode_line_p)\n            ++row;\n          " (span (|@| (class "keyword") (id "F:412045")) "if") " (" (span (|@| (class "negation-char") (id "F:412049")) "!") "row->enabled_p)\n            rc = CURSOR_MOVEMENT_MUST_SCROLL;\n        }\n\n      " (span (|@| (class "keyword") (id "F:412115")) "if") " (rc == CURSOR_MOVEMENT_CANNOT_BE_USED)\n        {\n          " (span (|@| (class "type") (id "F:412163")) "int") " " (span (|@| (class "variable-name") (id "F:412167")) "scroll_p") " = 0, " (span (|@| (class "variable-name") (id "F:412181")) "must_scroll") " = 0;\n          " (span (|@| (class "type") (id "F:412201")) "int") " " (span (|@| (class "variable-name") (id "F:412205")) "last_y") " = window_text_bottom_y (w) - this_scroll_margin;\n\n          " (span (|@| (class "keyword") (id "F:412265")) "if") " (PT > XFASTINT (w->last_point))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:412314")) "/* ") (span (|@| (class "comment") (id "F:412317")) "Point has moved forward.  ") (span (|@| (class "comment-delimiter") (id "F:412343")) "*/") "\n              " (span (|@| (class "keyword") (id "F:412353")) "while") " (MATRIX_ROW_END_CHARPOS (row) < PT\n                     && MATRIX_ROW_BOTTOM_Y (row) < last_y)\n                {\n                  xassert (row->enabled_p);\n                  ++row;\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:412497")) "/* ") (span (|@| (class "comment") (id "F:412500")) "If the end position of a row equals the start\n                 position of the next row, and PT is at that position,\n                 we would rather display cursor in the next line.  ") (span (|@| (class "comment-delimiter") (id "F:412656")) "*/") "\n              " (span (|@| (class "keyword") (id "F:412666")) "while") " (MATRIX_ROW_BOTTOM_Y (row) < last_y\n                     && MATRIX_ROW_END_CHARPOS (row) == PT\n                     && row < w->current_matrix->rows\n                                + w->current_matrix->nrows - 1\n                     && MATRIX_ROW_START_CHARPOS (row+1) == PT\n                     && " (span (|@| (class "negation-char") (id "F:412887")) "!") "cursor_row_p (w, row))\n                ++row;\n\n              " (span (|@| (class "comment-delimiter") (id "F:412928")) "/* ") (span (|@| (class "comment") (id "F:412931")) "If within the scroll margin, scroll.  Note that\n                 MATRIX_ROW_BOTTOM_Y gives the pixel position at which\n                 the next line would be drawn, and that\n                 this_scroll_margin can be zero.  ") (span (|@| (class "comment-delimiter") (id "F:413114")) "*/") "\n              " (span (|@| (class "keyword") (id "F:413124")) "if") " (MATRIX_ROW_BOTTOM_Y (row) > last_y\n                  || PT > MATRIX_ROW_END_CHARPOS (row)\n                  " (span (|@| (class "comment-delimiter") (id "F:413208")) "/* ") (span (|@| (class "comment") (id "F:413211")) "Line is completely visible last line in window\n                     and PT is to be set in the next line.  ") (span (|@| (class "comment-delimiter") (id "F:413304")) "*/") "\n                  || (MATRIX_ROW_BOTTOM_Y (row) == last_y\n                      && PT == MATRIX_ROW_END_CHARPOS (row)\n                      && " (span (|@| (class "negation-char") (id "F:413408")) "!") "row->ends_at_zv_p\n                      && " (span (|@| (class "negation-char") (id "F:413438")) "!") "MATRIX_ROW_ENDS_IN_MIDDLE_OF_CHAR_P (row)))\n                scroll_p = 1;\n            }\n          " (span (|@| (class "keyword") (id "F:413509")) "else") " " (span (|@| (class "keyword") (id "F:413514")) "if") " (PT < XFASTINT (w->last_point))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:413563")) "/* ") (span (|@| (class "comment") (id "F:413566")) "Cursor has to be moved backward.  Note that PT >=\n                 CHARPOS (startp) because of the outer if-statement.  ") (span (|@| (class "comment-delimiter") (id "F:413672")) "*/") "\n              " (span (|@| (class "keyword") (id "F:413682")) "while") " (" (span (|@| (class "negation-char") (id "F:413689")) "!") "row->mode_line_p\n                     && (MATRIX_ROW_START_CHARPOS (row) > PT\n                         || (MATRIX_ROW_START_CHARPOS (row) == PT\n                             && (MATRIX_ROW_STARTS_IN_MIDDLE_OF_CHAR_P (row)\n                                 || (" (span (|@| (class "comment-delimiter") (id "F:413864")) "/* ") (span (|@| (class "comment") (id "F:413867")) "STARTS_IN_MIDDLE_OF_STRING_P (row) ") (span (|@| (class "comment-delimiter") (id "F:413902")) "*/") "\n                                     row > w->current_matrix->rows\n                                     && (row-1)->ends_in_newline_from_string_p))))\n                     && (row->y > top_scroll_margin\n                         || CHARPOS (startp) == BEGV))\n                {\n                  xassert (row->enabled_p);\n                  --row;\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:414128")) "/* ") (span (|@| (class "comment") (id "F:414131")) "Consider the following case: Window starts at BEGV,\n                 there is invisible, intangible text at BEGV, so that\n                 display starts at some point START > BEGV.  It can\n                 happen that we are called with PT somewhere between\n                 BEGV and START.  Try to handle that case.  ") (span (|@| (class "comment-delimiter") (id "F:414394")) "*/") "\n              " (span (|@| (class "keyword") (id "F:414404")) "if") " (row < w->current_matrix->rows\n                  || row->mode_line_p)\n                {\n                  row = w->current_matrix->rows;\n                  " (span (|@| (class "keyword") (id "F:414506")) "if") " (row->mode_line_p)\n                    ++row;\n                }\n\n              " (span (|@| (class "comment-delimiter") (id "F:414553")) "/* ") (span (|@| (class "comment") (id "F:414556")) "Due to newlines in overlay strings, we may have to\n                 skip forward over overlay strings.  ") (span (|@| (class "comment-delimiter") (id "F:414646")) "*/") "\n              " (span (|@| (class "keyword") (id "F:414656")) "while") " (MATRIX_ROW_BOTTOM_Y (row) < last_y\n                     && MATRIX_ROW_END_CHARPOS (row) == PT\n                     && " (span (|@| (class "negation-char") (id "F:414753")) "!") "cursor_row_p (w, row))\n                ++row;\n\n              " (span (|@| (class "comment-delimiter") (id "F:414794")) "/* ") (span (|@| (class "comment") (id "F:414797")) "If within the scroll margin, scroll.  ") (span (|@| (class "comment-delimiter") (id "F:414835")) "*/") "\n              " (span (|@| (class "keyword") (id "F:414845")) "if") " (row->y < top_scroll_margin\n                  && CHARPOS (startp) != BEGV)\n                scroll_p = 1;\n            }\n          " (span (|@| (class "keyword") (id "F:414935")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:414954")) "/* ") (span (|@| (class "comment") (id "F:414957")) "Cursor did not move.  So don't scroll even if cursor line\n                 is partially visible, as it was so before.  ") (span (|@| (class "comment-delimiter") (id "F:415062")) "*/") "\n                 rc = CURSOR_MOVEMENT_SUCCESS;\n            }\n\n          " (span (|@| (class "keyword") (id "F:415109")) "if") " (PT < MATRIX_ROW_START_CHARPOS (row)\n              || PT > MATRIX_ROW_END_CHARPOS (row))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:415208")) "/* ") (span (|@| (class "comment") (id "F:415211")) "if PT is not in the glyph row, give up.  ") (span (|@| (class "comment-delimiter") (id "F:415252")) "*/") "\n              rc = CURSOR_MOVEMENT_MUST_SCROLL;\n              must_scroll = 1;\n            }\n          " (span (|@| (class "keyword") (id "F:415330")) "else") " " (span (|@| (class "keyword") (id "F:415335")) "if") " (rc != CURSOR_MOVEMENT_SUCCESS\n                   && " (span (|@| (class "negation-char") (id "F:415377")) "!") "NILP (XBUFFER (w->buffer)->bidi_display_reordering))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:415445")) "/* ") (span (|@| (class "comment") (id "F:415448")) "If rows are bidi-reordered and point moved, back up\n                 until we find a row that does not belong to a\n                 continuation line.  This is because we must consider\n                 all rows of a continued line as candidates for the\n                 new cursor positioning, since row start and end\n                 positions change non-linearly with vertical position\n                 in such rows.  ") (span (|@| (class "comment-delimiter") (id "F:415784")) "*/") "\n              " (span (|@| (class "comment-delimiter") (id "F:415794")) "/* ") (span (|@| (class "comment") (id "F:415797")) "FIXME: Revisit this when glyph ``spilling'' in\n                 continuation lines' rows is implemented for\n                 bidi-reordered rows.  ") (span (|@| (class "comment-delimiter") (id "F:415916")) "*/") "\n              " (span (|@| (class "keyword") (id "F:415926")) "while") " (MATRIX_ROW_CONTINUATION_LINE_P (row))\n                {\n                  xassert (row->enabled_p);\n                  --row;\n                  " (span (|@| (class "comment-delimiter") (id "F:416020")) "/* ") (span (|@| (class "comment") (id "F:416023")) "If we hit the beginning of the displayed portion\n                     without finding the first row of a continued\n                     line, give up.  ") (span (|@| (class "comment-delimiter") (id "F:416147")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:416154")) "if") " (row <= w->current_matrix->rows)\n                    {\n                      rc = CURSOR_MOVEMENT_MUST_SCROLL;\n                      " (span (|@| (class "keyword") (id "F:416248")) "break") ";\n                    }\n\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:416278")) "if") " (must_scroll)\n            ;\n          " (span (|@| (class "keyword") (id "F:416305")) "else") " " (span (|@| (class "keyword") (id "F:416310")) "if") " (rc != CURSOR_MOVEMENT_SUCCESS\n              && MATRIX_ROW_PARTIALLY_VISIBLE_P (w, row)\n              && make_cursor_line_fully_visible_p)\n            {\n              " (span (|@| (class "keyword") (id "F:416452")) "if") " (PT == MATRIX_ROW_END_CHARPOS (row)\n                  && " (span (|@| (class "negation-char") (id "F:416498")) "!") "row->ends_at_zv_p\n                  && " (span (|@| (class "negation-char") (id "F:416524")) "!") "MATRIX_ROW_ENDS_IN_MIDDLE_OF_CHAR_P (row))\n                rc = CURSOR_MOVEMENT_MUST_SCROLL;\n              " (span (|@| (class "keyword") (id "F:416611")) "else") " " (span (|@| (class "keyword") (id "F:416616")) "if") " (row->height > window_box_height (w))\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:416665")) "/* ") (span (|@| (class "comment") (id "F:416668")) "If we end up in a partially visible line, let's\n                     make it fully visible, except when it's taller\n                     than the window, in which case we can't do much\n                     about it.  ") (span (|@| (class "comment-delimiter") (id "F:416843")) "*/") "\n                  *scroll_step = 1;\n                  rc = CURSOR_MOVEMENT_MUST_SCROLL;\n                }\n              " (span (|@| (class "keyword") (id "F:416917")) "else") "\n                {\n                  set_cursor_from_row (w, row, w->current_matrix, 0, 0, 0, 0);\n                  " (span (|@| (class "keyword") (id "F:416995")) "if") " (" (span (|@| (class "negation-char") (id "F:416999")) "!") "cursor_row_fully_visible_p (w, 0, 1))\n                    rc = CURSOR_MOVEMENT_MUST_SCROLL;\n                  " (span (|@| (class "keyword") (id "F:417082")) "else") "\n                    rc = CURSOR_MOVEMENT_SUCCESS;\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:417137")) "else") " " (span (|@| (class "keyword") (id "F:417142")) "if") " (scroll_p)\n            rc = CURSOR_MOVEMENT_MUST_SCROLL;\n          " (span (|@| (class "keyword") (id "F:417198")) "else") " " (span (|@| (class "keyword") (id "F:417203")) "if") " (rc != CURSOR_MOVEMENT_SUCCESS\n                   && " (span (|@| (class "negation-char") (id "F:417245")) "!") "NILP (XBUFFER (w->buffer)->bidi_display_reordering))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:417313")) "/* ") (span (|@| (class "comment") (id "F:417316")) "With bidi-reordered rows, there could be more than\n                 one candidate row whose start and end positions\n                 occlude point.  We need to let set_cursor_from_row\n                 find the best candidate.  ") (span (|@| (class "comment-delimiter") (id "F:417501")) "*/") "\n              " (span (|@| (class "comment-delimiter") (id "F:417511")) "/* ") (span (|@| (class "comment") (id "F:417514")) "FIXME: Revisit this when glyph ``spilling'' in\n                 continuation lines' rows is implemented for\n                 bidi-reordered rows.  ") (span (|@| (class "comment-delimiter") (id "F:417633")) "*/") "\n              " (span (|@| (class "type") (id "F:417643")) "int") " " (span (|@| (class "variable-name") (id "F:417647")) "rv") " = 0;\n\n              " (span (|@| (class "keyword") (id "F:417663")) "do") "\n                {\n                  " (span (|@| (class "keyword") (id "F:417674")) "if") " (MATRIX_ROW_START_CHARPOS (row) <= PT\n                      && PT <= MATRIX_ROW_END_CHARPOS (row)\n                      && cursor_row_p (w, row))\n                    rv |= set_cursor_from_row (w, row, w->current_matrix,\n                                               0, 0, 0, 0);\n                  " (span (|@| (class "comment-delimiter") (id "F:417884")) "/* ") (span (|@| (class "comment") (id "F:417887")) "As soon as we've found the first suitable row\n                     whose ends_at_zv_p flag is set, we are done.  ") (span (|@| (class "comment-delimiter") (id "F:417986")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:417993")) "if") " (rv\n                      && MATRIX_ROW (w->current_matrix, w->cursor.vpos)->ends_at_zv_p)\n                    {\n                      rc = CURSOR_MOVEMENT_SUCCESS;\n                      " (span (|@| (class "keyword") (id "F:418127")) "break") ";\n                    }\n                  ++row;\n                }\n              " (span (|@| (class "keyword") (id "F:418164")) "while") " ((MATRIX_ROW_CONTINUATION_LINE_P (row)\n                      && MATRIX_ROW_BOTTOM_Y (row) <= last_y)\n                     || (MATRIX_ROW_START_CHARPOS (row) == PT\n                         && MATRIX_ROW_BOTTOM_Y (row) < last_y));\n              " (span (|@| (class "comment-delimiter") (id "F:418357")) "/* ") (span (|@| (class "comment") (id "F:418360")) "If we didn't find any candidate rows, or exited the\n                 loop before all the candidates were examined, signal\n                 to the caller that this method failed.  ") (span (|@| (class "comment-delimiter") (id "F:418511")) "*/") "\n              " (span (|@| (class "keyword") (id "F:418521")) "if") " (rc != CURSOR_MOVEMENT_SUCCESS\n                  && (" (span (|@| (class "negation-char") (id "F:418563")) "!") "rv || MATRIX_ROW_CONTINUATION_LINE_P (row)))\n                rc = CURSOR_MOVEMENT_MUST_SCROLL;\n              " (span (|@| (class "keyword") (id "F:418652")) "else") " " (span (|@| (class "keyword") (id "F:418657")) "if") " (rv)\n                rc = CURSOR_MOVEMENT_SUCCESS;\n            }\n          " (span (|@| (class "keyword") (id "F:418707")) "else") "\n            {\n              " (span (|@| (class "keyword") (id "F:418726")) "do") "\n                {\n                  " (span (|@| (class "keyword") (id "F:418737")) "if") " (set_cursor_from_row (w, row, w->current_matrix, 0, 0, 0, 0))\n                    {\n                      rc = CURSOR_MOVEMENT_SUCCESS;\n                      " (span (|@| (class "keyword") (id "F:418856")) "break") ";\n                    }\n                  ++row;\n                }\n              " (span (|@| (class "keyword") (id "F:418893")) "while") " (MATRIX_ROW_BOTTOM_Y (row) < last_y\n                     && MATRIX_ROW_START_CHARPOS (row) == PT\n                     && cursor_row_p (w, row));\n            }\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:419035")) "return") " rc;\n}\n\n" (span (|@| (class "type") (id "F:419049")) "void") "\n" (span (|@| (class "function-name") (id "F:419054")) "set_vertical_scroll_bar") " (w)\n     " (span (|@| (class "keyword") (id "F:419087")) "struct") " " (span (|@| (class "type") (id "F:419094")) "window") " *" (span (|@| (class "variable-name") (id "F:419102")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:419109")) "int") " " (span (|@| (class "variable-name") (id "F:419113")) "start") ", " (span (|@| (class "variable-name") (id "F:419120")) "end") ", " (span (|@| (class "variable-name") (id "F:419125")) "whole") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:419135")) "/* ") (span (|@| (class "comment") (id "F:419138")) "Calculate the start and end positions for the current window.\n     At some point, it would be nice to choose between scrollbars\n     which reflect the whole buffer size, with special markers\n     indicating narrowing, and scrollbars which reflect only the\n     visible region.\n\n     Note that mini-buffers sometimes aren't displaying any text.  ") (span (|@| (class "comment-delimiter") (id "F:419483")) "*/") "\n  " (span (|@| (class "keyword") (id "F:419488")) "if") " (" (span (|@| (class "negation-char") (id "F:419492")) "!") "MINI_WINDOW_P (w)\n      || (w == XWINDOW (minibuf_window)\n          && NILP (echo_area_buffer[0])))\n    {\n      " (span (|@| (class "keyword") (id "F:419598")) "struct") " " (span (|@| (class "type") (id "F:419605")) "buffer") " *" (span (|@| (class "variable-name") (id "F:419613")) "buf") " = XBUFFER (w->buffer);\n      whole = BUF_ZV (buf) - BUF_BEGV (buf);\n      start = marker_position (w->start) - BUF_BEGV (buf);\n      " (span (|@| (class "comment-delimiter") (id "F:419750")) "/* ") (span (|@| (class "comment") (id "F:419753")) "I don't think this is guaranteed to be right.  For the\n         moment, we'll pretend it is.  ") (span (|@| (class "comment-delimiter") (id "F:419840")) "*/") "\n      end = BUF_Z (buf) - XFASTINT (w->window_end_pos) - BUF_BEGV (buf);\n\n      " (span (|@| (class "keyword") (id "F:419923")) "if") " (end < start)\n        end = start;\n      " (span (|@| (class "keyword") (id "F:419960")) "if") " (whole < (end - start))\n        whole = end - start;\n    }\n  " (span (|@| (class "keyword") (id "F:420017")) "else") "\n    start = end = whole = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:420054")) "/* ") (span (|@| (class "comment") (id "F:420057")) "Indicate what this scroll bar ought to be displaying now.  ") (span (|@| (class "comment-delimiter") (id "F:420116")) "*/") "\n  " (span (|@| (class "keyword") (id "F:420121")) "if") " (FRAME_TERMINAL (XFRAME (w->frame))->set_vertical_scroll_bar_hook)\n    (*FRAME_TERMINAL (XFRAME (w->frame))->set_vertical_scroll_bar_hook)\n      (w, end - start, whole, start);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:420305")) "/* ") (span (|@| (class "comment") (id "F:420308")) "Redisplay leaf window WINDOW.  JUST_THIS_ONE_P non-zero means only\n   selected_window is redisplayed.\n\n   We can return without actually redisplaying the window if\n   fonts_changed_p is nonzero.  In that case, redisplay_internal will\n   retry.  ") (span (|@| (class "comment-delimiter") (id "F:420553")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:420557")) "static") " " (span (|@| (class "type") (id "F:420564")) "void") "\n" (span (|@| (class "function-name") (id "F:420569")) "redisplay_window") " (" (span (|@| (class "type") (id "F:420587")) "window") ", just_this_one_p)\n     " (span (|@| (class "type") (id "F:420617")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:420629")) "window") ";\n     " (span (|@| (class "type") (id "F:420642")) "int") " " (span (|@| (class "variable-name") (id "F:420646")) "just_this_one_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:420667")) "struct") " " (span (|@| (class "type") (id "F:420674")) "window") " *" (span (|@| (class "variable-name") (id "F:420682")) "w") " = XWINDOW (window);\n  " (span (|@| (class "keyword") (id "F:420706")) "struct") " " (span (|@| (class "type") (id "F:420713")) "frame") " *" (span (|@| (class "variable-name") (id "F:420720")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "keyword") (id "F:420745")) "struct") " " (span (|@| (class "type") (id "F:420752")) "buffer") " *" (span (|@| (class "variable-name") (id "F:420760")) "buffer") " = XBUFFER (w->buffer);\n  " (span (|@| (class "keyword") (id "F:420792")) "struct") " " (span (|@| (class "type") (id "F:420799")) "buffer") " *" (span (|@| (class "variable-name") (id "F:420807")) "old") " = current_buffer;\n  " (span (|@| (class "keyword") (id "F:420831")) "struct") " " (span (|@| (class "type") (id "F:420838")) "text_pos") " " (span (|@| (class "variable-name") (id "F:420847")) "lpoint") ", " (span (|@| (class "variable-name") (id "F:420855")) "opoint") ", " (span (|@| (class "variable-name") (id "F:420863")) "startp") ";\n  " (span (|@| (class "type") (id "F:420873")) "int") " " (span (|@| (class "variable-name") (id "F:420877")) "update_mode_line") ";\n  " (span (|@| (class "type") (id "F:420897")) "int") " " (span (|@| (class "variable-name") (id "F:420901")) "tem") ";\n  " (span (|@| (class "keyword") (id "F:420908")) "struct") " " (span (|@| (class "type") (id "F:420915")) "it") " " (span (|@| (class "variable-name") (id "F:420918")) "it") ";\n  " (span (|@| (class "comment-delimiter") (id "F:420924")) "/* ") (span (|@| (class "comment") (id "F:420927")) "Record it now because it's overwritten.  ") (span (|@| (class "comment-delimiter") (id "F:420968")) "*/") "\n  " (span (|@| (class "type") (id "F:420973")) "int") " " (span (|@| (class "variable-name") (id "F:420977")) "current_matrix_up_to_date_p") " = 0;\n  " (span (|@| (class "type") (id "F:421012")) "int") " " (span (|@| (class "variable-name") (id "F:421016")) "used_current_matrix_p") " = 0;\n  " (span (|@| (class "comment-delimiter") (id "F:421045")) "/* ") (span (|@| (class "comment") (id "F:421048")) "This is less strict than current_matrix_up_to_date_p.\n     It indictes that the buffer contents and narrowing are unchanged.  ") (span (|@| (class "comment-delimiter") (id "F:421174")) "*/") "\n  " (span (|@| (class "type") (id "F:421179")) "int") " " (span (|@| (class "variable-name") (id "F:421183")) "buffer_unchanged_p") " = 0;\n  " (span (|@| (class "type") (id "F:421209")) "int") " " (span (|@| (class "variable-name") (id "F:421213")) "temp_scroll_step") " = 0;\n  " (span (|@| (class "type") (id "F:421237")) "int") " " (span (|@| (class "variable-name") (id "F:421241")) "count") " = SPECPDL_INDEX ();\n  " (span (|@| (class "type") (id "F:421269")) "int") " " (span (|@| (class "variable-name") (id "F:421273")) "rc") ";\n  " (span (|@| (class "type") (id "F:421279")) "int") " " (span (|@| (class "variable-name") (id "F:421283")) "centering_position") " = -1;\n  " (span (|@| (class "type") (id "F:421310")) "int") " " (span (|@| (class "variable-name") (id "F:421314")) "last_line_misfit") " = 0;\n  " (span (|@| (class "type") (id "F:421338")) "int") " " (span (|@| (class "variable-name") (id "F:421342")) "beg_unchanged") ", " (span (|@| (class "variable-name") (id "F:421357")) "end_unchanged") ";\n\n  SET_TEXT_POS (lpoint, PT, PT_BYTE);\n  opoint = lpoint;\n\n  " (span (|@| (class "comment-delimiter") (id "F:421433")) "/* ") (span (|@| (class "comment") (id "F:421436")) "W must be a leaf window here.  ") (span (|@| (class "comment-delimiter") (id "F:421467")) "*/") "\n  xassert (" (span (|@| (class "negation-char") (id "F:421481")) "!") "NILP (w->buffer));\n" (span (|@| (class "preprocessor") (id "F:421501")) "#if") " GLYPH_DEBUG\n  *w->desired_matrix->method = 0;\n" (span (|@| (class "preprocessor") (id "F:421551")) "#endif") "\n\n " (span (|@| (class "constant") (id "F:421560")) "restart") ":\n  reconsider_clip_changes (w, buffer);\n\n  " (span (|@| (class "comment-delimiter") (id "F:421611")) "/* ") (span (|@| (class "comment") (id "F:421614")) "Has the mode line to be updated?  ") (span (|@| (class "comment-delimiter") (id "F:421648")) "*/") "\n  update_mode_line = (" (span (|@| (class "negation-char") (id "F:421673")) "!") "NILP (w->update_mode_line)\n                      || update_mode_lines\n                      || buffer->clip_changed\n                      || buffer->prevent_redisplay_optimizations_p);\n\n  " (span (|@| (class "keyword") (id "F:421820")) "if") " (MINI_WINDOW_P (w))\n    {\n      " (span (|@| (class "keyword") (id "F:421855")) "if") " (w == XWINDOW (echo_area_window)\n          && " (span (|@| (class "negation-char") (id "F:421897")) "!") "NILP (echo_area_buffer[0]))\n        {\n          " (span (|@| (class "keyword") (id "F:421932")) "if") " (update_mode_line)\n            " (span (|@| (class "comment-delimiter") (id "F:421959")) "/* ") (span (|@| (class "comment") (id "F:421962")) "We may have to update a tty frame's menu bar or a\n               tool-bar.  Example `M-x C-h C-h C-g'.  ") (span (|@| (class "comment-delimiter") (id "F:422059")) "*/") "\n            " (span (|@| (class "keyword") (id "F:422067")) "goto") " " (span (|@| (class "constant") (id "F:422072")) "finish_menu_bars") ";\n          " (span (|@| (class "keyword") (id "F:422093")) "else") "\n            " (span (|@| (class "comment-delimiter") (id "F:422103")) "/* ") (span (|@| (class "comment") (id "F:422106")) "We've already displayed the echo area glyphs in this window.  ") (span (|@| (class "comment-delimiter") (id "F:422168")) "*/") "\n            " (span (|@| (class "keyword") (id "F:422176")) "goto") " " (span (|@| (class "constant") (id "F:422181")) "finish_scroll_bars") ";\n        }\n      " (span (|@| (class "keyword") (id "F:422210")) "else") " " (span (|@| (class "keyword") (id "F:422215")) "if") " ((w != XWINDOW (minibuf_window)\n                || minibuf_level == 0)\n               " (span (|@| (class "comment-delimiter") (id "F:422283")) "/* ") (span (|@| (class "comment") (id "F:422286")) "When buffer is nonempty, redisplay window normally. ") (span (|@| (class "comment-delimiter") (id "F:422338")) "*/") "\n               && BUF_Z (XBUFFER (w->buffer)) == BUF_BEG (XBUFFER (w->buffer))\n               " (span (|@| (class "comment-delimiter") (id "F:422421")) "/* ") (span (|@| (class "comment") (id "F:422424")) "Quail displays non-mini buffers in minibuffer window.\n                  In that case, redisplay the window normally.  ") (span (|@| (class "comment-delimiter") (id "F:422528")) "*/") "\n               && " (span (|@| (class "negation-char") (id "F:422542")) "!") "NILP (Fmemq (w->buffer, Vminibuffer_list)))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:422593")) "/* ") (span (|@| (class "comment") (id "F:422596")) "W is a mini-buffer window, but it's not active, so clear\n             it.  ") (span (|@| (class "comment-delimiter") (id "F:422664")) "*/") "\n          " (span (|@| (class "type") (id "F:422670")) "int") " " (span (|@| (class "variable-name") (id "F:422674")) "yb") " = window_text_bottom_y (w);\n          " (span (|@| (class "keyword") (id "F:422708")) "struct") " " (span (|@| (class "type") (id "F:422715")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:422726")) "row") ";\n          " (span (|@| (class "type") (id "F:422734")) "int") " " (span (|@| (class "variable-name") (id "F:422738")) "y") ";\n\n          " (span (|@| (class "keyword") (id "F:422745")) "for") " (y = 0, row = w->desired_matrix->rows;\n               y < yb;\n               y += row->height, ++row)\n            blank_row (w, row, y);\n          " (span (|@| (class "keyword") (id "F:422868")) "goto") " " (span (|@| (class "constant") (id "F:422873")) "finish_scroll_bars") ";\n        }\n\n      clear_glyph_matrix (w->desired_matrix);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:422952")) "/* ") (span (|@| (class "comment") (id "F:422955")) "Otherwise set up data on this window; select its buffer and point\n     value.  ") (span (|@| (class "comment-delimiter") (id "F:423034")) "*/") "\n  " (span (|@| (class "comment-delimiter") (id "F:423039")) "/* ") (span (|@| (class "comment") (id "F:423042")) "Really select the buffer, for the sake of buffer-local\n     variables.  ") (span (|@| (class "comment-delimiter") (id "F:423114")) "*/") "\n  set_buffer_internal_1 (XBUFFER (w->buffer));\n\n  current_matrix_up_to_date_p\n    = (" (span (|@| (class "negation-char") (id "F:423202")) "!") "NILP (w->window_end_valid)\n       && " (span (|@| (class "negation-char") (id "F:423240")) "!") "current_buffer->clip_changed\n       && " (span (|@| (class "negation-char") (id "F:423280")) "!") "current_buffer->prevent_redisplay_optimizations_p\n       && XFASTINT (w->last_modified) >= MODIFF\n       && XFASTINT (w->last_overlay_modified) >= OVERLAY_MODIFF);\n\n  " (span (|@| (class "comment-delimiter") (id "F:423448")) "/* ") (span (|@| (class "comment") (id "F:423451")) "Run the window-bottom-change-functions\n     if it is possible that the text on the screen has changed\n     (either due to modification of the text, or any other reason).  ") (span (|@| (class "comment-delimiter") (id "F:423622")) "*/") "\n  " (span (|@| (class "keyword") (id "F:423627")) "if") " (" (span (|@| (class "negation-char") (id "F:423631")) "!") "current_matrix_up_to_date_p\n      && " (span (|@| (class "negation-char") (id "F:423669")) "!") "NILP (Vwindow_text_change_functions))\n    {\n      safe_run_hooks (Qwindow_text_change_functions);\n      " (span (|@| (class "keyword") (id "F:423774")) "goto") " " (span (|@| (class "constant") (id "F:423779")) "restart") ";\n    }\n\n  beg_unchanged = BEG_UNCHANGED;\n  end_unchanged = END_UNCHANGED;\n\n  SET_TEXT_POS (opoint, PT, PT_BYTE);\n\n  specbind (Qinhibit_point_motion_hooks, Qt);\n\n  buffer_unchanged_p\n    = (" (span (|@| (class "negation-char") (id "F:423976")) "!") "NILP (w->window_end_valid)\n       && " (span (|@| (class "negation-char") (id "F:424014")) "!") "current_buffer->clip_changed\n       && XFASTINT (w->last_modified) >= MODIFF\n       && XFASTINT (w->last_overlay_modified) >= OVERLAY_MODIFF);\n\n  " (span (|@| (class "comment-delimiter") (id "F:424161")) "/* ") (span (|@| (class "comment") (id "F:424164")) "When windows_or_buffers_changed is non-zero, we can't rely on\n     the window end being valid, so set it to nil there.  ") (span (|@| (class "comment-delimiter") (id "F:424284")) "*/") "\n  " (span (|@| (class "keyword") (id "F:424289")) "if") " (windows_or_buffers_changed)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:424333")) "/* ") (span (|@| (class "comment") (id "F:424336")) "If window starts on a continuation line, maybe adjust the\n         window start in case the window's width changed.  ") (span (|@| (class "comment-delimiter") (id "F:424446")) "*/") "\n      " (span (|@| (class "keyword") (id "F:424455")) "if") " (XMARKER (w->start)->buffer == current_buffer)\n        compute_window_start_on_continuation_line (w);\n\n      w->window_end_valid = Qnil;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:424597")) "/* ") (span (|@| (class "comment") (id "F:424600")) "Some sanity checks.  ") (span (|@| (class "comment-delimiter") (id "F:424621")) "*/") "\n  CHECK_WINDOW_END (w);\n  " (span (|@| (class "keyword") (id "F:424650")) "if") " (Z == Z_BYTE && CHARPOS (opoint) != BYTEPOS (opoint))\n    abort ();\n  " (span (|@| (class "keyword") (id "F:424723")) "if") " (BYTEPOS (opoint) < CHARPOS (opoint))\n    abort ();\n\n  " (span (|@| (class "comment-delimiter") (id "F:424781")) "/* ") (span (|@| (class "comment") (id "F:424784")) "If %c is in mode line, update it if needed.  ") (span (|@| (class "comment-delimiter") (id "F:424829")) "*/") "\n  " (span (|@| (class "keyword") (id "F:424834")) "if") " (" (span (|@| (class "negation-char") (id "F:424838")) "!") "NILP (w->column_number_displayed)\n      " (span (|@| (class "comment-delimiter") (id "F:424879")) "/* ") (span (|@| (class "comment") (id "F:424882")) "This alternative quickly identifies a common case\n         where no change is needed.  ") (span (|@| (class "comment-delimiter") (id "F:424962")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:424974")) "!") "(PT == XFASTINT (w->last_point)\n           && XFASTINT (w->last_modified) >= MODIFF\n           && XFASTINT (w->last_overlay_modified) >= OVERLAY_MODIFF)\n      && (XFASTINT (w->column_number_displayed)\n          != (" (span (|@| (class "type") (id "F:425176")) "int") ") current_column ()))  " (span (|@| (class "comment-delimiter") (id "F:425202")) "/* ") (span (|@| (class "comment") (id "F:425205")) "iftc ") (span (|@| (class "comment-delimiter") (id "F:425210")) "*/") "\n    update_mode_line = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:425242")) "/* ") (span (|@| (class "comment") (id "F:425245")) "Count number of windows showing the selected buffer.  An indirect\n     buffer counts as its base buffer.  ") (span (|@| (class "comment-delimiter") (id "F:425351")) "*/") "\n  " (span (|@| (class "keyword") (id "F:425356")) "if") " (" (span (|@| (class "negation-char") (id "F:425360")) "!") "just_this_one_p)\n    {\n      " (span (|@| (class "keyword") (id "F:425390")) "struct") " " (span (|@| (class "type") (id "F:425397")) "buffer") " *" (span (|@| (class "variable-name") (id "F:425405")) "current_base") ", *" (span (|@| (class "variable-name") (id "F:425420")) "window_base") ";\n      current_base = current_buffer;\n      window_base = XBUFFER (XWINDOW (selected_window)->buffer);\n      " (span (|@| (class "keyword") (id "F:425541")) "if") " (current_base->base_buffer)\n        current_base = current_base->base_buffer;\n      " (span (|@| (class "keyword") (id "F:425621")) "if") " (window_base->base_buffer)\n        window_base = window_base->base_buffer;\n      " (span (|@| (class "keyword") (id "F:425698")) "if") " (current_base == window_base)\n        buffer_shared++;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:425758")) "/* ") (span (|@| (class "comment") (id "F:425761")) "Point refers normally to the selected window.  For any other\n     window, set up appropriate value.  ") (span (|@| (class "comment-delimiter") (id "F:425862")) "*/") "\n  " (span (|@| (class "keyword") (id "F:425867")) "if") " (" (span (|@| (class "negation-char") (id "F:425871")) "!") "EQ (window, selected_window))\n    {\n      " (span (|@| (class "type") (id "F:425914")) "int") " " (span (|@| (class "variable-name") (id "F:425918")) "new_pt") " = XMARKER (w->pointm)->charpos;\n      " (span (|@| (class "type") (id "F:425963")) "int") " " (span (|@| (class "variable-name") (id "F:425967")) "new_pt_byte") " = marker_byte_position (w->pointm);\n      " (span (|@| (class "keyword") (id "F:426021")) "if") " (new_pt < BEGV)\n        {\n          new_pt = BEGV;\n          new_pt_byte = BEGV_BYTE;\n          set_marker_both (w->pointm, Qnil, BEGV, BEGV_BYTE);\n        }\n      " (span (|@| (class "keyword") (id "F:426153")) "else") " " (span (|@| (class "keyword") (id "F:426158")) "if") " (new_pt > (ZV - 1))\n        {\n          new_pt = ZV;\n          new_pt_byte = ZV_BYTE;\n          set_marker_both (w->pointm, Qnil, ZV, ZV_BYTE);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:426287")) "/* ") (span (|@| (class "comment") (id "F:426290")) "We don't use SET_PT so that the point-motion hooks don't run.  ") (span (|@| (class "comment-delimiter") (id "F:426353")) "*/") "\n      TEMP_SET_PT_BOTH (new_pt, new_pt_byte);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:426411")) "/* ") (span (|@| (class "comment") (id "F:426414")) "If any of the character widths specified in the display table\n     have changed, invalidate the width run cache.  It's true that\n     this may be a bit late to catch such changes, but the rest of\n     redisplay goes (non-fatally) haywire when the display table is\n     changed, so why should we worry about doing any better?  ") (span (|@| (class "comment-delimiter") (id "F:426740")) "*/") "\n  " (span (|@| (class "keyword") (id "F:426745")) "if") " (current_buffer->width_run_cache)\n    {\n      " (span (|@| (class "keyword") (id "F:426794")) "struct") " " (span (|@| (class "type") (id "F:426801")) "Lisp_Char_Table") " *" (span (|@| (class "variable-name") (id "F:426818")) "disptab") " = buffer_display_table ();\n\n      " (span (|@| (class "keyword") (id "F:426860")) "if") " (" (span (|@| (class "negation-char") (id "F:426864")) "!") " disptab_matches_widthtab (disptab,\n                                      XVECTOR (current_buffer->width_table)))\n        {\n          invalidate_region_cache (current_buffer,\n                                   current_buffer->width_run_cache,\n                                   BEG, Z);\n          recompute_width_table (current_buffer, disptab);\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:427230")) "/* ") (span (|@| (class "comment") (id "F:427233")) "If window-start is screwed up, choose a new one.  ") (span (|@| (class "comment-delimiter") (id "F:427283")) "*/") "\n  " (span (|@| (class "keyword") (id "F:427288")) "if") " (XMARKER (w->start)->buffer != current_buffer)\n    " (span (|@| (class "keyword") (id "F:427342")) "goto") " " (span (|@| (class "constant") (id "F:427347")) "recenter") ";\n\n  SET_TEXT_POS_FROM_MARKER (startp, w->start);\n\n  " (span (|@| (class "comment-delimiter") (id "F:427408")) "/* ") (span (|@| (class "comment") (id "F:427411")) "If someone specified a new starting point but did not insist,\n     check whether it can be used.  ") (span (|@| (class "comment-delimiter") (id "F:427509")) "*/") "\n  " (span (|@| (class "keyword") (id "F:427514")) "if") " (" (span (|@| (class "negation-char") (id "F:427518")) "!") "NILP (w->optional_new_start)\n      && CHARPOS (startp) >= BEGV\n      && CHARPOS (startp) <= ZV)\n    {\n      w->optional_new_start = Qnil;\n      start_display (&it, w, startp);\n      move_it_to (&it, PT, 0, it.last_visible_y, -1,\n                  MOVE_TO_POS | MOVE_TO_X | MOVE_TO_Y);\n      " (span (|@| (class "keyword") (id "F:427796")) "if") " (IT_CHARPOS (it) == PT)\n        w->force_start = Qt;\n      " (span (|@| (class "comment-delimiter") (id "F:427851")) "/* ") (span (|@| (class "comment") (id "F:427854")) "IT may overshoot PT if text at PT is invisible.  ") (span (|@| (class "comment-delimiter") (id "F:427903")) "*/") "\n      " (span (|@| (class "keyword") (id "F:427912")) "else") " " (span (|@| (class "keyword") (id "F:427917")) "if") " (IT_CHARPOS (it) > PT && CHARPOS (startp) <= PT)\n        w->force_start = Qt;\n    }\n\n " (span (|@| (class "constant") (id "F:427999")) "force_start") ":\n\n  " (span (|@| (class "comment-delimiter") (id "F:428015")) "/* ") (span (|@| (class "comment") (id "F:428018")) "Handle case where place to start displaying has been specified,\n     unless the specified location is outside the accessible range.  ") (span (|@| (class "comment-delimiter") (id "F:428151")) "*/") "\n  " (span (|@| (class "keyword") (id "F:428156")) "if") " (" (span (|@| (class "negation-char") (id "F:428160")) "!") "NILP (w->force_start)\n      || w->frozen_window_start_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:428230")) "/* ") (span (|@| (class "comment") (id "F:428233")) "We set this later on if we have to adjust point.  ") (span (|@| (class "comment-delimiter") (id "F:428283")) "*/") "\n      " (span (|@| (class "type") (id "F:428292")) "int") " " (span (|@| (class "variable-name") (id "F:428296")) "new_vpos") " = -1;\n\n      w->force_start = Qnil;\n      w->vscroll = 0;\n      w->window_end_valid = Qnil;\n\n      " (span (|@| (class "comment-delimiter") (id "F:428404")) "/* ") (span (|@| (class "comment") (id "F:428407")) "Forget any recorded base line for line number display.  ") (span (|@| (class "comment-delimiter") (id "F:428463")) "*/") "\n      " (span (|@| (class "keyword") (id "F:428472")) "if") " (" (span (|@| (class "negation-char") (id "F:428476")) "!") "buffer_unchanged_p)\n        w->base_line_number = Qnil;\n\n      " (span (|@| (class "comment-delimiter") (id "F:428533")) "/* ") (span (|@| (class "comment") (id "F:428536")) "Redisplay the mode line.  Select the buffer properly for that.\n         Also, run the hook window-scroll-functions\n         because we have scrolled.  ") (span (|@| (class "comment-delimiter") (id "F:428673")) "*/") "\n      " (span (|@| (class "comment-delimiter") (id "F:428682")) "/* ") (span (|@| (class "comment") (id "F:428685")) "Note, we do this after clearing force_start because\n         if there's an error, it is better to forget about force_start\n         than to get into an infinite loop calling the hook functions\n         and having them get more errors.  ") (span (|@| (class "comment-delimiter") (id "F:428900")) "*/") "\n      " (span (|@| (class "keyword") (id "F:428909")) "if") " (" (span (|@| (class "negation-char") (id "F:428913")) "!") "update_mode_line\n          || " (span (|@| (class "negation-char") (id "F:428937")) "!") " NILP (Vwindow_scroll_functions))\n        {\n          update_mode_line = 1;\n          w->update_mode_line = Qt;\n          startp = run_window_scroll_functions (window, startp);\n        }\n\n      w->last_modified = make_number (0);\n      w->last_overlay_modified = make_number (0);\n      " (span (|@| (class "keyword") (id "F:429189")) "if") " (CHARPOS (startp) < BEGV)\n        SET_TEXT_POS (startp, BEGV, BEGV_BYTE);\n      " (span (|@| (class "keyword") (id "F:429265")) "else") " " (span (|@| (class "keyword") (id "F:429270")) "if") " (CHARPOS (startp) > ZV)\n        SET_TEXT_POS (startp, ZV, ZV_BYTE);\n\n      " (span (|@| (class "comment-delimiter") (id "F:429341")) "/* ") (span (|@| (class "comment") (id "F:429344")) "Redisplay, then check if cursor has been set during the\n         redisplay.  Give up if new fonts were loaded.  ") (span (|@| (class "comment-delimiter") (id "F:429449")) "*/") "\n      " (span (|@| (class "comment-delimiter") (id "F:429458")) "/* ") (span (|@| (class "comment") (id "F:429461")) "We used to issue a CHECK_MARGINS argument to try_window here,\n         but this causes scrolling to fail when point begins inside\n         the scroll margin (bug#148) -- cyd  ") (span (|@| (class "comment-delimiter") (id "F:429622")) "*/") "\n      " (span (|@| (class "keyword") (id "F:429631")) "if") " (" (span (|@| (class "negation-char") (id "F:429635")) "!") "try_window (window, startp, 0))\n        {\n          w->force_start = Qt;\n          clear_glyph_matrix (w->desired_matrix);\n          " (span (|@| (class "keyword") (id "F:429741")) "goto") " " (span (|@| (class "constant") (id "F:429746")) "need_larger_matrices") ";\n        }\n\n      " (span (|@| (class "keyword") (id "F:429778")) "if") " (w->cursor.vpos < 0 && " (span (|@| (class "negation-char") (id "F:429804")) "!") "w->frozen_window_start_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:429837")) "/* ") (span (|@| (class "comment") (id "F:429840")) "If point does not appear, try to move point so it does\n             appear. The desired matrix has been built above, so we\n             can use it here.  ") (span (|@| (class "comment-delimiter") (id "F:429980")) "*/") "\n          new_vpos = window_box_height (w) / 2;\n        }\n\n      " (span (|@| (class "keyword") (id "F:430034")) "if") " (" (span (|@| (class "negation-char") (id "F:430038")) "!") "cursor_row_fully_visible_p (w, 0, 0))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:430083")) "/* ") (span (|@| (class "comment") (id "F:430086")) "Point does appear, but on a line partly visible at end of window.\n             Move it back to a fully-visible line.  ") (span (|@| (class "comment-delimiter") (id "F:430197")) "*/") "\n          new_vpos = window_box_height (w);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:430247")) "/* ") (span (|@| (class "comment") (id "F:430250")) "If we need to move point for either of the above reasons,\n         now actually do it.  ") (span (|@| (class "comment-delimiter") (id "F:430331")) "*/") "\n      " (span (|@| (class "keyword") (id "F:430340")) "if") " (new_vpos >= 0)\n        {\n          " (span (|@| (class "keyword") (id "F:430365")) "struct") " " (span (|@| (class "type") (id "F:430372")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:430383")) "row") ";\n\n          row = MATRIX_FIRST_TEXT_ROW (w->desired_matrix);\n          " (span (|@| (class "keyword") (id "F:430444")) "while") " (MATRIX_ROW_BOTTOM_Y (row) < new_vpos)\n            ++row;\n\n          TEMP_SET_PT_BOTH (MATRIX_ROW_START_CHARPOS (row),\n                            MATRIX_ROW_START_BYTEPOS (row));\n\n          " (span (|@| (class "keyword") (id "F:430599")) "if") " (w != XWINDOW (selected_window))\n            set_marker_both (w->pointm, Qnil, PT, PT_BYTE);\n          " (span (|@| (class "keyword") (id "F:430691")) "else") " " (span (|@| (class "keyword") (id "F:430696")) "if") " (current_buffer == old)\n            SET_TEXT_POS (lpoint, PT, PT_BYTE);\n\n          set_cursor_from_row (w, row, w->desired_matrix, 0, 0, 0, 0);\n\n          " (span (|@| (class "comment-delimiter") (id "F:430833")) "/* ") (span (|@| (class "comment") (id "F:430836")) "If we are highlighting the region, then we just changed\n             the region, so redisplay to show it.  ") (span (|@| (class "comment-delimiter") (id "F:430936")) "*/") "\n          " (span (|@| (class "keyword") (id "F:430942")) "if") " (" (span (|@| (class "negation-char") (id "F:430946")) "!") "NILP (Vtransient_mark_mode)\n              && " (span (|@| (class "negation-char") (id "F:430985")) "!") "NILP (current_buffer->mark_active))\n            {\n              clear_glyph_matrix (w->desired_matrix);\n              " (span (|@| (class "keyword") (id "F:431083")) "if") " (" (span (|@| (class "negation-char") (id "F:431087")) "!") "try_window (window, startp, 0))\n                " (span (|@| (class "keyword") (id "F:431122")) "goto") " " (span (|@| (class "constant") (id "F:431127")) "need_larger_matrices") ";\n            }\n        }\n\n" (span (|@| (class "preprocessor") (id "F:431160")) "#if") " GLYPH_DEBUG\n      debug_method_add (w, " (span (|@| (class "string") (id "F:431203")) "\"forced window start\"") ");\n" (span (|@| (class "preprocessor") (id "F:431227")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:431240")) "goto") " " (span (|@| (class "constant") (id "F:431245")) "done") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:431260")) "/* ") (span (|@| (class "comment") (id "F:431263")) "Handle case where text has not changed, only point, and it has\n     not moved off the frame, and we are not retrying after hscroll.\n     (current_matrix_up_to_date_p is nonzero when retrying.)  ") (span (|@| (class "comment-delimiter") (id "F:431457")) "*/") "\n  " (span (|@| (class "keyword") (id "F:431462")) "if") " (current_matrix_up_to_date_p\n      && (rc = try_cursor_movement (window, startp, &temp_scroll_step),\n          rc != CURSOR_MOVEMENT_CANNOT_BE_USED))\n    {\n      " (span (|@| (class "keyword") (id "F:431620")) "switch") " (rc)\n        {\n        " (span (|@| (class "keyword") (id "F:431636")) "case") " CURSOR_MOVEMENT_SUCCESS:\n          used_current_matrix_p = 1;\n          " (span (|@| (class "keyword") (id "F:431699")) "goto") " " (span (|@| (class "constant") (id "F:431704")) "done") ";\n\n        " (span (|@| (class "keyword") (id "F:431712")) "case") " CURSOR_MOVEMENT_MUST_SCROLL:\n          " (span (|@| (class "keyword") (id "F:431749")) "goto") " " (span (|@| (class "constant") (id "F:431754")) "try_to_scroll") ";\n\n        " (span (|@| (class "keyword") (id "F:431771")) "default") ":\n          abort ();\n        }\n    }\n  " (span (|@| (class "comment-delimiter") (id "F:431804")) "/* ") (span (|@| (class "comment") (id "F:431807")) "If current starting point was originally the beginning of a line\n     but no longer is, find a new starting point.  ") (span (|@| (class "comment-delimiter") (id "F:431923")) "*/") "\n  " (span (|@| (class "keyword") (id "F:431928")) "else") " " (span (|@| (class "keyword") (id "F:431933")) "if") " (" (span (|@| (class "negation-char") (id "F:431937")) "!") "NILP (w->start_at_line_beg)\n           && " (span (|@| (class "negation-char") (id "F:431973")) "!") "(CHARPOS (startp) <= BEGV\n                || FETCH_BYTE (BYTEPOS (startp) - 1) == " (span (|@| (class "string") (id "F:432042")) "'\\n'") "))\n    {\n" (span (|@| (class "preprocessor") (id "F:432055")) "#if") " GLYPH_DEBUG\n      debug_method_add (w, " (span (|@| (class "string") (id "F:432098")) "\"recenter 1\"") ");\n" (span (|@| (class "preprocessor") (id "F:432113")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:432126")) "goto") " " (span (|@| (class "constant") (id "F:432131")) "recenter") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:432150")) "/* ") (span (|@| (class "comment") (id "F:432153")) "Try scrolling with try_window_id.  Value is > 0 if update has\n     been done, it is -1 if we know that the same window start will\n     not work.  It is 0 if unsuccessful for some other reason.  ") (span (|@| (class "comment-delimiter") (id "F:432347")) "*/") "\n  " (span (|@| (class "keyword") (id "F:432352")) "else") " " (span (|@| (class "keyword") (id "F:432357")) "if") " ((tem = try_window_id (w)) != 0)\n    {\n" (span (|@| (class "preprocessor") (id "F:432399")) "#if") " GLYPH_DEBUG\n      debug_method_add (w, " (span (|@| (class "string") (id "F:432442")) "\"try_window_id %d\"") ", tem);\n" (span (|@| (class "preprocessor") (id "F:432468")) "#endif") "\n\n      " (span (|@| (class "keyword") (id "F:432482")) "if") " (fonts_changed_p)\n        " (span (|@| (class "keyword") (id "F:432504")) "goto") " " (span (|@| (class "constant") (id "F:432509")) "need_larger_matrices") ";\n      " (span (|@| (class "keyword") (id "F:432537")) "if") " (tem > 0)\n        " (span (|@| (class "keyword") (id "F:432551")) "goto") " " (span (|@| (class "constant") (id "F:432556")) "done") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:432569")) "/* ") (span (|@| (class "comment") (id "F:432572")) "Otherwise try_window_id has returned -1 which means that we\n         don't want the alternative below this comment to execute.  ") (span (|@| (class "comment-delimiter") (id "F:432693")) "*/") "\n    }\n  " (span (|@| (class "keyword") (id "F:432704")) "else") " " (span (|@| (class "keyword") (id "F:432709")) "if") " (CHARPOS (startp) >= BEGV\n           && CHARPOS (startp) <= ZV\n           && PT >= CHARPOS (startp)\n           && (CHARPOS (startp) < ZV\n               " (span (|@| (class "comment-delimiter") (id "F:432836")) "/* ") (span (|@| (class "comment") (id "F:432839")) "Avoid starting at end of buffer.  ") (span (|@| (class "comment-delimiter") (id "F:432873")) "*/") "\n               || CHARPOS (startp) == BEGV\n               || (XFASTINT (w->last_modified) >= MODIFF\n                   && XFASTINT (w->last_overlay_modified) >= OVERLAY_MODIFF)))\n    {\n\n      " (span (|@| (class "comment-delimiter") (id "F:433040")) "/* ") (span (|@| (class "comment") (id "F:433043")) "If first window line is a continuation line, and window start\n         is inside the modified region, but the first change is before\n         current window start, we must select a new window start.\n\n         However, if this is the result of a down-mouse event (e.g. by\n         extending the mouse-drag-overlay), we don't want to select a\n         new window start, since that would change the position under\n         the mouse, resulting in an unwanted mouse-movement rather\n         than a simple mouse-click.  ") (span (|@| (class "comment-delimiter") (id "F:433509")) "*/") "\n      " (span (|@| (class "keyword") (id "F:433518")) "if") " (NILP (w->start_at_line_beg)\n          && NILP (do_mouse_tracking)\n          && CHARPOS (startp) > BEGV\n          && CHARPOS (startp) > BEG + beg_unchanged\n          && CHARPOS (startp) <= Z - end_unchanged\n          " (span (|@| (class "comment-delimiter") (id "F:433709")) "/* ") (span (|@| (class "comment") (id "F:433712")) "Even if w->start_at_line_beg is nil, a new window may\n             start at a line_beg, since that's how set_buffer_window\n             sets it.  So, we need to check the return value of\n             compute_window_start_on_continuation_line.  (See also\n             bug#197).  ") (span (|@| (class "comment-delimiter") (id "F:433962")) "*/") "\n          && XMARKER (w->start)->buffer == current_buffer\n          && compute_window_start_on_continuation_line (w))\n        {\n          w->force_start = Qt;\n          SET_TEXT_POS_FROM_MARKER (startp, w->start);\n          " (span (|@| (class "keyword") (id "F:434147")) "goto") " " (span (|@| (class "constant") (id "F:434152")) "force_start") ";\n        }\n\n" (span (|@| (class "preprocessor") (id "F:434175")) "#if") " GLYPH_DEBUG\n      debug_method_add (w, " (span (|@| (class "string") (id "F:434218")) "\"same window start\"") ");\n" (span (|@| (class "preprocessor") (id "F:434240")) "#endif") "\n\n      " (span (|@| (class "comment-delimiter") (id "F:434254")) "/* ") (span (|@| (class "comment") (id "F:434257")) "Try to redisplay starting at same place as before.\n         If point has not moved off frame, accept the results.  ") (span (|@| (class "comment-delimiter") (id "F:434372")) "*/") "\n      " (span (|@| (class "keyword") (id "F:434381")) "if") " (" (span (|@| (class "negation-char") (id "F:434385")) "!") "current_matrix_up_to_date_p\n          " (span (|@| (class "comment-delimiter") (id "F:434417")) "/* ") (span (|@| (class "comment") (id "F:434420")) "Don't use try_window_reusing_current_matrix in this case\n             because a window scroll function can have changed the\n             buffer.  ") (span (|@| (class "comment-delimiter") (id "F:434552")) "*/") "\n          || " (span (|@| (class "negation-char") (id "F:434561")) "!") "NILP (Vwindow_scroll_functions)\n          || MINI_WINDOW_P (w)\n          || " (span (|@| (class "negation-char") (id "F:434624")) "!") "(used_current_matrix_p\n               = try_window_reusing_current_matrix (w)))\n        {\n          IF_DEBUG (debug_method_add (w, " (span (|@| (class "string") (id "F:434735")) "\"1\"") "));\n          " (span (|@| (class "keyword") (id "F:434745")) "if") " (try_window (window, startp, TRY_WINDOW_CHECK_MARGINS) < 0)\n            " (span (|@| (class "comment-delimiter") (id "F:434813")) "/* ") (span (|@| (class "comment") (id "F:434816")) "-1 means we need to scroll.\n               0 means we need new matrices, but fonts_changed_p\n               is set in that case, so we will detect it below.  ") (span (|@| (class "comment-delimiter") (id "F:434960")) "*/") "\n            " (span (|@| (class "keyword") (id "F:434968")) "goto") " " (span (|@| (class "constant") (id "F:434973")) "try_to_scroll") ";\n        }\n\n      " (span (|@| (class "keyword") (id "F:434998")) "if") " (fonts_changed_p)\n        " (span (|@| (class "keyword") (id "F:435020")) "goto") " " (span (|@| (class "constant") (id "F:435025")) "need_larger_matrices") ";\n\n      " (span (|@| (class "keyword") (id "F:435054")) "if") " (w->cursor.vpos >= 0)\n        {\n          " (span (|@| (class "keyword") (id "F:435085")) "if") " (" (span (|@| (class "negation-char") (id "F:435089")) "!") "just_this_one_p\n              || current_buffer->clip_changed\n              || BEG_UNCHANGED < CHARPOS (startp))\n            " (span (|@| (class "comment-delimiter") (id "F:435194")) "/* ") (span (|@| (class "comment") (id "F:435197")) "Forget any recorded base line for line number display.  ") (span (|@| (class "comment-delimiter") (id "F:435253")) "*/") "\n            w->base_line_number = Qnil;\n\n          " (span (|@| (class "keyword") (id "F:435293")) "if") " (" (span (|@| (class "negation-char") (id "F:435297")) "!") "cursor_row_fully_visible_p (w, 1, 0))\n            {\n              clear_glyph_matrix (w->desired_matrix);\n              last_line_misfit = 1;\n            }\n            " (span (|@| (class "comment-delimiter") (id "F:435431")) "/* ") (span (|@| (class "comment") (id "F:435434")) "Drop through and scroll.  ") (span (|@| (class "comment-delimiter") (id "F:435460")) "*/") "\n          " (span (|@| (class "keyword") (id "F:435466")) "else") "\n            " (span (|@| (class "keyword") (id "F:435476")) "goto") " " (span (|@| (class "constant") (id "F:435481")) "done") ";\n        }\n      " (span (|@| (class "keyword") (id "F:435496")) "else") "\n        clear_glyph_matrix (w->desired_matrix);\n    }\n\n " (span (|@| (class "constant") (id "F:435550")) "try_to_scroll") ":\n\n  w->last_modified = make_number (0);\n  w->last_overlay_modified = make_number (0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:435653")) "/* ") (span (|@| (class "comment") (id "F:435656")) "Redisplay the mode line.  Select the buffer properly for that.  ") (span (|@| (class "comment-delimiter") (id "F:435720")) "*/") "\n  " (span (|@| (class "keyword") (id "F:435725")) "if") " (" (span (|@| (class "negation-char") (id "F:435729")) "!") "update_mode_line)\n    {\n      update_mode_line = 1;\n      w->update_mode_line = Qt;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:435823")) "/* ") (span (|@| (class "comment") (id "F:435826")) "Try to scroll by specified few lines.  ") (span (|@| (class "comment-delimiter") (id "F:435865")) "*/") "\n  " (span (|@| (class "keyword") (id "F:435870")) "if") " ((scroll_conservatively\n       || scroll_step\n       || temp_scroll_step\n       || NUMBERP (current_buffer->scroll_up_aggressively)\n       || NUMBERP (current_buffer->scroll_down_aggressively))\n      && " (span (|@| (class "negation-char") (id "F:436076")) "!") "current_buffer->clip_changed\n      && CHARPOS (startp) >= BEGV\n      && CHARPOS (startp) <= ZV)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:436185")) "/* ") (span (|@| (class "comment") (id "F:436188")) "The function returns -1 if new fonts were loaded, 1 if\n         successful, 0 if not successful.  ") (span (|@| (class "comment-delimiter") (id "F:436279")) "*/") "\n      " (span (|@| (class "type") (id "F:436288")) "int") " " (span (|@| (class "variable-name") (id "F:436292")) "rc") " = try_scrolling (window, just_this_one_p,\n                              scroll_conservatively,\n                              scroll_step,\n                              temp_scroll_step, last_line_misfit);\n      " (span (|@| (class "keyword") (id "F:436443")) "switch") " (rc)\n        {\n        " (span (|@| (class "keyword") (id "F:436459")) "case") " SCROLLING_SUCCESS:\n          " (span (|@| (class "keyword") (id "F:436486")) "goto") " " (span (|@| (class "constant") (id "F:436491")) "done") ";\n\n        " (span (|@| (class "keyword") (id "F:436499")) "case") " SCROLLING_NEED_LARGER_MATRICES:\n          " (span (|@| (class "keyword") (id "F:436539")) "goto") " " (span (|@| (class "constant") (id "F:436544")) "need_larger_matrices") ";\n\n        " (span (|@| (class "keyword") (id "F:436568")) "case") " SCROLLING_FAILED:\n          " (span (|@| (class "keyword") (id "F:436594")) "break") ";\n\n        " (span (|@| (class "keyword") (id "F:436603")) "default") ":\n          abort ();\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:436637")) "/* ") (span (|@| (class "comment") (id "F:436640")) "Finally, just choose place to start which centers point ") (span (|@| (class "comment-delimiter") (id "F:436696")) "*/") "\n\n " (span (|@| (class "constant") (id "F:436701")) "recenter") ":\n  " (span (|@| (class "keyword") (id "F:436713")) "if") " (centering_position < 0)\n    centering_position = window_box_height (w) / 2;\n\n" (span (|@| (class "preprocessor") (id "F:436794")) "#if") " GLYPH_DEBUG\n  debug_method_add (w, " (span (|@| (class "string") (id "F:436833")) "\"recenter\"") ");\n" (span (|@| (class "preprocessor") (id "F:436846")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:436856")) "/* ") (span (|@| (class "comment") (id "F:436859")) "w->vscroll = 0; ") (span (|@| (class "comment-delimiter") (id "F:436875")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:436881")) "/* ") (span (|@| (class "comment") (id "F:436884")) "Forget any previously recorded base line for line number display.  ") (span (|@| (class "comment-delimiter") (id "F:436951")) "*/") "\n  " (span (|@| (class "keyword") (id "F:436956")) "if") " (" (span (|@| (class "negation-char") (id "F:436960")) "!") "buffer_unchanged_p)\n    w->base_line_number = Qnil;\n\n  " (span (|@| (class "comment-delimiter") (id "F:437016")) "/* ") (span (|@| (class "comment") (id "F:437019")) "Move backward half the height of the window.  ") (span (|@| (class "comment-delimiter") (id "F:437065")) "*/") "\n  init_iterator (&it, w, PT, PT_BYTE, " (span (|@| (class "constant") (id "F:437106")) "NULL") ", DEFAULT_FACE_ID);\n  it.current_y = it.last_visible_y;\n  move_it_vertically_backward (&it, centering_position);\n  xassert (IT_CHARPOS (it) >= BEGV);\n\n  " (span (|@| (class "comment-delimiter") (id "F:437263")) "/* ") (span (|@| (class "comment") (id "F:437266")) "The function move_it_vertically_backward may move over more\n     than the specified y-distance.  If it->w is small, e.g. a\n     mini-buffer window, we may end up in front of the window's\n     display area.  Start displaying at the start of the line\n     containing PT in this case.  ") (span (|@| (class "comment-delimiter") (id "F:437549")) "*/") "\n  " (span (|@| (class "keyword") (id "F:437554")) "if") " (it.current_y <= 0)\n    {\n      init_iterator (&it, w, PT, PT_BYTE, " (span (|@| (class "constant") (id "F:437625")) "NULL") ", DEFAULT_FACE_ID);\n      move_it_vertically_backward (&it, 0);\n      it.current_y = 0;\n    }\n\n  it.current_x = it.hpos = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:437757")) "/* ") (span (|@| (class "comment") (id "F:437760")) "Set startp here explicitly in case that helps avoid an infinite loop\n     in case the window-scroll-functions functions get errors.  ") (span (|@| (class "comment-delimiter") (id "F:437893")) "*/") "\n  set_marker_both (w->start, Qnil, IT_CHARPOS (it), IT_BYTEPOS (it));\n\n  " (span (|@| (class "comment-delimiter") (id "F:437969")) "/* ") (span (|@| (class "comment") (id "F:437972")) "Run scroll hooks.  ") (span (|@| (class "comment-delimiter") (id "F:437991")) "*/") "\n  startp = run_window_scroll_functions (window, it.current.pos);\n\n  " (span (|@| (class "comment-delimiter") (id "F:438062")) "/* ") (span (|@| (class "comment") (id "F:438065")) "Redisplay the window.  ") (span (|@| (class "comment-delimiter") (id "F:438088")) "*/") "\n  " (span (|@| (class "keyword") (id "F:438093")) "if") " (" (span (|@| (class "negation-char") (id "F:438097")) "!") "current_matrix_up_to_date_p\n      || windows_or_buffers_changed\n      || cursor_type_changed\n      " (span (|@| (class "comment-delimiter") (id "F:438197")) "/* ") (span (|@| (class "comment") (id "F:438200")) "Don't use try_window_reusing_current_matrix in this case\n         because it can have changed the buffer.  ") (span (|@| (class "comment-delimiter") (id "F:438300")) "*/") "\n      || " (span (|@| (class "negation-char") (id "F:438312")) "!") "NILP (Vwindow_scroll_functions)\n      || " (span (|@| (class "negation-char") (id "F:438354")) "!") "just_this_one_p\n      || MINI_WINDOW_P (w)\n      || " (span (|@| (class "negation-char") (id "F:438407")) "!") "(used_current_matrix_p\n           = try_window_reusing_current_matrix (w)))\n    try_window (window, startp, 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:438516")) "/* ") (span (|@| (class "comment") (id "F:438519")) "If new fonts have been loaded (due to fontsets), give up.  We\n     have to start a new redisplay since we need to re-adjust glyph\n     matrices.  ") (span (|@| (class "comment-delimiter") (id "F:438665")) "*/") "\n  " (span (|@| (class "keyword") (id "F:438670")) "if") " (fonts_changed_p)\n    " (span (|@| (class "keyword") (id "F:438695")) "goto") " " (span (|@| (class "constant") (id "F:438700")) "need_larger_matrices") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:438725")) "/* ") (span (|@| (class "comment") (id "F:438728")) "If cursor did not appear assume that the middle of the window is\n     in the first line of the window.  Do it again with the next line.\n     (Imagine a window of height 100, displaying two lines of height\n     60.  Moving back 50 from it->last_visible_y will end in the first\n     line.)  ") (span (|@| (class "comment-delimiter") (id "F:439017")) "*/") "\n  " (span (|@| (class "keyword") (id "F:439022")) "if") " (w->cursor.vpos < 0)\n    {\n      " (span (|@| (class "keyword") (id "F:439058")) "if") " (" (span (|@| (class "negation-char") (id "F:439062")) "!") "NILP (w->window_end_valid)\n          && PT >= Z - XFASTINT (w->window_end_pos))\n        {\n          clear_glyph_matrix (w->desired_matrix);\n          move_it_by_lines (&it, 1, 0);\n          try_window (window, it.current.pos, 0);\n        }\n      " (span (|@| (class "keyword") (id "F:439267")) "else") " " (span (|@| (class "keyword") (id "F:439272")) "if") " (PT < IT_CHARPOS (it))\n        {\n          clear_glyph_matrix (w->desired_matrix);\n          move_it_by_lines (&it, -1, 0);\n          try_window (window, it.current.pos, 0);\n        }\n      " (span (|@| (class "keyword") (id "F:439430")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:439441")) "/* ") (span (|@| (class "comment") (id "F:439444")) "Not much we can do about it.  ") (span (|@| (class "comment-delimiter") (id "F:439474")) "*/") "\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:439489")) "/* ") (span (|@| (class "comment") (id "F:439492")) "Consider the following case: Window starts at BEGV, there is\n     invisible, intangible text at BEGV, so that display starts at\n     some point START > BEGV.  It can happen that we are called with\n     PT somewhere between BEGV and START.  Try to handle that case.  ") (span (|@| (class "comment-delimiter") (id "F:439758")) "*/") "\n  " (span (|@| (class "keyword") (id "F:439763")) "if") " (w->cursor.vpos < 0)\n    {\n      " (span (|@| (class "keyword") (id "F:439799")) "struct") " " (span (|@| (class "type") (id "F:439806")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:439817")) "row") " = w->current_matrix->rows;\n      " (span (|@| (class "keyword") (id "F:439854")) "if") " (row->mode_line_p)\n        ++row;\n      set_cursor_from_row (w, row, w->current_matrix, 0, 0, 0, 0);\n    }\n\n  " (span (|@| (class "keyword") (id "F:439960")) "if") " (" (span (|@| (class "negation-char") (id "F:439964")) "!") "cursor_row_fully_visible_p (w, 0, 0))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:440015")) "/* ") (span (|@| (class "comment") (id "F:440018")) "If vscroll is enabled, disable it and try again.  ") (span (|@| (class "comment-delimiter") (id "F:440068")) "*/") "\n      " (span (|@| (class "keyword") (id "F:440077")) "if") " (w->vscroll)\n        {\n          w->vscroll = 0;\n          clear_glyph_matrix (w->desired_matrix);\n          " (span (|@| (class "keyword") (id "F:440161")) "goto") " " (span (|@| (class "constant") (id "F:440166")) "recenter") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:440186")) "/* ") (span (|@| (class "comment") (id "F:440189")) "If centering point failed to make the whole line visible,\n         put point at the top instead.  That has to make the whole line\n         visible, if it can be done.  ") (span (|@| (class "comment-delimiter") (id "F:440343")) "*/") "\n      " (span (|@| (class "keyword") (id "F:440352")) "if") " (centering_position == 0)\n        " (span (|@| (class "keyword") (id "F:440382")) "goto") " " (span (|@| (class "constant") (id "F:440387")) "done") ";\n\n      clear_glyph_matrix (w->desired_matrix);\n      centering_position = 0;\n      " (span (|@| (class "keyword") (id "F:440476")) "goto") " " (span (|@| (class "constant") (id "F:440481")) "recenter") ";\n    }\n\n " (span (|@| (class "constant") (id "F:440499")) "done") ":\n\n  SET_TEXT_POS_FROM_MARKER (startp, w->start);\n  w->start_at_line_beg = ((CHARPOS (startp) == BEGV\n                           || FETCH_BYTE (BYTEPOS (startp) - 1) == " (span (|@| (class "string") (id "F:440651")) "'\\n'") ")\n                          ? Qt : Qnil);\n\n  " (span (|@| (class "comment-delimiter") (id "F:440679")) "/* ") (span (|@| (class "comment") (id "F:440682")) "Display the mode line, if we must.  ") (span (|@| (class "comment-delimiter") (id "F:440718")) "*/") "\n  " (span (|@| (class "keyword") (id "F:440723")) "if") " ((update_mode_line\n       " (span (|@| (class "comment-delimiter") (id "F:440752")) "/* ") (span (|@| (class "comment") (id "F:440755")) "If window not full width, must redo its mode line\n          if (a) the window to its side is being redone and\n          (b) we do a frame-based redisplay.  This is a consequence\n          of how inverted lines are drawn in frame-based redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:440981")) "*/") "\n       || (" (span (|@| (class "negation-char") (id "F:440995")) "!") "just_this_one_p\n           && " (span (|@| (class "negation-char") (id "F:441019")) "!") "FRAME_WINDOW_P (f)\n           && " (span (|@| (class "negation-char") (id "F:441046")) "!") "WINDOW_FULL_WIDTH_P (w))\n       " (span (|@| (class "comment-delimiter") (id "F:441079")) "/* ") (span (|@| (class "comment") (id "F:441082")) "Line number to display.  ") (span (|@| (class "comment-delimiter") (id "F:441107")) "*/") "\n       || INTEGERP (w->base_line_pos)\n       " (span (|@| (class "comment-delimiter") (id "F:441155")) "/* ") (span (|@| (class "comment") (id "F:441158")) "Column number is displayed and different from the one displayed.  ") (span (|@| (class "comment-delimiter") (id "F:441224")) "*/") "\n       || (" (span (|@| (class "negation-char") (id "F:441238")) "!") "NILP (w->column_number_displayed)\n           && (XFASTINT (w->column_number_displayed)\n               != (" (span (|@| (class "type") (id "F:441338")) "int") ") current_column ()))) " (span (|@| (class "comment-delimiter") (id "F:441364")) "/* ") (span (|@| (class "comment") (id "F:441367")) "iftc ") (span (|@| (class "comment-delimiter") (id "F:441372")) "*/") "\n       " (span (|@| (class "comment-delimiter") (id "F:441382")) "/* ") (span (|@| (class "comment") (id "F:441385")) "This means that the window has a mode line.  ") (span (|@| (class "comment-delimiter") (id "F:441430")) "*/") "\n       && (WINDOW_WANTS_MODELINE_P (w)\n           || WINDOW_WANTS_HEADER_LINE_P (w)))\n    {\n      display_mode_lines (w);\n\n      " (span (|@| (class "comment-delimiter") (id "F:441555")) "/* ") (span (|@| (class "comment") (id "F:441558")) "If mode line height has changed, arrange for a thorough\n         immediate redisplay using the correct mode line height.  ") (span (|@| (class "comment-delimiter") (id "F:441673")) "*/") "\n      " (span (|@| (class "keyword") (id "F:441682")) "if") " (WINDOW_WANTS_MODELINE_P (w)\n          && CURRENT_MODE_LINE_HEIGHT (w) != DESIRED_MODE_LINE_HEIGHT (w))\n        {\n          fonts_changed_p = 1;\n          MATRIX_MODE_LINE_ROW (w->current_matrix)->height\n            = DESIRED_MODE_LINE_HEIGHT (w);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:441908")) "/* ") (span (|@| (class "comment") (id "F:441911")) "If header line height has changed, arrange for a thorough\n         immediate redisplay using the correct header line height.  ") (span (|@| (class "comment-delimiter") (id "F:442030")) "*/") "\n      " (span (|@| (class "keyword") (id "F:442039")) "if") " (WINDOW_WANTS_HEADER_LINE_P (w)\n          && CURRENT_HEADER_LINE_HEIGHT (w) != DESIRED_HEADER_LINE_HEIGHT (w))\n        {\n          fonts_changed_p = 1;\n          MATRIX_HEADER_LINE_ROW (w->current_matrix)->height\n            = DESIRED_HEADER_LINE_HEIGHT (w);\n        }\n\n      " (span (|@| (class "keyword") (id "F:442276")) "if") " (fonts_changed_p)\n        " (span (|@| (class "keyword") (id "F:442298")) "goto") " " (span (|@| (class "constant") (id "F:442303")) "need_larger_matrices") ";\n    }\n\n  " (span (|@| (class "keyword") (id "F:442334")) "if") " (" (span (|@| (class "negation-char") (id "F:442338")) "!") "line_number_displayed\n      && " (span (|@| (class "negation-char") (id "F:442370")) "!") "BUFFERP (w->base_line_pos))\n    {\n      w->base_line_pos = Qnil;\n      w->base_line_number = Qnil;\n    }\n\n " (span (|@| (class "constant") (id "F:442478")) "finish_menu_bars") ":\n\n  " (span (|@| (class "comment-delimiter") (id "F:442499")) "/* ") (span (|@| (class "comment") (id "F:442502")) "When we reach a frame's selected window, redo the frame's menu bar.  ") (span (|@| (class "comment-delimiter") (id "F:442571")) "*/") "\n  " (span (|@| (class "keyword") (id "F:442576")) "if") " (update_mode_line\n      && EQ (FRAME_SELECTED_WINDOW (f), window))\n    {\n      " (span (|@| (class "type") (id "F:442658")) "int") " " (span (|@| (class "variable-name") (id "F:442662")) "redisplay_menu_p") " = 0;\n      " (span (|@| (class "type") (id "F:442690")) "int") " " (span (|@| (class "variable-name") (id "F:442694")) "redisplay_tool_bar_p") " = 0;\n\n      " (span (|@| (class "keyword") (id "F:442727")) "if") " (FRAME_WINDOW_P (f))\n        {\n" (span (|@| (class "preprocessor") (id "F:442754")) "#if") " " (span (|@| (class "preprocessor") (id "F:442758")) "defined") " (USE_X_TOOLKIT) || " (span (|@| (class "preprocessor") (id "F:442785")) "defined") " (HAVE_NTGUI) \\\n    || " (span (|@| (class "preprocessor") (id "F:442815")) "defined") " (HAVE_NS) || " (span (|@| (class "preprocessor") (id "F:442836")) "defined") " (USE_GTK)\n          redisplay_menu_p = FRAME_EXTERNAL_MENU_BAR (f);\n" (span (|@| (class "preprocessor") (id "F:442905")) "#else") "\n          redisplay_menu_p = FRAME_MENU_BAR_LINES (f) > 0;\n" (span (|@| (class "preprocessor") (id "F:442963")) "#endif") "\n        }\n      " (span (|@| (class "keyword") (id "F:442979")) "else") "\n        redisplay_menu_p = FRAME_MENU_BAR_LINES (f) > 0;\n\n      " (span (|@| (class "keyword") (id "F:443048")) "if") " (redisplay_menu_p)\n        display_menu_bar (w);\n\n" (span (|@| (class "preprocessor") (id "F:443101")) "#ifdef") " HAVE_WINDOW_SYSTEM\n      " (span (|@| (class "keyword") (id "F:443133")) "if") " (FRAME_WINDOW_P (f))\n        {\n" (span (|@| (class "preprocessor") (id "F:443167")) "#if") " " (span (|@| (class "preprocessor") (id "F:443171")) "defined") " (USE_GTK) || " (span (|@| (class "preprocessor") (id "F:443192")) "defined") " (HAVE_NS)\n          redisplay_tool_bar_p = FRAME_EXTERNAL_TOOL_BAR (f);\n" (span (|@| (class "preprocessor") (id "F:443272")) "#else") "\n          redisplay_tool_bar_p = WINDOWP (f->tool_bar_window)\n            && (FRAME_TOOL_BAR_LINES (f) > 0\n                || " (span (|@| (class "negation-char") (id "F:443404")) "!") "NILP (Vauto_resize_tool_bars));\n" (span (|@| (class "preprocessor") (id "F:443437")) "#endif") "\n\n          " (span (|@| (class "keyword") (id "F:443455")) "if") " (redisplay_tool_bar_p && redisplay_tool_bar (f))\n            {\n              " (span (|@| (class "keyword") (id "F:443521")) "extern") " " (span (|@| (class "type") (id "F:443528")) "int") " " (span (|@| (class "variable-name") (id "F:443532")) "ignore_mouse_drag_p") ";\n              ignore_mouse_drag_p = 1;\n            }\n        }\n" (span (|@| (class "preprocessor") (id "F:443602")) "#endif") "\n    }\n\n" (span (|@| (class "preprocessor") (id "F:443616")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "keyword") (id "F:443644")) "if") " (FRAME_WINDOW_P (f)\n      && update_window_fringes (w, (just_this_one_p\n                                    || (" (span (|@| (class "negation-char") (id "F:443731")) "!") "used_current_matrix_p && " (span (|@| (class "negation-char") (id "F:443757")) "!") "overlay_arrow_seen)\n                                    || w->pseudo_window_p)))\n    {\n      update_begin (f);\n      BLOCK_INPUT;\n      " (span (|@| (class "keyword") (id "F:443866")) "if") " (draw_window_fringes (w, 1))\n        x_draw_vertical_border (w);\n      UNBLOCK_INPUT;\n      update_end (f);\n    }\n" (span (|@| (class "preprocessor") (id "F:443976")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:443983")) "/* ") (span (|@| (class "comment") (id "F:443986")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:444005")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:444011")) "/* ") (span (|@| (class "comment") (id "F:444014")) "We go to this label, with fonts_changed_p nonzero,\n     if it is necessary to try again using larger glyph matrices.\n     We have to redeem the scroll bar even in this case,\n     because the loop in redisplay_internal expects that.  ") (span (|@| (class "comment-delimiter") (id "F:444247")) "*/") "\n " (span (|@| (class "constant") (id "F:444251")) "need_larger_matrices") ":\n  ;\n " (span (|@| (class "constant") (id "F:444278")) "finish_scroll_bars") ":\n\n  " (span (|@| (class "keyword") (id "F:444301")) "if") " (WINDOW_HAS_VERTICAL_SCROLL_BAR (w))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:444353")) "/* ") (span (|@| (class "comment") (id "F:444356")) "Set the thumb's position and size.  ") (span (|@| (class "comment-delimiter") (id "F:444392")) "*/") "\n      set_vertical_scroll_bar (w);\n\n      " (span (|@| (class "comment-delimiter") (id "F:444437")) "/* ") (span (|@| (class "comment") (id "F:444440")) "Note that we actually used the scroll bar attached to this\n         window, so it shouldn't be deleted at the end of redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:444562")) "*/") "\n      " (span (|@| (class "keyword") (id "F:444571")) "if") " (FRAME_TERMINAL (f)->redeem_scroll_bar_hook)\n        (*FRAME_TERMINAL (f)->redeem_scroll_bar_hook) (w);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:444687")) "/* ") (span (|@| (class "comment") (id "F:444690")) "Restore current_buffer and value of point in it.  The window\n     update may have changed the buffer, so first make sure `opoint'\n     is still valid (Bug#6177).  ") (span (|@| (class "comment-delimiter") (id "F:444853")) "*/") "\n  " (span (|@| (class "keyword") (id "F:444858")) "if") " (CHARPOS (opoint) < BEGV)\n    TEMP_SET_PT_BOTH (BEGV, BEGV_BYTE);\n  " (span (|@| (class "keyword") (id "F:444929")) "else") " " (span (|@| (class "keyword") (id "F:444934")) "if") " (CHARPOS (opoint) > ZV)\n    TEMP_SET_PT_BOTH (Z, Z_BYTE);\n  " (span (|@| (class "keyword") (id "F:444997")) "else") "\n    TEMP_SET_PT_BOTH (CHARPOS (opoint), BYTEPOS (opoint));\n\n  set_buffer_internal_1 (old);\n  " (span (|@| (class "comment-delimiter") (id "F:445095")) "/* ") (span (|@| (class "comment") (id "F:445098")) "Avoid an abort in TEMP_SET_PT_BOTH if the buffer has become\n     shorter.  This can be caused by log truncation in *Messages*. ") (span (|@| (class "comment-delimiter") (id "F:445225")) "*/") "\n  " (span (|@| (class "keyword") (id "F:445230")) "if") " (CHARPOS (lpoint) <= ZV)\n    TEMP_SET_PT_BOTH (CHARPOS (lpoint), BYTEPOS (lpoint));\n\n  unbind_to (count, Qnil);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:445349")) "/* ") (span (|@| (class "comment") (id "F:445352")) "Build the complete desired matrix of WINDOW with a window start\n   buffer position POS.\n\n   Value is 1 if successful.  It is zero if fonts were loaded during\n   redisplay which makes re-adjusting glyph matrices necessary, and -1\n   if point would appear in the scroll margins.\n   (We check the former only if TRY_WINDOW_IGNORE_FONTS_CHANGE is\n   unset in FLAGS, and the latter only if TRY_WINDOW_CHECK_MARGINS is\n   set in FLAGS.)  ") (span (|@| (class "comment-delimiter") (id "F:445784")) "*/") "\n\n" (span (|@| (class "type") (id "F:445788")) "int") "\n" (span (|@| (class "function-name") (id "F:445792")) "try_window") " (" (span (|@| (class "type") (id "F:445804")) "window") ", pos, flags)\n     " (span (|@| (class "type") (id "F:445829")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:445841")) "window") ";\n     " (span (|@| (class "keyword") (id "F:445854")) "struct") " " (span (|@| (class "type") (id "F:445861")) "text_pos") " " (span (|@| (class "variable-name") (id "F:445870")) "pos") ";\n     " (span (|@| (class "type") (id "F:445880")) "int") " " (span (|@| (class "variable-name") (id "F:445884")) "flags") ";\n{\n  " (span (|@| (class "keyword") (id "F:445895")) "struct") " " (span (|@| (class "type") (id "F:445902")) "window") " *" (span (|@| (class "variable-name") (id "F:445910")) "w") " = XWINDOW (window);\n  " (span (|@| (class "keyword") (id "F:445934")) "struct") " " (span (|@| (class "type") (id "F:445941")) "it") " " (span (|@| (class "variable-name") (id "F:445944")) "it") ";\n  " (span (|@| (class "keyword") (id "F:445950")) "struct") " " (span (|@| (class "type") (id "F:445957")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:445968")) "last_text_row") " = " (span (|@| (class "constant") (id "F:445984")) "NULL") ";\n  " (span (|@| (class "keyword") (id "F:445992")) "struct") " " (span (|@| (class "type") (id "F:445999")) "frame") " *" (span (|@| (class "variable-name") (id "F:446006")) "f") " = XFRAME (w->frame);\n\n  " (span (|@| (class "comment-delimiter") (id "F:446032")) "/* ") (span (|@| (class "comment") (id "F:446035")) "Make POS the new window start.  ") (span (|@| (class "comment-delimiter") (id "F:446067")) "*/") "\n  set_marker_both (w->start, Qnil, CHARPOS (pos), BYTEPOS (pos));\n\n  " (span (|@| (class "comment-delimiter") (id "F:446139")) "/* ") (span (|@| (class "comment") (id "F:446142")) "Mark cursor position as unknown.  No overlay arrow seen.  ") (span (|@| (class "comment-delimiter") (id "F:446200")) "*/") "\n  w->cursor.vpos = -1;\n  overlay_arrow_seen = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:446255")) "/* ") (span (|@| (class "comment") (id "F:446258")) "Initialize iterator and info to start at POS.  ") (span (|@| (class "comment-delimiter") (id "F:446305")) "*/") "\n  start_display (&it, w, pos);\n\n  " (span (|@| (class "comment-delimiter") (id "F:446342")) "/* ") (span (|@| (class "comment") (id "F:446345")) "Display all lines of W.  ") (span (|@| (class "comment-delimiter") (id "F:446370")) "*/") "\n  " (span (|@| (class "keyword") (id "F:446375")) "while") " (it.current_y < it.last_visible_y)\n    {\n      " (span (|@| (class "keyword") (id "F:446428")) "if") " (display_line (&it))\n        last_text_row = it.glyph_row - 1;\n      " (span (|@| (class "keyword") (id "F:446493")) "if") " (fonts_changed_p && " (span (|@| (class "negation-char") (id "F:446516")) "!") "(flags & TRY_WINDOW_IGNORE_FONTS_CHANGE))\n        " (span (|@| (class "keyword") (id "F:446560")) "return") " 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:446579")) "/* ") (span (|@| (class "comment") (id "F:446582")) "Don't let the cursor end in the scroll margins.  ") (span (|@| (class "comment-delimiter") (id "F:446631")) "*/") "\n  " (span (|@| (class "keyword") (id "F:446636")) "if") " ((flags & TRY_WINDOW_CHECK_MARGINS)\n      && " (span (|@| (class "negation-char") (id "F:446684")) "!") "MINI_WINDOW_P (w))\n    {\n      " (span (|@| (class "type") (id "F:446716")) "int") " " (span (|@| (class "variable-name") (id "F:446720")) "this_scroll_margin") ";\n\n      " (span (|@| (class "keyword") (id "F:446747")) "if") " (scroll_margin > 0)\n        {\n          this_scroll_margin = min (scroll_margin, WINDOW_TOTAL_LINES (w) / 4);\n          this_scroll_margin *= FRAME_LINE_HEIGHT (f);\n        }\n      " (span (|@| (class "keyword") (id "F:446903")) "else") "\n        this_scroll_margin = 0;\n\n      " (span (|@| (class "keyword") (id "F:446940")) "if") " ((w->cursor.y >= 0     " (span (|@| (class "comment-delimiter") (id "F:446962")) "/* ") (span (|@| (class "comment") (id "F:446965")) "not vscrolled ") (span (|@| (class "comment-delimiter") (id "F:446979")) "*/") "\n           && w->cursor.y < this_scroll_margin\n           && CHARPOS (pos) > BEGV\n           && IT_CHARPOS (it) < ZV)\n          " (span (|@| (class "comment-delimiter") (id "F:447082")) "/* ") (span (|@| (class "comment") (id "F:447085")) "rms: considering make_cursor_line_fully_visible_p here\n             seems to give wrong results.  We don't want to recenter\n             when the last line is partly visible, we want to allow\n             that case to be handled in the usual way.  ") (span (|@| (class "comment-delimiter") (id "F:447312")) "*/") "\n          || w->cursor.y > it.last_visible_y - this_scroll_margin - 1)\n        {\n          w->cursor.vpos = -1;\n          clear_glyph_matrix (w->desired_matrix);\n          " (span (|@| (class "keyword") (id "F:447452")) "return") " -1;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:447475")) "/* ") (span (|@| (class "comment") (id "F:447478")) "If bottom moved off end of frame, change mode line percentage.  ") (span (|@| (class "comment-delimiter") (id "F:447542")) "*/") "\n  " (span (|@| (class "keyword") (id "F:447547")) "if") " (XFASTINT (w->window_end_pos) <= 0\n      && Z != IT_CHARPOS (it))\n    w->update_mode_line = Qt;\n\n  " (span (|@| (class "comment-delimiter") (id "F:447649")) "/* ") (span (|@| (class "comment") (id "F:447652")) "Set window_end_pos to the offset of the last character displayed\n     on the window from the end of current_buffer.  Set\n     window_end_vpos to its row number.  ") (span (|@| (class "comment-delimiter") (id "F:447814")) "*/") "\n  " (span (|@| (class "keyword") (id "F:447819")) "if") " (last_text_row)\n    {\n      xassert (MATRIX_ROW_DISPLAYS_TEXT_P (last_text_row));\n      w->window_end_bytepos\n        = Z_BYTE - MATRIX_ROW_END_BYTEPOS (last_text_row);\n      w->window_end_pos\n        = make_number (Z - MATRIX_ROW_END_CHARPOS (last_text_row));\n      w->window_end_vpos\n        = make_number (MATRIX_ROW_VPOS (last_text_row, w->desired_matrix));\n      xassert (MATRIX_ROW (w->desired_matrix, XFASTINT (w->window_end_vpos))\n               ->displays_text_p);\n    }\n  " (span (|@| (class "keyword") (id "F:448276")) "else") "\n    {\n      w->window_end_bytepos = Z_BYTE - ZV_BYTE;\n      w->window_end_pos = make_number (Z - ZV);\n      w->window_end_vpos = make_number (0);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:448436")) "/* ") (span (|@| (class "comment") (id "F:448439")) "But that is not valid info until redisplay finishes.  ") (span (|@| (class "comment-delimiter") (id "F:448493")) "*/") "\n  w->window_end_valid = Qnil;\n  " (span (|@| (class "keyword") (id "F:448528")) "return") " 1;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:448544")) "/************************************************************************") (span (|@| (class "comment") (id "F:448617")) "\n    Window redisplay reusing current matrix when buffer has not changed\n ***********************************************************************") (span (|@| (class "comment-delimiter") (id "F:448762")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:448766")) "/* ") (span (|@| (class "comment") (id "F:448769")) "Try redisplay of window W showing an unchanged buffer with a\n   different window start than the last time it was displayed by\n   reusing its current matrix.  Value is non-zero if successful.\n   W->start is the new window start.  ") (span (|@| (class "comment-delimiter") (id "F:448998")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:449002")) "static") " " (span (|@| (class "type") (id "F:449009")) "int") "\n" (span (|@| (class "function-name") (id "F:449013")) "try_window_reusing_current_matrix") " (w)\n     " (span (|@| (class "keyword") (id "F:449056")) "struct") " " (span (|@| (class "type") (id "F:449063")) "window") " *" (span (|@| (class "variable-name") (id "F:449071")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:449078")) "struct") " " (span (|@| (class "type") (id "F:449085")) "frame") " *" (span (|@| (class "variable-name") (id "F:449092")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "keyword") (id "F:449117")) "struct") " " (span (|@| (class "type") (id "F:449124")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:449135")) "row") ", *" (span (|@| (class "variable-name") (id "F:449141")) "bottom_row") ";\n  " (span (|@| (class "keyword") (id "F:449155")) "struct") " " (span (|@| (class "type") (id "F:449162")) "it") " " (span (|@| (class "variable-name") (id "F:449165")) "it") ";\n  " (span (|@| (class "keyword") (id "F:449171")) "struct") " " (span (|@| (class "type") (id "F:449178")) "run") " " (span (|@| (class "variable-name") (id "F:449182")) "run") ";\n  " (span (|@| (class "keyword") (id "F:449189")) "struct") " " (span (|@| (class "type") (id "F:449196")) "text_pos") " " (span (|@| (class "variable-name") (id "F:449205")) "start") ", " (span (|@| (class "variable-name") (id "F:449212")) "new_start") ";\n  " (span (|@| (class "type") (id "F:449225")) "int") " " (span (|@| (class "variable-name") (id "F:449229")) "nrows_scrolled") ", " (span (|@| (class "variable-name") (id "F:449245")) "i") ";\n  " (span (|@| (class "keyword") (id "F:449250")) "struct") " " (span (|@| (class "type") (id "F:449257")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:449268")) "last_text_row") ";\n  " (span (|@| (class "keyword") (id "F:449285")) "struct") " " (span (|@| (class "type") (id "F:449292")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:449303")) "last_reused_text_row") ";\n  " (span (|@| (class "keyword") (id "F:449327")) "struct") " " (span (|@| (class "type") (id "F:449334")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:449345")) "start_row") ";\n  " (span (|@| (class "type") (id "F:449358")) "int") " " (span (|@| (class "variable-name") (id "F:449362")) "start_vpos") ", " (span (|@| (class "variable-name") (id "F:449374")) "min_y") ", " (span (|@| (class "variable-name") (id "F:449381")) "max_y") ";\n\n" (span (|@| (class "preprocessor") (id "F:449389")) "#if") " GLYPH_DEBUG\n  " (span (|@| (class "keyword") (id "F:449407")) "if") " (inhibit_try_window_reusing)\n    " (span (|@| (class "keyword") (id "F:449443")) "return") " 0;\n" (span (|@| (class "preprocessor") (id "F:449453")) "#endif") "\n\n  " (span (|@| (class "keyword") (id "F:449463")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:449467")) "/* ") (span (|@| (class "comment") (id "F:449470")) "This function doesn't handle terminal frames.  ") (span (|@| (class "comment-delimiter") (id "F:449517")) "*/") "\n      " (span (|@| (class "negation-char") (id "F:449526")) "!") "FRAME_WINDOW_P (f)\n      " (span (|@| (class "comment-delimiter") (id "F:449552")) "/* ") (span (|@| (class "comment") (id "F:449555")) "Don't try to reuse the display if windows have been split\n         or such.  ") (span (|@| (class "comment-delimiter") (id "F:449625")) "*/") "\n      || windows_or_buffers_changed\n      || cursor_type_changed)\n    " (span (|@| (class "keyword") (id "F:449698")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:449711")) "/* ") (span (|@| (class "comment") (id "F:449714")) "Can't do this if region may have changed.  ") (span (|@| (class "comment-delimiter") (id "F:449757")) "*/") "\n  " (span (|@| (class "keyword") (id "F:449762")) "if") " ((" (span (|@| (class "negation-char") (id "F:449767")) "!") "NILP (Vtransient_mark_mode)\n       && " (span (|@| (class "negation-char") (id "F:449806")) "!") "NILP (current_buffer->mark_active))\n      || " (span (|@| (class "negation-char") (id "F:449852")) "!") "NILP (w->region_showing)\n      || " (span (|@| (class "negation-char") (id "F:449887")) "!") "NILP (Vshow_trailing_whitespace))\n    " (span (|@| (class "keyword") (id "F:449926")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:449939")) "/* ") (span (|@| (class "comment") (id "F:449942")) "If top-line visibility has changed, give up.  ") (span (|@| (class "comment-delimiter") (id "F:449988")) "*/") "\n  " (span (|@| (class "keyword") (id "F:449993")) "if") " (WINDOW_WANTS_HEADER_LINE_P (w)\n      != MATRIX_HEADER_LINE_ROW (w->current_matrix)->mode_line_p)\n    " (span (|@| (class "keyword") (id "F:450098")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:450111")) "/* ") (span (|@| (class "comment") (id "F:450114")) "Give up if old or new display is scrolled vertically.  We could\n     make this function handle this, but right now it doesn't.  ") (span (|@| (class "comment-delimiter") (id "F:450242")) "*/") "\n  start_row = MATRIX_FIRST_TEXT_ROW (w->current_matrix);\n  " (span (|@| (class "keyword") (id "F:450304")) "if") " (w->vscroll || MATRIX_ROW_PARTIALLY_VISIBLE_P (w, start_row))\n    " (span (|@| (class "keyword") (id "F:450373")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:450386")) "/* ") (span (|@| (class "comment") (id "F:450389")) "The variable new_start now holds the new window start.  The old\n     start `start' can be determined from the current matrix.  ") (span (|@| (class "comment-delimiter") (id "F:450516")) "*/") "\n  SET_TEXT_POS_FROM_MARKER (new_start, w->start);\n  start = start_row->minpos;\n  start_vpos = MATRIX_ROW_VPOS (start_row, w->current_matrix);\n\n  " (span (|@| (class "comment-delimiter") (id "F:450664")) "/* ") (span (|@| (class "comment") (id "F:450667")) "Clear the desired matrix for the display below.  ") (span (|@| (class "comment-delimiter") (id "F:450716")) "*/") "\n  clear_glyph_matrix (w->desired_matrix);\n\n  " (span (|@| (class "keyword") (id "F:450764")) "if") " (CHARPOS (new_start) <= CHARPOS (start))\n    {\n      " (span (|@| (class "type") (id "F:450820")) "int") " " (span (|@| (class "variable-name") (id "F:450824")) "first_row_y") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:450844")) "/* ") (span (|@| (class "comment") (id "F:450847")) "Don't use this method if the display starts with an ellipsis\n         displayed for invisible text.  It's not easy to handle that case\n         below, and it's certainly not worth the effort since this is\n         not a frequent case.  ") (span (|@| (class "comment-delimiter") (id "F:451062")) "*/") "\n      " (span (|@| (class "keyword") (id "F:451071")) "if") " (in_ellipses_for_invisible_text_p (&start_row->start, w))\n        " (span (|@| (class "keyword") (id "F:451133")) "return") " 0;\n\n      IF_DEBUG (debug_method_add (w, " (span (|@| (class "string") (id "F:451181")) "\"twu1\"") "));\n\n      " (span (|@| (class "comment-delimiter") (id "F:451198")) "/* ") (span (|@| (class "comment") (id "F:451201")) "Display up to a row that can be reused.  The variable\n         last_text_row is set to the last row displayed that displays\n         text.  Note that it.vpos == 0 if or if not there is a\n         header-line; it's not the same as the MATRIX_ROW_VPOS!  ") (span (|@| (class "comment-delimiter") (id "F:451439")) "*/") "\n      start_display (&it, w, new_start);\n      first_row_y = it.current_y;\n      w->cursor.vpos = -1;\n      last_text_row = last_reused_text_row = " (span (|@| (class "constant") (id "F:451589")) "NULL") ";\n\n      " (span (|@| (class "keyword") (id "F:451602")) "while") " (it.current_y < it.last_visible_y\n             && " (span (|@| (class "negation-char") (id "F:451651")) "!") "fonts_changed_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:451675")) "/* ") (span (|@| (class "comment") (id "F:451678")) "If we have reached into the characters in the START row,\n             that means the line boundaries have changed.  So we\n             can't start copying with the row START.  Maybe it will\n             work to start copying with the following row.  ") (span (|@| (class "comment-delimiter") (id "F:451907")) "*/") "\n          " (span (|@| (class "keyword") (id "F:451913")) "while") " (IT_CHARPOS (it) > CHARPOS (start))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:451969")) "/* ") (span (|@| (class "comment") (id "F:451972")) "Advance to the next row as the \"start\".  ") (span (|@| (class "comment-delimiter") (id "F:452013")) "*/") "\n              start_row++;\n              start = start_row->minpos;\n              " (span (|@| (class "comment-delimiter") (id "F:452077")) "/* ") (span (|@| (class "comment") (id "F:452080")) "If there are no more rows to try, or just one, give up.  ") (span (|@| (class "comment-delimiter") (id "F:452137")) "*/") "\n              " (span (|@| (class "keyword") (id "F:452147")) "if") " (start_row == MATRIX_MODE_LINE_ROW (w->current_matrix) - 1\n                  || w->vscroll || MATRIX_ROW_PARTIALLY_VISIBLE_P (w, start_row)\n                  || CHARPOS (start) == ZV)\n                {\n                  clear_glyph_matrix (w->desired_matrix);\n                  " (span (|@| (class "keyword") (id "F:452358")) "return") " 0;\n                }\n\n              start_vpos = MATRIX_ROW_VPOS (start_row, w->current_matrix);\n            }\n          " (span (|@| (class "comment-delimiter") (id "F:452451")) "/* ") (span (|@| (class "comment") (id "F:452454")) "If we have reached alignment,\n             we can copy the rest of the rows.  ") (span (|@| (class "comment-delimiter") (id "F:452525")) "*/") "\n          " (span (|@| (class "keyword") (id "F:452531")) "if") " (IT_CHARPOS (it) == CHARPOS (start))\n            " (span (|@| (class "keyword") (id "F:452576")) "break") ";\n\n          " (span (|@| (class "keyword") (id "F:452587")) "if") " (display_line (&it))\n            last_text_row = it.glyph_row - 1;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:452660")) "/* ") (span (|@| (class "comment") (id "F:452663")) "A value of current_y < last_visible_y means that we stopped\n         at the previous window start, which in turn means that we\n         have at least one reusable row.  ") (span (|@| (class "comment-delimiter") (id "F:452818")) "*/") "\n      " (span (|@| (class "keyword") (id "F:452827")) "if") " (it.current_y < it.last_visible_y)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:452871")) "/* ") (span (|@| (class "comment") (id "F:452874")) "IT.vpos always starts from 0; it counts text lines.  ") (span (|@| (class "comment-delimiter") (id "F:452927")) "*/") "\n          nrows_scrolled = it.vpos - (start_row - MATRIX_FIRST_TEXT_ROW (w->current_matrix));\n\n          " (span (|@| (class "comment-delimiter") (id "F:453021")) "/* ") (span (|@| (class "comment") (id "F:453024")) "Find PT if not already found in the lines displayed.  ") (span (|@| (class "comment-delimiter") (id "F:453078")) "*/") "\n          " (span (|@| (class "keyword") (id "F:453084")) "if") " (w->cursor.vpos < 0)\n            {\n              " (span (|@| (class "type") (id "F:453122")) "int") " " (span (|@| (class "variable-name") (id "F:453126")) "dy") " = it.current_y - start_row->y;\n\n              row = MATRIX_FIRST_TEXT_ROW (w->current_matrix);\n              row = row_containing_pos (w, PT, row, " (span (|@| (class "constant") (id "F:453262")) "NULL") ", dy);\n              " (span (|@| (class "keyword") (id "F:453280")) "if") " (row)\n                set_cursor_from_row (w, row, w->current_matrix, 0, 0,\n                                     dy, nrows_scrolled);\n              " (span (|@| (class "keyword") (id "F:453382")) "else") "\n                {\n                  clear_glyph_matrix (w->desired_matrix);\n                  " (span (|@| (class "keyword") (id "F:453439")) "return") " 0;\n                }\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:453464")) "/* ") (span (|@| (class "comment") (id "F:453467")) "Scroll the display.  Do it before the current matrix is\n             changed.  The problem here is that update has not yet\n             run, i.e. part of the current matrix is not up to date.\n             scroll_run_hook will clear the cursor, and use the\n             current matrix to get the height of the row the cursor is\n             in.  ") (span (|@| (class "comment-delimiter") (id "F:453777")) "*/") "\n          run.current_y = start_row->y;\n          run.desired_y = it.current_y;\n          run.height = it.last_visible_y - it.current_y;\n\n          " (span (|@| (class "keyword") (id "F:453900")) "if") " (run.height > 0 && run.current_y != run.desired_y)\n            {\n              update_begin (f);\n              FRAME_RIF (f)->update_window_begin_hook (w);\n              FRAME_RIF (f)->clear_window_mouse_face (w);\n              FRAME_RIF (f)->scroll_run_hook (w, &run);\n              FRAME_RIF (f)->update_window_end_hook (w, 0, 0);\n              update_end (f);\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:454228")) "/* ") (span (|@| (class "comment") (id "F:454231")) "Shift current matrix down by nrows_scrolled lines.  ") (span (|@| (class "comment-delimiter") (id "F:454283")) "*/") "\n          bottom_row = MATRIX_BOTTOM_TEXT_ROW (w->current_matrix, w);\n          rotate_matrix (w->current_matrix,\n                         start_vpos,\n                         MATRIX_ROW_VPOS (bottom_row, w->current_matrix),\n                         nrows_scrolled);\n\n          " (span (|@| (class "comment-delimiter") (id "F:454480")) "/* ") (span (|@| (class "comment") (id "F:454483")) "Disable lines that must be updated.  ") (span (|@| (class "comment-delimiter") (id "F:454520")) "*/") "\n          " (span (|@| (class "keyword") (id "F:454526")) "for") " (i = 0; i < nrows_scrolled; ++i)\n            (start_row + i)->enabled_p = 0;\n\n          " (span (|@| (class "comment-delimiter") (id "F:454604")) "/* ") (span (|@| (class "comment") (id "F:454607")) "Re-compute Y positions.  ") (span (|@| (class "comment-delimiter") (id "F:454632")) "*/") "\n          min_y = WINDOW_HEADER_LINE_HEIGHT (w);\n          max_y = it.last_visible_y;\n          " (span (|@| (class "keyword") (id "F:454710")) "for") " (row = start_row + nrows_scrolled;\n               row < bottom_row;\n               ++row)\n            {\n              row->y = it.current_y;\n              row->visible_height = row->height;\n\n              " (span (|@| (class "keyword") (id "F:454877")) "if") " (row->y < min_y)\n                row->visible_height -= min_y - row->y;\n              " (span (|@| (class "keyword") (id "F:454945")) "if") " (row->y + row->height > max_y)\n                row->visible_height -= row->y + row->height - max_y;\n              row->redraw_fringe_bitmaps_p = 1;\n\n              it.current_y += row->height;\n\n              " (span (|@| (class "keyword") (id "F:455120")) "if") " (MATRIX_ROW_DISPLAYS_TEXT_P (row))\n                last_reused_text_row = row;\n              " (span (|@| (class "keyword") (id "F:455195")) "if") " (MATRIX_ROW_BOTTOM_Y (row) >= it.last_visible_y)\n                " (span (|@| (class "keyword") (id "F:455249")) "break") ";\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:455267")) "/* ") (span (|@| (class "comment") (id "F:455270")) "Disable lines in the current matrix which are now\n             below the window.  ") (span (|@| (class "comment-delimiter") (id "F:455345")) "*/") "\n          " (span (|@| (class "keyword") (id "F:455351")) "for") " (++row; row < bottom_row; ++row)\n            row->enabled_p = row->mode_line_p = 0;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:455442")) "/* ") (span (|@| (class "comment") (id "F:455445")) "Update window_end_pos etc.; last_reused_text_row is the last\n         reused row from the current matrix containing text, if any.\n         The value of last_text_row is the last displayed line\n         containing text.  ") (span (|@| (class "comment-delimiter") (id "F:455644")) "*/") "\n      " (span (|@| (class "keyword") (id "F:455653")) "if") " (last_reused_text_row)\n        {\n          w->window_end_bytepos\n            = Z_BYTE - MATRIX_ROW_END_BYTEPOS (last_reused_text_row);\n          w->window_end_pos\n            = make_number (Z - MATRIX_ROW_END_CHARPOS (last_reused_text_row));\n          w->window_end_vpos\n            = make_number (MATRIX_ROW_VPOS (last_reused_text_row,\n                                            w->current_matrix));\n        }\n      " (span (|@| (class "keyword") (id "F:455983")) "else") " " (span (|@| (class "keyword") (id "F:455988")) "if") " (last_text_row)\n        {\n          w->window_end_bytepos\n            = Z_BYTE - MATRIX_ROW_END_BYTEPOS (last_text_row);\n          w->window_end_pos\n            = make_number (Z - MATRIX_ROW_END_CHARPOS (last_text_row));\n          w->window_end_vpos\n            = make_number (MATRIX_ROW_VPOS (last_text_row, w->desired_matrix));\n        }\n      " (span (|@| (class "keyword") (id "F:456281")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:456292")) "/* ") (span (|@| (class "comment") (id "F:456295")) "This window must be completely empty.  ") (span (|@| (class "comment-delimiter") (id "F:456334")) "*/") "\n          w->window_end_bytepos = Z_BYTE - ZV_BYTE;\n          w->window_end_pos = make_number (Z - ZV);\n          w->window_end_vpos = make_number (0);\n        }\n      w->window_end_valid = Qnil;\n\n      " (span (|@| (class "comment-delimiter") (id "F:456512")) "/* ") (span (|@| (class "comment") (id "F:456515")) "Update hint: don't try scrolling again in update_window.  ") (span (|@| (class "comment-delimiter") (id "F:456573")) "*/") "\n      w->desired_matrix->no_scrolling_p = 1;\n\n" (span (|@| (class "preprocessor") (id "F:456622")) "#if") " GLYPH_DEBUG\n      debug_method_add (w, " (span (|@| (class "string") (id "F:456665")) "\"try_window_reusing_current_matrix 1\"") ");\n" (span (|@| (class "preprocessor") (id "F:456705")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:456718")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:456736")) "else") " " (span (|@| (class "keyword") (id "F:456741")) "if") " (CHARPOS (new_start) > CHARPOS (start))\n    {\n      " (span (|@| (class "keyword") (id "F:456796")) "struct") " " (span (|@| (class "type") (id "F:456803")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:456814")) "pt_row") ", *" (span (|@| (class "variable-name") (id "F:456823")) "row") ";\n      " (span (|@| (class "keyword") (id "F:456834")) "struct") " " (span (|@| (class "type") (id "F:456841")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:456852")) "first_reusable_row") ";\n      " (span (|@| (class "keyword") (id "F:456878")) "struct") " " (span (|@| (class "type") (id "F:456885")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:456896")) "first_row_to_display") ";\n      " (span (|@| (class "type") (id "F:456924")) "int") " " (span (|@| (class "variable-name") (id "F:456928")) "dy") ";\n      " (span (|@| (class "type") (id "F:456938")) "int") " " (span (|@| (class "variable-name") (id "F:456942")) "yb") " = window_text_bottom_y (w);\n\n      " (span (|@| (class "comment-delimiter") (id "F:456980")) "/* ") (span (|@| (class "comment") (id "F:456983")) "Find the row starting at new_start, if there is one.  Don't\n         reuse a partially visible line at the end.  ") (span (|@| (class "comment-delimiter") (id "F:457089")) "*/") "\n      first_reusable_row = start_row;\n      " (span (|@| (class "keyword") (id "F:457136")) "while") " (first_reusable_row->enabled_p\n             && MATRIX_ROW_BOTTOM_Y (first_reusable_row) < yb\n             && (MATRIX_ROW_START_CHARPOS (first_reusable_row)\n                 < CHARPOS (new_start)))\n        ++first_reusable_row;\n\n      " (span (|@| (class "comment-delimiter") (id "F:457341")) "/* ") (span (|@| (class "comment") (id "F:457344")) "Give up if there is no row to reuse.  ") (span (|@| (class "comment-delimiter") (id "F:457382")) "*/") "\n      " (span (|@| (class "keyword") (id "F:457391")) "if") " (MATRIX_ROW_BOTTOM_Y (first_reusable_row) >= yb\n          || " (span (|@| (class "negation-char") (id "F:457448")) "!") "first_reusable_row->enabled_p\n          || (MATRIX_ROW_START_CHARPOS (first_reusable_row)\n              != CHARPOS (new_start)))\n        " (span (|@| (class "keyword") (id "F:457565")) "return") " 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:457582")) "/* ") (span (|@| (class "comment") (id "F:457585")) "We can reuse fully visible rows beginning with\n         first_reusable_row to the end of the window.  Set\n         first_row_to_display to the first row that cannot be reused.\n         Set pt_row to the row containing point, if there is any.  ") (span (|@| (class "comment-delimiter") (id "F:457828")) "*/") "\n      pt_row = " (span (|@| (class "constant") (id "F:457846")) "NULL") ";\n      " (span (|@| (class "keyword") (id "F:457858")) "for") " (first_row_to_display = first_reusable_row;\n           MATRIX_ROW_BOTTOM_Y (first_row_to_display) < yb;\n           ++first_row_to_display)\n        {\n          " (span (|@| (class "keyword") (id "F:457993")) "if") " (PT >= MATRIX_ROW_START_CHARPOS (first_row_to_display)\n              && PT < MATRIX_ROW_END_CHARPOS (first_row_to_display))\n            pt_row = first_row_to_display;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:458159")) "/* ") (span (|@| (class "comment") (id "F:458162")) "Start displaying at the start of first_row_to_display.  ") (span (|@| (class "comment-delimiter") (id "F:458218")) "*/") "\n      xassert (first_row_to_display->y < yb);\n      init_to_row_start (&it, w, first_row_to_display);\n\n      nrows_scrolled = (MATRIX_ROW_VPOS (first_reusable_row, w->current_matrix)\n                        - start_vpos);\n      it.vpos = (MATRIX_ROW_VPOS (first_row_to_display, w->current_matrix)\n                 - nrows_scrolled);\n      it.current_y = (first_row_to_display->y - first_reusable_row->y\n                      + WINDOW_HEADER_LINE_HEIGHT (w));\n\n      " (span (|@| (class "comment-delimiter") (id "F:458638")) "/* ") (span (|@| (class "comment") (id "F:458641")) "Display lines beginning with first_row_to_display in the\n         desired matrix.  Set last_text_row to the last row displayed\n         that displays text.  ") (span (|@| (class "comment-delimiter") (id "F:458798")) "*/") "\n      it.glyph_row = MATRIX_ROW (w->desired_matrix, it.vpos);\n      " (span (|@| (class "keyword") (id "F:458869")) "if") " (pt_row == " (span (|@| (class "constant") (id "F:458883")) "NULL") ")\n        w->cursor.vpos = -1;\n      last_text_row = " (span (|@| (class "constant") (id "F:458933")) "NULL") ";\n      " (span (|@| (class "keyword") (id "F:458945")) "while") " (it.current_y < it.last_visible_y && " (span (|@| (class "negation-char") (id "F:458988")) "!") "fonts_changed_p)\n        " (span (|@| (class "keyword") (id "F:459007")) "if") " (display_line (&it))\n          last_text_row = it.glyph_row - 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:459075")) "/* ") (span (|@| (class "comment") (id "F:459078")) "If point is in a reused row, adjust y and vpos of the cursor\n         position.  ") (span (|@| (class "comment-delimiter") (id "F:459152")) "*/") "\n      " (span (|@| (class "keyword") (id "F:459161")) "if") " (pt_row)\n        {\n          w->cursor.vpos -= nrows_scrolled;\n          w->cursor.y -= first_reusable_row->y - start_row->y;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:459279")) "/* ") (span (|@| (class "comment") (id "F:459282")) "Give up if point isn't in a row displayed or reused.  (This\n         also handles the case where w->cursor.vpos < nrows_scrolled\n         after the calls to display_line, which can happen with scroll\n         margins.  See bug#1295.)  ") (span (|@| (class "comment-delimiter") (id "F:459496")) "*/") "\n      " (span (|@| (class "keyword") (id "F:459505")) "if") " (w->cursor.vpos < 0)\n        {\n          clear_glyph_matrix (w->desired_matrix);\n          " (span (|@| (class "keyword") (id "F:459578")) "return") " 0;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:459598")) "/* ") (span (|@| (class "comment") (id "F:459601")) "Scroll the display.  ") (span (|@| (class "comment-delimiter") (id "F:459622")) "*/") "\n      run.current_y = first_reusable_row->y;\n      run.desired_y = WINDOW_HEADER_LINE_HEIGHT (w);\n      run.height = it.last_visible_y - run.current_y;\n      dy = run.current_y - run.desired_y;\n\n      " (span (|@| (class "keyword") (id "F:459826")) "if") " (run.height)\n        {\n          update_begin (f);\n          FRAME_RIF (f)->update_window_begin_hook (w);\n          FRAME_RIF (f)->clear_window_mouse_face (w);\n          FRAME_RIF (f)->scroll_run_hook (w, &run);\n          FRAME_RIF (f)->update_window_end_hook (w, 0, 0);\n          update_end (f);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:460087")) "/* ") (span (|@| (class "comment") (id "F:460090")) "Adjust Y positions of reused rows.  ") (span (|@| (class "comment-delimiter") (id "F:460126")) "*/") "\n      bottom_row = MATRIX_BOTTOM_TEXT_ROW (w->current_matrix, w);\n      min_y = WINDOW_HEADER_LINE_HEIGHT (w);\n      max_y = it.last_visible_y;\n      " (span (|@| (class "keyword") (id "F:460279")) "for") " (row = first_reusable_row; row < first_row_to_display; ++row)\n        {\n          row->y -= dy;\n          row->visible_height = row->height;\n          " (span (|@| (class "keyword") (id "F:460406")) "if") " (row->y < min_y)\n            row->visible_height -= min_y - row->y;\n          " (span (|@| (class "keyword") (id "F:460473")) "if") " (row->y + row->height > max_y)\n            row->visible_height -= row->y + row->height - max_y;\n          row->redraw_fringe_bitmaps_p = 1;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:460612")) "/* ") (span (|@| (class "comment") (id "F:460615")) "Scroll the current matrix.  ") (span (|@| (class "comment-delimiter") (id "F:460643")) "*/") "\n      xassert (nrows_scrolled > 0);\n      rotate_matrix (w->current_matrix,\n                     start_vpos,\n                     MATRIX_ROW_VPOS (bottom_row, w->current_matrix),\n                     -nrows_scrolled);\n\n      " (span (|@| (class "comment-delimiter") (id "F:460829")) "/* ") (span (|@| (class "comment") (id "F:460832")) "Disable rows not reused.  ") (span (|@| (class "comment-delimiter") (id "F:460858")) "*/") "\n      " (span (|@| (class "keyword") (id "F:460867")) "for") " (row -= nrows_scrolled; row < bottom_row; ++row)\n        row->enabled_p = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:460948")) "/* ") (span (|@| (class "comment") (id "F:460951")) "Point may have moved to a different line, so we cannot assume that\n         the previous cursor position is valid; locate the correct row.  ") (span (|@| (class "comment-delimiter") (id "F:461084")) "*/") "\n      " (span (|@| (class "keyword") (id "F:461093")) "if") " (pt_row)\n        {\n          " (span (|@| (class "keyword") (id "F:461111")) "for") " (row = MATRIX_ROW (w->current_matrix, w->cursor.vpos);\n               row < bottom_row && PT >= MATRIX_ROW_END_CHARPOS (row);\n               row++)\n            {\n              w->cursor.vpos++;\n              w->cursor.y = row->y;\n            }\n          " (span (|@| (class "keyword") (id "F:461320")) "if") " (row < bottom_row)\n            {\n              " (span (|@| (class "keyword") (id "F:461356")) "struct") " " (span (|@| (class "type") (id "F:461363")) "glyph") " *" (span (|@| (class "variable-name") (id "F:461370")) "glyph") " = row->glyphs[TEXT_AREA] + w->cursor.hpos;\n              " (span (|@| (class "keyword") (id "F:461426")) "struct") " " (span (|@| (class "type") (id "F:461433")) "glyph") " *" (span (|@| (class "variable-name") (id "F:461440")) "end") " = glyph + row->used[TEXT_AREA];\n\n              " (span (|@| (class "comment-delimiter") (id "F:461484")) "/* ") (span (|@| (class "comment") (id "F:461487")) "Can't use this optimization with bidi-reordered glyph\n                 rows, unless cursor is already at point. ") (span (|@| (class "comment-delimiter") (id "F:461585")) "*/") "\n              " (span (|@| (class "keyword") (id "F:461595")) "if") " (" (span (|@| (class "negation-char") (id "F:461599")) "!") "NILP (XBUFFER (w->buffer)->bidi_display_reordering))\n                {\n                  " (span (|@| (class "keyword") (id "F:461661")) "if") " (" (span (|@| (class "negation-char") (id "F:461665")) "!") "(w->cursor.hpos >= 0\n                        && w->cursor.hpos < row->used[TEXT_AREA]\n                        && BUFFERP (glyph->object)\n                        && glyph->charpos == PT))\n                    " (span (|@| (class "keyword") (id "F:461796")) "return") " 0;\n                }\n              " (span (|@| (class "keyword") (id "F:461817")) "else") "\n                " (span (|@| (class "keyword") (id "F:461824")) "for") " (; glyph < end\n                       && (" (span (|@| (class "negation-char") (id "F:461856")) "!") "BUFFERP (glyph->object)\n                           || glyph->charpos < PT);\n                     glyph++)\n                  {\n                    w->cursor.hpos++;\n                    w->cursor.x += glyph->pixel_width;\n                  }\n            }\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:462022")) "/* ") (span (|@| (class "comment") (id "F:462025")) "Adjust window end.  A null value of last_text_row means that\n         the window end is in reused rows which in turn means that\n         only its vpos can have changed.  ") (span (|@| (class "comment-delimiter") (id "F:462181")) "*/") "\n      " (span (|@| (class "keyword") (id "F:462190")) "if") " (last_text_row)\n        {\n          w->window_end_bytepos\n            = Z_BYTE - MATRIX_ROW_END_BYTEPOS (last_text_row);\n          w->window_end_pos\n            = make_number (Z - MATRIX_ROW_END_CHARPOS (last_text_row));\n          w->window_end_vpos\n            = make_number (MATRIX_ROW_VPOS (last_text_row, w->desired_matrix));\n        }\n      " (span (|@| (class "keyword") (id "F:462483")) "else") "\n        {\n          w->window_end_vpos\n            = make_number (XFASTINT (w->window_end_vpos) - nrows_scrolled);\n        }\n\n      w->window_end_valid = Qnil;\n      w->desired_matrix->no_scrolling_p = 1;\n\n" (span (|@| (class "preprocessor") (id "F:462666")) "#if") " GLYPH_DEBUG\n      debug_method_add (w, " (span (|@| (class "string") (id "F:462709")) "\"try_window_reusing_current_matrix 2\"") ");\n" (span (|@| (class "preprocessor") (id "F:462749")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:462762")) "return") " 1;\n    }\n\n  " (span (|@| (class "keyword") (id "F:462781")) "return") " 0;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:462797")) "/************************************************************************") (span (|@| (class "comment") (id "F:462870")) "\n   Window redisplay reusing current matrix when buffer has changed\n ***********************************************************************") (span (|@| (class "comment-delimiter") (id "F:463010")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:463014")) "static") " " (span (|@| (class "keyword") (id "F:463021")) "struct") " " (span (|@| (class "type") (id "F:463028")) "glyph_row") " *" (span (|@| (class "function-name") (id "F:463039")) "find_last_unchanged_at_beg_row") " P_ ((" (span (|@| (class "keyword") (id "F:463075")) "struct") " " (span (|@| (class "type") (id "F:463082")) "window") " *));\n" (span (|@| (class "keyword") (id "F:463094")) "static") " " (span (|@| (class "keyword") (id "F:463101")) "struct") " " (span (|@| (class "type") (id "F:463108")) "glyph_row") " *" (span (|@| (class "function-name") (id "F:463119")) "find_first_unchanged_at_end_row") " P_ ((" (span (|@| (class "keyword") (id "F:463156")) "struct") " " (span (|@| (class "type") (id "F:463163")) "window") " *,\n                                                             " (span (|@| (class "type") (id "F:463185")) "int") " *, " (span (|@| (class "type") (id "F:463192")) "int") " *));\n" (span (|@| (class "keyword") (id "F:463201")) "static") " " (span (|@| (class "keyword") (id "F:463208")) "struct") " " (span (|@| (class "type") (id "F:463215")) "glyph_row") " *\n" (span (|@| (class "function-name") (id "F:463227")) "find_last_row_displaying_text") " P_ ((" (span (|@| (class "keyword") (id "F:463262")) "struct") " " (span (|@| (class "type") (id "F:463269")) "glyph_matrix") " *, " (span (|@| (class "keyword") (id "F:463285")) "struct") " " (span (|@| (class "type") (id "F:463292")) "it") " *,\n                                   " (span (|@| (class "keyword") (id "F:463305")) "struct") " " (span (|@| (class "type") (id "F:463312")) "glyph_row") " *));\n\n\n" (span (|@| (class "comment-delimiter") (id "F:463329")) "/* ") (span (|@| (class "comment") (id "F:463332")) "Return the last row in MATRIX displaying text.  If row START is\n   non-null, start searching with that row.  IT gives the dimensions\n   of the display.  Value is null if matrix is empty; otherwise it is\n   a pointer to the row found.  ") (span (|@| (class "comment-delimiter") (id "F:463567")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:463571")) "static") " " (span (|@| (class "keyword") (id "F:463578")) "struct") " " (span (|@| (class "type") (id "F:463585")) "glyph_row") " *\n" (span (|@| (class "function-name") (id "F:463597")) "find_last_row_displaying_text") " (matrix, " (span (|@| (class "type") (id "F:463636")) "it") ", start)\n     " (span (|@| (class "keyword") (id "F:463652")) "struct") " " (span (|@| (class "type") (id "F:463659")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:463673")) "matrix") ";\n     " (span (|@| (class "keyword") (id "F:463686")) "struct") " " (span (|@| (class "type") (id "F:463693")) "it") " *" (span (|@| (class "variable-name") (id "F:463697")) "it") ";\n     " (span (|@| (class "keyword") (id "F:463706")) "struct") " " (span (|@| (class "type") (id "F:463713")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:463724")) "start") ";\n{\n  " (span (|@| (class "keyword") (id "F:463735")) "struct") " " (span (|@| (class "type") (id "F:463742")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:463753")) "row") ", *" (span (|@| (class "variable-name") (id "F:463759")) "row_found") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:463773")) "/* ") (span (|@| (class "comment") (id "F:463776")) "Set row_found to the last row in IT->w's current matrix\n     displaying text.  The loop looks funny but think of partially\n     visible lines.  ") (span (|@| (class "comment-delimiter") (id "F:463920")) "*/") "\n  row_found = " (span (|@| (class "constant") (id "F:463937")) "NULL") ";\n  row = start ? start : MATRIX_FIRST_TEXT_ROW (matrix);\n  " (span (|@| (class "keyword") (id "F:464001")) "while") " (MATRIX_ROW_DISPLAYS_TEXT_P (row))\n    {\n      xassert (row->enabled_p);\n      row_found = row;\n      " (span (|@| (class "keyword") (id "F:464109")) "if") " (MATRIX_ROW_BOTTOM_Y (row) >= it->last_visible_y)\n        " (span (|@| (class "keyword") (id "F:464163")) "break") ";\n      ++row;\n    }\n\n  " (span (|@| (class "keyword") (id "F:464192")) "return") " row_found;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:464214")) "/* ") (span (|@| (class "comment") (id "F:464217")) "Return the last row in the current matrix of W that is not affected\n   by changes at the start of current_buffer that occurred since W's\n   current matrix was built.  Value is null if no such row exists.\n\n   BEG_UNCHANGED us the number of characters unchanged at the start of\n   current_buffer.  BEG + BEG_UNCHANGED is the buffer position of the\n   first changed character in current_buffer.  Characters at positions <\n   BEG + BEG_UNCHANGED are at the same buffer positions as they were\n   when the current matrix was built.  ") (span (|@| (class "comment-delimiter") (id "F:464744")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:464748")) "static") " " (span (|@| (class "keyword") (id "F:464755")) "struct") " " (span (|@| (class "type") (id "F:464762")) "glyph_row") " *\n" (span (|@| (class "function-name") (id "F:464774")) "find_last_unchanged_at_beg_row") " (w)\n     " (span (|@| (class "keyword") (id "F:464814")) "struct") " " (span (|@| (class "type") (id "F:464821")) "window") " *" (span (|@| (class "variable-name") (id "F:464829")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:464836")) "int") " " (span (|@| (class "variable-name") (id "F:464840")) "first_changed_pos") " = BEG + BEG_UNCHANGED;\n  " (span (|@| (class "keyword") (id "F:464883")) "struct") " " (span (|@| (class "type") (id "F:464890")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:464901")) "row") ";\n  " (span (|@| (class "keyword") (id "F:464908")) "struct") " " (span (|@| (class "type") (id "F:464915")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:464926")) "row_found") " = " (span (|@| (class "constant") (id "F:464938")) "NULL") ";\n  " (span (|@| (class "type") (id "F:464946")) "int") " " (span (|@| (class "variable-name") (id "F:464950")) "yb") " = window_text_bottom_y (w);\n\n  " (span (|@| (class "comment-delimiter") (id "F:464984")) "/* ") (span (|@| (class "comment") (id "F:464987")) "Find the last row displaying unchanged text.  ") (span (|@| (class "comment-delimiter") (id "F:465033")) "*/") "\n  " (span (|@| (class "keyword") (id "F:465038")) "for") " (row = MATRIX_FIRST_TEXT_ROW (w->current_matrix);\n       MATRIX_ROW_DISPLAYS_TEXT_P (row)\n         && MATRIX_ROW_START_CHARPOS (row) < first_changed_pos;\n       ++row)\n    {\n      " (span (|@| (class "keyword") (id "F:465215")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:465219")) "/* ") (span (|@| (class "comment") (id "F:465222")) "If row ends before first_changed_pos, it is unchanged,\n             except in some case.  ") (span (|@| (class "comment-delimiter") (id "F:465305")) "*/") "\n          MATRIX_ROW_END_CHARPOS (row) <= first_changed_pos\n          " (span (|@| (class "comment-delimiter") (id "F:465364")) "/* ") (span (|@| (class "comment") (id "F:465367")) "When row ends in ZV and we write at ZV it is not\n             unchanged.  ") (span (|@| (class "comment-delimiter") (id "F:465441")) "*/") "\n          && " (span (|@| (class "negation-char") (id "F:465450")) "!") "row->ends_at_zv_p\n          " (span (|@| (class "comment-delimiter") (id "F:465472")) "/* ") (span (|@| (class "comment") (id "F:465475")) "When first_changed_pos is the end of a continued line,\n             row is not unchanged because it may be no longer\n             continued.  ") (span (|@| (class "comment-delimiter") (id "F:465603")) "*/") "\n          && " (span (|@| (class "negation-char") (id "F:465612")) "!") "(MATRIX_ROW_END_CHARPOS (row) == first_changed_pos\n               && (row->continued_p\n                   || row->exact_window_width_line_p)))\n        row_found = row;\n\n      " (span (|@| (class "comment-delimiter") (id "F:465760")) "/* ") (span (|@| (class "comment") (id "F:465763")) "Stop if last visible row.  ") (span (|@| (class "comment-delimiter") (id "F:465790")) "*/") "\n      " (span (|@| (class "keyword") (id "F:465799")) "if") " (MATRIX_ROW_BOTTOM_Y (row) >= yb)\n        " (span (|@| (class "keyword") (id "F:465837")) "break") ";\n    }\n\n  " (span (|@| (class "keyword") (id "F:465853")) "return") " row_found;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:465875")) "/* ") (span (|@| (class "comment") (id "F:465878")) "Find the first glyph row in the current matrix of W that is not\n   affected by changes at the end of current_buffer since the\n   time W's current matrix was built.\n\n   Return in *DELTA the number of chars by which buffer positions in\n   unchanged text at the end of current_buffer must be adjusted.\n\n   Return in *DELTA_BYTES the corresponding number of bytes.\n\n   Value is null if no such row exists, i.e. all rows are affected by\n   changes.  ") (span (|@| (class "comment-delimiter") (id "F:466323")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:466327")) "static") " " (span (|@| (class "keyword") (id "F:466334")) "struct") " " (span (|@| (class "type") (id "F:466341")) "glyph_row") " *\n" (span (|@| (class "function-name") (id "F:466353")) "find_first_unchanged_at_end_row") " (w, delta, delta_bytes)\n     " (span (|@| (class "keyword") (id "F:466414")) "struct") " " (span (|@| (class "type") (id "F:466421")) "window") " *" (span (|@| (class "variable-name") (id "F:466429")) "w") ";\n     " (span (|@| (class "type") (id "F:466437")) "int") " *" (span (|@| (class "variable-name") (id "F:466442")) "delta") ", *" (span (|@| (class "variable-name") (id "F:466450")) "delta_bytes") ";\n{\n  " (span (|@| (class "keyword") (id "F:466467")) "struct") " " (span (|@| (class "type") (id "F:466474")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:466485")) "row") ";\n  " (span (|@| (class "keyword") (id "F:466492")) "struct") " " (span (|@| (class "type") (id "F:466499")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:466510")) "row_found") " = " (span (|@| (class "constant") (id "F:466522")) "NULL") ";\n\n  *delta = *delta_bytes = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:466561")) "/* ") (span (|@| (class "comment") (id "F:466564")) "Display must not have been paused, otherwise the current matrix\n     is not up to date.  ") (span (|@| (class "comment-delimiter") (id "F:466653")) "*/") "\n  eassert (" (span (|@| (class "negation-char") (id "F:466667")) "!") "NILP (w->window_end_valid));\n\n  " (span (|@| (class "comment-delimiter") (id "F:466700")) "/* ") (span (|@| (class "comment") (id "F:466703")) "A value of window_end_pos >= END_UNCHANGED means that the window\n     end is in the range of changed text.  If so, there is no\n     unchanged row at the end of W's current matrix.  ") (span (|@| (class "comment-delimiter") (id "F:466884")) "*/") "\n  " (span (|@| (class "keyword") (id "F:466889")) "if") " (XFASTINT (w->window_end_pos) >= END_UNCHANGED)\n    " (span (|@| (class "keyword") (id "F:466944")) "return") " " (span (|@| (class "constant") (id "F:466951")) "NULL") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:466960")) "/* ") (span (|@| (class "comment") (id "F:466963")) "Set row to the last row in W's current matrix displaying text.  ") (span (|@| (class "comment-delimiter") (id "F:467027")) "*/") "\n  row = MATRIX_ROW (w->current_matrix, XFASTINT (w->window_end_vpos));\n\n  " (span (|@| (class "comment-delimiter") (id "F:467104")) "/* ") (span (|@| (class "comment") (id "F:467107")) "If matrix is entirely empty, no unchanged row exists.  ") (span (|@| (class "comment-delimiter") (id "F:467162")) "*/") "\n  " (span (|@| (class "keyword") (id "F:467167")) "if") " (MATRIX_ROW_DISPLAYS_TEXT_P (row))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:467217")) "/* ") (span (|@| (class "comment") (id "F:467220")) "The value of row is the last glyph row in the matrix having a\n         meaningful buffer position in it.  The end position of row\n         corresponds to window_end_pos.  This allows us to translate\n         buffer positions in the current matrix to current buffer\n         positions for characters not in changed text.  ") (span (|@| (class "comment-delimiter") (id "F:467513")) "*/") "\n      " (span (|@| (class "type") (id "F:467522")) "int") " " (span (|@| (class "variable-name") (id "F:467526")) "Z_old") " = MATRIX_ROW_END_CHARPOS (row) + XFASTINT (w->window_end_pos);\n      " (span (|@| (class "type") (id "F:467601")) "int") " " (span (|@| (class "variable-name") (id "F:467605")) "Z_BYTE_old") " = MATRIX_ROW_END_BYTEPOS (row) + w->window_end_bytepos;\n      " (span (|@| (class "type") (id "F:467678")) "int") " " (span (|@| (class "variable-name") (id "F:467682")) "last_unchanged_pos") ", " (span (|@| (class "variable-name") (id "F:467702")) "last_unchanged_pos_old") ";\n      " (span (|@| (class "keyword") (id "F:467732")) "struct") " " (span (|@| (class "type") (id "F:467739")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:467750")) "first_text_row") "\n        = MATRIX_FIRST_TEXT_ROW (w->current_matrix);\n\n      *delta = Z - Z_old;\n      *delta_bytes = Z_BYTE - Z_BYTE_old;\n\n      " (span (|@| (class "comment-delimiter") (id "F:467887")) "/* ") (span (|@| (class "comment") (id "F:467890")) "Set last_unchanged_pos to the buffer position of the last\n         character in the buffer that has not been changed.  Z is the\n         index + 1 of the last character in current_buffer, i.e. by\n         subtracting END_UNCHANGED we get the index of the last\n         unchanged character, and we have to add BEG to get its buffer\n         position.  ") (span (|@| (class "comment-delimiter") (id "F:468206")) "*/") "\n      last_unchanged_pos = Z - END_UNCHANGED + BEG;\n      last_unchanged_pos_old = last_unchanged_pos - *delta;\n\n      " (span (|@| (class "comment-delimiter") (id "F:468328")) "/* ") (span (|@| (class "comment") (id "F:468331")) "Search backward from ROW for a row displaying a line that\n         starts at a minimum position >= last_unchanged_pos_old.  ") (span (|@| (class "comment-delimiter") (id "F:468448")) "*/") "\n      " (span (|@| (class "keyword") (id "F:468457")) "for") " (; row > first_text_row; --row)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:468499")) "/* ") (span (|@| (class "comment") (id "F:468502")) "This used to abort, but it can happen.\n             It is ok to just stop the search instead here.  KFS.  ") (span (|@| (class "comment-delimiter") (id "F:468601")) "*/") "\n          " (span (|@| (class "keyword") (id "F:468607")) "if") " (" (span (|@| (class "negation-char") (id "F:468611")) "!") "row->enabled_p || " (span (|@| (class "negation-char") (id "F:468630")) "!") "MATRIX_ROW_DISPLAYS_TEXT_P (row))\n            " (span (|@| (class "keyword") (id "F:468670")) "break") ";\n\n          " (span (|@| (class "keyword") (id "F:468681")) "if") " (MATRIX_ROW_START_CHARPOS (row) >= last_unchanged_pos_old)\n            row_found = row;\n        }\n    }\n\n  eassert (" (span (|@| (class "negation-char") (id "F:468786")) "!") "row_found || MATRIX_ROW_DISPLAYS_TEXT_P (row_found));\n\n  " (span (|@| (class "keyword") (id "F:468844")) "return") " row_found;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:468866")) "/* ") (span (|@| (class "comment") (id "F:468869")) "Make sure that glyph rows in the current matrix of window W\n   reference the same glyph memory as corresponding rows in the\n   frame's frame matrix.  This function is called after scrolling W's\n   current matrix on a terminal frame in try_window_id and\n   try_window_reusing_current_matrix.  ") (span (|@| (class "comment-delimiter") (id "F:469161")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:469165")) "static") " " (span (|@| (class "type") (id "F:469172")) "void") "\n" (span (|@| (class "function-name") (id "F:469177")) "sync_frame_with_window_matrix_rows") " (w)\n     " (span (|@| (class "keyword") (id "F:469221")) "struct") " " (span (|@| (class "type") (id "F:469228")) "window") " *" (span (|@| (class "variable-name") (id "F:469236")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:469243")) "struct") " " (span (|@| (class "type") (id "F:469250")) "frame") " *" (span (|@| (class "variable-name") (id "F:469257")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "keyword") (id "F:469282")) "struct") " " (span (|@| (class "type") (id "F:469289")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:469300")) "window_row") ", *" (span (|@| (class "variable-name") (id "F:469313")) "window_row_end") ", *" (span (|@| (class "variable-name") (id "F:469330")) "frame_row") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:469344")) "/* ") (span (|@| (class "comment") (id "F:469347")) "Preconditions: W must be a leaf window and full-width.  Its frame\n     must have a frame matrix.  ") (span (|@| (class "comment-delimiter") (id "F:469445")) "*/") "\n  xassert (NILP (w->hchild) && NILP (w->vchild));\n  xassert (WINDOW_FULL_WIDTH_P (w));\n  xassert (" (span (|@| (class "negation-char") (id "F:469546")) "!") "FRAME_WINDOW_P (f));\n\n  " (span (|@| (class "comment-delimiter") (id "F:469571")) "/* ") (span (|@| (class "comment") (id "F:469574")) "If W is a full-width window, glyph pointers in W's current matrix\n     have, by definition, to be the same as glyph pointers in the\n     corresponding frame matrix.  Note that frame matrices have no\n     marginal areas (see build_frame_matrix).  ") (span (|@| (class "comment-delimiter") (id "F:469820")) "*/") "\n  window_row = w->current_matrix->rows;\n  window_row_end = window_row + w->current_matrix->nrows;\n  frame_row = f->current_matrix->rows + WINDOW_TOP_EDGE_LINE (w);\n  " (span (|@| (class "keyword") (id "F:469989")) "while") " (window_row < window_row_end)\n    {\n      " (span (|@| (class "keyword") (id "F:470037")) "struct") " " (span (|@| (class "type") (id "F:470044")) "glyph") " *" (span (|@| (class "variable-name") (id "F:470051")) "start") " = window_row->glyphs[LEFT_MARGIN_AREA];\n      " (span (|@| (class "keyword") (id "F:470103")) "struct") " " (span (|@| (class "type") (id "F:470110")) "glyph") " *" (span (|@| (class "variable-name") (id "F:470117")) "end") " = window_row->glyphs[LAST_AREA];\n\n      frame_row->glyphs[LEFT_MARGIN_AREA] = start;\n      frame_row->glyphs[TEXT_AREA] = start;\n      frame_row->glyphs[RIGHT_MARGIN_AREA] = end;\n      frame_row->glyphs[LAST_AREA] = end;\n\n      " (span (|@| (class "comment-delimiter") (id "F:470349")) "/* ") (span (|@| (class "comment") (id "F:470352")) "Disable frame rows whose corresponding window rows have\n         been disabled in try_window_id.  ") (span (|@| (class "comment-delimiter") (id "F:470443")) "*/") "\n      " (span (|@| (class "keyword") (id "F:470452")) "if") " (" (span (|@| (class "negation-char") (id "F:470456")) "!") "window_row->enabled_p)\n        frame_row->enabled_p = 0;\n\n      ++window_row, ++frame_row;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:470551")) "/* ") (span (|@| (class "comment") (id "F:470554")) "Find the glyph row in window W containing CHARPOS.  Consider all\n   rows between START and END (not inclusive).  END null means search\n   all rows to the end of the display area of W.  Value is the row\n   containing CHARPOS or null.  ") (span (|@| (class "comment-delimiter") (id "F:470788")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:470792")) "struct") " " (span (|@| (class "type") (id "F:470799")) "glyph_row") " *\n" (span (|@| (class "function-name") (id "F:470811")) "row_containing_pos") " (w, charpos, start, end, dy)\n     " (span (|@| (class "keyword") (id "F:470864")) "struct") " " (span (|@| (class "type") (id "F:470871")) "window") " *" (span (|@| (class "variable-name") (id "F:470879")) "w") ";\n     " (span (|@| (class "type") (id "F:470887")) "int") " " (span (|@| (class "variable-name") (id "F:470891")) "charpos") ";\n     " (span (|@| (class "keyword") (id "F:470905")) "struct") " " (span (|@| (class "type") (id "F:470912")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:470923")) "start") ", *" (span (|@| (class "variable-name") (id "F:470931")) "end") ";\n     " (span (|@| (class "type") (id "F:470941")) "int") " " (span (|@| (class "variable-name") (id "F:470945")) "dy") ";\n{\n  " (span (|@| (class "keyword") (id "F:470953")) "struct") " " (span (|@| (class "type") (id "F:470960")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:470971")) "row") " = start;\n  " (span (|@| (class "keyword") (id "F:470986")) "struct") " " (span (|@| (class "type") (id "F:470993")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:471004")) "best_row") " = " (span (|@| (class "constant") (id "F:471015")) "NULL") ";\n  " (span (|@| (class "type") (id "F:471023")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:471033")) "mindif") " = BUF_ZV (XBUFFER (w->buffer)) + 1;\n  " (span (|@| (class "type") (id "F:471078")) "int") " " (span (|@| (class "variable-name") (id "F:471082")) "last_y") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:471093")) "/* ") (span (|@| (class "comment") (id "F:471096")) "If we happen to start on a header-line, skip that.  ") (span (|@| (class "comment-delimiter") (id "F:471148")) "*/") "\n  " (span (|@| (class "keyword") (id "F:471153")) "if") " (row->mode_line_p)\n    ++row;\n\n  " (span (|@| (class "keyword") (id "F:471189")) "if") " ((end && row >= end) || " (span (|@| (class "negation-char") (id "F:471216")) "!") "row->enabled_p)\n    " (span (|@| (class "keyword") (id "F:471237")) "return") " " (span (|@| (class "constant") (id "F:471244")) "NULL") ";\n\n  last_y = window_text_bottom_y (w) - dy;\n\n  " (span (|@| (class "keyword") (id "F:471296")) "while") " (1)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:471318")) "/* ") (span (|@| (class "comment") (id "F:471321")) "Give up if we have gone too far.  ") (span (|@| (class "comment-delimiter") (id "F:471355")) "*/") "\n      " (span (|@| (class "keyword") (id "F:471364")) "if") " (end && row >= end)\n        " (span (|@| (class "keyword") (id "F:471388")) "return") " " (span (|@| (class "constant") (id "F:471395")) "NULL") ";\n      " (span (|@| (class "comment-delimiter") (id "F:471407")) "/* ") (span (|@| (class "comment") (id "F:471410")) "This formerly returned if they were equal.\n         I think that both quantities are of a \"last plus one\" type;\n         if so, when they are equal, the row is within the screen. -- rms.  ") (span (|@| (class "comment-delimiter") (id "F:471584")) "*/") "\n      " (span (|@| (class "keyword") (id "F:471593")) "if") " (MATRIX_ROW_BOTTOM_Y (row) > last_y)\n        " (span (|@| (class "keyword") (id "F:471634")) "return") " " (span (|@| (class "constant") (id "F:471641")) "NULL") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:471654")) "/* ") (span (|@| (class "comment") (id "F:471657")) "If it is in this row, return this row.  ") (span (|@| (class "comment-delimiter") (id "F:471697")) "*/") "\n      " (span (|@| (class "keyword") (id "F:471706")) "if") " (" (span (|@| (class "negation-char") (id "F:471710")) "!") " (MATRIX_ROW_END_CHARPOS (row) < charpos\n             || (MATRIX_ROW_END_CHARPOS (row) == charpos\n                 " (span (|@| (class "comment-delimiter") (id "F:471805")) "/* ") (span (|@| (class "comment") (id "F:471808")) "The end position of a row equals the start\n                    position of the next row.  If CHARPOS is there, we\n                    would rather display it in the next line, except\n                    when this line ends in ZV.  ") (span (|@| (class "comment-delimiter") (id "F:471997")) "*/") "\n                 && " (span (|@| (class "negation-char") (id "F:472006")) "!") "row->ends_at_zv_p\n                 && " (span (|@| (class "negation-char") (id "F:472031")) "!") "MATRIX_ROW_ENDS_IN_MIDDLE_OF_CHAR_P (row)))\n          && charpos >= MATRIX_ROW_START_CHARPOS (row))\n        {\n          " (span (|@| (class "keyword") (id "F:472131")) "struct") " " (span (|@| (class "type") (id "F:472138")) "glyph") " *" (span (|@| (class "variable-name") (id "F:472145")) "g") ";\n\n          " (span (|@| (class "keyword") (id "F:472152")) "if") " (NILP (XBUFFER (w->buffer)->bidi_display_reordering))\n            " (span (|@| (class "keyword") (id "F:472214")) "return") " row;\n          " (span (|@| (class "comment-delimiter") (id "F:472229")) "/* ") (span (|@| (class "comment") (id "F:472232")) "In bidi-reordered rows, there could be several rows\n             occluding point.  We need to find the one which fits\n             CHARPOS the best.  ") (span (|@| (class "comment-delimiter") (id "F:472368")) "*/") "\n          " (span (|@| (class "keyword") (id "F:472374")) "for") " (g = row->glyphs[TEXT_AREA];\n               g < row->glyphs[TEXT_AREA] + row->used[TEXT_AREA];\n               g++)\n            {\n              " (span (|@| (class "keyword") (id "F:472493")) "if") " (" (span (|@| (class "negation-char") (id "F:472497")) "!") "STRINGP (g->object))\n                {\n                  " (span (|@| (class "keyword") (id "F:472527")) "if") " (g->charpos > 0 && eabs (g->charpos - charpos) < mindif)\n                    {\n                      mindif = eabs (g->charpos - charpos);\n                      best_row = row;\n                    }\n                }\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:472693")) "else") " " (span (|@| (class "keyword") (id "F:472698")) "if") " (best_row)\n        " (span (|@| (class "keyword") (id "F:472713")) "return") " best_row;\n      ++row;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:472753")) "/* ") (span (|@| (class "comment") (id "F:472756")) "Try to redisplay window W by reusing its existing display.  W's\n   current matrix must be up to date when this function is called,\n   i.e. window_end_valid must not be nil.\n\n   Value is\n\n   1    if display has been updated\n   0    if otherwise unsuccessful\n   -1   if redisplay with same window start is known not to succeed\n\n   The following steps are performed:\n\n   1. Find the last row in the current matrix of W that is not\n   affected by changes at the start of current_buffer.  If no such row\n   is found, give up.\n\n   2. Find the first row in W's current matrix that is not affected by\n   changes at the end of current_buffer.  Maybe there is no such row.\n\n   3. Display lines beginning with the row + 1 found in step 1 to the\n   row found in step 2 or, if step 2 didn't find a row, to the end of\n   the window.\n\n   4. If cursor is not known to appear on the window, give up.\n\n   5. If display stopped at the row found in step 2, scroll the\n   display and current matrix as needed.\n\n   6. Maybe display some lines at the end of W, if we must.  This can\n   happen under various circumstances, like a partially visible line\n   becoming fully visible, or because newly displayed lines are displayed\n   in smaller font sizes.\n\n   7. Update W's window end information.  ") (span (|@| (class "comment-delimiter") (id "F:474020")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:474024")) "static") " " (span (|@| (class "type") (id "F:474031")) "int") "\n" (span (|@| (class "function-name") (id "F:474035")) "try_window_id") " (w)\n     " (span (|@| (class "keyword") (id "F:474058")) "struct") " " (span (|@| (class "type") (id "F:474065")) "window") " *" (span (|@| (class "variable-name") (id "F:474073")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:474080")) "struct") " " (span (|@| (class "type") (id "F:474087")) "frame") " *" (span (|@| (class "variable-name") (id "F:474094")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "keyword") (id "F:474119")) "struct") " " (span (|@| (class "type") (id "F:474126")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:474140")) "current_matrix") " = w->current_matrix;\n  " (span (|@| (class "keyword") (id "F:474178")) "struct") " " (span (|@| (class "type") (id "F:474185")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:474199")) "desired_matrix") " = w->desired_matrix;\n  " (span (|@| (class "keyword") (id "F:474237")) "struct") " " (span (|@| (class "type") (id "F:474244")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:474255")) "last_unchanged_at_beg_row") ";\n  " (span (|@| (class "keyword") (id "F:474284")) "struct") " " (span (|@| (class "type") (id "F:474291")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:474302")) "first_unchanged_at_end_row") ";\n  " (span (|@| (class "keyword") (id "F:474332")) "struct") " " (span (|@| (class "type") (id "F:474339")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:474350")) "row") ";\n  " (span (|@| (class "keyword") (id "F:474357")) "struct") " " (span (|@| (class "type") (id "F:474364")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:474375")) "bottom_row") ";\n  " (span (|@| (class "type") (id "F:474389")) "int") " " (span (|@| (class "variable-name") (id "F:474393")) "bottom_vpos") ";\n  " (span (|@| (class "keyword") (id "F:474408")) "struct") " " (span (|@| (class "type") (id "F:474415")) "it") " " (span (|@| (class "variable-name") (id "F:474418")) "it") ";\n  " (span (|@| (class "type") (id "F:474424")) "int") " " (span (|@| (class "variable-name") (id "F:474428")) "delta") " = 0, " (span (|@| (class "variable-name") (id "F:474439")) "delta_bytes") " = 0, " (span (|@| (class "variable-name") (id "F:474456")) "stop_pos") ", " (span (|@| (class "variable-name") (id "F:474466")) "dvpos") ", " (span (|@| (class "variable-name") (id "F:474473")) "dy") ";\n  " (span (|@| (class "keyword") (id "F:474479")) "struct") " " (span (|@| (class "type") (id "F:474486")) "text_pos") " " (span (|@| (class "variable-name") (id "F:474495")) "start_pos") ";\n  " (span (|@| (class "keyword") (id "F:474508")) "struct") " " (span (|@| (class "type") (id "F:474515")) "run") " " (span (|@| (class "variable-name") (id "F:474519")) "run") ";\n  " (span (|@| (class "type") (id "F:474526")) "int") " " (span (|@| (class "variable-name") (id "F:474530")) "first_unchanged_at_end_vpos") " = 0;\n  " (span (|@| (class "keyword") (id "F:474565")) "struct") " " (span (|@| (class "type") (id "F:474572")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:474583")) "last_text_row") ", *" (span (|@| (class "variable-name") (id "F:474599")) "last_text_row_at_end") ";\n  " (span (|@| (class "keyword") (id "F:474623")) "struct") " " (span (|@| (class "type") (id "F:474630")) "text_pos") " " (span (|@| (class "variable-name") (id "F:474639")) "start") ";\n  " (span (|@| (class "type") (id "F:474648")) "int") " " (span (|@| (class "variable-name") (id "F:474652")) "first_changed_charpos") ", " (span (|@| (class "variable-name") (id "F:474675")) "last_changed_charpos") ";\n\n" (span (|@| (class "preprocessor") (id "F:474698")) "#if") " GLYPH_DEBUG\n  " (span (|@| (class "keyword") (id "F:474716")) "if") " (inhibit_try_window_id)\n    " (span (|@| (class "keyword") (id "F:474747")) "return") " 0;\n" (span (|@| (class "preprocessor") (id "F:474757")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:474767")) "/* ") (span (|@| (class "comment") (id "F:474770")) "This is handy for debugging.  ") (span (|@| (class "comment-delimiter") (id "F:474800")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:474803")) "#if") " 0\n" (span (|@| (class "preprocessor") (id "F:474809")) "#define") " " (span (|@| (class "function-name") (id "F:474817")) "GIVE_UP") "(" (span (|@| (class "variable-name") (id "F:474825")) "X") ")                                              \\\n  " (span (|@| (class "keyword") (id "F:474837")) "do") " {                                                          \\\n    fprintf (stderr, " (span (|@| (class "string") (id "F:474872")) "\"try_window_id give up %d\\n\"") ", (X));        \\\n    " (span (|@| (class "keyword") (id "F:474914")) "return") " 0;                                                   \\\n  } " (span (|@| (class "keyword") (id "F:474936")) "while") " (0)\n" (span (|@| (class "preprocessor") (id "F:474946")) "#else") "\n" (span (|@| (class "preprocessor") (id "F:474952")) "#define") " " (span (|@| (class "function-name") (id "F:474960")) "GIVE_UP") "(" (span (|@| (class "variable-name") (id "F:474968")) "X") ") " (span (|@| (class "keyword") (id "F:474971")) "return") " 0\n" (span (|@| (class "preprocessor") (id "F:474980")) "#endif") "\n\n  SET_TEXT_POS_FROM_MARKER (start, w->start);\n\n  " (span (|@| (class "comment-delimiter") (id "F:475037")) "/* ") (span (|@| (class "comment") (id "F:475040")) "Don't use this for mini-windows because these can show\n     messages and mini-buffers, and we don't handle that here.  ") (span (|@| (class "comment-delimiter") (id "F:475159")) "*/") "\n  " (span (|@| (class "keyword") (id "F:475164")) "if") " (MINI_WINDOW_P (w))\n    GIVE_UP (1);\n\n  " (span (|@| (class "comment-delimiter") (id "F:475207")) "/* ") (span (|@| (class "comment") (id "F:475210")) "This flag is used to prevent redisplay optimizations.  ") (span (|@| (class "comment-delimiter") (id "F:475265")) "*/") "\n  " (span (|@| (class "keyword") (id "F:475270")) "if") " (windows_or_buffers_changed || cursor_type_changed)\n    GIVE_UP (2);\n\n  " (span (|@| (class "comment-delimiter") (id "F:475345")) "/* ") (span (|@| (class "comment") (id "F:475348")) "Verify that narrowing has not changed.\n     Also verify that we were not told to prevent redisplay optimizations.\n     It would be nice to further\n     reduce the number of cases where this prevents try_window_id.  ") (span (|@| (class "comment-delimiter") (id "F:475563")) "*/") "\n  " (span (|@| (class "keyword") (id "F:475568")) "if") " (current_buffer->clip_changed\n      || current_buffer->prevent_redisplay_optimizations_p)\n    GIVE_UP (3);\n\n  " (span (|@| (class "comment-delimiter") (id "F:475681")) "/* ") (span (|@| (class "comment") (id "F:475684")) "Window must either use window-based redisplay or be full width.  ") (span (|@| (class "comment-delimiter") (id "F:475749")) "*/") "\n  " (span (|@| (class "keyword") (id "F:475754")) "if") " (" (span (|@| (class "negation-char") (id "F:475758")) "!") "FRAME_WINDOW_P (f)\n      && (" (span (|@| (class "negation-char") (id "F:475788")) "!") "FRAME_LINE_INS_DEL_OK (f)\n          || " (span (|@| (class "negation-char") (id "F:475821")) "!") "WINDOW_FULL_WIDTH_P (w)))\n    GIVE_UP (4);\n\n  " (span (|@| (class "comment-delimiter") (id "F:475868")) "/* ") (span (|@| (class "comment") (id "F:475871")) "Give up if point is known NOT to appear in W.  ") (span (|@| (class "comment-delimiter") (id "F:475918")) "*/") "\n  " (span (|@| (class "keyword") (id "F:475923")) "if") " (PT < CHARPOS (start))\n    GIVE_UP (5);\n\n  " (span (|@| (class "comment-delimiter") (id "F:475969")) "/* ") (span (|@| (class "comment") (id "F:475972")) "Another way to prevent redisplay optimizations.  ") (span (|@| (class "comment-delimiter") (id "F:476021")) "*/") "\n  " (span (|@| (class "keyword") (id "F:476026")) "if") " (XFASTINT (w->last_modified) == 0)\n    GIVE_UP (6);\n\n  " (span (|@| (class "comment-delimiter") (id "F:476084")) "/* ") (span (|@| (class "comment") (id "F:476087")) "Verify that window is not hscrolled.  ") (span (|@| (class "comment-delimiter") (id "F:476125")) "*/") "\n  " (span (|@| (class "keyword") (id "F:476130")) "if") " (XFASTINT (w->hscroll) != 0)\n    GIVE_UP (7);\n\n  " (span (|@| (class "comment-delimiter") (id "F:476182")) "/* ") (span (|@| (class "comment") (id "F:476185")) "Verify that display wasn't paused.  ") (span (|@| (class "comment-delimiter") (id "F:476221")) "*/") "\n  " (span (|@| (class "keyword") (id "F:476226")) "if") " (NILP (w->window_end_valid))\n    GIVE_UP (8);\n\n  " (span (|@| (class "comment-delimiter") (id "F:476278")) "/* ") (span (|@| (class "comment") (id "F:476281")) "Can't use this if highlighting a region because a cursor movement\n     will do more than just set the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:476392")) "*/") "\n  " (span (|@| (class "keyword") (id "F:476397")) "if") " (" (span (|@| (class "negation-char") (id "F:476401")) "!") "NILP (Vtransient_mark_mode)\n      && " (span (|@| (class "negation-char") (id "F:476439")) "!") "NILP (current_buffer->mark_active))\n    GIVE_UP (9);\n\n  " (span (|@| (class "comment-delimiter") (id "F:476496")) "/* ") (span (|@| (class "comment") (id "F:476499")) "Likewise if highlighting trailing whitespace.  ") (span (|@| (class "comment-delimiter") (id "F:476546")) "*/") "\n  " (span (|@| (class "keyword") (id "F:476551")) "if") " (" (span (|@| (class "negation-char") (id "F:476555")) "!") "NILP (Vshow_trailing_whitespace))\n    GIVE_UP (11);\n\n  " (span (|@| (class "comment-delimiter") (id "F:476611")) "/* ") (span (|@| (class "comment") (id "F:476614")) "Likewise if showing a region.  ") (span (|@| (class "comment-delimiter") (id "F:476645")) "*/") "\n  " (span (|@| (class "keyword") (id "F:476650")) "if") " (" (span (|@| (class "negation-char") (id "F:476654")) "!") "NILP (w->region_showing))\n    GIVE_UP (10);\n\n  " (span (|@| (class "comment-delimiter") (id "F:476702")) "/* ") (span (|@| (class "comment") (id "F:476705")) "Can't use this if overlay arrow position and/or string have\n     changed.  ") (span (|@| (class "comment-delimiter") (id "F:476780")) "*/") "\n  " (span (|@| (class "keyword") (id "F:476785")) "if") " (overlay_arrows_changed_p ())\n    GIVE_UP (12);\n\n  " (span (|@| (class "comment-delimiter") (id "F:476839")) "/* ") (span (|@| (class "comment") (id "F:476842")) "When word-wrap is on, adding a space to the first word of a\n     wrapped line can change the wrap position, altering the line\n     above it.  It might be worthwhile to handle this more\n     intelligently, but for now just redisplay from scratch.  ") (span (|@| (class "comment-delimiter") (id "F:477089")) "*/") "\n  " (span (|@| (class "keyword") (id "F:477094")) "if") " (" (span (|@| (class "negation-char") (id "F:477098")) "!") "NILP (XBUFFER (w->buffer)->word_wrap))\n    GIVE_UP (21);\n\n  " (span (|@| (class "comment-delimiter") (id "F:477159")) "/* ") (span (|@| (class "comment") (id "F:477162")) "Under bidi reordering, adding or deleting a character in the\n     beginning of a paragraph, before the first strong directional\n     character, can change the base direction of the paragraph (unless\n     the buffer specifies a fixed paragraph direction), which will\n     require to redisplay the whole paragraph.  It might be worthwhile\n     to find the paragraph limits and widen the range of redisplayed\n     lines to that, but for now just give up this optimization and\n     redisplay from scratch.  ") (span (|@| (class "comment-delimiter") (id "F:477665")) "*/") "\n  " (span (|@| (class "keyword") (id "F:477670")) "if") " (" (span (|@| (class "negation-char") (id "F:477674")) "!") "NILP (XBUFFER (w->buffer)->bidi_display_reordering)\n      && NILP (XBUFFER (w->buffer)->bidi_paragraph_direction))\n    GIVE_UP (22);\n\n  " (span (|@| (class "comment-delimiter") (id "F:477811")) "/* ") (span (|@| (class "comment") (id "F:477814")) "Make sure beg_unchanged and end_unchanged are up to date.  Do it\n     only if buffer has really changed.  The reason is that the gap is\n     initially at Z for freshly visited files.  The code below would\n     set end_unchanged to 0 in that case.  ") (span (|@| (class "comment-delimiter") (id "F:478062")) "*/") "\n  " (span (|@| (class "keyword") (id "F:478067")) "if") " (MODIFF > SAVE_MODIFF\n      " (span (|@| (class "comment-delimiter") (id "F:478098")) "/* ") (span (|@| (class "comment") (id "F:478101")) "This seems to happen sometimes after saving a buffer.  ") (span (|@| (class "comment-delimiter") (id "F:478156")) "*/") "\n      || BEG_UNCHANGED + END_UNCHANGED > Z_BYTE)\n    {\n      " (span (|@| (class "keyword") (id "F:478220")) "if") " (GPT - BEG < BEG_UNCHANGED)\n        BEG_UNCHANGED = GPT - BEG;\n      " (span (|@| (class "keyword") (id "F:478285")) "if") " (Z - GPT < END_UNCHANGED)\n        END_UNCHANGED = Z - GPT;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:478349")) "/* ") (span (|@| (class "comment") (id "F:478352")) "The position of the first and last character that has been changed.  ") (span (|@| (class "comment-delimiter") (id "F:478421")) "*/") "\n  first_changed_charpos = BEG + BEG_UNCHANGED;\n  last_changed_charpos  = Z - END_UNCHANGED;\n\n  " (span (|@| (class "comment-delimiter") (id "F:478519")) "/* ") (span (|@| (class "comment") (id "F:478522")) "If window starts after a line end, and the last change is in\n     front of that newline, then changes don't affect the display.\n     This case happens with stealth-fontification.  Note that although\n     the display is unchanged, glyph positions in the matrix have to\n     be adjusted, of course.  ") (span (|@| (class "comment-delimiter") (id "F:478820")) "*/") "\n  row = MATRIX_ROW (w->current_matrix, XFASTINT (w->window_end_vpos));\n  " (span (|@| (class "keyword") (id "F:478896")) "if") " (MATRIX_ROW_DISPLAYS_TEXT_P (row)\n      && ((last_changed_charpos < CHARPOS (start)\n           && CHARPOS (start) == BEGV)\n          || (last_changed_charpos < CHARPOS (start) - 1\n              && FETCH_BYTE (BYTEPOS (start) - 1) == " (span (|@| (class "string") (id "F:479111")) "'\\n'") ")))\n    {\n      " (span (|@| (class "type") (id "F:479131")) "int") " " (span (|@| (class "variable-name") (id "F:479135")) "Z_old") ", " (span (|@| (class "variable-name") (id "F:479142")) "delta") ", " (span (|@| (class "variable-name") (id "F:479149")) "Z_BYTE_old") ", " (span (|@| (class "variable-name") (id "F:479161")) "delta_bytes") ";\n      " (span (|@| (class "keyword") (id "F:479180")) "struct") " " (span (|@| (class "type") (id "F:479187")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:479198")) "r0") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:479209")) "/* ") (span (|@| (class "comment") (id "F:479212")) "Compute how many chars/bytes have been added to or removed\n         from the buffer.  ") (span (|@| (class "comment-delimiter") (id "F:479291")) "*/") "\n      Z_old = MATRIX_ROW_END_CHARPOS (row) + XFASTINT (w->window_end_pos);\n      Z_BYTE_old = MATRIX_ROW_END_BYTEPOS (row) + w->window_end_bytepos;\n      delta = Z - Z_old;\n      delta_bytes = Z_BYTE - Z_BYTE_old;\n\n      " (span (|@| (class "comment-delimiter") (id "F:479515")) "/* ") (span (|@| (class "comment") (id "F:479518")) "Give up if PT is not in the window.  Note that it already has\n         been checked at the start of try_window_id that PT is not in\n         front of the window start.  ") (span (|@| (class "comment-delimiter") (id "F:479673")) "*/") "\n      " (span (|@| (class "keyword") (id "F:479682")) "if") " (PT >= MATRIX_ROW_END_CHARPOS (row) + delta)\n        GIVE_UP (13);\n\n      " (span (|@| (class "comment-delimiter") (id "F:479752")) "/* ") (span (|@| (class "comment") (id "F:479755")) "If window start is unchanged, we can reuse the whole matrix\n         as is, after adjusting glyph positions.  No need to compute\n         the window end again, since its offset from Z hasn't changed.  ") (span (|@| (class "comment-delimiter") (id "F:479942")) "*/") "\n      r0 = MATRIX_FIRST_TEXT_ROW (current_matrix);\n      " (span (|@| (class "keyword") (id "F:480002")) "if") " (CHARPOS (start) == MATRIX_ROW_START_CHARPOS (r0) + delta\n          && BYTEPOS (start) == MATRIX_ROW_START_BYTEPOS (r0) + delta_bytes\n          " (span (|@| (class "comment-delimiter") (id "F:480135")) "/* ") (span (|@| (class "comment") (id "F:480138")) "PT must not be in a partially visible line.  ") (span (|@| (class "comment-delimiter") (id "F:480183")) "*/") "\n          && " (span (|@| (class "negation-char") (id "F:480192")) "!") "(PT >= MATRIX_ROW_START_CHARPOS (row) + delta\n               && MATRIX_ROW_BOTTOM_Y (row) > window_text_bottom_y (w)))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:480311")) "/* ") (span (|@| (class "comment") (id "F:480314")) "Adjust positions in the glyph matrix.  ") (span (|@| (class "comment-delimiter") (id "F:480353")) "*/") "\n          " (span (|@| (class "keyword") (id "F:480359")) "if") " (delta || delta_bytes)\n            {\n              " (span (|@| (class "keyword") (id "F:480399")) "struct") " " (span (|@| (class "type") (id "F:480406")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:480417")) "r1") "\n                = MATRIX_BOTTOM_TEXT_ROW (current_matrix, w);\n              increment_matrix_positions (w->current_matrix,\n                                          MATRIX_ROW_VPOS (r0, current_matrix),\n                                          MATRIX_ROW_VPOS (r1, current_matrix),\n                                          delta, delta_bytes);\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:480651")) "/* ") (span (|@| (class "comment") (id "F:480654")) "Set the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:480671")) "*/") "\n          row = row_containing_pos (w, PT, r0, " (span (|@| (class "constant") (id "F:480714")) "NULL") ", 0);\n          " (span (|@| (class "keyword") (id "F:480727")) "if") " (row)\n            set_cursor_from_row (w, row, current_matrix, 0, 0, 0, 0);\n          " (span (|@| (class "keyword") (id "F:480802")) "else") "\n            abort ();\n          " (span (|@| (class "keyword") (id "F:480825")) "return") " 1;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:480847")) "/* ") (span (|@| (class "comment") (id "F:480850")) "Handle the case that changes are all below what is displayed in\n     the window, and that PT is in the window.  This shortcut cannot\n     be taken if ZV is visible in the window, and text has been added\n     there that is visible in the window.  ") (span (|@| (class "comment-delimiter") (id "F:481096")) "*/") "\n  " (span (|@| (class "keyword") (id "F:481101")) "if") " (first_changed_charpos >= MATRIX_ROW_END_CHARPOS (row)\n      " (span (|@| (class "comment-delimiter") (id "F:481165")) "/* ") (span (|@| (class "comment") (id "F:481168")) "ZV is not visible in the window, or there are no\n         changes at ZV, actually.  ") (span (|@| (class "comment-delimiter") (id "F:481245")) "*/") "\n      && (current_matrix->zv > MATRIX_ROW_END_CHARPOS (row)\n          || first_changed_charpos == last_changed_charpos))\n    {\n      " (span (|@| (class "keyword") (id "F:481374")) "struct") " " (span (|@| (class "type") (id "F:481381")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:481392")) "r0") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:481403")) "/* ") (span (|@| (class "comment") (id "F:481406")) "Give up if PT is not in the window.  Note that it already has\n         been checked at the start of try_window_id that PT is not in\n         front of the window start.  ") (span (|@| (class "comment-delimiter") (id "F:481561")) "*/") "\n      " (span (|@| (class "keyword") (id "F:481570")) "if") " (PT >= MATRIX_ROW_END_CHARPOS (row))\n        GIVE_UP (14);\n\n      " (span (|@| (class "comment-delimiter") (id "F:481632")) "/* ") (span (|@| (class "comment") (id "F:481635")) "If window start is unchanged, we can reuse the whole matrix\n         as is, without changing glyph positions since no text has\n         been added/removed in front of the window end.  ") (span (|@| (class "comment-delimiter") (id "F:481805")) "*/") "\n      r0 = MATRIX_FIRST_TEXT_ROW (current_matrix);\n      " (span (|@| (class "keyword") (id "F:481865")) "if") " (TEXT_POS_EQUAL_P (start, r0->minpos)\n          " (span (|@| (class "comment-delimiter") (id "F:481909")) "/* ") (span (|@| (class "comment") (id "F:481912")) "PT must not be in a partially visible line.  ") (span (|@| (class "comment-delimiter") (id "F:481957")) "*/") "\n          && " (span (|@| (class "negation-char") (id "F:481966")) "!") "(PT >= MATRIX_ROW_START_CHARPOS (row)\n               && MATRIX_ROW_BOTTOM_Y (row) > window_text_bottom_y (w)))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:482077")) "/* ") (span (|@| (class "comment") (id "F:482080")) "We have to compute the window end anew since text\n             could have been added/removed after it.  ") (span (|@| (class "comment-delimiter") (id "F:482177")) "*/") "\n          w->window_end_pos\n            = make_number (Z - MATRIX_ROW_END_CHARPOS (row));\n          w->window_end_bytepos\n            = Z_BYTE - MATRIX_ROW_END_BYTEPOS (row);\n\n          " (span (|@| (class "comment-delimiter") (id "F:482331")) "/* ") (span (|@| (class "comment") (id "F:482334")) "Set the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:482351")) "*/") "\n          row = row_containing_pos (w, PT, r0, " (span (|@| (class "constant") (id "F:482394")) "NULL") ", 0);\n          " (span (|@| (class "keyword") (id "F:482407")) "if") " (row)\n            set_cursor_from_row (w, row, current_matrix, 0, 0, 0, 0);\n          " (span (|@| (class "keyword") (id "F:482482")) "else") "\n            abort ();\n          " (span (|@| (class "keyword") (id "F:482505")) "return") " 2;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:482527")) "/* ") (span (|@| (class "comment") (id "F:482530")) "Give up if window start is in the changed area.\n\n     The condition used to read\n\n     (BEG_UNCHANGED + END_UNCHANGED != Z - BEG && ...)\n\n     but why that was tested escapes me at the moment.  ") (span (|@| (class "comment-delimiter") (id "F:482724")) "*/") "\n  " (span (|@| (class "keyword") (id "F:482729")) "if") " (CHARPOS (start) >= first_changed_charpos\n      && CHARPOS (start) <= last_changed_charpos)\n    GIVE_UP (15);\n\n  " (span (|@| (class "comment-delimiter") (id "F:482845")) "/* ") (span (|@| (class "comment") (id "F:482848")) "Check that window start agrees with the start of the first glyph\n     row in its current matrix.  Check this after we know the window\n     start is not in changed text, otherwise positions would not be\n     comparable.  ") (span (|@| (class "comment-delimiter") (id "F:483068")) "*/") "\n  row = MATRIX_FIRST_TEXT_ROW (current_matrix);\n  " (span (|@| (class "keyword") (id "F:483121")) "if") " (" (span (|@| (class "negation-char") (id "F:483125")) "!") "TEXT_POS_EQUAL_P (start, row->minpos))\n    GIVE_UP (16);\n\n  " (span (|@| (class "comment-delimiter") (id "F:483186")) "/* ") (span (|@| (class "comment") (id "F:483189")) "Give up if the window ends in strings.  Overlay strings\n     at the end are difficult to handle, so don't try.  ") (span (|@| (class "comment-delimiter") (id "F:483301")) "*/") "\n  row = MATRIX_ROW (current_matrix, XFASTINT (w->window_end_vpos));\n  " (span (|@| (class "keyword") (id "F:483374")) "if") " (MATRIX_ROW_START_CHARPOS (row) == MATRIX_ROW_END_CHARPOS (row))\n    GIVE_UP (20);\n\n  " (span (|@| (class "comment-delimiter") (id "F:483463")) "/* ") (span (|@| (class "comment") (id "F:483466")) "Compute the position at which we have to start displaying new\n     lines.  Some of the lines at the top of the window might be\n     reusable because they are not displaying changed text.  Find the\n     last row in W's current matrix not affected by changes at the\n     start of current_buffer.  Value is null if changes start in the\n     first line of window.  ") (span (|@| (class "comment-delimiter") (id "F:483827")) "*/") "\n  last_unchanged_at_beg_row = find_last_unchanged_at_beg_row (w);\n  " (span (|@| (class "keyword") (id "F:483898")) "if") " (last_unchanged_at_beg_row)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:483941")) "/* ") (span (|@| (class "comment") (id "F:483944")) "Avoid starting to display in the moddle of a character, a TAB\n         for instance.  This is easier than to set up the iterator\n         exactly, and it's not a frequent case, so the additional\n         effort wouldn't really pay off.  ") (span (|@| (class "comment-delimiter") (id "F:484160")) "*/") "\n      " (span (|@| (class "keyword") (id "F:484169")) "while") " ((MATRIX_ROW_ENDS_IN_MIDDLE_OF_CHAR_P (last_unchanged_at_beg_row)\n              || last_unchanged_at_beg_row->ends_in_newline_from_string_p)\n             && last_unchanged_at_beg_row > w->current_matrix->rows)\n        --last_unchanged_at_beg_row;\n\n      " (span (|@| (class "keyword") (id "F:484408")) "if") " (MATRIX_ROW_ENDS_IN_MIDDLE_OF_CHAR_P (last_unchanged_at_beg_row))\n        GIVE_UP (17);\n\n      " (span (|@| (class "keyword") (id "F:484499")) "if") " (init_to_row_end (&it, w, last_unchanged_at_beg_row) == 0)\n        GIVE_UP (18);\n      start_pos = it.current.pos;\n\n      " (span (|@| (class "comment-delimiter") (id "F:484617")) "/* ") (span (|@| (class "comment") (id "F:484620")) "Start displaying new lines in the desired matrix at the same\n         vpos we would use in the current matrix, i.e. below\n         last_unchanged_at_beg_row.  ") (span (|@| (class "comment-delimiter") (id "F:484765")) "*/") "\n      it.vpos = 1 + MATRIX_ROW_VPOS (last_unchanged_at_beg_row,\n                                     current_matrix);\n      it.glyph_row = MATRIX_ROW (desired_matrix, it.vpos);\n      it.current_y = MATRIX_ROW_BOTTOM_Y (last_unchanged_at_beg_row);\n\n      xassert (it.hpos == 0 && it.current_x == 0);\n    }\n  " (span (|@| (class "keyword") (id "F:485047")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:485064")) "/* ") (span (|@| (class "comment") (id "F:485067")) "There are no reusable lines at the start of the window.\n         Start displaying in the first text line.  ") (span (|@| (class "comment-delimiter") (id "F:485167")) "*/") "\n      start_display (&it, w, start);\n      it.vpos = it.first_vpos;\n      start_pos = it.current.pos;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:485281")) "/* ") (span (|@| (class "comment") (id "F:485284")) "Find the first row that is not affected by changes at the end of\n     the buffer.  Value will be null if there is no unchanged row, in\n     which case we must redisplay to the end of the window.  delta\n     will be set to the value by which buffer positions beginning with\n     first_unchanged_at_end_row have to be adjusted due to text\n     changes.  ") (span (|@| (class "comment-delimiter") (id "F:485636")) "*/") "\n  first_unchanged_at_end_row\n    = find_first_unchanged_at_end_row (w, &delta, &delta_bytes);\n  IF_DEBUG (debug_delta = delta);\n  IF_DEBUG (debug_delta_bytes = delta_bytes);\n\n  " (span (|@| (class "comment-delimiter") (id "F:485816")) "/* ") (span (|@| (class "comment") (id "F:485819")) "Set stop_pos to the buffer position up to which we will have to\n     display new lines.  If first_unchanged_at_end_row != NULL, this\n     is the buffer position of the start of the line displayed in that\n     row.  For first_unchanged_at_end_row == NULL, use 0 to indicate\n     that we don't stop at a buffer position.  ") (span (|@| (class "comment-delimiter") (id "F:486139")) "*/") "\n  stop_pos = 0;\n  " (span (|@| (class "keyword") (id "F:486160")) "if") " (first_unchanged_at_end_row)\n    {\n      xassert (last_unchanged_at_beg_row == " (span (|@| (class "constant") (id "F:486242")) "NULL") "\n               || first_unchanged_at_end_row >= last_unchanged_at_beg_row);\n\n      " (span (|@| (class "comment-delimiter") (id "F:486323")) "/* ") (span (|@| (class "comment") (id "F:486326")) "If this is a continuation line, move forward to the next one\n         that isn't.  Changes in lines above affect this line.\n         Caution: this may move first_unchanged_at_end_row to a row\n         not displaying text.  ") (span (|@| (class "comment-delimiter") (id "F:486528")) "*/") "\n      " (span (|@| (class "keyword") (id "F:486537")) "while") " (MATRIX_ROW_CONTINUATION_LINE_P (first_unchanged_at_end_row)\n             && MATRIX_ROW_DISPLAYS_TEXT_P (first_unchanged_at_end_row)\n             && (MATRIX_ROW_BOTTOM_Y (first_unchanged_at_end_row)\n                 < it.last_visible_y))\n        ++first_unchanged_at_end_row;\n\n      " (span (|@| (class "keyword") (id "F:486791")) "if") " (" (span (|@| (class "negation-char") (id "F:486795")) "!") "MATRIX_ROW_DISPLAYS_TEXT_P (first_unchanged_at_end_row)\n          || (MATRIX_ROW_BOTTOM_Y (first_unchanged_at_end_row)\n              >= it.last_visible_y))\n        first_unchanged_at_end_row = " (span (|@| (class "constant") (id "F:486968")) "NULL") ";\n      " (span (|@| (class "keyword") (id "F:486980")) "else") "\n        {\n          stop_pos = (MATRIX_ROW_START_CHARPOS (first_unchanged_at_end_row)\n                      + delta);\n          first_unchanged_at_end_vpos\n            = MATRIX_ROW_VPOS (first_unchanged_at_end_row, current_matrix);\n          xassert (stop_pos >= Z - END_UNCHANGED);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:487230")) "else") " " (span (|@| (class "keyword") (id "F:487235")) "if") " (last_unchanged_at_beg_row == " (span (|@| (class "constant") (id "F:487268")) "NULL") ")\n    GIVE_UP (19);\n\n\n" (span (|@| (class "preprocessor") (id "F:487294")) "#if") " GLYPH_DEBUG\n\n  " (span (|@| (class "comment-delimiter") (id "F:487313")) "/* ") (span (|@| (class "comment") (id "F:487316")) "Either there is no unchanged row at the end, or the one we have\n     now displays text.  This is a necessary condition for the window\n     end pos calculation at the end of this function.  ") (span (|@| (class "comment-delimiter") (id "F:487505")) "*/") "\n  xassert (first_unchanged_at_end_row == " (span (|@| (class "constant") (id "F:487549")) "NULL") "\n           || MATRIX_ROW_DISPLAYS_TEXT_P (first_unchanged_at_end_row));\n\n  debug_last_unchanged_at_beg_vpos\n    = (last_unchanged_at_beg_row\n       ? MATRIX_ROW_VPOS (last_unchanged_at_beg_row, current_matrix)\n       : -1);\n  debug_first_unchanged_at_end_vpos = first_unchanged_at_end_vpos;\n\n" (span (|@| (class "preprocessor") (id "F:487839")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:487846")) "/* ") (span (|@| (class "comment") (id "F:487849")) "GLYPH_DEBUG != 0 ") (span (|@| (class "comment-delimiter") (id "F:487866")) "*/") "\n\n\n  " (span (|@| (class "comment-delimiter") (id "F:487873")) "/* ") (span (|@| (class "comment") (id "F:487876")) "Display new lines.  Set last_text_row to the last new line\n     displayed which has text on it, i.e. might end up as being the\n     line where the window_end_vpos is.  ") (span (|@| (class "comment-delimiter") (id "F:488044")) "*/") "\n  w->cursor.vpos = -1;\n  last_text_row = " (span (|@| (class "constant") (id "F:488088")) "NULL") ";\n  overlay_arrow_seen = 0;\n  " (span (|@| (class "keyword") (id "F:488122")) "while") " (it.current_y < it.last_visible_y\n         && " (span (|@| (class "negation-char") (id "F:488167")) "!") "fonts_changed_p\n         && (first_unchanged_at_end_row == " (span (|@| (class "constant") (id "F:488220")) "NULL") "\n             || IT_CHARPOS (it) < stop_pos))\n    {\n      " (span (|@| (class "keyword") (id "F:488275")) "if") " (display_line (&it))\n        last_text_row = it.glyph_row - 1;\n    }\n\n  " (span (|@| (class "keyword") (id "F:488343")) "if") " (fonts_changed_p)\n    " (span (|@| (class "keyword") (id "F:488368")) "return") " -1;\n\n\n  " (span (|@| (class "comment-delimiter") (id "F:488383")) "/* ") (span (|@| (class "comment") (id "F:488386")) "Compute differences in buffer positions, y-positions etc.  for\n     lines reused at the bottom of the window.  Compute what we can\n     scroll.  ") (span (|@| (class "comment-delimiter") (id "F:488531")) "*/") "\n  " (span (|@| (class "keyword") (id "F:488536")) "if") " (first_unchanged_at_end_row\n      " (span (|@| (class "comment-delimiter") (id "F:488573")) "/* ") (span (|@| (class "comment") (id "F:488576")) "No lines reused because we displayed everything up to the\n         bottom of the window.  ") (span (|@| (class "comment-delimiter") (id "F:488666")) "*/") "\n      && it.current_y < it.last_visible_y)\n    {\n      dvpos = (it.vpos\n               - MATRIX_ROW_VPOS (first_unchanged_at_end_row,\n                                  current_matrix));\n      dy = it.current_y - first_unchanged_at_end_row->y;\n      run.current_y = first_unchanged_at_end_row->y;\n      run.desired_y = run.current_y + dy;\n      run.height = it.last_visible_y - max (run.current_y, run.desired_y);\n    }\n  " (span (|@| (class "keyword") (id "F:489055")) "else") "\n    {\n      delta = delta_bytes = dvpos = dy\n        = run.current_y = run.desired_y = run.height = 0;\n      first_unchanged_at_end_row = " (span (|@| (class "constant") (id "F:489191")) "NULL") ";\n    }\n  IF_DEBUG (debug_dvpos = dvpos; debug_dy = dy);\n\n\n  " (span (|@| (class "comment-delimiter") (id "F:489256")) "/* ") (span (|@| (class "comment") (id "F:489259")) "Find the cursor if not already found.  We have to decide whether\n     PT will appear on this window (it sometimes doesn't, but this is\n     not a very frequent case.)  This decision has to be made before\n     the current matrix is altered.  A value of cursor.vpos < 0 means\n     that PT is either in one of the lines beginning at\n     first_unchanged_at_end_row or below the window.  Don't care for\n     lines that might be displayed later at the window end; as\n     mentioned, this is not a frequent case.  ") (span (|@| (class "comment-delimiter") (id "F:489767")) "*/") "\n  " (span (|@| (class "keyword") (id "F:489772")) "if") " (w->cursor.vpos < 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:489808")) "/* ") (span (|@| (class "comment") (id "F:489811")) "Cursor in unchanged rows at the top?  ") (span (|@| (class "comment-delimiter") (id "F:489849")) "*/") "\n      " (span (|@| (class "keyword") (id "F:489858")) "if") " (PT < CHARPOS (start_pos)\n          && last_unchanged_at_beg_row)\n        {\n          row = row_containing_pos (w, PT,\n                                    MATRIX_FIRST_TEXT_ROW (w->current_matrix),\n                                    last_unchanged_at_beg_row + 1, 0);\n          " (span (|@| (class "keyword") (id "F:490056")) "if") " (row)\n            set_cursor_from_row (w, row, w->current_matrix, 0, 0, 0, 0);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:490141")) "/* ") (span (|@| (class "comment") (id "F:490144")) "Start from first_unchanged_at_end_row looking for PT.  ") (span (|@| (class "comment-delimiter") (id "F:490199")) "*/") "\n      " (span (|@| (class "keyword") (id "F:490208")) "else") " " (span (|@| (class "keyword") (id "F:490213")) "if") " (first_unchanged_at_end_row)\n        {\n          row = row_containing_pos (w, PT - delta,\n                                    first_unchanged_at_end_row, " (span (|@| (class "constant") (id "F:490328")) "NULL") ", 0);\n          " (span (|@| (class "keyword") (id "F:490341")) "if") " (row)\n            set_cursor_from_row (w, row, w->current_matrix, delta,\n                                 delta_bytes, dy, dvpos);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:490450")) "/* ") (span (|@| (class "comment") (id "F:490453")) "Give up if cursor was not found.  ") (span (|@| (class "comment-delimiter") (id "F:490487")) "*/") "\n      " (span (|@| (class "keyword") (id "F:490496")) "if") " (w->cursor.vpos < 0)\n        {\n          clear_glyph_matrix (w->desired_matrix);\n          " (span (|@| (class "keyword") (id "F:490569")) "return") " -1;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:490592")) "/* ") (span (|@| (class "comment") (id "F:490595")) "Don't let the cursor end in the scroll margins.  ") (span (|@| (class "comment-delimiter") (id "F:490644")) "*/") "\n  {\n    " (span (|@| (class "type") (id "F:490655")) "int") " " (span (|@| (class "variable-name") (id "F:490659")) "this_scroll_margin") ", " (span (|@| (class "variable-name") (id "F:490679")) "cursor_height") ";\n\n    this_scroll_margin = max (0, scroll_margin);\n    this_scroll_margin = min (this_scroll_margin, WINDOW_TOTAL_LINES (w) / 4);\n    this_scroll_margin *= FRAME_LINE_HEIGHT (it.f);\n    cursor_height = MATRIX_ROW (w->desired_matrix, w->cursor.vpos)->height;\n\n    " (span (|@| (class "keyword") (id "F:490956")) "if") " ((w->cursor.y < this_scroll_margin\n         && CHARPOS (start) > BEGV)\n        " (span (|@| (class "comment-delimiter") (id "F:491024")) "/* ") (span (|@| (class "comment") (id "F:491027")) "Old redisplay didn't take scroll margin into account at the bottom,\n           but then global-hl-line-mode doesn't scroll.  KFS 2004-06-14 ") (span (|@| (class "comment-delimiter") (id "F:491160")) "*/") "\n        || (w->cursor.y + (make_cursor_line_fully_visible_p\n                           ? cursor_height + this_scroll_margin\n                           : 1)) > it.last_visible_y)\n      {\n        w->cursor.vpos = -1;\n        clear_glyph_matrix (w->desired_matrix);\n        " (span (|@| (class "keyword") (id "F:491364")) "return") " -1;\n      }\n  }\n\n  " (span (|@| (class "comment-delimiter") (id "F:491390")) "/* ") (span (|@| (class "comment") (id "F:491393")) "Scroll the display.  Do it before changing the current matrix so\n     that xterm.c doesn't get confused about where the cursor glyph is\n     found.  ") (span (|@| (class "comment-delimiter") (id "F:491542")) "*/") "\n  " (span (|@| (class "keyword") (id "F:491547")) "if") " (dy && run.height)\n    {\n      update_begin (f);\n\n      " (span (|@| (class "keyword") (id "F:491606")) "if") " (FRAME_WINDOW_P (f))\n        {\n          FRAME_RIF (f)->update_window_begin_hook (w);\n          FRAME_RIF (f)->clear_window_mouse_face (w);\n          FRAME_RIF (f)->scroll_run_hook (w, &run);\n          FRAME_RIF (f)->update_window_end_hook (w, 0, 0);\n        }\n      " (span (|@| (class "keyword") (id "F:491834")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:491845")) "/* ") (span (|@| (class "comment") (id "F:491848")) "Terminal frame.  In this case, dvpos gives the number of\n             lines to scroll by; dvpos < 0 means scroll up.  ") (span (|@| (class "comment-delimiter") (id "F:491959")) "*/") "\n          " (span (|@| (class "type") (id "F:491965")) "int") " " (span (|@| (class "variable-name") (id "F:491969")) "first_unchanged_at_end_vpos") "\n            = MATRIX_ROW_VPOS (first_unchanged_at_end_row, w->current_matrix);\n          " (span (|@| (class "type") (id "F:492072")) "int") " " (span (|@| (class "variable-name") (id "F:492076")) "from") " = WINDOW_TOP_EDGE_LINE (w) + first_unchanged_at_end_vpos;\n          " (span (|@| (class "type") (id "F:492142")) "int") " " (span (|@| (class "variable-name") (id "F:492146")) "end") " = (WINDOW_TOP_EDGE_LINE (w)\n                     + (WINDOW_WANTS_HEADER_LINE_P (w) ? 1 : 0)\n                     + window_internal_height (w));\n\n          " (span (|@| (class "comment-delimiter") (id "F:492270")) "/* ") (span (|@| (class "comment") (id "F:492273")) "Perform the operation on the screen.  ") (span (|@| (class "comment-delimiter") (id "F:492311")) "*/") "\n          " (span (|@| (class "keyword") (id "F:492317")) "if") " (dvpos > 0)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:492346")) "/* ") (span (|@| (class "comment") (id "F:492349")) "Scroll last_unchanged_at_beg_row to the end of the\n                 window down dvpos lines.  ") (span (|@| (class "comment-delimiter") (id "F:492429")) "*/") "\n              set_terminal_window (f, end);\n\n              " (span (|@| (class "comment-delimiter") (id "F:492477")) "/* ") (span (|@| (class "comment") (id "F:492480")) "On dumb terminals delete dvpos lines at the end\n                 before inserting dvpos empty lines.  ") (span (|@| (class "comment-delimiter") (id "F:492568")) "*/") "\n              " (span (|@| (class "keyword") (id "F:492578")) "if") " (" (span (|@| (class "negation-char") (id "F:492582")) "!") "FRAME_SCROLL_REGION_OK (f))\n                ins_del_lines (f, end - dvpos, -dvpos);\n\n              " (span (|@| (class "comment-delimiter") (id "F:492661")) "/* ") (span (|@| (class "comment") (id "F:492664")) "Insert dvpos empty lines in front of\n                 last_unchanged_at_beg_row.  ") (span (|@| (class "comment-delimiter") (id "F:492746")) "*/") "\n              ins_del_lines (f, from, dvpos);\n            }\n          " (span (|@| (class "keyword") (id "F:492798")) "else") " " (span (|@| (class "keyword") (id "F:492803")) "if") " (dvpos < 0)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:492832")) "/* ") (span (|@| (class "comment") (id "F:492835")) "Scroll up last_unchanged_at_beg_vpos to the end of\n                 the window to last_unchanged_at_beg_vpos - |dvpos|.  ") (span (|@| (class "comment-delimiter") (id "F:492942")) "*/") "\n              set_terminal_window (f, end);\n\n              " (span (|@| (class "comment-delimiter") (id "F:492990")) "/* ") (span (|@| (class "comment") (id "F:492993")) "Delete dvpos lines in front of\n                 last_unchanged_at_beg_vpos.  ins_del_lines will set\n                 the cursor to the given vpos and emit |dvpos| delete\n                 line sequences.  ") (span (|@| (class "comment-delimiter") (id "F:493155")) "*/") "\n              ins_del_lines (f, from + dvpos, dvpos);\n\n              " (span (|@| (class "comment-delimiter") (id "F:493213")) "/* ") (span (|@| (class "comment") (id "F:493216")) "On a dumb terminal insert dvpos empty lines at the\n                 end.  ") (span (|@| (class "comment-delimiter") (id "F:493290")) "*/") "\n              " (span (|@| (class "keyword") (id "F:493300")) "if") " (" (span (|@| (class "negation-char") (id "F:493304")) "!") "FRAME_SCROLL_REGION_OK (f))\n                ins_del_lines (f, end + dvpos, -dvpos);\n            }\n\n          set_terminal_window (f, 0);\n        }\n\n      update_end (f);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:493449")) "/* ") (span (|@| (class "comment") (id "F:493452")) "Shift reused rows of the current matrix to the right position.\n     BOTTOM_ROW is the last + 1 row in the current matrix reserved for\n     text.  ") (span (|@| (class "comment-delimiter") (id "F:493598")) "*/") "\n  bottom_row = MATRIX_BOTTOM_TEXT_ROW (current_matrix, w);\n  bottom_vpos = MATRIX_ROW_VPOS (bottom_row, current_matrix);\n  " (span (|@| (class "keyword") (id "F:493724")) "if") " (dvpos < 0)\n    {\n      rotate_matrix (current_matrix, first_unchanged_at_end_vpos + dvpos,\n                     bottom_vpos, dvpos);\n      enable_glyph_matrix_rows (current_matrix, bottom_vpos + dvpos,\n                                bottom_vpos, 0);\n    }\n  " (span (|@| (class "keyword") (id "F:493945")) "else") " " (span (|@| (class "keyword") (id "F:493950")) "if") " (dvpos > 0)\n    {\n      rotate_matrix (current_matrix, first_unchanged_at_end_vpos,\n                     bottom_vpos, dvpos);\n      enable_glyph_matrix_rows (current_matrix, first_unchanged_at_end_vpos,\n                                first_unchanged_at_end_vpos + dvpos, 0);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:494196")) "/* ") (span (|@| (class "comment") (id "F:494199")) "For frame-based redisplay, make sure that current frame and window\n     matrix are in sync with respect to glyph memory.  ") (span (|@| (class "comment-delimiter") (id "F:494321")) "*/") "\n  " (span (|@| (class "keyword") (id "F:494326")) "if") " (" (span (|@| (class "negation-char") (id "F:494330")) "!") "FRAME_WINDOW_P (f))\n    sync_frame_with_window_matrix_rows (w);\n\n  " (span (|@| (class "comment-delimiter") (id "F:494398")) "/* ") (span (|@| (class "comment") (id "F:494401")) "Adjust buffer positions in reused rows.  ") (span (|@| (class "comment-delimiter") (id "F:494442")) "*/") "\n  " (span (|@| (class "keyword") (id "F:494447")) "if") " (delta || delta_bytes)\n    increment_matrix_positions (current_matrix,\n                                first_unchanged_at_end_vpos + dvpos,\n                                bottom_vpos, delta, delta_bytes);\n\n  " (span (|@| (class "comment-delimiter") (id "F:494603")) "/* ") (span (|@| (class "comment") (id "F:494606")) "Adjust Y positions.  ") (span (|@| (class "comment-delimiter") (id "F:494627")) "*/") "\n  " (span (|@| (class "keyword") (id "F:494632")) "if") " (dy)\n    shift_glyph_matrix (w, current_matrix,\n                        first_unchanged_at_end_vpos + dvpos,\n                        bottom_vpos, dy);\n\n  " (span (|@| (class "keyword") (id "F:494747")) "if") " (first_unchanged_at_end_row)\n    {\n      first_unchanged_at_end_row += dvpos;\n      " (span (|@| (class "keyword") (id "F:494834")) "if") " (first_unchanged_at_end_row->y >= it.last_visible_y\n          || " (span (|@| (class "negation-char") (id "F:494895")) "!") "MATRIX_ROW_DISPLAYS_TEXT_P (first_unchanged_at_end_row))\n        first_unchanged_at_end_row = " (span (|@| (class "constant") (id "F:494983")) "NULL") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:494998")) "/* ") (span (|@| (class "comment") (id "F:495001")) "If scrolling up, there may be some lines to display at the end of\n     the window.  ") (span (|@| (class "comment-delimiter") (id "F:495085")) "*/") "\n  last_text_row_at_end = " (span (|@| (class "constant") (id "F:495113")) "NULL") ";\n  " (span (|@| (class "keyword") (id "F:495121")) "if") " (dy < 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:495145")) "/* ") (span (|@| (class "comment") (id "F:495148")) "Scrolling up can leave for example a partially visible line\n         at the end of the window to be redisplayed.  ") (span (|@| (class "comment-delimiter") (id "F:495255")) "*/") "\n      " (span (|@| (class "comment-delimiter") (id "F:495264")) "/* ") (span (|@| (class "comment") (id "F:495267")) "Set last_row to the glyph row in the current matrix where the\n         window end line is found.  It has been moved up or down in\n         the matrix by dvpos.  ") (span (|@| (class "comment-delimiter") (id "F:495414")) "*/") "\n      " (span (|@| (class "type") (id "F:495423")) "int") " " (span (|@| (class "variable-name") (id "F:495427")) "last_vpos") " = XFASTINT (w->window_end_vpos) + dvpos;\n      " (span (|@| (class "keyword") (id "F:495484")) "struct") " " (span (|@| (class "type") (id "F:495491")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:495502")) "last_row") " = MATRIX_ROW (current_matrix, last_vpos);\n\n      " (span (|@| (class "comment-delimiter") (id "F:495560")) "/* ") (span (|@| (class "comment") (id "F:495563")) "If last_row is the window end line, it should display text.  ") (span (|@| (class "comment-delimiter") (id "F:495624")) "*/") "\n      xassert (last_row->displays_text_p);\n\n      " (span (|@| (class "comment-delimiter") (id "F:495677")) "/* ") (span (|@| (class "comment") (id "F:495680")) "If window end line was partially visible before, begin\n         displaying at that line.  Otherwise begin displaying with the\n         line following it.  ") (span (|@| (class "comment-delimiter") (id "F:495821")) "*/") "\n      " (span (|@| (class "keyword") (id "F:495830")) "if") " (MATRIX_ROW_BOTTOM_Y (last_row) - dy >= it.last_visible_y)\n        {\n          init_to_row_start (&it, w, last_row);\n          it.vpos = last_vpos;\n          it.current_y = last_row->y;\n        }\n      " (span (|@| (class "keyword") (id "F:496000")) "else") "\n        {\n          init_to_row_end (&it, w, last_row);\n          it.vpos = 1 + last_vpos;\n          it.current_y = MATRIX_ROW_BOTTOM_Y (last_row);\n          ++last_row;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:496150")) "/* ") (span (|@| (class "comment") (id "F:496153")) "We may start in a continuation line.  If so, we have to\n         get the right continuation_lines_width and current_x.  ") (span (|@| (class "comment-delimiter") (id "F:496266")) "*/") "\n      it.continuation_lines_width = last_row->continuation_lines_width;\n      it.hpos = it.current_x = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:496382")) "/* ") (span (|@| (class "comment") (id "F:496385")) "Display the rest of the lines at the window end.  ") (span (|@| (class "comment-delimiter") (id "F:496435")) "*/") "\n      it.glyph_row = MATRIX_ROW (desired_matrix, it.vpos);\n      " (span (|@| (class "keyword") (id "F:496503")) "while") " (it.current_y < it.last_visible_y\n             && " (span (|@| (class "negation-char") (id "F:496552")) "!") "fonts_changed_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:496576")) "/* ") (span (|@| (class "comment") (id "F:496579")) "Is it always sure that the display agrees with lines in\n             the current matrix?  I don't think so, so we mark rows\n             displayed invalid in the current matrix by setting their\n             enabled_p flag to zero.  ") (span (|@| (class "comment-delimiter") (id "F:496790")) "*/") "\n          MATRIX_ROW (w->current_matrix, it.vpos)->enabled_p = 0;\n          " (span (|@| (class "keyword") (id "F:496855")) "if") " (display_line (&it))\n            last_text_row_at_end = it.glyph_row - 1;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:496937")) "/* ") (span (|@| (class "comment") (id "F:496940")) "Update window_end_pos and window_end_vpos.  ") (span (|@| (class "comment-delimiter") (id "F:496984")) "*/") "\n  " (span (|@| (class "keyword") (id "F:496989")) "if") " (first_unchanged_at_end_row\n      && " (span (|@| (class "negation-char") (id "F:497029")) "!") "last_text_row_at_end)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:497064")) "/* ") (span (|@| (class "comment") (id "F:497067")) "Window end line if one of the preserved rows from the current\n         matrix.  Set row to the last row displaying text in current\n         matrix starting at first_unchanged_at_end_row, after\n         scrolling.  ") (span (|@| (class "comment-delimiter") (id "F:497260")) "*/") "\n      xassert (first_unchanged_at_end_row->displays_text_p);\n      row = find_last_row_displaying_text (w->current_matrix, &it,\n                                           first_unchanged_at_end_row);\n      xassert (row && MATRIX_ROW_DISPLAYS_TEXT_P (row));\n\n      w->window_end_pos = make_number (Z - MATRIX_ROW_END_CHARPOS (row));\n      w->window_end_bytepos = Z_BYTE - MATRIX_ROW_END_BYTEPOS (row);\n      w->window_end_vpos\n        = make_number (MATRIX_ROW_VPOS (row, w->current_matrix));\n      xassert (w->window_end_bytepos >= 0);\n      IF_DEBUG (debug_method_add (w, " (span (|@| (class "string") (id "F:497794")) "\"A\"") "));\n    }\n  " (span (|@| (class "keyword") (id "F:497809")) "else") " " (span (|@| (class "keyword") (id "F:497814")) "if") " (last_text_row_at_end)\n    {\n      w->window_end_pos\n        = make_number (Z - MATRIX_ROW_END_CHARPOS (last_text_row_at_end));\n      w->window_end_bytepos\n        = Z_BYTE - MATRIX_ROW_END_BYTEPOS (last_text_row_at_end);\n      w->window_end_vpos\n        = make_number (MATRIX_ROW_VPOS (last_text_row_at_end, desired_matrix));\n      xassert (w->window_end_bytepos >= 0);\n      IF_DEBUG (debug_method_add (w, " (span (|@| (class "string") (id "F:498204")) "\"B\"") "));\n    }\n  " (span (|@| (class "keyword") (id "F:498219")) "else") " " (span (|@| (class "keyword") (id "F:498224")) "if") " (last_text_row)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:498255")) "/* ") (span (|@| (class "comment") (id "F:498258")) "We have displayed either to the end of the window or at the\n         end of the window, i.e. the last row with text is to be found\n         in the desired matrix.  ") (span (|@| (class "comment-delimiter") (id "F:498408")) "*/") "\n      w->window_end_pos\n        = make_number (Z - MATRIX_ROW_END_CHARPOS (last_text_row));\n      w->window_end_bytepos\n        = Z_BYTE - MATRIX_ROW_END_BYTEPOS (last_text_row);\n      w->window_end_vpos\n        = make_number (MATRIX_ROW_VPOS (last_text_row, desired_matrix));\n      xassert (w->window_end_bytepos >= 0);\n    }\n  " (span (|@| (class "keyword") (id "F:498719")) "else") " " (span (|@| (class "keyword") (id "F:498724")) "if") " (first_unchanged_at_end_row == " (span (|@| (class "constant") (id "F:498758")) "NULL") "\n           && last_text_row == " (span (|@| (class "constant") (id "F:498787")) "NULL") "\n           && last_text_row_at_end == " (span (|@| (class "constant") (id "F:498823")) "NULL") ")\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:498841")) "/* ") (span (|@| (class "comment") (id "F:498844")) "Displayed to end of window, but no line containing text was\n         displayed.  Lines were deleted at the end of the window.  ") (span (|@| (class "comment-delimiter") (id "F:498964")) "*/") "\n      " (span (|@| (class "type") (id "F:498973")) "int") " " (span (|@| (class "variable-name") (id "F:498977")) "first_vpos") " = WINDOW_WANTS_HEADER_LINE_P (w) ? 1 : 0;\n      " (span (|@| (class "type") (id "F:499036")) "int") " " (span (|@| (class "variable-name") (id "F:499040")) "vpos") " = XFASTINT (w->window_end_vpos);\n      " (span (|@| (class "keyword") (id "F:499084")) "struct") " " (span (|@| (class "type") (id "F:499091")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:499102")) "current_row") " = current_matrix->rows + vpos;\n      " (span (|@| (class "keyword") (id "F:499151")) "struct") " " (span (|@| (class "type") (id "F:499158")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:499169")) "desired_row") " = desired_matrix->rows + vpos;\n\n      " (span (|@| (class "keyword") (id "F:499219")) "for") " (row = " (span (|@| (class "constant") (id "F:499230")) "NULL") ";\n           row == " (span (|@| (class "constant") (id "F:499247")) "NULL") " && vpos >= first_vpos;\n           --vpos, --current_row, --desired_row)\n        {\n          " (span (|@| (class "keyword") (id "F:499323")) "if") " (desired_row->enabled_p)\n            {\n              " (span (|@| (class "keyword") (id "F:499365")) "if") " (desired_row->displays_text_p)\n                row = desired_row;\n            }\n          " (span (|@| (class "keyword") (id "F:499430")) "else") " " (span (|@| (class "keyword") (id "F:499435")) "if") " (current_row->displays_text_p)\n            row  = current_row;\n        }\n\n      xassert (row != " (span (|@| (class "constant") (id "F:499520")) "NULL") ");\n      w->window_end_vpos = make_number (vpos + 1);\n      w->window_end_pos = make_number (Z - MATRIX_ROW_END_CHARPOS (row));\n      w->window_end_bytepos = Z_BYTE - MATRIX_ROW_END_BYTEPOS (row);\n      xassert (w->window_end_bytepos >= 0);\n      IF_DEBUG (debug_method_add (w, " (span (|@| (class "string") (id "F:499802")) "\"C\"") "));\n    }\n  " (span (|@| (class "keyword") (id "F:499817")) "else") "\n    abort ();\n\n  IF_DEBUG (debug_end_pos = XFASTINT (w->window_end_pos);\n            debug_end_vpos = XFASTINT (w->window_end_vpos));\n\n  " (span (|@| (class "comment-delimiter") (id "F:499952")) "/* ") (span (|@| (class "comment") (id "F:499955")) "Record that display has not been completed.  ") (span (|@| (class "comment-delimiter") (id "F:500000")) "*/") "\n  w->window_end_valid = Qnil;\n  w->desired_matrix->no_scrolling_p = 1;\n  " (span (|@| (class "keyword") (id "F:500076")) "return") " 3;\n\n" (span (|@| (class "preprocessor") (id "F:500087")) "#undef") " GIVE_UP\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:500108")) "/***********************************************************************") (span (|@| (class "comment") (id "F:500180")) "\n                        More debugging support\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:500278")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:500282")) "#if") " GLYPH_DEBUG\n\n" (span (|@| (class "type") (id "F:500299")) "void") " " (span (|@| (class "function-name") (id "F:500304")) "dump_glyph_row") " P_ ((" (span (|@| (class "keyword") (id "F:500324")) "struct") " " (span (|@| (class "type") (id "F:500331")) "glyph_row") " *, " (span (|@| (class "type") (id "F:500344")) "int") ", " (span (|@| (class "type") (id "F:500349")) "int") "));\n" (span (|@| (class "type") (id "F:500356")) "void") " " (span (|@| (class "function-name") (id "F:500361")) "dump_glyph_matrix") " P_ ((" (span (|@| (class "keyword") (id "F:500384")) "struct") " " (span (|@| (class "type") (id "F:500391")) "glyph_matrix") " *, " (span (|@| (class "type") (id "F:500407")) "int") "));\n" (span (|@| (class "type") (id "F:500414")) "void") " " (span (|@| (class "function-name") (id "F:500419")) "dump_glyph") " P_ ((" (span (|@| (class "keyword") (id "F:500435")) "struct") " " (span (|@| (class "type") (id "F:500442")) "glyph_row") " *, " (span (|@| (class "keyword") (id "F:500455")) "struct") " " (span (|@| (class "type") (id "F:500462")) "glyph") " *, " (span (|@| (class "type") (id "F:500471")) "int") "));\n\n\n" (span (|@| (class "comment-delimiter") (id "F:500480")) "/* ") (span (|@| (class "comment") (id "F:500483")) "Dump the contents of glyph matrix MATRIX on stderr.\n\n   GLYPHS 0 means don't show glyph contents.\n   GLYPHS 1 means show glyphs in short form\n   GLYPHS > 1 means show glyphs in long form.  ") (span (|@| (class "comment-delimiter") (id "F:500672")) "*/") "\n\n" (span (|@| (class "type") (id "F:500676")) "void") "\n" (span (|@| (class "function-name") (id "F:500681")) "dump_glyph_matrix") " (matrix, glyphs)\n     " (span (|@| (class "keyword") (id "F:500721")) "struct") " " (span (|@| (class "type") (id "F:500728")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:500742")) "matrix") ";\n     " (span (|@| (class "type") (id "F:500755")) "int") " " (span (|@| (class "variable-name") (id "F:500759")) "glyphs") ";\n{\n  " (span (|@| (class "type") (id "F:500771")) "int") " " (span (|@| (class "variable-name") (id "F:500775")) "i") ";\n  " (span (|@| (class "keyword") (id "F:500780")) "for") " (i = 0; i < matrix->nrows; ++i)\n    dump_glyph_row (MATRIX_ROW (matrix, i), i, glyphs);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:500876")) "/* ") (span (|@| (class "comment") (id "F:500879")) "Dump contents of glyph GLYPH to stderr.  ROW and AREA are\n   the glyph row and area where the glyph comes from.  ") (span (|@| (class "comment-delimiter") (id "F:500992")) "*/") "\n\n" (span (|@| (class "type") (id "F:500996")) "void") "\n" (span (|@| (class "function-name") (id "F:501001")) "dump_glyph") " (row, " (span (|@| (class "type") (id "F:501018")) "glyph") ", area)\n     " (span (|@| (class "keyword") (id "F:501036")) "struct") " " (span (|@| (class "type") (id "F:501043")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:501054")) "row") ";\n     " (span (|@| (class "keyword") (id "F:501064")) "struct") " " (span (|@| (class "type") (id "F:501071")) "glyph") " *" (span (|@| (class "variable-name") (id "F:501078")) "glyph") ";\n     " (span (|@| (class "type") (id "F:501090")) "int") " " (span (|@| (class "variable-name") (id "F:501094")) "area") ";\n{\n  " (span (|@| (class "keyword") (id "F:501104")) "if") " (glyph->type == CHAR_GLYPH)\n    {\n      fprintf (stderr,\n               " (span (|@| (class "string") (id "F:501172")) "\"  %5d %4c %6d %c %3d 0x%05x %c %4d %1.1d%1.1d\\n\"") ",\n               glyph - row->glyphs[TEXT_AREA],\n               " (span (|@| (class "string") (id "F:501271")) "'C'") ",\n               glyph->charpos,\n               (BUFFERP (glyph->object)\n                ? " (span (|@| (class "string") (id "F:501337")) "'B'") "\n                : (STRINGP (glyph->object)\n                   ? " (span (|@| (class "string") (id "F:501377")) "'S'") "\n                   : " (span (|@| (class "string") (id "F:501388")) "'-'") ")),\n               glyph->pixel_width,\n               glyph->u.ch,\n               (glyph->u.ch < 0x80 && glyph->u.ch >= " (span (|@| (class "string") (id "F:501490")) "' '") "\n                ? glyph->u.ch\n                : " (span (|@| (class "string") (id "F:501514")) "'.'") "),\n               glyph->face_id,\n               glyph->left_box_line_p,\n               glyph->right_box_line_p);\n    }\n  " (span (|@| (class "keyword") (id "F:501618")) "else") " " (span (|@| (class "keyword") (id "F:501623")) "if") " (glyph->type == STRETCH_GLYPH)\n    {\n      fprintf (stderr,\n               " (span (|@| (class "string") (id "F:501694")) "\"  %5d %4c %6d %c %3d 0x%05x %c %4d %1.1d%1.1d\\n\"") ",\n               glyph - row->glyphs[TEXT_AREA],\n               " (span (|@| (class "string") (id "F:501793")) "'S'") ",\n               glyph->charpos,\n               (BUFFERP (glyph->object)\n                ? " (span (|@| (class "string") (id "F:501859")) "'B'") "\n                : (STRINGP (glyph->object)\n                   ? " (span (|@| (class "string") (id "F:501899")) "'S'") "\n                   : " (span (|@| (class "string") (id "F:501910")) "'-'") ")),\n               glyph->pixel_width,\n               0,\n               " (span (|@| (class "string") (id "F:501964")) "'.'") ",\n               glyph->face_id,\n               glyph->left_box_line_p,\n               glyph->right_box_line_p);\n    }\n  " (span (|@| (class "keyword") (id "F:502067")) "else") " " (span (|@| (class "keyword") (id "F:502072")) "if") " (glyph->type == IMAGE_GLYPH)\n    {\n      fprintf (stderr,\n               " (span (|@| (class "string") (id "F:502141")) "\"  %5d %4c %6d %c %3d 0x%05x %c %4d %1.1d%1.1d\\n\"") ",\n               glyph - row->glyphs[TEXT_AREA],\n               " (span (|@| (class "string") (id "F:502240")) "'I'") ",\n               glyph->charpos,\n               (BUFFERP (glyph->object)\n                ? " (span (|@| (class "string") (id "F:502306")) "'B'") "\n                : (STRINGP (glyph->object)\n                   ? " (span (|@| (class "string") (id "F:502346")) "'S'") "\n                   : " (span (|@| (class "string") (id "F:502357")) "'-'") ")),\n               glyph->pixel_width,\n               glyph->u.img_id,\n               " (span (|@| (class "string") (id "F:502425")) "'.'") ",\n               glyph->face_id,\n               glyph->left_box_line_p,\n               glyph->right_box_line_p);\n    }\n  " (span (|@| (class "keyword") (id "F:502528")) "else") " " (span (|@| (class "keyword") (id "F:502533")) "if") " (glyph->type == COMPOSITE_GLYPH)\n    {\n      fprintf (stderr,\n               " (span (|@| (class "string") (id "F:502606")) "\"  %5d %4c %6d %c %3d 0x%05x\"") ",\n               glyph - row->glyphs[TEXT_AREA],\n               " (span (|@| (class "string") (id "F:502685")) "'+'") ",\n               glyph->charpos,\n               (BUFFERP (glyph->object)\n                ? " (span (|@| (class "string") (id "F:502751")) "'B'") "\n                : (STRINGP (glyph->object)\n                   ? " (span (|@| (class "string") (id "F:502791")) "'S'") "\n                   : " (span (|@| (class "string") (id "F:502802")) "'-'") ")),\n               glyph->pixel_width,\n               glyph->u.cmp.id);\n      " (span (|@| (class "keyword") (id "F:502869")) "if") " (glyph->u.cmp.automatic)\n        fprintf (stderr,\n                 " (span (|@| (class "string") (id "F:502918")) "\"[%d-%d]\"") ",\n                 glyph->u.cmp.from, glyph->u.cmp.to);\n      fprintf (stderr, " (span (|@| (class "string") (id "F:502992")) "\" . %4d %1.1d%1.1d\\n\"") ",\n               glyph->face_id,\n               glyph->left_box_line_p,\n               glyph->right_box_line_p);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:503115")) "/* ") (span (|@| (class "comment") (id "F:503118")) "Dump the contents of glyph row at VPOS in MATRIX to stderr.\n   GLYPHS 0 means don't show glyph contents.\n   GLYPHS 1 means show glyphs in short form\n   GLYPHS > 1 means show glyphs in long form.  ") (span (|@| (class "comment-delimiter") (id "F:503314")) "*/") "\n\n" (span (|@| (class "type") (id "F:503318")) "void") "\n" (span (|@| (class "function-name") (id "F:503323")) "dump_glyph_row") " (row, vpos, glyphs)\n     " (span (|@| (class "keyword") (id "F:503363")) "struct") " " (span (|@| (class "type") (id "F:503370")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:503381")) "row") ";\n     " (span (|@| (class "type") (id "F:503391")) "int") " " (span (|@| (class "variable-name") (id "F:503395")) "vpos") ", " (span (|@| (class "variable-name") (id "F:503401")) "glyphs") ";\n{\n  " (span (|@| (class "keyword") (id "F:503413")) "if") " (glyphs != 1)\n    {\n      fprintf (stderr, " (span (|@| (class "string") (id "F:503459")) "\"Row Start   End Used oE><\\\\CTZFesm     X    Y    W    H    V    A    P\\n\"") ");\n      fprintf (stderr, " (span (|@| (class "string") (id "F:503559")) "\"======================================================================\\n\"") ");\n\n      fprintf (stderr, " (span (|@| (class "string") (id "F:503660")) "\"%3d %5d %5d %4d %1.1d%1.1d%1.1d%1.1d\\\n%1.1d%1.1d%1.1d%1.1d%1.1d%1.1d%1.1d%1.1d  %4d %4d %4d %4d %4d %4d %4d\\n\"") ",\n               vpos,\n               MATRIX_ROW_START_CHARPOS (row),\n               MATRIX_ROW_END_CHARPOS (row),\n               row->used[TEXT_AREA],\n               row->contains_overlapping_glyphs_p,\n               row->enabled_p,\n               row->truncated_on_left_p,\n               row->truncated_on_right_p,\n               row->continued_p,\n               MATRIX_ROW_CONTINUATION_LINE_P (row),\n               row->displays_text_p,\n               row->ends_at_zv_p,\n               row->fill_line_p,\n               row->ends_in_middle_of_char_p,\n               row->starts_in_middle_of_char_p,\n               row->mouse_face_p,\n               row->x,\n               row->y,\n               row->pixel_width,\n               row->height,\n               row->visible_height,\n               row->ascent,\n               row->phys_ascent);\n      fprintf (stderr, " (span (|@| (class "string") (id "F:504473")) "\"%9d %5d\\t%5d\\n\"") ", row->start.overlay_string_index,\n               row->end.overlay_string_index,\n               row->continuation_lines_width);\n      fprintf (stderr, " (span (|@| (class "string") (id "F:504626")) "\"%9d %5d\\n\"") ",\n               CHARPOS (row->start.string_pos),\n               CHARPOS (row->end.string_pos));\n      fprintf (stderr, " (span (|@| (class "string") (id "F:504743")) "\"%9d %5d\\n\"") ", row->start.dpvec_index,\n               row->end.dpvec_index);\n    }\n\n  " (span (|@| (class "keyword") (id "F:504820")) "if") " (glyphs > 1)\n    {\n      " (span (|@| (class "type") (id "F:504848")) "int") " " (span (|@| (class "variable-name") (id "F:504852")) "area") ";\n\n      " (span (|@| (class "keyword") (id "F:504865")) "for") " (area = LEFT_MARGIN_AREA; area < LAST_AREA; ++area)\n        {\n          " (span (|@| (class "keyword") (id "F:504927")) "struct") " " (span (|@| (class "type") (id "F:504934")) "glyph") " *" (span (|@| (class "variable-name") (id "F:504941")) "glyph") " = row->glyphs[area];\n          " (span (|@| (class "keyword") (id "F:504971")) "struct") " " (span (|@| (class "type") (id "F:504978")) "glyph") " *" (span (|@| (class "variable-name") (id "F:504985")) "glyph_end") " = glyph + row->used[area];\n\n          " (span (|@| (class "comment-delimiter") (id "F:505026")) "/* ") (span (|@| (class "comment") (id "F:505029")) "Glyph for a line end in text.  ") (span (|@| (class "comment-delimiter") (id "F:505060")) "*/") "\n          " (span (|@| (class "keyword") (id "F:505066")) "if") " (area == TEXT_AREA && glyph == glyph_end && glyph->charpos > 0)\n            ++glyph_end;\n\n          " (span (|@| (class "keyword") (id "F:505155")) "if") " (glyph < glyph_end)\n            fprintf (stderr, " (span (|@| (class "string") (id "F:505200")) "\"  Glyph    Type Pos   O W    Code C Face LR\\n\"") ");\n\n          " (span (|@| (class "keyword") (id "F:505254")) "for") " (; glyph < glyph_end; ++glyph)\n            dump_glyph (row, glyph, area);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:505336")) "else") " " (span (|@| (class "keyword") (id "F:505341")) "if") " (glyphs == 1)\n    {\n      " (span (|@| (class "type") (id "F:505370")) "int") " " (span (|@| (class "variable-name") (id "F:505374")) "area") ";\n\n      " (span (|@| (class "keyword") (id "F:505387")) "for") " (area = LEFT_MARGIN_AREA; area < LAST_AREA; ++area)\n        {\n          " (span (|@| (class "type") (id "F:505449")) "char") " *" (span (|@| (class "variable-name") (id "F:505455")) "s") " = (" (span (|@| (class "type") (id "F:505460")) "char") " *) alloca (row->used[area] + 1);\n          " (span (|@| (class "type") (id "F:505501")) "int") " " (span (|@| (class "variable-name") (id "F:505505")) "i") ";\n\n          " (span (|@| (class "keyword") (id "F:505512")) "for") " (i = 0; i < row->used[area]; ++i)\n            {\n              " (span (|@| (class "keyword") (id "F:505564")) "struct") " " (span (|@| (class "type") (id "F:505571")) "glyph") " *" (span (|@| (class "variable-name") (id "F:505578")) "glyph") " = row->glyphs[area] + i;\n              " (span (|@| (class "keyword") (id "F:505616")) "if") " (glyph->type == CHAR_GLYPH\n                  && glyph->u.ch < 0x80\n                  && glyph->u.ch >= " (span (|@| (class "string") (id "F:505694")) "' '") ")\n                s[i] = glyph->u.ch;\n              " (span (|@| (class "keyword") (id "F:505728")) "else") "\n                s[i] = " (span (|@| (class "string") (id "F:505742")) "'.'") ";\n            }\n\n          s[i] = " (span (|@| (class "string") (id "F:505765")) "'\\0'") ";\n          fprintf (stderr, " (span (|@| (class "string") (id "F:505791")) "\"%3d: (%d) '%s'\\n\"") ", vpos, row->enabled_p, s);\n        }\n    }\n}\n\n\nDEFUN (" (span (|@| (class "string") (id "F:505857")) "\"dump-glyph-matrix\"") ", Fdump_glyph_matrix,\n       Sdump_glyph_matrix, 0, 1, " (span (|@| (class "string") (id "F:505931")) "\"p\"") ",\n       doc: " (span (|@| (class "comment-delimiter") (id "F:505948")) "/* ") (span (|@| (class "comment") (id "F:505951")) "Dump the current matrix of the selected window to stderr.\nShows contents of glyph row structures.  With non-nil\nparameter GLYPHS, dump glyphs as well.  If GLYPHS is 1 show\nglyphs in short form, otherwise show glyphs in long form.  ") (span (|@| (class "comment-delimiter") (id "F:506182")) "*/") ")\n     (glyphs)\n     " (span (|@| (class "type") (id "F:506205")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:506217")) "glyphs") ";\n{\n  " (span (|@| (class "keyword") (id "F:506229")) "struct") " " (span (|@| (class "type") (id "F:506236")) "window") " *" (span (|@| (class "variable-name") (id "F:506244")) "w") " = XWINDOW (selected_window);\n  " (span (|@| (class "keyword") (id "F:506277")) "struct") " " (span (|@| (class "type") (id "F:506284")) "buffer") " *" (span (|@| (class "variable-name") (id "F:506292")) "buffer") " = XBUFFER (w->buffer);\n\n  fprintf (stderr, " (span (|@| (class "string") (id "F:506342")) "\"PT = %d, BEGV = %d. ZV = %d\\n\"") ",\n           BUF_PT (buffer), BUF_BEGV (buffer), BUF_ZV (buffer));\n  fprintf (stderr, " (span (|@| (class "string") (id "F:506452")) "\"Cursor x = %d, y = %d, hpos = %d, vpos = %d\\n\"") ",\n           w->cursor.x, w->cursor.y, w->cursor.hpos, w->cursor.vpos);\n  fprintf (stderr, " (span (|@| (class "string") (id "F:506583")) "\"=============================================\\n\"") ");\n  dump_glyph_matrix (w->current_matrix,\n                     NILP (glyphs) ? 0 : XINT (glyphs));\n  " (span (|@| (class "keyword") (id "F:506720")) "return") " Qnil;\n}\n\n\n" (span (|@| (class "function-name") (id "F:506737")) "DEFUN") " (" (span (|@| (class "string") (id "F:506744")) "\"dump-frame-glyph-matrix\"") ", Fdump_frame_glyph_matrix,\n       Sdump_frame_glyph_matrix, 0, 0, " (span (|@| (class "string") (id "F:506836")) "\"\"") ", doc: " (span (|@| (class "comment-delimiter") (id "F:506845")) "/* */") ")\n     ()\n{\n  " (span (|@| (class "keyword") (id "F:506864")) "struct") " " (span (|@| (class "type") (id "F:506871")) "frame") " *" (span (|@| (class "variable-name") (id "F:506878")) "f") " = XFRAME (selected_frame);\n  dump_glyph_matrix (f->current_matrix, 1);\n  " (span (|@| (class "keyword") (id "F:506953")) "return") " Qnil;\n}\n\n\nDEFUN (" (span (|@| (class "string") (id "F:506977")) "\"dump-glyph-row\"") ", Fdump_glyph_row, Sdump_glyph_row, 1, 2, " (span (|@| (class "string") (id "F:507035")) "\"\"") ",\n       doc: " (span (|@| (class "comment-delimiter") (id "F:507051")) "/* ") (span (|@| (class "comment") (id "F:507054")) "Dump glyph row ROW to stderr.\nGLYPH 0 means don't dump glyphs.\nGLYPH 1 means dump glyphs in short form.\nGLYPH > 1 or omitted means dump glyphs in long form.  ") (span (|@| (class "comment-delimiter") (id "F:507212")) "*/") ")\n     (row, glyphs)\n     " (span (|@| (class "type") (id "F:507240")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:507252")) "row") ", " (span (|@| (class "variable-name") (id "F:507257")) "glyphs") ";\n{\n  " (span (|@| (class "keyword") (id "F:507269")) "struct") " " (span (|@| (class "type") (id "F:507276")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:507290")) "matrix") ";\n  " (span (|@| (class "type") (id "F:507300")) "int") " " (span (|@| (class "variable-name") (id "F:507304")) "vpos") ";\n\n  CHECK_NUMBER (row);\n  matrix = XWINDOW (selected_window)->current_matrix;\n  vpos = XINT (row);\n  " (span (|@| (class "keyword") (id "F:507410")) "if") " (vpos >= 0 && vpos < matrix->nrows)\n    dump_glyph_row (MATRIX_ROW (matrix, vpos),\n                    vpos,\n                    INTEGERP (glyphs) ? XINT (glyphs) : 2);\n  " (span (|@| (class "keyword") (id "F:507556")) "return") " Qnil;\n}\n\n\nDEFUN (" (span (|@| (class "string") (id "F:507580")) "\"dump-tool-bar-row\"") ", Fdump_tool_bar_row, Sdump_tool_bar_row, 1, 2, " (span (|@| (class "string") (id "F:507647")) "\"\"") ",\n       doc: " (span (|@| (class "comment-delimiter") (id "F:507663")) "/* ") (span (|@| (class "comment") (id "F:507666")) "Dump glyph row ROW of the tool-bar of the current frame to stderr.\nGLYPH 0 means don't dump glyphs.\nGLYPH 1 means dump glyphs in short form.\nGLYPH > 1 or omitted means dump glyphs in long form.  ") (span (|@| (class "comment-delimiter") (id "F:507861")) "*/") ")\n     (row, glyphs)\n     " (span (|@| (class "type") (id "F:507889")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:507901")) "row") ", " (span (|@| (class "variable-name") (id "F:507906")) "glyphs") ";\n{\n  " (span (|@| (class "keyword") (id "F:507918")) "struct") " " (span (|@| (class "type") (id "F:507925")) "frame") " *" (span (|@| (class "variable-name") (id "F:507932")) "sf") " = SELECTED_FRAME ();\n  " (span (|@| (class "keyword") (id "F:507958")) "struct") " " (span (|@| (class "type") (id "F:507965")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:507979")) "m") " = XWINDOW (sf->tool_bar_window)->current_matrix;\n  " (span (|@| (class "type") (id "F:508032")) "int") " " (span (|@| (class "variable-name") (id "F:508036")) "vpos") ";\n\n  CHECK_NUMBER (row);\n  vpos = XINT (row);\n  " (span (|@| (class "keyword") (id "F:508088")) "if") " (vpos >= 0 && vpos < m->nrows)\n    dump_glyph_row (MATRIX_ROW (m, vpos), vpos,\n                    INTEGERP (glyphs) ? XINT (glyphs) : 2);\n  " (span (|@| (class "keyword") (id "F:508218")) "return") " Qnil;\n}\n\n\nDEFUN (" (span (|@| (class "string") (id "F:508242")) "\"trace-redisplay\"") ", Ftrace_redisplay, Strace_redisplay, 0, 1, " (span (|@| (class "string") (id "F:508303")) "\"P\"") ",\n       doc: " (span (|@| (class "comment-delimiter") (id "F:508320")) "/* ") (span (|@| (class "comment") (id "F:508323")) "Toggle tracing of redisplay.\nWith ARG, turn tracing on if and only if ARG is positive.  ") (span (|@| (class "comment-delimiter") (id "F:508411")) "*/") ")\n     (arg)\n     " (span (|@| (class "type") (id "F:508431")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:508443")) "arg") ";\n{\n  " (span (|@| (class "keyword") (id "F:508452")) "if") " (NILP (arg))\n    trace_redisplay_p = " (span (|@| (class "negation-char") (id "F:508492")) "!") "trace_redisplay_p;\n  " (span (|@| (class "keyword") (id "F:508514")) "else") "\n    {\n      arg = Fprefix_numeric_value (arg);\n      trace_redisplay_p = XINT (arg) > 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:508617")) "return") " Qnil;\n}\n\n\nDEFUN (" (span (|@| (class "string") (id "F:508641")) "\"trace-to-stderr\"") ", Ftrace_to_stderr, Strace_to_stderr, 1, MANY, " (span (|@| (class "string") (id "F:508705")) "\"\"") ",\n       doc: " (span (|@| (class "comment-delimiter") (id "F:508721")) "/* ") (span (|@| (class "comment") (id "F:508724")) "Like `format', but print result to stderr.\nusage: (trace-to-stderr STRING &rest OBJECTS)  ") (span (|@| (class "comment-delimiter") (id "F:508814")) "*/") ")\n     (nargs, args)\n     " (span (|@| (class "type") (id "F:508842")) "int") " " (span (|@| (class "variable-name") (id "F:508846")) "nargs") ";\n     " (span (|@| (class "type") (id "F:508858")) "Lisp_Object") " *" (span (|@| (class "variable-name") (id "F:508871")) "args") ";\n{\n  " (span (|@| (class "type") (id "F:508881")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:508893")) "s") " = Fformat (nargs, args);\n  fprintf (stderr, " (span (|@| (class "string") (id "F:508939")) "\"%s\"") ", SDATA (s));\n  " (span (|@| (class "keyword") (id "F:508959")) "return") " Qnil;\n}\n\n" (span (|@| (class "preprocessor") (id "F:508975")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:508982")) "/* ") (span (|@| (class "comment") (id "F:508985")) "GLYPH_DEBUG ") (span (|@| (class "comment-delimiter") (id "F:508997")) "*/") "\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:509004")) "/***********************************************************************") (span (|@| (class "comment") (id "F:509076")) "\n                     Building Desired Matrix Rows\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:509184")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:509188")) "/* ") (span (|@| (class "comment") (id "F:509191")) "Return a temporary glyph row holding the glyphs of an overlay arrow.\n   Used for non-window-redisplay windows, and for windows w/o left fringe.  ") (span (|@| (class "comment-delimiter") (id "F:509336")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:509340")) "static") " " (span (|@| (class "keyword") (id "F:509347")) "struct") " " (span (|@| (class "type") (id "F:509354")) "glyph_row") " *\n" (span (|@| (class "function-name") (id "F:509366")) "get_overlay_arrow_glyph_row") " (w, overlay_arrow_string)\n     " (span (|@| (class "keyword") (id "F:509425")) "struct") " " (span (|@| (class "type") (id "F:509432")) "window") " *" (span (|@| (class "variable-name") (id "F:509440")) "w") ";\n     " (span (|@| (class "type") (id "F:509448")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:509460")) "overlay_arrow_string") ";\n{\n  " (span (|@| (class "keyword") (id "F:509486")) "struct") " " (span (|@| (class "type") (id "F:509493")) "frame") " *" (span (|@| (class "variable-name") (id "F:509500")) "f") " = XFRAME (WINDOW_FRAME (w));\n  " (span (|@| (class "keyword") (id "F:509533")) "struct") " " (span (|@| (class "type") (id "F:509540")) "buffer") " *" (span (|@| (class "variable-name") (id "F:509548")) "buffer") " = XBUFFER (w->buffer);\n  " (span (|@| (class "keyword") (id "F:509580")) "struct") " " (span (|@| (class "type") (id "F:509587")) "buffer") " *" (span (|@| (class "variable-name") (id "F:509595")) "old") " = current_buffer;\n  " (span (|@| (class "keyword") (id "F:509619")) "const") " " (span (|@| (class "type") (id "F:509625")) "unsigned") " " (span (|@| (class "type") (id "F:509634")) "char") " *" (span (|@| (class "variable-name") (id "F:509640")) "arrow_string") " = SDATA (overlay_arrow_string);\n  " (span (|@| (class "type") (id "F:509687")) "int") " " (span (|@| (class "variable-name") (id "F:509691")) "arrow_len") " = SCHARS (overlay_arrow_string);\n  " (span (|@| (class "keyword") (id "F:509736")) "const") " " (span (|@| (class "type") (id "F:509742")) "unsigned") " " (span (|@| (class "type") (id "F:509751")) "char") " *" (span (|@| (class "variable-name") (id "F:509757")) "arrow_end") " = arrow_string + arrow_len;\n  " (span (|@| (class "keyword") (id "F:509797")) "const") " " (span (|@| (class "type") (id "F:509803")) "unsigned") " " (span (|@| (class "type") (id "F:509812")) "char") " *" (span (|@| (class "variable-name") (id "F:509818")) "p") ";\n  " (span (|@| (class "keyword") (id "F:509823")) "struct") " " (span (|@| (class "type") (id "F:509830")) "it") " " (span (|@| (class "variable-name") (id "F:509833")) "it") ";\n  " (span (|@| (class "type") (id "F:509839")) "int") " " (span (|@| (class "variable-name") (id "F:509843")) "multibyte_p") ";\n  " (span (|@| (class "type") (id "F:509858")) "int") " " (span (|@| (class "variable-name") (id "F:509862")) "n_glyphs_before") ";\n\n  set_buffer_temp (buffer);\n  init_iterator (&it, w, -1, -1, &scratch_glyph_row, DEFAULT_FACE_ID);\n  it.glyph_row->used[TEXT_AREA] = 0;\n  SET_TEXT_POS (it.position, 0, 0);\n\n  multibyte_p = " (span (|@| (class "negation-char") (id "F:510069")) "!") "NILP (buffer->enable_multibyte_characters);\n  p = arrow_string;\n  " (span (|@| (class "keyword") (id "F:510136")) "while") " (p < arrow_end)\n    {\n      " (span (|@| (class "type") (id "F:510170")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:510182")) "face") ", " (span (|@| (class "variable-name") (id "F:510188")) "ilisp") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:510202")) "/* ") (span (|@| (class "comment") (id "F:510205")) "Get the next character.  ") (span (|@| (class "comment-delimiter") (id "F:510230")) "*/") "\n      " (span (|@| (class "keyword") (id "F:510239")) "if") " (multibyte_p)\n        it.c = string_char_and_length (p, &it.len);\n      " (span (|@| (class "keyword") (id "F:510307")) "else") "\n        it.c = *p, it.len = 1;\n      p += it.len;\n\n      " (span (|@| (class "comment-delimiter") (id "F:510362")) "/* ") (span (|@| (class "comment") (id "F:510365")) "Get its face.  ") (span (|@| (class "comment-delimiter") (id "F:510380")) "*/") "\n      ilisp = make_number (p - arrow_string);\n      face = Fget_text_property (ilisp, Qface, overlay_arrow_string);\n      it.face_id = compute_char_face (f, it.c, face);\n\n      " (span (|@| (class "comment-delimiter") (id "F:510560")) "/* ") (span (|@| (class "comment") (id "F:510563")) "Compute its width, get its glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:510599")) "*/") "\n      n_glyphs_before = it.glyph_row->used[TEXT_AREA];\n      SET_TEXT_POS (it.position, -1, -1);\n      PRODUCE_GLYPHS (&it);\n\n      " (span (|@| (class "comment-delimiter") (id "F:510734")) "/* ") (span (|@| (class "comment") (id "F:510737")) "If this character doesn't fit any more in the line, we have\n         to remove some glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:510823")) "*/") "\n      " (span (|@| (class "keyword") (id "F:510832")) "if") " (it.current_x > it.last_visible_x)\n        {\n          it.glyph_row->used[TEXT_AREA] = n_glyphs_before;\n          " (span (|@| (class "keyword") (id "F:510928")) "break") ";\n        }\n    }\n\n  set_buffer_temp (old);\n  " (span (|@| (class "keyword") (id "F:510972")) "return") " it.glyph_row;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:510997")) "/* ") (span (|@| (class "comment") (id "F:511000")) "Insert truncation glyphs at the start of IT->glyph_row.  Truncation\n   glyphs are only inserted for terminal frames since we can't really\n   win with truncation glyphs when partially visible glyphs are\n   involved.  Which glyphs to insert is determined by\n   produce_special_glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:511284")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:511288")) "static") " " (span (|@| (class "type") (id "F:511295")) "void") "\n" (span (|@| (class "function-name") (id "F:511300")) "insert_left_trunc_glyphs") " (" (span (|@| (class "type") (id "F:511326")) "it") ")\n     " (span (|@| (class "keyword") (id "F:511335")) "struct") " " (span (|@| (class "type") (id "F:511342")) "it") " *" (span (|@| (class "variable-name") (id "F:511346")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:511354")) "struct") " " (span (|@| (class "type") (id "F:511361")) "it") " " (span (|@| (class "variable-name") (id "F:511364")) "truncate_it") ";\n  " (span (|@| (class "keyword") (id "F:511379")) "struct") " " (span (|@| (class "type") (id "F:511386")) "glyph") " *" (span (|@| (class "variable-name") (id "F:511393")) "from") ", *" (span (|@| (class "variable-name") (id "F:511400")) "end") ", *" (span (|@| (class "variable-name") (id "F:511406")) "to") ", *" (span (|@| (class "variable-name") (id "F:511411")) "toend") ";\n\n  xassert (" (span (|@| (class "negation-char") (id "F:511430")) "!") "FRAME_WINDOW_P (it->f));\n\n  " (span (|@| (class "comment-delimiter") (id "F:511459")) "/* ") (span (|@| (class "comment") (id "F:511462")) "Get the truncation glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:511490")) "*/") "\n  truncate_it = *it;\n  truncate_it.current_x = 0;\n  truncate_it.face_id = DEFAULT_FACE_ID;\n  truncate_it.glyph_row = &scratch_glyph_row;\n  truncate_it.glyph_row->used[TEXT_AREA] = 0;\n  CHARPOS (truncate_it.position) = BYTEPOS (truncate_it.position) = -1;\n  truncate_it.object = make_number (0);\n  produce_special_glyphs (&truncate_it, IT_TRUNCATION);\n\n  " (span (|@| (class "comment-delimiter") (id "F:511847")) "/* ") (span (|@| (class "comment") (id "F:511850")) "Overwrite glyphs from IT with truncation glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:511900")) "*/") "\n  " (span (|@| (class "keyword") (id "F:511905")) "if") " (" (span (|@| (class "negation-char") (id "F:511909")) "!") "it->glyph_row->reversed_p)\n    {\n      from = truncate_it.glyph_row->glyphs[TEXT_AREA];\n      end = from + truncate_it.glyph_row->used[TEXT_AREA];\n      to = it->glyph_row->glyphs[TEXT_AREA];\n      toend = to + it->glyph_row->used[TEXT_AREA];\n\n      " (span (|@| (class "keyword") (id "F:512160")) "while") " (from < end)\n        *to++ = *from++;\n\n      " (span (|@| (class "comment-delimiter") (id "F:512204")) "/* ") (span (|@| (class "comment") (id "F:512207")) "There may be padding glyphs left over.  Overwrite them too.  ") (span (|@| (class "comment-delimiter") (id "F:512268")) "*/") "\n      " (span (|@| (class "keyword") (id "F:512277")) "while") " (to < toend && CHAR_GLYPH_PADDING_P (*to))\n        {\n          from = truncate_it.glyph_row->glyphs[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:512384")) "while") " (from < end)\n            *to++ = *from++;\n        }\n\n      " (span (|@| (class "keyword") (id "F:512435")) "if") " (to > toend)\n        it->glyph_row->used[TEXT_AREA] = to - it->glyph_row->glyphs[TEXT_AREA];\n    }\n  " (span (|@| (class "keyword") (id "F:512532")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:512549")) "/* ") (span (|@| (class "comment") (id "F:512552")) "In R2L rows, overwrite the last (rightmost) glyphs, and do\n         that back to front.  ") (span (|@| (class "comment-delimiter") (id "F:512634")) "*/") "\n      end = truncate_it.glyph_row->glyphs[TEXT_AREA];\n      from = end + truncate_it.glyph_row->used[TEXT_AREA] - 1;\n      toend = it->glyph_row->glyphs[TEXT_AREA];\n      to = toend + it->glyph_row->used[TEXT_AREA] - 1;\n\n      " (span (|@| (class "keyword") (id "F:512864")) "while") " (from >= end && to >= toend)\n        *to-- = *from--;\n      " (span (|@| (class "keyword") (id "F:512923")) "while") " (to >= toend && CHAR_GLYPH_PADDING_P (*to))\n        {\n          from =\n            truncate_it.glyph_row->glyphs[TEXT_AREA]\n            + truncate_it.glyph_row->used[TEXT_AREA] - 1;\n          " (span (|@| (class "keyword") (id "F:513086")) "while") " (from >= end && to >= toend)\n            *to-- = *from--;\n        }\n      " (span (|@| (class "keyword") (id "F:513152")) "if") " (from >= end)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:513175")) "/* ") (span (|@| (class "comment") (id "F:513178")) "Need to free some room before prepending additional\n             glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:513245")) "*/") "\n          " (span (|@| (class "type") (id "F:513251")) "int") " " (span (|@| (class "variable-name") (id "F:513255")) "move_by") " = from - end + 1;\n          " (span (|@| (class "keyword") (id "F:513284")) "struct") " " (span (|@| (class "type") (id "F:513291")) "glyph") " *" (span (|@| (class "variable-name") (id "F:513298")) "g0") " = it->glyph_row->glyphs[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:513340")) "struct") " " (span (|@| (class "type") (id "F:513347")) "glyph") " *" (span (|@| (class "variable-name") (id "F:513354")) "g") " = g0 + it->glyph_row->used[TEXT_AREA] - 1;\n\n          " (span (|@| (class "keyword") (id "F:513403")) "for") " ( ; g >= g0; g--)\n            g[move_by] = *g;\n          " (span (|@| (class "keyword") (id "F:513450")) "while") " (from >= end)\n            *to-- = *from--;\n          it->glyph_row->used[TEXT_AREA] += move_by;\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:513551")) "/* ") (span (|@| (class "comment") (id "F:513554")) "Compute the pixel height and width of IT->glyph_row.\n\n   Most of the time, ascent and height of a display line will be equal\n   to the max_ascent and max_height values of the display iterator\n   structure.  This is not the case if\n\n   1. We hit ZV without displaying anything.  In this case, max_ascent\n   and max_height will be zero.\n\n   2. We have some glyphs that don't contribute to the line height.\n   (The glyph row flag contributes_to_line_height_p is for future\n   pixmap extensions).\n\n   The first case is easily covered by using default values because in\n   these cases, the line height does not really matter, except that it\n   must not be zero.  ") (span (|@| (class "comment-delimiter") (id "F:514212")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:514216")) "static") " " (span (|@| (class "type") (id "F:514223")) "void") "\n" (span (|@| (class "function-name") (id "F:514228")) "compute_line_metrics") " (" (span (|@| (class "type") (id "F:514250")) "it") ")\n     " (span (|@| (class "keyword") (id "F:514259")) "struct") " " (span (|@| (class "type") (id "F:514266")) "it") " *" (span (|@| (class "variable-name") (id "F:514270")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:514278")) "struct") " " (span (|@| (class "type") (id "F:514285")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:514296")) "row") " = it->glyph_row;\n  " (span (|@| (class "type") (id "F:514319")) "int") " " (span (|@| (class "variable-name") (id "F:514323")) "area") ", " (span (|@| (class "variable-name") (id "F:514329")) "i") ";\n\n  " (span (|@| (class "keyword") (id "F:514335")) "if") " (FRAME_WINDOW_P (it->f))\n    {\n      " (span (|@| (class "type") (id "F:514375")) "int") " " (span (|@| (class "variable-name") (id "F:514379")) "i") ", " (span (|@| (class "variable-name") (id "F:514382")) "min_y") ", " (span (|@| (class "variable-name") (id "F:514389")) "max_y") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:514403")) "/* ") (span (|@| (class "comment") (id "F:514406")) "The line may consist of one space only, that was added to\n         place the cursor on it.  If so, the row's height hasn't been\n         computed yet.  ") (span (|@| (class "comment-delimiter") (id "F:514544")) "*/") "\n      " (span (|@| (class "keyword") (id "F:514553")) "if") " (row->height == 0)\n        {\n          " (span (|@| (class "keyword") (id "F:514581")) "if") " (it->max_ascent + it->max_descent == 0)\n            it->max_descent = it->max_phys_descent = FRAME_LINE_HEIGHT (it->f);\n          row->ascent = it->max_ascent;\n          row->height = it->max_ascent + it->max_descent;\n          row->phys_ascent = it->max_phys_ascent;\n          row->phys_height = it->max_phys_ascent + it->max_phys_descent;\n          row->extra_line_spacing = it->max_extra_line_spacing;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:514957")) "/* ") (span (|@| (class "comment") (id "F:514960")) "Compute the width of this line.  ") (span (|@| (class "comment-delimiter") (id "F:514993")) "*/") "\n      row->pixel_width = row->x;\n      " (span (|@| (class "keyword") (id "F:515035")) "for") " (i = 0; i < row->used[TEXT_AREA]; ++i)\n        row->pixel_width += row->glyphs[TEXT_AREA][i].pixel_width;\n\n      xassert (row->pixel_width >= 0);\n      xassert (row->ascent >= 0 && row->height > 0);\n\n      row->overlapping_p = (MATRIX_ROW_OVERLAPS_SUCC_P (row)\n                            || MATRIX_ROW_OVERLAPS_PRED_P (row));\n\n      " (span (|@| (class "comment-delimiter") (id "F:515345")) "/* ") (span (|@| (class "comment") (id "F:515348")) "If first line's physical ascent is larger than its logical\n         ascent, use the physical ascent, and make the row taller.\n         This makes accented characters fully visible.  ") (span (|@| (class "comment-delimiter") (id "F:515530")) "*/") "\n      " (span (|@| (class "keyword") (id "F:515539")) "if") " (row == MATRIX_FIRST_TEXT_ROW (it->w->desired_matrix)\n          && row->phys_ascent > row->ascent)\n        {\n          row->height += row->phys_ascent - row->ascent;\n          row->ascent = row->phys_ascent;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:515732")) "/* ") (span (|@| (class "comment") (id "F:515735")) "Compute how much of the line is visible.  ") (span (|@| (class "comment-delimiter") (id "F:515777")) "*/") "\n      row->visible_height = row->height;\n\n      min_y = WINDOW_HEADER_LINE_HEIGHT (it->w);\n      max_y = WINDOW_BOX_HEIGHT_NO_MODE_LINE (it->w);\n\n      " (span (|@| (class "keyword") (id "F:515932")) "if") " (row->y < min_y)\n        row->visible_height -= min_y - row->y;\n      " (span (|@| (class "keyword") (id "F:515998")) "if") " (row->y + row->height > max_y)\n        row->visible_height -= row->y + row->height - max_y;\n    }\n  " (span (|@| (class "keyword") (id "F:516094")) "else") "\n    {\n      row->pixel_width = row->used[TEXT_AREA];\n      " (span (|@| (class "keyword") (id "F:516158")) "if") " (row->continued_p)\n        row->pixel_width -= it->continuation_pixel_width;\n      " (span (|@| (class "keyword") (id "F:516237")) "else") " " (span (|@| (class "keyword") (id "F:516242")) "if") " (row->truncated_on_right_p)\n        row->pixel_width -= it->truncation_pixel_width;\n      row->ascent = row->phys_ascent = 0;\n      row->height = row->phys_height = row->visible_height = 1;\n      row->extra_line_spacing = 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:516472")) "/* ") (span (|@| (class "comment") (id "F:516475")) "Compute a hash code for this row.  ") (span (|@| (class "comment-delimiter") (id "F:516510")) "*/") "\n  row->hash = 0;\n  " (span (|@| (class "keyword") (id "F:516532")) "for") " (area = LEFT_MARGIN_AREA; area < LAST_AREA; ++area)\n    " (span (|@| (class "keyword") (id "F:516592")) "for") " (i = 0; i < row->used[area]; ++i)\n      row->hash = ((((row->hash << 4) + (row->hash >> 24)) & 0x0fffffff)\n                   + row->glyphs[area][i].u.val\n                   + row->glyphs[area][i].face_id\n                   + row->glyphs[area][i].padding_p\n                   + (row->glyphs[area][i].type << 2));\n\n  it->max_ascent = it->max_descent = 0;\n  it->max_phys_ascent = it->max_phys_descent = 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:516948")) "/* ") (span (|@| (class "comment") (id "F:516951")) "Append one space to the glyph row of iterator IT if doing a\n   window-based redisplay.  The space has the same face as\n   IT->face_id.  Value is non-zero if a space was added.\n\n   This function is called to make sure that there is always one glyph\n   at the end of a glyph row that the cursor can be set on under\n   window-systems.  (If there weren't such a glyph we would not know\n   how wide and tall a box cursor should be displayed).\n\n   At the same time this space let's a nicely handle clearing to the\n   end of the line if the row ends in italic text.  ") (span (|@| (class "comment-delimiter") (id "F:517511")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:517515")) "static") " " (span (|@| (class "type") (id "F:517522")) "int") "\n" (span (|@| (class "function-name") (id "F:517526")) "append_space_for_newline") " (" (span (|@| (class "type") (id "F:517552")) "it") ", default_face_p)\n     " (span (|@| (class "keyword") (id "F:517577")) "struct") " " (span (|@| (class "type") (id "F:517584")) "it") " *" (span (|@| (class "variable-name") (id "F:517588")) "it") ";\n     " (span (|@| (class "type") (id "F:517597")) "int") " " (span (|@| (class "variable-name") (id "F:517601")) "default_face_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:517621")) "if") " (FRAME_WINDOW_P (it->f))\n    {\n      " (span (|@| (class "type") (id "F:517661")) "int") " " (span (|@| (class "variable-name") (id "F:517665")) "n") " = it->glyph_row->used[TEXT_AREA];\n\n      " (span (|@| (class "keyword") (id "F:517708")) "if") " (it->glyph_row->glyphs[TEXT_AREA] + n\n          < it->glyph_row->glyphs[1 + TEXT_AREA])\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:517798")) "/* ") (span (|@| (class "comment") (id "F:517801")) "Save some values that must not be changed.\n             Must save IT->c and IT->len because otherwise\n             ITERATOR_AT_END_P wouldn't work anymore after\n             append_space_for_newline has been called.  ") (span (|@| (class "comment-delimiter") (id "F:517997")) "*/") "\n          " (span (|@| (class "keyword") (id "F:518003")) "enum") " " (span (|@| (class "type") (id "F:518008")) "display_element_type") " " (span (|@| (class "variable-name") (id "F:518029")) "saved_what") " = it->what;\n          " (span (|@| (class "type") (id "F:518055")) "int") " " (span (|@| (class "variable-name") (id "F:518059")) "saved_c") " = it->c, " (span (|@| (class "variable-name") (id "F:518076")) "saved_len") " = it->len;\n          " (span (|@| (class "type") (id "F:518100")) "int") " " (span (|@| (class "variable-name") (id "F:518104")) "saved_x") " = it->current_x;\n          " (span (|@| (class "type") (id "F:518132")) "int") " " (span (|@| (class "variable-name") (id "F:518136")) "saved_face_id") " = it->face_id;\n          " (span (|@| (class "keyword") (id "F:518168")) "struct") " " (span (|@| (class "type") (id "F:518175")) "text_pos") " " (span (|@| (class "variable-name") (id "F:518184")) "saved_pos") ";\n          " (span (|@| (class "type") (id "F:518198")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:518210")) "saved_object") ";\n          " (span (|@| (class "keyword") (id "F:518227")) "struct") " " (span (|@| (class "type") (id "F:518234")) "face") " *" (span (|@| (class "variable-name") (id "F:518240")) "face") ";\n\n          saved_object = it->object;\n          saved_pos = it->position;\n\n          it->what = IT_CHARACTER;\n          bzero (&it->position, " (span (|@| (class "keyword") (id "F:518360")) "sizeof") " it->position);\n          it->object = make_number (0);\n          it->c = " (span (|@| (class "string") (id "F:518426")) "' '") ";\n          it->len = 1;\n\n          " (span (|@| (class "keyword") (id "F:518451")) "if") " (default_face_p)\n            it->face_id = DEFAULT_FACE_ID;\n          " (span (|@| (class "keyword") (id "F:518510")) "else") " " (span (|@| (class "keyword") (id "F:518515")) "if") " (it->face_before_selective_p)\n            it->face_id = it->saved_face_id;\n          face = FACE_FROM_ID (it->f, it->face_id);\n          it->face_id = FACE_FOR_CHAR (it->f, face, 0, -1, Qnil);\n\n          PRODUCE_GLYPHS (it);\n\n          it->override_ascent = -1;\n          it->constrain_row_ascent_descent_p = 0;\n          it->current_x = saved_x;\n          it->object = saved_object;\n          it->position = saved_pos;\n          it->what = saved_what;\n          it->face_id = saved_face_id;\n          it->len = saved_len;\n          it->c = saved_c;\n          " (span (|@| (class "keyword") (id "F:518980")) "return") " 1;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:519002")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:519016")) "/* ") (span (|@| (class "comment") (id "F:519019")) "Extend the face of the last glyph in the text area of IT->glyph_row\n   to the end of the display line.  Called from display_line.  If the\n   glyph row is empty, add a space glyph to it so that we know the\n   face to draw.  Set the glyph row flag fill_line_p.  If the glyph\n   row is R2L, prepend a stretch glyph to cover the empty space to the\n   left of the leftmost glyph.  ") (span (|@| (class "comment-delimiter") (id "F:519395")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:519399")) "static") " " (span (|@| (class "type") (id "F:519406")) "void") "\n" (span (|@| (class "function-name") (id "F:519411")) "extend_face_to_end_of_line") " (" (span (|@| (class "type") (id "F:519439")) "it") ")\n     " (span (|@| (class "keyword") (id "F:519448")) "struct") " " (span (|@| (class "type") (id "F:519455")) "it") " *" (span (|@| (class "variable-name") (id "F:519459")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:519467")) "struct") " " (span (|@| (class "type") (id "F:519474")) "face") " *" (span (|@| (class "variable-name") (id "F:519480")) "face") ";\n  " (span (|@| (class "keyword") (id "F:519488")) "struct") " " (span (|@| (class "type") (id "F:519495")) "frame") " *" (span (|@| (class "variable-name") (id "F:519502")) "f") " = it->f;\n\n  " (span (|@| (class "comment-delimiter") (id "F:519516")) "/* ") (span (|@| (class "comment") (id "F:519519")) "If line is already filled, do nothing.  Non window-system frames\n     get a grace of one more ``pixel'' because their characters are\n     1-``pixel'' wide, so they hit the equality too early.  This grace\n     is needed only for R2L rows that are not continued, to produce\n     one extra blank where we could display the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:519848")) "*/") "\n  " (span (|@| (class "keyword") (id "F:519853")) "if") " (it->current_x >= it->last_visible_x\n      + (" (span (|@| (class "negation-char") (id "F:519902")) "!") "FRAME_WINDOW_P (f)\n         && it->glyph_row->reversed_p\n         && " (span (|@| (class "negation-char") (id "F:519958")) "!") "it->glyph_row->continued_p))\n    " (span (|@| (class "keyword") (id "F:519992")) "return") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:520003")) "/* ") (span (|@| (class "comment") (id "F:520006")) "Face extension extends the background and box of IT->face_id\n     to the end of the line.  If the background equals the background\n     of the frame, we don't have to do anything.  ") (span (|@| (class "comment-delimiter") (id "F:520187")) "*/") "\n  " (span (|@| (class "keyword") (id "F:520192")) "if") " (it->face_before_selective_p)\n    face = FACE_FROM_ID (f, it->saved_face_id);\n  " (span (|@| (class "keyword") (id "F:520275")) "else") "\n    face = FACE_FROM_ID (f, it->face_id);\n\n  " (span (|@| (class "keyword") (id "F:520325")) "if") " (FRAME_WINDOW_P (f)\n      && it->glyph_row->displays_text_p\n      && face->box == FACE_NO_BOX\n      && face->background == FRAME_BACKGROUND_PIXEL (f)\n      && " (span (|@| (class "negation-char") (id "F:520487")) "!") "face->stipple\n      && " (span (|@| (class "negation-char") (id "F:520511")) "!") "it->glyph_row->reversed_p)\n    " (span (|@| (class "keyword") (id "F:520543")) "return") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:520554")) "/* ") (span (|@| (class "comment") (id "F:520557")) "Set the glyph row flag indicating that the face of the last glyph\n     in the text area has to be drawn to the end of the text area.  ") (span (|@| (class "comment-delimiter") (id "F:520691")) "*/") "\n  it->glyph_row->fill_line_p = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:520731")) "/* ") (span (|@| (class "comment") (id "F:520734")) "If current character of IT is not ASCII, make sure we have the\n     ASCII face.  This will be automatically undone the next time\n     get_next_display_element returns a multibyte character.  Note\n     that the character will always be single byte in unibyte\n     text.  ") (span (|@| (class "comment-delimiter") (id "F:521004")) "*/") "\n  " (span (|@| (class "keyword") (id "F:521009")) "if") " (" (span (|@| (class "negation-char") (id "F:521013")) "!") "ASCII_CHAR_P (it->c))\n    {\n      it->face_id = FACE_FOR_CHAR (f, face, 0, -1, Qnil);\n    }\n\n  " (span (|@| (class "keyword") (id "F:521109")) "if") " (FRAME_WINDOW_P (f))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:521145")) "/* ") (span (|@| (class "comment") (id "F:521148")) "If the row is empty, add a space with the current face of IT,\n         so that we know which face to draw.  ") (span (|@| (class "comment-delimiter") (id "F:521249")) "*/") "\n      " (span (|@| (class "keyword") (id "F:521258")) "if") " (it->glyph_row->used[TEXT_AREA] == 0)\n        {\n          it->glyph_row->glyphs[TEXT_AREA][0] = space_glyph;\n          it->glyph_row->glyphs[TEXT_AREA][0].face_id = it->face_id;\n          it->glyph_row->used[TEXT_AREA] = 1;\n        }\n" (span (|@| (class "preprocessor") (id "F:521460")) "#ifdef") " HAVE_WINDOW_SYSTEM\n      " (span (|@| (class "keyword") (id "F:521492")) "if") " (it->glyph_row->reversed_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:521529")) "/* ") (span (|@| (class "comment") (id "F:521532")) "Prepend a stretch glyph to the row, such that the\n             rightmost glyph will be drawn flushed all the way to the\n             right margin of the window.  The stretch glyph that will\n             occupy the empty space, if any, to the left of the\n             glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:521780")) "*/") "\n          " (span (|@| (class "keyword") (id "F:521786")) "struct") " " (span (|@| (class "type") (id "F:521793")) "font") " *" (span (|@| (class "variable-name") (id "F:521799")) "font") " = face->font ? face->font : FRAME_FONT (f);\n          " (span (|@| (class "keyword") (id "F:521851")) "struct") " " (span (|@| (class "type") (id "F:521858")) "glyph") " *" (span (|@| (class "variable-name") (id "F:521865")) "row_start") " = it->glyph_row->glyphs[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:521914")) "struct") " " (span (|@| (class "type") (id "F:521921")) "glyph") " *" (span (|@| (class "variable-name") (id "F:521928")) "row_end") " = row_start + it->glyph_row->used[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:521985")) "struct") " " (span (|@| (class "type") (id "F:521992")) "glyph") " *" (span (|@| (class "variable-name") (id "F:521999")) "g") ";\n          " (span (|@| (class "type") (id "F:522005")) "int") " " (span (|@| (class "variable-name") (id "F:522009")) "row_width") ", " (span (|@| (class "variable-name") (id "F:522020")) "stretch_ascent") ", " (span (|@| (class "variable-name") (id "F:522036")) "stretch_width") ";\n          " (span (|@| (class "keyword") (id "F:522054")) "struct") " " (span (|@| (class "type") (id "F:522061")) "text_pos") " " (span (|@| (class "variable-name") (id "F:522070")) "saved_pos") ";\n          " (span (|@| (class "type") (id "F:522084")) "int") " " (span (|@| (class "variable-name") (id "F:522088")) "saved_face_id") ", " (span (|@| (class "variable-name") (id "F:522103")) "saved_avoid_cursor") ";\n\n          " (span (|@| (class "keyword") (id "F:522127")) "for") " (row_width = 0, g = row_start; g < row_end; g++)\n            row_width += g->pixel_width;\n          stretch_width = window_box_width (it->w, TEXT_AREA) - row_width;\n          " (span (|@| (class "keyword") (id "F:522285")) "if") " (stretch_width > 0)\n            {\n              stretch_ascent =\n                (((it->ascent + it->descent)\n                  * FONT_BASE (font)) / FONT_HEIGHT (font));\n              saved_pos = it->position;\n              bzero (&it->position, " (span (|@| (class "keyword") (id "F:522479")) "sizeof") " it->position);\n              saved_avoid_cursor = it->avoid_cursor_p;\n              it->avoid_cursor_p = 1;\n              saved_face_id = it->face_id;\n              " (span (|@| (class "comment-delimiter") (id "F:522623")) "/* ") (span (|@| (class "comment") (id "F:522626")) "The last row's stretch glyph should get the default\n                 face, to avoid painting the rest of the window with\n                 the region face, if the region ends at ZV.  ") (span (|@| (class "comment-delimiter") (id "F:522780")) "*/") "\n              " (span (|@| (class "keyword") (id "F:522790")) "if") " (it->glyph_row->ends_at_zv_p)\n                it->face_id = DEFAULT_FACE_ID;\n              " (span (|@| (class "keyword") (id "F:522863")) "else") "\n                it->face_id = face->id;\n              append_stretch_glyph (it, make_number (0), stretch_width,\n                                    it->ascent + it->descent, stretch_ascent);\n              it->position = saved_pos;\n              it->avoid_cursor_p = saved_avoid_cursor;\n              it->face_id = saved_face_id;\n            }\n        }\n" (span (|@| (class "preprocessor") (id "F:523137")) "#endif") "  " (span (|@| (class "comment-delimiter") (id "F:523144")) "/* ") (span (|@| (class "comment") (id "F:523147")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:523166")) "*/") "\n    }\n  " (span (|@| (class "keyword") (id "F:523177")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:523194")) "/* ") (span (|@| (class "comment") (id "F:523197")) "Save some values that must not be changed.  ") (span (|@| (class "comment-delimiter") (id "F:523241")) "*/") "\n      " (span (|@| (class "type") (id "F:523250")) "int") " " (span (|@| (class "variable-name") (id "F:523254")) "saved_x") " = it->current_x;\n      " (span (|@| (class "keyword") (id "F:523285")) "struct") " " (span (|@| (class "type") (id "F:523292")) "text_pos") " " (span (|@| (class "variable-name") (id "F:523301")) "saved_pos") ";\n      " (span (|@| (class "type") (id "F:523318")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:523330")) "saved_object") ";\n      " (span (|@| (class "keyword") (id "F:523350")) "enum") " " (span (|@| (class "type") (id "F:523355")) "display_element_type") " " (span (|@| (class "variable-name") (id "F:523376")) "saved_what") " = it->what;\n      " (span (|@| (class "type") (id "F:523405")) "int") " " (span (|@| (class "variable-name") (id "F:523409")) "saved_face_id") " = it->face_id;\n\n      saved_object = it->object;\n      saved_pos = it->position;\n\n      it->what = IT_CHARACTER;\n      bzero (&it->position, " (span (|@| (class "keyword") (id "F:523564")) "sizeof") " it->position);\n      it->object = make_number (0);\n      it->c = " (span (|@| (class "string") (id "F:523636")) "' '") ";\n      it->len = 1;\n      " (span (|@| (class "comment-delimiter") (id "F:523666")) "/* ") (span (|@| (class "comment") (id "F:523669")) "The last row's blank glyphs should get the default face, to\n         avoid painting the rest of the window with the region face,\n         if the region ends at ZV.  ") (span (|@| (class "comment-delimiter") (id "F:523820")) "*/") "\n      " (span (|@| (class "keyword") (id "F:523829")) "if") " (it->glyph_row->ends_at_zv_p)\n        it->face_id = DEFAULT_FACE_ID;\n      " (span (|@| (class "keyword") (id "F:523900")) "else") "\n        it->face_id = face->id;\n\n      PRODUCE_GLYPHS (it);\n\n      " (span (|@| (class "keyword") (id "F:523965")) "while") " (it->current_x <= it->last_visible_x)\n        PRODUCE_GLYPHS (it);\n\n      " (span (|@| (class "comment-delimiter") (id "F:524038")) "/* ") (span (|@| (class "comment") (id "F:524041")) "Don't count these blanks really.  It would let us insert a left\n         truncation glyph below and make us set the cursor on them, maybe.  ") (span (|@| (class "comment-delimiter") (id "F:524174")) "*/") "\n      it->current_x = saved_x;\n      it->object = saved_object;\n      it->position = saved_pos;\n      it->what = saved_what;\n      it->face_id = saved_face_id;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:524347")) "/* ") (span (|@| (class "comment") (id "F:524350")) "Value is non-zero if text starting at CHARPOS in current_buffer is\n   trailing whitespace.  ") (span (|@| (class "comment-delimiter") (id "F:524442")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:524446")) "static") " " (span (|@| (class "type") (id "F:524453")) "int") "\n" (span (|@| (class "function-name") (id "F:524457")) "trailing_whitespace_p") " (charpos)\n     " (span (|@| (class "type") (id "F:524494")) "int") " " (span (|@| (class "variable-name") (id "F:524498")) "charpos") ";\n{\n  " (span (|@| (class "type") (id "F:524511")) "int") " " (span (|@| (class "variable-name") (id "F:524515")) "bytepos") " = CHAR_TO_BYTE (charpos);\n  " (span (|@| (class "type") (id "F:524551")) "int") " " (span (|@| (class "variable-name") (id "F:524555")) "c") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:524565")) "while") " (bytepos < ZV_BYTE\n         && (c = FETCH_CHAR (bytepos),\n             c == " (span (|@| (class "string") (id "F:524633")) "' '") " || c == " (span (|@| (class "string") (id "F:524645")) "'\\t'") "))\n    ++bytepos;\n\n  " (span (|@| (class "keyword") (id "F:524670")) "if") " (bytepos >= ZV_BYTE || c == " (span (|@| (class "string") (id "F:524701")) "'\\n'") " || c == " (span (|@| (class "string") (id "F:524714")) "'\\r'") ")\n    {\n      " (span (|@| (class "keyword") (id "F:524732")) "if") " (bytepos != PT_BYTE)\n        " (span (|@| (class "keyword") (id "F:524757")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:524775")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:524789")) "/* ") (span (|@| (class "comment") (id "F:524792")) "Highlight trailing whitespace, if any, in ROW.  ") (span (|@| (class "comment-delimiter") (id "F:524840")) "*/") "\n\n" (span (|@| (class "type") (id "F:524844")) "void") "\n" (span (|@| (class "function-name") (id "F:524849")) "highlight_trailing_whitespace") " (f, row)\n     " (span (|@| (class "keyword") (id "F:524893")) "struct") " " (span (|@| (class "type") (id "F:524900")) "frame") " *" (span (|@| (class "variable-name") (id "F:524907")) "f") ";\n     " (span (|@| (class "keyword") (id "F:524915")) "struct") " " (span (|@| (class "type") (id "F:524922")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:524933")) "row") ";\n{\n  " (span (|@| (class "type") (id "F:524942")) "int") " " (span (|@| (class "variable-name") (id "F:524946")) "used") " = row->used[TEXT_AREA];\n\n  " (span (|@| (class "keyword") (id "F:524978")) "if") " (used)\n    {\n      " (span (|@| (class "keyword") (id "F:525000")) "struct") " " (span (|@| (class "type") (id "F:525007")) "glyph") " *" (span (|@| (class "variable-name") (id "F:525014")) "start") " = row->glyphs[TEXT_AREA];\n      " (span (|@| (class "keyword") (id "F:525052")) "struct") " " (span (|@| (class "type") (id "F:525059")) "glyph") " *" (span (|@| (class "variable-name") (id "F:525066")) "glyph") " = start + used - 1;\n\n      " (span (|@| (class "keyword") (id "F:525099")) "if") " (row->reversed_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:525126")) "/* ") (span (|@| (class "comment") (id "F:525129")) "Right-to-left rows need to be processed in the opposite\n             direction, so swap the edge pointers. ") (span (|@| (class "comment-delimiter") (id "F:525229")) "*/") "\n          glyph = start;\n          start = row->glyphs[TEXT_AREA] + used - 1;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:525306")) "/* ") (span (|@| (class "comment") (id "F:525309")) "Skip over glyphs inserted to display the cursor at the\n         end of a line, for extending the face of the last glyph\n         to the end of the line on terminals, and for truncation\n         and continuation glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:525508")) "*/") "\n      " (span (|@| (class "keyword") (id "F:525517")) "if") " (" (span (|@| (class "negation-char") (id "F:525521")) "!") "row->reversed_p)\n        {\n          " (span (|@| (class "keyword") (id "F:525545")) "while") " (glyph >= start\n                 && glyph->type == CHAR_GLYPH\n                 && INTEGERP (glyph->object))\n            --glyph;\n        }\n      " (span (|@| (class "keyword") (id "F:525654")) "else") "\n        {\n          " (span (|@| (class "keyword") (id "F:525665")) "while") " (glyph <= start\n                 && glyph->type == CHAR_GLYPH\n                 && INTEGERP (glyph->object))\n            ++glyph;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:525775")) "/* ") (span (|@| (class "comment") (id "F:525778")) "If last glyph is a space or stretch, and it's trailing\n         whitespace, set the face of all trailing whitespace glyphs in\n         IT->glyph_row to `trailing-whitespace'.  ") (span (|@| (class "comment-delimiter") (id "F:525940")) "*/") "\n      " (span (|@| (class "keyword") (id "F:525949")) "if") " ((row->reversed_p ? glyph <= start : glyph >= start)\n          && BUFFERP (glyph->object)\n          && (glyph->type == STRETCH_GLYPH\n              || (glyph->type == CHAR_GLYPH\n                  && glyph->u.ch == " (span (|@| (class "string") (id "F:526130")) "' '") "))\n          && trailing_whitespace_p (glyph->charpos))\n        {\n          " (span (|@| (class "type") (id "F:526188")) "int") " " (span (|@| (class "variable-name") (id "F:526192")) "face_id") " = lookup_named_face (f, Qtrailing_whitespace, 0);\n          " (span (|@| (class "keyword") (id "F:526253")) "if") " (face_id < 0)\n            " (span (|@| (class "keyword") (id "F:526275")) "return") ";\n\n          " (span (|@| (class "keyword") (id "F:526287")) "if") " (" (span (|@| (class "negation-char") (id "F:526291")) "!") "row->reversed_p)\n            {\n              " (span (|@| (class "keyword") (id "F:526323")) "while") " (glyph >= start\n                     && BUFFERP (glyph->object)\n                     && (glyph->type == STRETCH_GLYPH\n                         || (glyph->type == CHAR_GLYPH\n                             && glyph->u.ch == " (span (|@| (class "string") (id "F:526479")) "' '") ")))\n                (glyph--)->face_id = face_id;\n            }\n          " (span (|@| (class "keyword") (id "F:526528")) "else") "\n            {\n              " (span (|@| (class "keyword") (id "F:526547")) "while") " (glyph <= start\n                     && BUFFERP (glyph->object)\n                     && (glyph->type == STRETCH_GLYPH\n                         || (glyph->type == CHAR_GLYPH\n                             && glyph->u.ch == " (span (|@| (class "string") (id "F:526703")) "' '") ")))\n                (glyph++)->face_id = face_id;\n            }\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:526762")) "/* ") (span (|@| (class "comment") (id "F:526765")) "Value is non-zero if glyph row ROW in window W should be\n   used to hold the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:526851")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:526855")) "static") " " (span (|@| (class "type") (id "F:526862")) "int") "\n" (span (|@| (class "function-name") (id "F:526866")) "cursor_row_p") " (w, row)\n     " (span (|@| (class "keyword") (id "F:526893")) "struct") " " (span (|@| (class "type") (id "F:526900")) "window") " *" (span (|@| (class "variable-name") (id "F:526908")) "w") ";\n     " (span (|@| (class "keyword") (id "F:526916")) "struct") " " (span (|@| (class "type") (id "F:526923")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:526934")) "row") ";\n{\n  " (span (|@| (class "type") (id "F:526943")) "int") " " (span (|@| (class "variable-name") (id "F:526947")) "cursor_row_p") " = 1;\n\n  " (span (|@| (class "keyword") (id "F:526968")) "if") " (PT == CHARPOS (row->end.pos))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:527014")) "/* ") (span (|@| (class "comment") (id "F:527017")) "Suppose the row ends on a string.\n         Unless the row is continued, that means it ends on a newline\n         in the string.  If it's anything other than a display string\n         (e.g. a before-string from an overlay), we don't want the\n         cursor there.  (This heuristic seems to give the optimal\n         behavior for the various types of multi-line strings.)  ") (span (|@| (class "comment-delimiter") (id "F:527354")) "*/") "\n      " (span (|@| (class "keyword") (id "F:527363")) "if") " (CHARPOS (row->end.string_pos) >= 0)\n        {\n          " (span (|@| (class "keyword") (id "F:527409")) "if") " (row->continued_p)\n            cursor_row_p = 1;\n          " (span (|@| (class "keyword") (id "F:527457")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:527476")) "/* ") (span (|@| (class "comment") (id "F:527479")) "Check for `display' property.  ") (span (|@| (class "comment-delimiter") (id "F:527510")) "*/") "\n              " (span (|@| (class "keyword") (id "F:527520")) "struct") " " (span (|@| (class "type") (id "F:527527")) "glyph") " *" (span (|@| (class "variable-name") (id "F:527534")) "beg") " = row->glyphs[TEXT_AREA];\n              " (span (|@| (class "keyword") (id "F:527571")) "struct") " " (span (|@| (class "type") (id "F:527578")) "glyph") " *" (span (|@| (class "variable-name") (id "F:527585")) "end") " = beg + row->used[TEXT_AREA] - 1;\n              " (span (|@| (class "keyword") (id "F:527630")) "struct") " " (span (|@| (class "type") (id "F:527637")) "glyph") " *" (span (|@| (class "variable-name") (id "F:527644")) "glyph") ";\n\n              cursor_row_p = 0;\n              " (span (|@| (class "keyword") (id "F:527684")) "for") " (glyph = end; glyph >= beg; --glyph)\n                " (span (|@| (class "keyword") (id "F:527727")) "if") " (STRINGP (glyph->object))\n                  {\n                    " (span (|@| (class "type") (id "F:527768")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:527780")) "prop") "\n                      = Fget_char_property (make_number (PT),\n                                            Qdisplay, Qnil);\n                    cursor_row_p =\n                      (" (span (|@| (class "negation-char") (id "F:527889")) "!") "NILP (prop)\n                       && display_prop_string_p (prop, glyph->object));\n                    " (span (|@| (class "keyword") (id "F:527966")) "break") ";\n                  }\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:527995")) "else") " " (span (|@| (class "keyword") (id "F:528000")) "if") " (MATRIX_ROW_ENDS_IN_MIDDLE_OF_CHAR_P (row))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:528053")) "/* ") (span (|@| (class "comment") (id "F:528056")) "If the row ends in middle of a real character,\n             and the line is continued, we want the cursor here.\n             That's because CHARPOS (ROW->end.pos) would equal\n             PT if PT is before the character.  ") (span (|@| (class "comment-delimiter") (id "F:528258")) "*/") "\n          " (span (|@| (class "keyword") (id "F:528264")) "if") " (" (span (|@| (class "negation-char") (id "F:528268")) "!") "row->ends_in_ellipsis_p)\n            cursor_row_p = row->continued_p;\n          " (span (|@| (class "keyword") (id "F:528335")) "else") "\n          " (span (|@| (class "comment-delimiter") (id "F:528343")) "/* ") (span (|@| (class "comment") (id "F:528346")) "If the row ends in an ellipsis, then\n             CHARPOS (ROW->end.pos) will equal point after the\n             invisible text.  We want that position to be displayed\n             after the ellipsis.  ") (span (|@| (class "comment-delimiter") (id "F:528527")) "*/") "\n            cursor_row_p = 0;\n        }\n      " (span (|@| (class "comment-delimiter") (id "F:528562")) "/* ") (span (|@| (class "comment") (id "F:528565")) "If the row ends at ZV, display the cursor at the end of that\n         row instead of at the start of the row below.  ") (span (|@| (class "comment-delimiter") (id "F:528675")) "*/") "\n      " (span (|@| (class "keyword") (id "F:528684")) "else") " " (span (|@| (class "keyword") (id "F:528689")) "if") " (row->ends_at_zv_p)\n        cursor_row_p = 1;\n      " (span (|@| (class "keyword") (id "F:528737")) "else") "\n        cursor_row_p = 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:528770")) "return") " cursor_row_p;\n}\n\n\f\n\n" (span (|@| (class "comment-delimiter") (id "F:528797")) "/* ") (span (|@| (class "comment") (id "F:528800")) "Push the display property PROP so that it will be rendered at the\n   current position in IT.  Return 1 if PROP was successfully pushed,\n   0 otherwise.  ") (span (|@| (class "comment-delimiter") (id "F:528953")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:528957")) "static") " " (span (|@| (class "type") (id "F:528964")) "int") "\n" (span (|@| (class "function-name") (id "F:528968")) "push_display_prop") " (" (span (|@| (class "keyword") (id "F:528987")) "struct") " " (span (|@| (class "type") (id "F:528994")) "it") " *" (span (|@| (class "variable-name") (id "F:528998")) "it") ", " (span (|@| (class "type") (id "F:529002")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:529014")) "prop") ")\n{\n  push_it (it);\n\n  " (span (|@| (class "keyword") (id "F:529041")) "if") " (STRINGP (prop))\n    {\n      " (span (|@| (class "keyword") (id "F:529073")) "if") " (SCHARS (prop) == 0)\n        {\n          pop_it (it);\n          " (span (|@| (class "keyword") (id "F:529119")) "return") " 0;\n        }\n\n      it->string = prop;\n      it->multibyte_p = STRING_MULTIBYTE (it->string);\n      it->current.overlay_string_index = -1;\n      IT_STRING_CHARPOS (*it) = IT_STRING_BYTEPOS (*it) = 0;\n      it->end_charpos = it->string_nchars = SCHARS (it->string);\n      it->method = GET_FROM_STRING;\n      it->stop_charpos = 0;\n    }\n  " (span (|@| (class "keyword") (id "F:529456")) "else") " " (span (|@| (class "keyword") (id "F:529461")) "if") " (CONSP (prop) && EQ (XCAR (prop), Qspace))\n    {\n      it->method = GET_FROM_STRETCH;\n      it->object = prop;\n    }\n" (span (|@| (class "preprocessor") (id "F:529581")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  " (span (|@| (class "keyword") (id "F:529609")) "else") " " (span (|@| (class "keyword") (id "F:529614")) "if") " (IMAGEP (prop))\n    {\n      it->what = IT_IMAGE;\n      it->image_id = lookup_image (it->f, prop);\n      it->method = GET_FROM_IMAGE;\n    }\n" (span (|@| (class "preprocessor") (id "F:529756")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:529763")) "/* ") (span (|@| (class "comment") (id "F:529766")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:529785")) "*/") "\n  " (span (|@| (class "keyword") (id "F:529790")) "else") "\n    {\n      pop_it (it);              " (span (|@| (class "comment-delimiter") (id "F:529821")) "/* ") (span (|@| (class "comment") (id "F:529824")) "bogus display property, give up ") (span (|@| (class "comment-delimiter") (id "F:529856")) "*/") "\n      " (span (|@| (class "keyword") (id "F:529865")) "return") " 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:529884")) "return") " 1;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:529897")) "/* ") (span (|@| (class "comment") (id "F:529900")) "Return the character-property PROP at the current position in IT.  ") (span (|@| (class "comment-delimiter") (id "F:529967")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:529971")) "static") " " (span (|@| (class "type") (id "F:529978")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:529990")) "get_it_property") " (" (span (|@| (class "type") (id "F:530007")) "it") ", prop)\n     " (span (|@| (class "keyword") (id "F:530022")) "struct") " " (span (|@| (class "type") (id "F:530029")) "it") " *" (span (|@| (class "variable-name") (id "F:530033")) "it") ";\n     " (span (|@| (class "type") (id "F:530042")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:530054")) "prop") ";\n{\n  " (span (|@| (class "type") (id "F:530064")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:530076")) "position") ";\n\n  " (span (|@| (class "keyword") (id "F:530089")) "if") " (STRINGP (it->object))\n    position = make_number (IT_STRING_CHARPOS (*it));\n  " (span (|@| (class "keyword") (id "F:530171")) "else") " " (span (|@| (class "keyword") (id "F:530176")) "if") " (BUFFERP (it->object))\n    position = make_number (IT_CHARPOS (*it));\n  " (span (|@| (class "keyword") (id "F:530251")) "else") "\n    " (span (|@| (class "keyword") (id "F:530260")) "return") " Qnil;\n\n  " (span (|@| (class "keyword") (id "F:530276")) "return") " Fget_char_property (position, prop, it->object);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:530335")) "/* ") (span (|@| (class "comment") (id "F:530338")) "See if there's a line- or wrap-prefix, and if so, push it on IT.  ") (span (|@| (class "comment-delimiter") (id "F:530404")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:530408")) "static") " " (span (|@| (class "type") (id "F:530415")) "void") "\n" (span (|@| (class "function-name") (id "F:530420")) "handle_line_prefix") " (" (span (|@| (class "keyword") (id "F:530440")) "struct") " " (span (|@| (class "type") (id "F:530447")) "it") " *" (span (|@| (class "variable-name") (id "F:530451")) "it") ")\n{\n  " (span (|@| (class "type") (id "F:530459")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:530471")) "prefix") ";\n  " (span (|@| (class "keyword") (id "F:530481")) "if") " (it->continuation_lines_width > 0)\n    {\n      prefix = get_it_property (it, Qwrap_prefix);\n      " (span (|@| (class "keyword") (id "F:530582")) "if") " (NILP (prefix))\n        prefix = Vwrap_prefix;\n    }\n  " (span (|@| (class "keyword") (id "F:530633")) "else") "\n    {\n      prefix = get_it_property (it, Qline_prefix);\n      " (span (|@| (class "keyword") (id "F:530701")) "if") " (NILP (prefix))\n        prefix = Vline_prefix;\n    }\n  " (span (|@| (class "keyword") (id "F:530752")) "if") " (" (span (|@| (class "negation-char") (id "F:530756")) "!") " NILP (prefix) && push_display_prop (it, prefix))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:530819")) "/* ") (span (|@| (class "comment") (id "F:530822")) "If the prefix is wider than the window, and we try to wrap\n         it, it would acquire its own wrap prefix, and so on till the\n         iterator stack overflows.  So, don't wrap the prefix.  ") (span (|@| (class "comment-delimiter") (id "F:531001")) "*/") "\n      it->line_wrap = TRUNCATE;\n      it->avoid_cursor_p = 1;\n    }\n}\n\n\f\n\n" (span (|@| (class "comment-delimiter") (id "F:531078")) "/* ") (span (|@| (class "comment") (id "F:531081")) "Remove N glyphs at the start of a reversed IT->glyph_row.  Called\n   only for R2L lines from display_line, when it decides that too many\n   glyphs were produced by PRODUCE_GLYPHS, and the line needs to be\n   continued.  ") (span (|@| (class "comment-delimiter") (id "F:531301")) "*/") "\n" (span (|@| (class "keyword") (id "F:531304")) "static") " " (span (|@| (class "type") (id "F:531311")) "void") "\n" (span (|@| (class "function-name") (id "F:531316")) "unproduce_glyphs") " (" (span (|@| (class "type") (id "F:531334")) "it") ", n)\n     " (span (|@| (class "keyword") (id "F:531346")) "struct") " " (span (|@| (class "type") (id "F:531353")) "it") " *" (span (|@| (class "variable-name") (id "F:531357")) "it") ";\n     " (span (|@| (class "type") (id "F:531366")) "int") " " (span (|@| (class "variable-name") (id "F:531370")) "n") ";\n{\n  " (span (|@| (class "keyword") (id "F:531377")) "struct") " " (span (|@| (class "type") (id "F:531384")) "glyph") " *" (span (|@| (class "variable-name") (id "F:531391")) "glyph") ", *" (span (|@| (class "variable-name") (id "F:531399")) "end") ";\n\n  xassert (it->glyph_row);\n  xassert (it->glyph_row->reversed_p);\n  xassert (it->area == TEXT_AREA);\n  xassert (n <= it->glyph_row->used[TEXT_AREA]);\n\n  " (span (|@| (class "keyword") (id "F:531558")) "if") " (n > it->glyph_row->used[TEXT_AREA])\n    n = it->glyph_row->used[TEXT_AREA];\n  glyph = it->glyph_row->glyphs[TEXT_AREA] + n;\n  end = it->glyph_row->glyphs[TEXT_AREA] + it->glyph_row->used[TEXT_AREA];\n  " (span (|@| (class "keyword") (id "F:531763")) "for") " ( ; glyph < end; glyph++)\n    glyph[-n] = *glyph;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:531820")) "/* ") (span (|@| (class "comment") (id "F:531823")) "Find the positions in a bidi-reordered ROW to serve as ROW->minpos\n   and ROW->maxpos.  ") (span (|@| (class "comment-delimiter") (id "F:531911")) "*/") "\n" (span (|@| (class "keyword") (id "F:531914")) "static") " " (span (|@| (class "type") (id "F:531921")) "void") "\n" (span (|@| (class "function-name") (id "F:531926")) "find_row_edges") " (" (span (|@| (class "type") (id "F:531942")) "it") ", row, min_pos, min_bpos, max_pos, max_bpos)\n     " (span (|@| (class "keyword") (id "F:531994")) "struct") " " (span (|@| (class "type") (id "F:532001")) "it") " *" (span (|@| (class "variable-name") (id "F:532005")) "it") ";\n     " (span (|@| (class "keyword") (id "F:532014")) "struct") " " (span (|@| (class "type") (id "F:532021")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:532032")) "row") ";\n     " (span (|@| (class "type") (id "F:532042")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:532052")) "min_pos") ", " (span (|@| (class "variable-name") (id "F:532061")) "min_bpos") ", " (span (|@| (class "variable-name") (id "F:532071")) "max_pos") ", " (span (|@| (class "variable-name") (id "F:532080")) "max_bpos") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:532094")) "/* ") (span (|@| (class "comment") (id "F:532097")) "FIXME: Revisit this when glyph ``spilling'' in continuation\n     lines' rows is implemented for bidi-reordered rows.  ") (span (|@| (class "comment-delimiter") (id "F:532215")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:532221")) "/* ") (span (|@| (class "comment") (id "F:532224")) "ROW->minpos is the value of min_pos, the minimal buffer position\n     we have in ROW.  ") (span (|@| (class "comment-delimiter") (id "F:532311")) "*/") "\n  " (span (|@| (class "keyword") (id "F:532316")) "if") " (min_pos <= ZV)\n    SET_TEXT_POS (row->minpos, min_pos, min_bpos);\n  " (span (|@| (class "keyword") (id "F:532388")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:532405")) "/* ") (span (|@| (class "comment") (id "F:532408")) "We didn't find _any_ valid buffer positions in any of the\n         glyphs, so we must trust the iterator's computed\n         positions.  ") (span (|@| (class "comment-delimiter") (id "F:532531")) "*/") "\n      row->minpos = row->start.pos;\n      max_pos = CHARPOS (it->current.pos);\n      max_bpos = BYTEPOS (it->current.pos);\n    }\n\n  " (span (|@| (class "keyword") (id "F:532666")) "if") " (" (span (|@| (class "negation-char") (id "F:532670")) "!") "max_pos)\n    abort ();\n\n  " (span (|@| (class "comment-delimiter") (id "F:532697")) "/* ") (span (|@| (class "comment") (id "F:532700")) "Here are the various use-cases for ending the row, and the\n     corresponding values for ROW->maxpos:\n\n     Line ends in a newline from buffer       eol_pos + 1\n     Line is continued from buffer            max_pos + 1\n     Line is truncated on right               it->current.pos\n     Line ends in a newline from string       max_pos\n     Line is continued from string            max_pos\n     Line is continued from display vector    max_pos\n     Line is entirely from a string           min_pos == max_pos\n     Line is entirely from a display vector   min_pos == max_pos\n     Line that ends at ZV                     ZV\n\n     If you discover other use-cases, please add them here as\n     appropriate.  ") (span (|@| (class "comment-delimiter") (id "F:533404")) "*/") "\n  " (span (|@| (class "keyword") (id "F:533409")) "if") " (row->ends_at_zv_p)\n    row->maxpos = it->current.pos;\n  " (span (|@| (class "keyword") (id "F:533469")) "else") " " (span (|@| (class "keyword") (id "F:533474")) "if") " (row->used[TEXT_AREA])\n    {\n      " (span (|@| (class "keyword") (id "F:533512")) "if") " (row->ends_in_newline_from_string_p)\n        SET_TEXT_POS (row->maxpos, max_pos, max_bpos);\n      " (span (|@| (class "keyword") (id "F:533606")) "else") " " (span (|@| (class "keyword") (id "F:533611")) "if") " (CHARPOS (it->eol_pos) > 0)\n        SET_TEXT_POS (row->maxpos,\n                      CHARPOS (it->eol_pos) + 1, BYTEPOS (it->eol_pos) + 1);\n      " (span (|@| (class "keyword") (id "F:533739")) "else") " " (span (|@| (class "keyword") (id "F:533744")) "if") " (row->continued_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:533772")) "/* ") (span (|@| (class "comment") (id "F:533775")) "If max_pos is different from IT's current position, it\n             means IT->method does not belong to the display element\n             at max_pos.  However, it also means that the display\n             element at max_pos was displayed in its entirety on this\n             line, which is equivalent to saying that the next line\n             starts at the next buffer position.  ") (span (|@| (class "comment-delimiter") (id "F:534118")) "*/") "\n          " (span (|@| (class "keyword") (id "F:534124")) "if") " (IT_CHARPOS (*it) == max_pos && it->method != GET_FROM_BUFFER)\n            SET_TEXT_POS (row->maxpos, max_pos, max_bpos);\n          " (span (|@| (class "keyword") (id "F:534245")) "else") "\n            {\n              INC_BOTH (max_pos, max_bpos);\n              SET_TEXT_POS (row->maxpos, max_pos, max_bpos);\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:534364")) "else") " " (span (|@| (class "keyword") (id "F:534369")) "if") " (row->truncated_on_right_p)\n        " (span (|@| (class "comment-delimiter") (id "F:534401")) "/* ") (span (|@| (class "comment") (id "F:534404")) "display_line already called reseat_at_next_visible_line_start,\n           which puts the iterator at the beginning of the next line, in\n           the logical order. ") (span (|@| (class "comment-delimiter") (id "F:534556")) "*/") "\n        row->maxpos = it->current.pos;\n      " (span (|@| (class "keyword") (id "F:534597")) "else") " " (span (|@| (class "keyword") (id "F:534602")) "if") " (max_pos == min_pos && it->method != GET_FROM_BUFFER)\n        " (span (|@| (class "comment-delimiter") (id "F:534660")) "/* ") (span (|@| (class "comment") (id "F:534663")) "A line that is entirely from a string/image/stretch...  ") (span (|@| (class "comment-delimiter") (id "F:534719")) "*/") "\n        row->maxpos = row->minpos;\n      " (span (|@| (class "keyword") (id "F:534756")) "else") "\n        abort ();\n    }\n  " (span (|@| (class "keyword") (id "F:534780")) "else") "\n    row->maxpos = it->current.pos;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:534823")) "/* ") (span (|@| (class "comment") (id "F:534826")) "Construct the glyph row IT->glyph_row in the desired matrix of\n   IT->w from text at the current position of IT.  See dispextern.h\n   for an overview of struct it.  Value is non-zero if\n   IT->glyph_row displays text, as opposed to a line displaying ZV\n   only.  ") (span (|@| (class "comment-delimiter") (id "F:535089")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:535093")) "static") " " (span (|@| (class "type") (id "F:535100")) "int") "\n" (span (|@| (class "function-name") (id "F:535104")) "display_line") " (" (span (|@| (class "type") (id "F:535118")) "it") ")\n     " (span (|@| (class "keyword") (id "F:535127")) "struct") " " (span (|@| (class "type") (id "F:535134")) "it") " *" (span (|@| (class "variable-name") (id "F:535138")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:535146")) "struct") " " (span (|@| (class "type") (id "F:535153")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:535164")) "row") " = it->glyph_row;\n  " (span (|@| (class "type") (id "F:535187")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:535199")) "overlay_arrow_string") ";\n  " (span (|@| (class "keyword") (id "F:535223")) "struct") " " (span (|@| (class "type") (id "F:535230")) "it") " " (span (|@| (class "variable-name") (id "F:535233")) "wrap_it") ";\n  " (span (|@| (class "type") (id "F:535244")) "int") " " (span (|@| (class "variable-name") (id "F:535248")) "may_wrap") " = 0, " (span (|@| (class "variable-name") (id "F:535262")) "wrap_x") ";\n  " (span (|@| (class "type") (id "F:535272")) "int") " " (span (|@| (class "variable-name") (id "F:535276")) "wrap_row_used") " = -1, " (span (|@| (class "variable-name") (id "F:535296")) "wrap_row_ascent") ", " (span (|@| (class "variable-name") (id "F:535313")) "wrap_row_height") ";\n  " (span (|@| (class "type") (id "F:535332")) "int") " " (span (|@| (class "variable-name") (id "F:535336")) "wrap_row_phys_ascent") ", " (span (|@| (class "variable-name") (id "F:535358")) "wrap_row_phys_height") ";\n  " (span (|@| (class "type") (id "F:535382")) "int") " " (span (|@| (class "variable-name") (id "F:535386")) "wrap_row_extra_line_spacing") ";\n  " (span (|@| (class "type") (id "F:535417")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:535427")) "wrap_row_min_pos") ", " (span (|@| (class "variable-name") (id "F:535445")) "wrap_row_min_bpos") ";\n  " (span (|@| (class "type") (id "F:535466")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:535476")) "wrap_row_max_pos") ", " (span (|@| (class "variable-name") (id "F:535494")) "wrap_row_max_bpos") ";\n  " (span (|@| (class "type") (id "F:535515")) "int") " " (span (|@| (class "variable-name") (id "F:535519")) "cvpos") ";\n  " (span (|@| (class "type") (id "F:535528")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:535538")) "min_pos") " = ZV + 1, " (span (|@| (class "variable-name") (id "F:535556")) "min_bpos") ", " (span (|@| (class "variable-name") (id "F:535566")) "max_pos") " = 0, " (span (|@| (class "variable-name") (id "F:535579")) "max_bpos") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:535592")) "/* ") (span (|@| (class "comment") (id "F:535595")) "We always start displaying at hpos zero even if hscrolled.  ") (span (|@| (class "comment-delimiter") (id "F:535655")) "*/") "\n  xassert (it->hpos == 0 && it->current_x == 0);\n\n  " (span (|@| (class "keyword") (id "F:535710")) "if") " (MATRIX_ROW_VPOS (row, it->w->desired_matrix)\n      >= it->w->desired_matrix->nrows)\n    {\n      it->w->nrows_scale_factor++;\n      fonts_changed_p = 1;\n      " (span (|@| (class "keyword") (id "F:535872")) "return") " 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:535891")) "/* ") (span (|@| (class "comment") (id "F:535894")) "Is IT->w showing the region?  ") (span (|@| (class "comment-delimiter") (id "F:535924")) "*/") "\n  it->w->region_showing = it->region_beg_charpos > 0 ? Qt : Qnil;\n\n  " (span (|@| (class "comment-delimiter") (id "F:535996")) "/* ") (span (|@| (class "comment") (id "F:535999")) "Clear the result glyph row and enable it.  ") (span (|@| (class "comment-delimiter") (id "F:536042")) "*/") "\n  prepare_desired_row (row);\n\n  row->y = it->current_y;\n  row->start = it->start;\n  row->continuation_lines_width = it->continuation_lines_width;\n  row->displays_text_p = 1;\n  row->starts_in_middle_of_char_p = it->starts_in_middle_of_char_p;\n  it->starts_in_middle_of_char_p = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:536328")) "/* ") (span (|@| (class "comment") (id "F:536331")) "Arrange the overlays nicely for our purposes.  Usually, we call\n     display_line on only one line at a time, in which case this\n     can't really hurt too much, or we call it on lines which appear\n     one after another in the buffer, in which case all calls to\n     recenter_overlay_lists but the first will be pretty cheap.  ") (span (|@| (class "comment-delimiter") (id "F:536659")) "*/") "\n  recenter_overlay_lists (current_buffer, IT_CHARPOS (*it));\n\n  " (span (|@| (class "comment-delimiter") (id "F:536726")) "/* ") (span (|@| (class "comment") (id "F:536729")) "Move over display elements that are not visible because we are\n     hscrolled.  This may stop at an x-position < IT->first_visible_x\n     if the first glyph is partially visible or if we hit a line end.  ") (span (|@| (class "comment-delimiter") (id "F:536933")) "*/") "\n  " (span (|@| (class "keyword") (id "F:536938")) "if") " (it->current_x < it->first_visible_x)\n    {\n      move_it_in_display_line_to (it, ZV, it->first_visible_x,\n                                  MOVE_TO_POS | MOVE_TO_X);\n    }\n  " (span (|@| (class "keyword") (id "F:537088")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:537105")) "/* ") (span (|@| (class "comment") (id "F:537108")) "We only do this when not calling `move_it_in_display_line_to'\n         above, because move_it_in_display_line_to calls\n         handle_line_prefix itself.  ") (span (|@| (class "comment-delimiter") (id "F:537250")) "*/") "\n      handle_line_prefix (it);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:537293")) "/* ") (span (|@| (class "comment") (id "F:537296")) "Get the initial row height.  This is either the height of the\n     text hscrolled, if there is any, or zero.  ") (span (|@| (class "comment-delimiter") (id "F:537406")) "*/") "\n  row->ascent = it->max_ascent;\n  row->height = it->max_ascent + it->max_descent;\n  row->phys_ascent = it->max_phys_ascent;\n  row->phys_height = it->max_phys_ascent + it->max_phys_descent;\n  row->extra_line_spacing = it->max_extra_line_spacing;\n\n" (span (|@| (class "comment-delimiter") (id "F:537655")) "/* ") (span (|@| (class "comment") (id "F:537658")) "Utility macro to record max and min buffer positions seen until now.  ") (span (|@| (class "comment-delimiter") (id "F:537728")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:537731")) "#define") " " (span (|@| (class "function-name") (id "F:537739")) "RECORD_MAX_MIN_POS") "(" (span (|@| (class "variable-name") (id "F:537758")) "IT") ")                                  \\\n  " (span (|@| (class "keyword") (id "F:537770")) "do") "                                                            \\\n    {                                                           \\\n      " (span (|@| (class "keyword") (id "F:537803")) "if") " (IT_CHARPOS (*(IT)) < min_pos)                         \\\n        {                                                       \\\n          min_pos = IT_CHARPOS (*(IT));                         \\\n          min_bpos = IT_BYTEPOS (*(IT));                        \\\n        }                                                       \\\n      " (span (|@| (class "keyword") (id "F:537946")) "if") " (IT_CHARPOS (*(IT)) > max_pos)                         \\\n        {                                                       \\\n          max_pos = IT_CHARPOS (*(IT));                         \\\n          max_bpos = IT_BYTEPOS (*(IT));                        \\\n        }                                                       \\\n    }                                                           \\\n  " (span (|@| (class "keyword") (id "F:538100")) "while") " (0)\n\n  " (span (|@| (class "comment-delimiter") (id "F:538113")) "/* ") (span (|@| (class "comment") (id "F:538116")) "Loop generating characters.  The loop is left with IT on the next\n     character to display.  ") (span (|@| (class "comment-delimiter") (id "F:538210")) "*/") "\n  " (span (|@| (class "keyword") (id "F:538215")) "while") " (1)\n    {\n      " (span (|@| (class "type") (id "F:538237")) "int") " " (span (|@| (class "variable-name") (id "F:538241")) "n_glyphs_before") ", " (span (|@| (class "variable-name") (id "F:538258")) "hpos_before") ", " (span (|@| (class "variable-name") (id "F:538271")) "x_before") ";\n      " (span (|@| (class "type") (id "F:538287")) "int") " " (span (|@| (class "variable-name") (id "F:538291")) "x") ", " (span (|@| (class "variable-name") (id "F:538294")) "i") ", " (span (|@| (class "variable-name") (id "F:538297")) "nglyphs") ";\n      " (span (|@| (class "type") (id "F:538312")) "int") " " (span (|@| (class "variable-name") (id "F:538316")) "ascent") " = 0, " (span (|@| (class "variable-name") (id "F:538328")) "descent") " = 0, " (span (|@| (class "variable-name") (id "F:538341")) "phys_ascent") " = 0, " (span (|@| (class "variable-name") (id "F:538358")) "phys_descent") " = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:538383")) "/* ") (span (|@| (class "comment") (id "F:538386")) "Retrieve the next thing to display.  Value is zero if end of\n         buffer reached.  ") (span (|@| (class "comment-delimiter") (id "F:538466")) "*/") "\n      " (span (|@| (class "keyword") (id "F:538475")) "if") " (" (span (|@| (class "negation-char") (id "F:538479")) "!") "get_next_display_element (it))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:538517")) "/* ") (span (|@| (class "comment") (id "F:538520")) "Maybe add a space at the end of this line that is used to\n             display the cursor there under X.  Set the charpos of the\n             first glyph of blank lines not corresponding to any text\n             to -1.  ") (span (|@| (class "comment-delimiter") (id "F:538719")) "*/") "\n          " (span (|@| (class "keyword") (id "F:538725")) "if") " (IT_OVERFLOW_NEWLINE_INTO_FRINGE (it))\n            row->exact_window_width_line_p = 1;\n          " (span (|@| (class "keyword") (id "F:538811")) "else") " " (span (|@| (class "keyword") (id "F:538816")) "if") " ((append_space_for_newline (it, 1) && row->used[TEXT_AREA] == 1)\n                   || row->used[TEXT_AREA] == 0)\n            {\n              row->glyphs[TEXT_AREA]->charpos = -1;\n              row->displays_text_p = 0;\n\n              " (span (|@| (class "keyword") (id "F:539012")) "if") " (" (span (|@| (class "negation-char") (id "F:539016")) "!") "NILP (XBUFFER (it->w->buffer)->indicate_empty_lines)\n                  && (" (span (|@| (class "negation-char") (id "F:539078")) "!") "MINI_WINDOW_P (it->w)\n                      || (minibuf_level && EQ (it->window, minibuf_window))))\n                row->indicate_empty_line_p = 1;\n            }\n\n          it->continuation_lines_width = 0;\n          row->ends_at_zv_p = 1;\n          " (span (|@| (class "comment-delimiter") (id "F:539273")) "/* ") (span (|@| (class "comment") (id "F:539276")) "A row that displays right-to-left text must always have\n             its last face extended all the way to the end of line,\n             even if this row ends in ZV, because we still write to th\n             screen left to right.  ") (span (|@| (class "comment-delimiter") (id "F:539486")) "*/") "\n          " (span (|@| (class "keyword") (id "F:539492")) "if") " (row->reversed_p)\n            extend_face_to_end_of_line (it);\n          " (span (|@| (class "keyword") (id "F:539554")) "break") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:539571")) "/* ") (span (|@| (class "comment") (id "F:539574")) "Now, get the metrics of what we want to display.  This also\n         generates glyphs in `row' (which is IT->glyph_row).  ") (span (|@| (class "comment-delimiter") (id "F:539689")) "*/") "\n      n_glyphs_before = row->used[TEXT_AREA];\n      x = it->current_x;\n\n      " (span (|@| (class "comment-delimiter") (id "F:539770")) "/* ") (span (|@| (class "comment") (id "F:539773")) "Remember the line height so far in case the next element doesn't\n         fit on the line.  ") (span (|@| (class "comment-delimiter") (id "F:539858")) "*/") "\n      " (span (|@| (class "keyword") (id "F:539867")) "if") " (it->line_wrap != TRUNCATE)\n        {\n          ascent = it->max_ascent;\n          descent = it->max_descent;\n          phys_ascent = it->max_phys_ascent;\n          phys_descent = it->max_phys_descent;\n\n          " (span (|@| (class "keyword") (id "F:540041")) "if") " (it->line_wrap == WORD_WRAP && it->area == TEXT_AREA)\n            {\n              " (span (|@| (class "keyword") (id "F:540112")) "if") " (IT_DISPLAYING_WHITESPACE (it))\n                may_wrap = 1;\n              " (span (|@| (class "keyword") (id "F:540170")) "else") " " (span (|@| (class "keyword") (id "F:540175")) "if") " (may_wrap)\n                {\n                  wrap_it = *it;\n                  wrap_x = x;\n                  wrap_row_used = row->used[TEXT_AREA];\n                  wrap_row_ascent = row->ascent;\n                  wrap_row_height = row->height;\n                  wrap_row_phys_ascent = row->phys_ascent;\n                  wrap_row_phys_height = row->phys_height;\n                  wrap_row_extra_line_spacing = row->extra_line_spacing;\n                  wrap_row_min_pos = min_pos;\n                  wrap_row_min_bpos = min_bpos;\n                  wrap_row_max_pos = max_pos;\n                  wrap_row_max_bpos = max_bpos;\n                  may_wrap = 0;\n                }\n            }\n        }\n\n      PRODUCE_GLYPHS (it);\n\n      " (span (|@| (class "comment-delimiter") (id "F:540688")) "/* ") (span (|@| (class "comment") (id "F:540691")) "If this display element was in marginal areas, continue with\n         the next one.  ") (span (|@| (class "comment-delimiter") (id "F:540769")) "*/") "\n      " (span (|@| (class "keyword") (id "F:540778")) "if") " (it->area != TEXT_AREA)\n        {\n          row->ascent = max (row->ascent, it->max_ascent);\n          row->height = max (row->height, it->max_ascent + it->max_descent);\n          row->phys_ascent = max (row->phys_ascent, it->max_phys_ascent);\n          row->phys_height = max (row->phys_height,\n                                  it->max_phys_ascent + it->max_phys_descent);\n          row->extra_line_spacing = max (row->extra_line_spacing,\n                                         it->max_extra_line_spacing);\n          set_iterator_to_next (it, 1);\n          " (span (|@| (class "keyword") (id "F:541223")) "continue") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:541243")) "/* ") (span (|@| (class "comment") (id "F:541246")) "Does the display element fit on the line?  If we truncate\n         lines, we should draw past the right edge of the window.  If\n         we don't truncate, we want to stop so that we can display the\n         continuation glyph before the right margin.  If lines are\n         continued, there are two possible strategies for characters\n         resulting in more than 1 glyph (e.g. tabs): Display as many\n         glyphs as possible in this line and leave the rest for the\n         continuation line, or display the whole element in the next\n         line.  Original redisplay did the former, so we do it also.  ") (span (|@| (class "comment-delimiter") (id "F:541801")) "*/") "\n      nglyphs = row->used[TEXT_AREA] - n_glyphs_before;\n      hpos_before = it->hpos;\n      x_before = x;\n\n      " (span (|@| (class "keyword") (id "F:541917")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:541921")) "/* ") (span (|@| (class "comment") (id "F:541924")) "Not a newline.  ") (span (|@| (class "comment-delimiter") (id "F:541940")) "*/") "\n          nglyphs > 0\n          " (span (|@| (class "comment-delimiter") (id "F:541961")) "/* ") (span (|@| (class "comment") (id "F:541964")) "Glyphs produced fit entirely in the line.  ") (span (|@| (class "comment-delimiter") (id "F:542007")) "*/") "\n          && it->current_x < it->last_visible_x)\n        {\n          it->hpos += nglyphs;\n          row->ascent = max (row->ascent, it->max_ascent);\n          row->height = max (row->height, it->max_ascent + it->max_descent);\n          row->phys_ascent = max (row->phys_ascent, it->max_phys_ascent);\n          row->phys_height = max (row->phys_height,\n                                  it->max_phys_ascent + it->max_phys_descent);\n          row->extra_line_spacing = max (row->extra_line_spacing,\n                                         it->max_extra_line_spacing);\n          " (span (|@| (class "keyword") (id "F:542461")) "if") " (it->current_x - it->pixel_width < it->first_visible_x)\n            row->x = x - it->first_visible_x;\n          " (span (|@| (class "comment-delimiter") (id "F:542562")) "/* ") (span (|@| (class "comment") (id "F:542565")) "Record the maximum and minimum buffer positions seen so\n             far in glyphs that will be displayed by this row.  ") (span (|@| (class "comment-delimiter") (id "F:542678")) "*/") "\n          " (span (|@| (class "keyword") (id "F:542684")) "if") " (it->bidi_p)\n            RECORD_MAX_MIN_POS (it);\n        }\n      " (span (|@| (class "keyword") (id "F:542739")) "else") "\n        {\n          " (span (|@| (class "type") (id "F:542750")) "int") " " (span (|@| (class "variable-name") (id "F:542754")) "new_x") ";\n          " (span (|@| (class "keyword") (id "F:542764")) "struct") " " (span (|@| (class "type") (id "F:542771")) "glyph") " *" (span (|@| (class "variable-name") (id "F:542778")) "glyph") ";\n\n          " (span (|@| (class "keyword") (id "F:542789")) "for") " (i = 0; i < nglyphs; ++i, x = new_x)\n            {\n              glyph = row->glyphs[TEXT_AREA] + n_glyphs_before + i;\n              new_x = x + glyph->pixel_width;\n\n              " (span (|@| (class "keyword") (id "F:542945")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:542949")) "/* ") (span (|@| (class "comment") (id "F:542952")) "Lines are continued.  ") (span (|@| (class "comment-delimiter") (id "F:542974")) "*/") "\n                  it->line_wrap != TRUNCATE\n                  && (" (span (|@| (class "comment-delimiter") (id "F:543015")) "/* ") (span (|@| (class "comment") (id "F:543018")) "Glyph doesn't fit on the line.  ") (span (|@| (class "comment-delimiter") (id "F:543050")) "*/") "\n                      new_x > it->last_visible_x\n                      " (span (|@| (class "comment-delimiter") (id "F:543096")) "/* ") (span (|@| (class "comment") (id "F:543099")) "Or it fits exactly on a window system frame.  ") (span (|@| (class "comment-delimiter") (id "F:543145")) "*/") "\n                      || (new_x == it->last_visible_x\n                          && FRAME_WINDOW_P (it->f))))\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:543230")) "/* ") (span (|@| (class "comment") (id "F:543233")) "End of a continued line.  ") (span (|@| (class "comment-delimiter") (id "F:543259")) "*/") "\n\n                  " (span (|@| (class "keyword") (id "F:543267")) "if") " (it->hpos == 0\n                      || (new_x == it->last_visible_x\n                          && FRAME_WINDOW_P (it->f)))\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:543374")) "/* ") (span (|@| (class "comment") (id "F:543377")) "Current glyph is the only one on the line or\n                         fits exactly on the line.  We must continue\n                         the line because we can't draw the cursor\n                         after the glyph.  ") (span (|@| (class "comment-delimiter") (id "F:543538")) "*/") "\n                      row->continued_p = 1;\n                      it->current_x = new_x;\n                      it->continuation_lines_width += new_x;\n                      ++it->hpos;\n                      " (span (|@| (class "comment-delimiter") (id "F:543677")) "/* ") (span (|@| (class "comment") (id "F:543680")) "Record the maximum and minimum buffer\n                         positions seen so far in glyphs that will be\n                         displayed by this row.  ") (span (|@| (class "comment-delimiter") (id "F:543795")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:543806")) "if") " (it->bidi_p)\n                        RECORD_MAX_MIN_POS (it);\n                      " (span (|@| (class "keyword") (id "F:543858")) "if") " (i == nglyphs - 1)\n                        {\n                          " (span (|@| (class "comment-delimiter") (id "F:543890")) "/* ") (span (|@| (class "comment") (id "F:543893")) "If line-wrap is on, check if a previous\n                             wrap point was found.  ") (span (|@| (class "comment-delimiter") (id "F:543964")) "*/") "\n                          " (span (|@| (class "keyword") (id "F:543972")) "if") " (wrap_row_used > 0\n                              " (span (|@| (class "comment-delimiter") (id "F:544003")) "/* ") (span (|@| (class "comment") (id "F:544006")) "Even if there is a previous wrap\n                                 point, continue the line here as\n                                 usual, if (i) the previous character\n                                 was a space or tab AND (ii) the\n                                 current character is not.  ") (span (|@| (class "comment-delimiter") (id "F:544188")) "*/") "\n                              && (" (span (|@| (class "negation-char") (id "F:544204")) "!") "may_wrap\n                                  || IT_DISPLAYING_WHITESPACE (it)))\n                            " (span (|@| (class "keyword") (id "F:544262")) "goto") " " (span (|@| (class "constant") (id "F:544267")) "back_to_wrap") ";\n\n                          set_iterator_to_next (it, 1);\n                          " (span (|@| (class "keyword") (id "F:544322")) "if") " (IT_OVERFLOW_NEWLINE_INTO_FRINGE (it))\n                            {\n                              " (span (|@| (class "keyword") (id "F:544382")) "if") " (" (span (|@| (class "negation-char") (id "F:544386")) "!") "get_next_display_element (it))\n                                {\n                                  row->exact_window_width_line_p = 1;\n                                  it->continuation_lines_width = 0;\n                                  row->continued_p = 0;\n                                  row->ends_at_zv_p = 1;\n                                }\n                              " (span (|@| (class "keyword") (id "F:544578")) "else") " " (span (|@| (class "keyword") (id "F:544583")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n                                {\n                                  row->continued_p = 0;\n                                  row->exact_window_width_line_p = 1;\n                                }\n                            }\n                        }\n                    }\n                  " (span (|@| (class "keyword") (id "F:544727")) "else") " " (span (|@| (class "keyword") (id "F:544732")) "if") " (CHAR_GLYPH_PADDING_P (*glyph)\n                           && " (span (|@| (class "negation-char") (id "F:544775")) "!") "FRAME_WINDOW_P (it->f))\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:544816")) "/* ") (span (|@| (class "comment") (id "F:544819")) "A padding glyph that doesn't fit on this line.\n                         This means the whole character doesn't fit\n                         on the line.  ") (span (|@| (class "comment-delimiter") (id "F:544931")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:544942")) "if") " (row->reversed_p)\n                        unproduce_glyphs (it, row->used[TEXT_AREA]\n                                               - n_glyphs_before);\n                      row->used[TEXT_AREA] = n_glyphs_before;\n\n                      " (span (|@| (class "comment-delimiter") (id "F:545098")) "/* ") (span (|@| (class "comment") (id "F:545101")) "Fill the rest of the row with continuation\n                         glyphs like in 20.x.  ") (span (|@| (class "comment-delimiter") (id "F:545170")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:545181")) "while") " (row->glyphs[TEXT_AREA] + row->used[TEXT_AREA]\n                             < row->glyphs[1 + TEXT_AREA])\n                        produce_special_glyphs (it, IT_CONTINUATION);\n\n                      row->continued_p = 1;\n                      it->current_x = x_before;\n                      it->continuation_lines_width += x_before;\n\n                      " (span (|@| (class "comment-delimiter") (id "F:545445")) "/* ") (span (|@| (class "comment") (id "F:545448")) "Restore the height to what it was before the\n                         element not fitting on the line.  ") (span (|@| (class "comment-delimiter") (id "F:545531")) "*/") "\n                      it->max_ascent = ascent;\n                      it->max_descent = descent;\n                      it->max_phys_ascent = phys_ascent;\n                      it->max_phys_descent = phys_descent;\n                    }\n                  " (span (|@| (class "keyword") (id "F:545702")) "else") " " (span (|@| (class "keyword") (id "F:545707")) "if") " (wrap_row_used > 0)\n                    {\n                    " (span (|@| (class "constant") (id "F:545744")) "back_to_wrap") ":\n                      " (span (|@| (class "keyword") (id "F:545766")) "if") " (row->reversed_p)\n                        unproduce_glyphs (it,\n                                          row->used[TEXT_AREA] - wrap_row_used);\n                      *it = wrap_it;\n                      it->continuation_lines_width += wrap_x;\n                      row->used[TEXT_AREA] = wrap_row_used;\n                      row->ascent = wrap_row_ascent;\n                      row->height = wrap_row_height;\n                      row->phys_ascent = wrap_row_phys_ascent;\n                      row->phys_height = wrap_row_phys_height;\n                      row->extra_line_spacing = wrap_row_extra_line_spacing;\n                      min_pos = wrap_row_min_pos;\n                      min_bpos = wrap_row_min_bpos;\n                      max_pos = wrap_row_max_pos;\n                      max_bpos = wrap_row_max_bpos;\n                      row->continued_p = 1;\n                      row->ends_at_zv_p = 0;\n                      row->exact_window_width_line_p = 0;\n                      it->continuation_lines_width += x;\n\n                      " (span (|@| (class "comment-delimiter") (id "F:546519")) "/* ") (span (|@| (class "comment") (id "F:546522")) "Make sure that a non-default face is extended\n                         up to the right margin of the window.  ") (span (|@| (class "comment-delimiter") (id "F:546611")) "*/") "\n                      extend_face_to_end_of_line (it);\n                    }\n                  " (span (|@| (class "keyword") (id "F:546667")) "else") " " (span (|@| (class "keyword") (id "F:546672")) "if") " (it->c == " (span (|@| (class "string") (id "F:546685")) "'\\t'") " && FRAME_WINDOW_P (it->f))\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:546733")) "/* ") (span (|@| (class "comment") (id "F:546736")) "A TAB that extends past the right edge of the\n                         window.  This produces a single glyph on\n                         window system frames.  We leave the glyph in\n                         this row and let it fill the row, but don't\n                         consume the TAB.  ") (span (|@| (class "comment-delimiter") (id "F:546946")) "*/") "\n                      it->continuation_lines_width += it->last_visible_x;\n                      row->ends_in_middle_of_char_p = 1;\n                      row->continued_p = 1;\n                      glyph->pixel_width = it->last_visible_x - x;\n                      it->starts_in_middle_of_char_p = 1;\n                    }\n                  " (span (|@| (class "keyword") (id "F:547191")) "else") "\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:547212")) "/* ") (span (|@| (class "comment") (id "F:547215")) "Something other than a TAB that draws past\n                         the right edge of the window.  Restore\n                         positions to values before the element.  ") (span (|@| (class "comment-delimiter") (id "F:547346")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:547357")) "if") " (row->reversed_p)\n                        unproduce_glyphs (it, row->used[TEXT_AREA]\n                                               - (n_glyphs_before + i));\n                      row->used[TEXT_AREA] = n_glyphs_before + i;\n\n                      " (span (|@| (class "comment-delimiter") (id "F:547523")) "/* ") (span (|@| (class "comment") (id "F:547526")) "Display continuation glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:547556")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:547567")) "if") " (" (span (|@| (class "negation-char") (id "F:547571")) "!") "FRAME_WINDOW_P (it->f))\n                        produce_special_glyphs (it, IT_CONTINUATION);\n                      row->continued_p = 1;\n\n                      it->current_x = x_before;\n                      it->continuation_lines_width += x;\n                      extend_face_to_end_of_line (it);\n\n                      " (span (|@| (class "keyword") (id "F:547803")) "if") " (nglyphs > 1 && i > 0)\n                        {\n                          row->ends_in_middle_of_char_p = 1;\n                          it->starts_in_middle_of_char_p = 1;\n                        }\n\n                      " (span (|@| (class "comment-delimiter") (id "F:547929")) "/* ") (span (|@| (class "comment") (id "F:547932")) "Restore the height to what it was before the\n                         element not fitting on the line.  ") (span (|@| (class "comment-delimiter") (id "F:548015")) "*/") "\n                      it->max_ascent = ascent;\n                      it->max_descent = descent;\n                      it->max_phys_ascent = phys_ascent;\n                      it->max_phys_descent = phys_descent;\n                    }\n\n                  " (span (|@| (class "keyword") (id "F:548187")) "break") ";\n                }\n              " (span (|@| (class "keyword") (id "F:548205")) "else") " " (span (|@| (class "keyword") (id "F:548210")) "if") " (new_x > it->first_visible_x)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:548251")) "/* ") (span (|@| (class "comment") (id "F:548254")) "Increment number of glyphs actually displayed.  ") (span (|@| (class "comment-delimiter") (id "F:548302")) "*/") "\n                  ++it->hpos;\n\n                  " (span (|@| (class "comment-delimiter") (id "F:548326")) "/* ") (span (|@| (class "comment") (id "F:548329")) "Record the maximum and minimum buffer positions\n                     seen so far in glyphs that will be displayed by\n                     this row.  ") (span (|@| (class "comment-delimiter") (id "F:548450")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:548457")) "if") " (it->bidi_p)\n                    RECORD_MAX_MIN_POS (it);\n\n                  " (span (|@| (class "keyword") (id "F:548509")) "if") " (x < it->first_visible_x)\n                    " (span (|@| (class "comment-delimiter") (id "F:548544")) "/* ") (span (|@| (class "comment") (id "F:548547")) "Glyph is partially visible, i.e. row starts at\n                       negative X position.  ") (span (|@| (class "comment-delimiter") (id "F:548625")) "*/") "\n                    row->x = x - it->first_visible_x;\n                }\n              " (span (|@| (class "keyword") (id "F:548679")) "else") "\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:548692")) "/* ") (span (|@| (class "comment") (id "F:548695")) "Glyph is completely off the left margin of the\n                     window.  This should not happen because of the\n                     move_it_in_display_line at the start of this\n                     function, unless the text display area of the\n                     window is empty.  ") (span (|@| (class "comment-delimiter") (id "F:548926")) "*/") "\n                  xassert (it->first_visible_x <= it->last_visible_x);\n                }\n            }\n\n          row->ascent = max (row->ascent, it->max_ascent);\n          row->height = max (row->height, it->max_ascent + it->max_descent);\n          row->phys_ascent = max (row->phys_ascent, it->max_phys_ascent);\n          row->phys_height = max (row->phys_height,\n                                  it->max_phys_ascent + it->max_phys_descent);\n          row->extra_line_spacing = max (row->extra_line_spacing,\n                                         it->max_extra_line_spacing);\n\n          " (span (|@| (class "comment-delimiter") (id "F:549381")) "/* ") (span (|@| (class "comment") (id "F:549384")) "End of this display line if row is continued.  ") (span (|@| (class "comment-delimiter") (id "F:549431")) "*/") "\n          " (span (|@| (class "keyword") (id "F:549437")) "if") " (row->continued_p || row->ends_at_zv_p)\n            " (span (|@| (class "keyword") (id "F:549485")) "break") ";\n        }\n\n    " (span (|@| (class "constant") (id "F:549500")) "at_end_of_line") ":\n      " (span (|@| (class "comment-delimiter") (id "F:549522")) "/* ") (span (|@| (class "comment") (id "F:549525")) "Is this a line end?  If yes, we're also done, after making\n         sure that a non-default face is extended up to the right\n         margin of the window.  ") (span (|@| (class "comment-delimiter") (id "F:549668")) "*/") "\n      " (span (|@| (class "keyword") (id "F:549677")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n        {\n          " (span (|@| (class "type") (id "F:549719")) "int") " " (span (|@| (class "variable-name") (id "F:549723")) "used_before") " = row->used[TEXT_AREA];\n\n          row->ends_in_newline_from_string_p = STRINGP (it->object);\n\n          " (span (|@| (class "comment-delimiter") (id "F:549826")) "/* ") (span (|@| (class "comment") (id "F:549829")) "Add a space at the end of the line that is used to\n             display the cursor there.  ") (span (|@| (class "comment-delimiter") (id "F:549913")) "*/") "\n          " (span (|@| (class "keyword") (id "F:549919")) "if") " (" (span (|@| (class "negation-char") (id "F:549923")) "!") "IT_OVERFLOW_NEWLINE_INTO_FRINGE (it))\n            append_space_for_newline (it, 0);\n\n          " (span (|@| (class "comment-delimiter") (id "F:550005")) "/* ") (span (|@| (class "comment") (id "F:550008")) "Extend the face to the end of the line.  ") (span (|@| (class "comment-delimiter") (id "F:550049")) "*/") "\n          extend_face_to_end_of_line (it);\n\n          " (span (|@| (class "comment-delimiter") (id "F:550092")) "/* ") (span (|@| (class "comment") (id "F:550095")) "Make sure we have the position.  ") (span (|@| (class "comment-delimiter") (id "F:550128")) "*/") "\n          " (span (|@| (class "keyword") (id "F:550134")) "if") " (used_before == 0)\n            row->glyphs[TEXT_AREA]->charpos = CHARPOS (it->position);\n\n          " (span (|@| (class "comment-delimiter") (id "F:550223")) "/* ") (span (|@| (class "comment") (id "F:550226")) "Record the position of the newline, for use in\n             find_row_edges.  ") (span (|@| (class "comment-delimiter") (id "F:550296")) "*/") "\n          it->eol_pos = it->current.pos;\n\n          " (span (|@| (class "comment-delimiter") (id "F:550337")) "/* ") (span (|@| (class "comment") (id "F:550340")) "Consume the line end.  This skips over invisible lines.  ") (span (|@| (class "comment-delimiter") (id "F:550397")) "*/") "\n          set_iterator_to_next (it, 1);\n          it->continuation_lines_width = 0;\n          " (span (|@| (class "keyword") (id "F:550473")) "break") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:550490")) "/* ") (span (|@| (class "comment") (id "F:550493")) "Proceed with next display element.  Note that this skips\n         over lines invisible because of selective display.  ") (span (|@| (class "comment-delimiter") (id "F:550604")) "*/") "\n      set_iterator_to_next (it, 1);\n\n      " (span (|@| (class "comment-delimiter") (id "F:550650")) "/* ") (span (|@| (class "comment") (id "F:550653")) "If we truncate lines, we are done when the last displayed\n         glyphs reach past the right margin of the window.  ") (span (|@| (class "comment-delimiter") (id "F:550764")) "*/") "\n      " (span (|@| (class "keyword") (id "F:550773")) "if") " (it->line_wrap == TRUNCATE\n          && (FRAME_WINDOW_P (it->f)\n              ? (it->current_x >= it->last_visible_x)\n              : (it->current_x > it->last_visible_x)))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:550934")) "/* ") (span (|@| (class "comment") (id "F:550937")) "Maybe add truncation glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:550967")) "*/") "\n          " (span (|@| (class "keyword") (id "F:550973")) "if") " (" (span (|@| (class "negation-char") (id "F:550977")) "!") "FRAME_WINDOW_P (it->f))\n            {\n              " (span (|@| (class "type") (id "F:551016")) "int") " " (span (|@| (class "variable-name") (id "F:551020")) "i") ", " (span (|@| (class "variable-name") (id "F:551023")) "n") ";\n\n              " (span (|@| (class "keyword") (id "F:551034")) "if") " (" (span (|@| (class "negation-char") (id "F:551038")) "!") "row->reversed_p)\n                {\n                  " (span (|@| (class "keyword") (id "F:551064")) "for") " (i = row->used[TEXT_AREA] - 1; i > 0; --i)\n                    " (span (|@| (class "keyword") (id "F:551117")) "if") " (" (span (|@| (class "negation-char") (id "F:551121")) "!") "CHAR_GLYPH_PADDING_P (row->glyphs[TEXT_AREA][i]))\n                      " (span (|@| (class "keyword") (id "F:551180")) "break") ";\n                }\n              " (span (|@| (class "keyword") (id "F:551198")) "else") "\n                {\n                  " (span (|@| (class "keyword") (id "F:551211")) "for") " (i = 0; i < row->used[TEXT_AREA]; i++)\n                    " (span (|@| (class "keyword") (id "F:551260")) "if") " (" (span (|@| (class "negation-char") (id "F:551264")) "!") "CHAR_GLYPH_PADDING_P (row->glyphs[TEXT_AREA][i]))\n                      " (span (|@| (class "keyword") (id "F:551323")) "break") ";\n                  " (span (|@| (class "comment-delimiter") (id "F:551334")) "/* ") (span (|@| (class "comment") (id "F:551337")) "Remove any padding glyphs at the front of ROW, to\n                     make room for the truncation glyphs we will be\n                     adding below.  The loop below always inserts at\n                     least one truncation glyph, so also remove the\n                     last glyph added to ROW.  ") (span (|@| (class "comment-delimiter") (id "F:551583")) "*/") "\n                  unproduce_glyphs (it, i + 1);\n                  " (span (|@| (class "comment-delimiter") (id "F:551624")) "/* ") (span (|@| (class "comment") (id "F:551627")) "Adjust i for the loop below.  ") (span (|@| (class "comment-delimiter") (id "F:551657")) "*/") "\n                  i = row->used[TEXT_AREA] - (i + 1);\n                }\n\n              " (span (|@| (class "keyword") (id "F:551712")) "for") " (n = row->used[TEXT_AREA]; i < n; ++i)\n                {\n                  row->used[TEXT_AREA] = i;\n                  produce_special_glyphs (it, IT_TRUNCATION);\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:551851")) "else") " " (span (|@| (class "keyword") (id "F:551856")) "if") " (IT_OVERFLOW_NEWLINE_INTO_FRINGE (it))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:551912")) "/* ") (span (|@| (class "comment") (id "F:551915")) "Don't truncate if we can overflow newline into fringe.  ") (span (|@| (class "comment-delimiter") (id "F:551971")) "*/") "\n              " (span (|@| (class "keyword") (id "F:551981")) "if") " (" (span (|@| (class "negation-char") (id "F:551985")) "!") "get_next_display_element (it))\n                {\n                  it->continuation_lines_width = 0;\n                  row->ends_at_zv_p = 1;\n                  row->exact_window_width_line_p = 1;\n                  " (span (|@| (class "keyword") (id "F:552130")) "break") ";\n                }\n              " (span (|@| (class "keyword") (id "F:552148")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n                {\n                  row->exact_window_width_line_p = 1;\n                  " (span (|@| (class "keyword") (id "F:552232")) "goto") " " (span (|@| (class "constant") (id "F:552237")) "at_end_of_line") ";\n                }\n            }\n\n          row->truncated_on_right_p = 1;\n          it->continuation_lines_width = 0;\n          reseat_at_next_visible_line_start (it, 0);\n          row->ends_at_zv_p = FETCH_BYTE (IT_BYTEPOS (*it) - 1) != " (span (|@| (class "string") (id "F:552442")) "'\\n'") ";\n          it->hpos = hpos_before;\n          it->current_x = x_before;\n          " (span (|@| (class "keyword") (id "F:552507")) "break") ";\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:552526")) "/* ") (span (|@| (class "comment") (id "F:552529")) "If line is not empty and hscrolled, maybe insert truncation glyphs\n     at the left window margin.  ") (span (|@| (class "comment-delimiter") (id "F:552629")) "*/") "\n  " (span (|@| (class "keyword") (id "F:552634")) "if") " (it->first_visible_x\n      && IT_CHARPOS (*it) != CHARPOS (row->start.pos))\n    {\n      " (span (|@| (class "keyword") (id "F:552725")) "if") " (" (span (|@| (class "negation-char") (id "F:552729")) "!") "FRAME_WINDOW_P (it->f))\n        insert_left_trunc_glyphs (it);\n      row->truncated_on_left_p = 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:552831")) "/* ") (span (|@| (class "comment") (id "F:552834")) "If the start of this line is the overlay arrow-position, then\n     mark this glyph row as the one containing the overlay arrow.\n     This is clearly a mess with variable size fonts.  It would be\n     better to let it be displayed like cursors under X.  ") (span (|@| (class "comment-delimiter") (id "F:553087")) "*/") "\n  " (span (|@| (class "keyword") (id "F:553092")) "if") " ((row->displays_text_p || " (span (|@| (class "negation-char") (id "F:553121")) "!") "overlay_arrow_seen)\n      && (overlay_arrow_string = overlay_arrow_at_row (it, row),\n          " (span (|@| (class "negation-char") (id "F:553210")) "!") "NILP (overlay_arrow_string)))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:553253")) "/* ") (span (|@| (class "comment") (id "F:553256")) "Overlay arrow in window redisplay is a fringe bitmap.  ") (span (|@| (class "comment-delimiter") (id "F:553311")) "*/") "\n      " (span (|@| (class "keyword") (id "F:553320")) "if") " (STRINGP (overlay_arrow_string))\n        {\n          " (span (|@| (class "keyword") (id "F:553362")) "struct") " " (span (|@| (class "type") (id "F:553369")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:553380")) "arrow_row") "\n            = get_overlay_arrow_glyph_row (it->w, overlay_arrow_string);\n          " (span (|@| (class "keyword") (id "F:553459")) "struct") " " (span (|@| (class "type") (id "F:553466")) "glyph") " *" (span (|@| (class "variable-name") (id "F:553473")) "glyph") " = arrow_row->glyphs[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:553514")) "struct") " " (span (|@| (class "type") (id "F:553521")) "glyph") " *" (span (|@| (class "variable-name") (id "F:553528")) "arrow_end") " = glyph + arrow_row->used[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:553579")) "struct") " " (span (|@| (class "type") (id "F:553586")) "glyph") " *" (span (|@| (class "variable-name") (id "F:553593")) "p") " = row->glyphs[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:553624")) "struct") " " (span (|@| (class "type") (id "F:553631")) "glyph") " *" (span (|@| (class "variable-name") (id "F:553638")) "p2") ", *" (span (|@| (class "variable-name") (id "F:553643")) "end") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:553652")) "/* ") (span (|@| (class "comment") (id "F:553655")) "Copy the arrow glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:553679")) "*/") "\n          " (span (|@| (class "keyword") (id "F:553685")) "while") " (glyph < arrow_end)\n            *p++ = *glyph++;\n\n          " (span (|@| (class "comment-delimiter") (id "F:553737")) "/* ") (span (|@| (class "comment") (id "F:553740")) "Throw away padding glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:553768")) "*/") "\n          p2 = p;\n          end = row->glyphs[TEXT_AREA] + row->used[TEXT_AREA];\n          " (span (|@| (class "keyword") (id "F:553841")) "while") " (p2 < end && CHAR_GLYPH_PADDING_P (*p2))\n            ++p2;\n          " (span (|@| (class "keyword") (id "F:553902")) "if") " (p2 > p)\n            {\n              " (span (|@| (class "keyword") (id "F:553928")) "while") " (p2 < end)\n                *p++ = *p2++;\n              row->used[TEXT_AREA] = p2 - row->glyphs[TEXT_AREA];\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:554036")) "else") "\n        {\n          xassert (INTEGERP (overlay_arrow_string));\n          row->overlay_arrow_bitmap = XINT (overlay_arrow_string);\n        }\n      overlay_arrow_seen = 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:554192")) "/* ") (span (|@| (class "comment") (id "F:554195")) "Compute pixel dimensions of this line.  ") (span (|@| (class "comment-delimiter") (id "F:554235")) "*/") "\n  compute_line_metrics (it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:554270")) "/* ") (span (|@| (class "comment") (id "F:554273")) "Remember the position at which this line ends.  ") (span (|@| (class "comment-delimiter") (id "F:554321")) "*/") "\n  row->end = it->current;\n  " (span (|@| (class "keyword") (id "F:554352")) "if") " (" (span (|@| (class "negation-char") (id "F:554356")) "!") "it->bidi_p)\n    {\n      row->minpos = row->start.pos;\n      row->maxpos = row->end.pos;\n    }\n  " (span (|@| (class "keyword") (id "F:554453")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:554470")) "/* ") (span (|@| (class "comment") (id "F:554473")) "ROW->minpos and ROW->maxpos must be the smallest and\n         `1 + the largest' buffer positions in ROW.  But if ROW was\n         bidi-reordered, these two positions can be anywhere in the\n         row, so we must determine them now.  ") (span (|@| (class "comment-delimiter") (id "F:554687")) "*/") "\n      find_row_edges (it, row, min_pos, min_bpos, max_pos, max_bpos);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:554769")) "/* ") (span (|@| (class "comment") (id "F:554772")) "Record whether this row ends inside an ellipsis.  ") (span (|@| (class "comment-delimiter") (id "F:554822")) "*/") "\n  row->ends_in_ellipsis_p\n    = (it->method == GET_FROM_DISPLAY_VECTOR\n       && it->ellipsis_p);\n\n  " (span (|@| (class "comment-delimiter") (id "F:554926")) "/* ") (span (|@| (class "comment") (id "F:554929")) "Save fringe bitmaps in this row.  ") (span (|@| (class "comment-delimiter") (id "F:554963")) "*/") "\n  row->left_user_fringe_bitmap = it->left_user_fringe_bitmap;\n  row->left_user_fringe_face_id = it->left_user_fringe_face_id;\n  row->right_user_fringe_bitmap = it->right_user_fringe_bitmap;\n  row->right_user_fringe_face_id = it->right_user_fringe_face_id;\n\n  it->left_user_fringe_bitmap = 0;\n  it->left_user_fringe_face_id = 0;\n  it->right_user_fringe_bitmap = 0;\n  it->right_user_fringe_face_id = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:555370")) "/* ") (span (|@| (class "comment") (id "F:555373")) "Maybe set the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:555396")) "*/") "\n  cvpos = it->w->cursor.vpos;\n  " (span (|@| (class "keyword") (id "F:555431")) "if") " ((cvpos < 0\n       " (span (|@| (class "comment-delimiter") (id "F:555453")) "/* ") (span (|@| (class "comment") (id "F:555456")) "In bidi-reordered rows, keep checking for proper cursor\n          position even if one has been found already, because buffer\n          positions in such rows change non-linearly with ROW->VPOS,\n          when a line is continued.  One exception: when we are at ZV,\n          display cursor on the first suitable glyph row, since all\n          the empty rows after that also have their position set to ZV.  ") (span (|@| (class "comment-delimiter") (id "F:555828")) "*/") "\n       " (span (|@| (class "comment-delimiter") (id "F:555838")) "/* ") (span (|@| (class "comment") (id "F:555841")) "FIXME: Revisit this when glyph ``spilling'' in continuation\n          lines' rows is implemented for bidi-reordered rows.  ") (span (|@| (class "comment-delimiter") (id "F:555957")) "*/") "\n       || (it->bidi_p\n           && " (span (|@| (class "negation-char") (id "F:555989")) "!") "MATRIX_ROW (it->w->desired_matrix, cvpos)->ends_at_zv_p))\n      && PT >= MATRIX_ROW_START_CHARPOS (row)\n      && PT <= MATRIX_ROW_END_CHARPOS (row)\n      && cursor_row_p (it->w, row))\n    set_cursor_from_row (it->w, row, it->w->desired_matrix, 0, 0, 0, 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:556250")) "/* ") (span (|@| (class "comment") (id "F:556253")) "Highlight trailing whitespace.  ") (span (|@| (class "comment-delimiter") (id "F:556285")) "*/") "\n  " (span (|@| (class "keyword") (id "F:556290")) "if") " (" (span (|@| (class "negation-char") (id "F:556294")) "!") "NILP (Vshow_trailing_whitespace))\n    highlight_trailing_whitespace (it->f, it->glyph_row);\n\n  " (span (|@| (class "comment-delimiter") (id "F:556390")) "/* ") (span (|@| (class "comment") (id "F:556393")) "Prepare for the next line.  This line starts horizontally at (X\n     HPOS) = (0 0).  Vertical positions are incremented.  As a\n     convenience for the caller, IT->glyph_row is set to the next\n     row to be used.  ") (span (|@| (class "comment-delimiter") (id "F:556608")) "*/") "\n  it->current_x = it->hpos = 0;\n  it->current_y += row->height;\n  SET_TEXT_POS (it->eol_pos, 0, 0);\n  ++it->vpos;\n  ++it->glyph_row;\n  " (span (|@| (class "comment-delimiter") (id "F:556746")) "/* ") (span (|@| (class "comment") (id "F:556749")) "The next row should by default use the same value of the\n     reversed_p flag as this one.  set_iterator_to_next decides when\n     it's a new paragraph, and PRODUCE_GLYPHS recomputes the value of\n     the flag accordingly.  ") (span (|@| (class "comment-delimiter") (id "F:556973")) "*/") "\n  " (span (|@| (class "keyword") (id "F:556978")) "if") " (it->glyph_row < MATRIX_BOTTOM_TEXT_ROW (it->w->desired_matrix, it->w))\n    it->glyph_row->reversed_p = row->reversed_p;\n  it->start = row->end;\n  " (span (|@| (class "keyword") (id "F:557128")) "return") " row->displays_text_p;\n\n" (span (|@| (class "preprocessor") (id "F:557158")) "#undef") " RECORD_MAX_MIN_POS\n}\n\nDEFUN (" (span (|@| (class "string") (id "F:557194")) "\"current-bidi-paragraph-direction\"") ", Fcurrent_bidi_paragraph_direction,\n       Scurrent_bidi_paragraph_direction, 0, 1, 0,\n       doc: " (span (|@| (class "comment-delimiter") (id "F:557328")) "/* ") (span (|@| (class "comment") (id "F:557331")) "Return paragraph direction at point in BUFFER.\nValue is either `left-to-right' or `right-to-left'.\nIf BUFFER is omitted or nil, it defaults to the current buffer.\n\nParagraph direction determines how the text in the paragraph is displayed.\nIn left-to-right paragraphs, text begins at the left margin of the window\nand the reading direction is generally left to right.  In right-to-left\nparagraphs, text begins at the right margin and is read from right to left.\n\nSee also `bidi-paragraph-direction'.  ") (span (|@| (class "comment-delimiter") (id "F:557831")) "*/") ")\n     (buffer)\n     " (span (|@| (class "type") (id "F:557854")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:557866")) "buffer") ";\n{\n  " (span (|@| (class "keyword") (id "F:557878")) "struct") " " (span (|@| (class "type") (id "F:557885")) "buffer") " *" (span (|@| (class "variable-name") (id "F:557893")) "buf") ";\n  " (span (|@| (class "keyword") (id "F:557900")) "struct") " " (span (|@| (class "type") (id "F:557907")) "buffer") " *" (span (|@| (class "variable-name") (id "F:557915")) "old") ";\n\n  " (span (|@| (class "keyword") (id "F:557923")) "if") " (NILP (buffer))\n    buf = current_buffer;\n  " (span (|@| (class "keyword") (id "F:557970")) "else") "\n    {\n      CHECK_BUFFER (buffer);\n      buf = XBUFFER (buffer);\n      old = current_buffer;\n    }\n\n  " (span (|@| (class "keyword") (id "F:558077")) "if") " (NILP (buf->bidi_display_reordering))\n    " (span (|@| (class "keyword") (id "F:558122")) "return") " Qleft_to_right;\n  " (span (|@| (class "keyword") (id "F:558147")) "else") " " (span (|@| (class "keyword") (id "F:558152")) "if") " (" (span (|@| (class "negation-char") (id "F:558156")) "!") "NILP (buf->bidi_paragraph_direction))\n    " (span (|@| (class "keyword") (id "F:558199")) "return") " buf->bidi_paragraph_direction;\n  " (span (|@| (class "keyword") (id "F:558239")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:558256")) "/* ") (span (|@| (class "comment") (id "F:558259")) "Determine the direction from buffer text.  We could try to\n         use current_matrix if it is up to date, but this seems fast\n         enough as it is.  ") (span (|@| (class "comment-delimiter") (id "F:558400")) "*/") "\n      " (span (|@| (class "keyword") (id "F:558409")) "struct") " " (span (|@| (class "type") (id "F:558416")) "bidi_it") " " (span (|@| (class "variable-name") (id "F:558424")) "itb") ";\n      " (span (|@| (class "type") (id "F:558435")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:558445")) "pos") " = BUF_PT (buf);\n      " (span (|@| (class "type") (id "F:558471")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:558481")) "bytepos") " = BUF_PT_BYTE (buf);\n\n      " (span (|@| (class "keyword") (id "F:558517")) "if") " (buf != current_buffer)\n        set_buffer_temp (buf);\n      " (span (|@| (class "comment-delimiter") (id "F:558574")) "/* ") (span (|@| (class "comment") (id "F:558577")) "Find previous non-empty line.  ") (span (|@| (class "comment-delimiter") (id "F:558608")) "*/") "\n      " (span (|@| (class "keyword") (id "F:558617")) "if") " (pos >= ZV && pos > BEGV)\n        {\n          pos--;\n          bytepos = CHAR_TO_BYTE (pos);\n        }\n      " (span (|@| (class "keyword") (id "F:558701")) "while") " (FETCH_BYTE (bytepos) == " (span (|@| (class "string") (id "F:558732")) "'\\n'") ")\n        {\n          " (span (|@| (class "keyword") (id "F:558744")) "if") " (bytepos <= BEGV_BYTE)\n            " (span (|@| (class "keyword") (id "F:558775")) "break") ";\n          bytepos--;\n          pos--;\n        }\n      " (span (|@| (class "keyword") (id "F:558815")) "while") " (" (span (|@| (class "negation-char") (id "F:558822")) "!") "CHAR_HEAD_P (FETCH_BYTE (bytepos)))\n        bytepos--;\n      itb.charpos = pos;\n      itb.bytepos = bytepos;\n      itb.first_elt = 1;\n\n      bidi_paragraph_init (NEUTRAL_DIR, &itb);\n      " (span (|@| (class "keyword") (id "F:559004")) "if") " (buf != current_buffer)\n        set_buffer_temp (old);\n      " (span (|@| (class "keyword") (id "F:559061")) "switch") " (itb.paragraph_dir)\n        {\n        " (span (|@| (class "keyword") (id "F:559092")) "case") " L2R:\n          " (span (|@| (class "keyword") (id "F:559105")) "return") " Qleft_to_right;\n          " (span (|@| (class "keyword") (id "F:559131")) "break") ";\n        " (span (|@| (class "keyword") (id "F:559139")) "case") " R2L:\n          " (span (|@| (class "keyword") (id "F:559152")) "return") " Qright_to_left;\n          " (span (|@| (class "keyword") (id "F:559178")) "break") ";\n        " (span (|@| (class "keyword") (id "F:559186")) "default") ":\n          abort ();\n        }\n    }\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:559223")) "/***********************************************************************") (span (|@| (class "comment") (id "F:559295")) "\n                               Menu Bar\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:559386")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:559390")) "/* ") (span (|@| (class "comment") (id "F:559393")) "Redisplay the menu bar in the frame for window W.\n\n   The menu bar of X frames that don't have X toolkit support is\n   displayed in a special window W->frame->menu_bar_window.\n\n   The menu bar of terminal frames is treated specially as far as\n   glyph matrices are concerned.  Menu bar lines are not part of\n   windows, so the update is done directly on the frame matrix rows\n   for the menu bar.  ") (span (|@| (class "comment-delimiter") (id "F:559791")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:559795")) "static") " " (span (|@| (class "type") (id "F:559802")) "void") "\n" (span (|@| (class "function-name") (id "F:559807")) "display_menu_bar") " (w)\n     " (span (|@| (class "keyword") (id "F:559833")) "struct") " " (span (|@| (class "type") (id "F:559840")) "window") " *" (span (|@| (class "variable-name") (id "F:559848")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:559855")) "struct") " " (span (|@| (class "type") (id "F:559862")) "frame") " *" (span (|@| (class "variable-name") (id "F:559869")) "f") " = XFRAME (WINDOW_FRAME (w));\n  " (span (|@| (class "keyword") (id "F:559902")) "struct") " " (span (|@| (class "type") (id "F:559909")) "it") " " (span (|@| (class "variable-name") (id "F:559912")) "it") ";\n  " (span (|@| (class "type") (id "F:559918")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:559930")) "items") ";\n  " (span (|@| (class "type") (id "F:559939")) "int") " " (span (|@| (class "variable-name") (id "F:559943")) "i") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:559949")) "/* ") (span (|@| (class "comment") (id "F:559952")) "Don't do all this for graphical frames.  ") (span (|@| (class "comment-delimiter") (id "F:559993")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:559996")) "#ifdef") " HAVE_NTGUI\n  " (span (|@| (class "keyword") (id "F:560016")) "if") " (FRAME_W32_P (f))\n    " (span (|@| (class "keyword") (id "F:560041")) "return") ";\n" (span (|@| (class "preprocessor") (id "F:560049")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:560056")) "#if") " " (span (|@| (class "preprocessor") (id "F:560060")) "defined") " (USE_X_TOOLKIT) || " (span (|@| (class "preprocessor") (id "F:560087")) "defined") " (USE_GTK)\n  " (span (|@| (class "keyword") (id "F:560107")) "if") " (FRAME_X_P (f))\n    " (span (|@| (class "keyword") (id "F:560130")) "return") ";\n" (span (|@| (class "preprocessor") (id "F:560138")) "#endif") "\n\n" (span (|@| (class "preprocessor") (id "F:560146")) "#ifdef") " HAVE_NS\n  " (span (|@| (class "keyword") (id "F:560163")) "if") " (FRAME_NS_P (f))\n    " (span (|@| (class "keyword") (id "F:560187")) "return") ";\n" (span (|@| (class "preprocessor") (id "F:560195")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:560202")) "/* ") (span (|@| (class "comment") (id "F:560205")) "HAVE_NS ") (span (|@| (class "comment-delimiter") (id "F:560213")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:560217")) "#ifdef") " USE_X_TOOLKIT\n  xassert (" (span (|@| (class "negation-char") (id "F:560249")) "!") "FRAME_WINDOW_P (f));\n  init_iterator (&it, w, -1, -1, f->desired_matrix->rows, MENU_FACE_ID);\n  it.first_visible_x = 0;\n  it.last_visible_x = FRAME_TOTAL_COLS (f) * FRAME_COLUMN_WIDTH (f);\n" (span (|@| (class "preprocessor") (id "F:560439")) "#else") " " (span (|@| (class "comment-delimiter") (id "F:560445")) "/* ") (span (|@| (class "comment") (id "F:560448")) "not USE_X_TOOLKIT ") (span (|@| (class "comment-delimiter") (id "F:560466")) "*/") "\n  " (span (|@| (class "keyword") (id "F:560471")) "if") " (FRAME_WINDOW_P (f))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:560507")) "/* ") (span (|@| (class "comment") (id "F:560510")) "Menu bar lines are displayed in the desired matrix of the\n         dummy window menu_bar_window.  ") (span (|@| (class "comment-delimiter") (id "F:560601")) "*/") "\n      " (span (|@| (class "keyword") (id "F:560610")) "struct") " " (span (|@| (class "type") (id "F:560617")) "window") " *" (span (|@| (class "variable-name") (id "F:560625")) "menu_w") ";\n      xassert (WINDOWP (f->menu_bar_window));\n      menu_w = XWINDOW (f->menu_bar_window);\n      init_iterator (&it, menu_w, -1, -1, menu_w->desired_matrix->rows,\n                     MENU_FACE_ID);\n      it.first_visible_x = 0;\n      it.last_visible_x = FRAME_TOTAL_COLS (f) * FRAME_COLUMN_WIDTH (f);\n    }\n  " (span (|@| (class "keyword") (id "F:560929")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:560946")) "/* ") (span (|@| (class "comment") (id "F:560949")) "This is a TTY frame, i.e. character hpos/vpos are used as\n         pixel x/y.  ") (span (|@| (class "comment-delimiter") (id "F:561021")) "*/") "\n      init_iterator (&it, w, -1, -1, f->desired_matrix->rows,\n                     MENU_FACE_ID);\n      it.first_visible_x = 0;\n      it.last_visible_x = FRAME_COLS (f);\n    }\n" (span (|@| (class "preprocessor") (id "F:561186")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:561193")) "/* ") (span (|@| (class "comment") (id "F:561196")) "not USE_X_TOOLKIT ") (span (|@| (class "comment-delimiter") (id "F:561214")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:561220")) "if") " (" (span (|@| (class "negation-char") (id "F:561224")) "!") " mode_line_inverse_video)\n    " (span (|@| (class "comment-delimiter") (id "F:561255")) "/* ") (span (|@| (class "comment") (id "F:561258")) "Force the menu-bar to be displayed in the default face.  ") (span (|@| (class "comment-delimiter") (id "F:561315")) "*/") "\n    it.base_face_id = it.face_id = DEFAULT_FACE_ID;\n\n  " (span (|@| (class "comment-delimiter") (id "F:561373")) "/* ") (span (|@| (class "comment") (id "F:561376")) "Clear all rows of the menu bar.  ") (span (|@| (class "comment-delimiter") (id "F:561409")) "*/") "\n  " (span (|@| (class "keyword") (id "F:561414")) "for") " (i = 0; i < FRAME_MENU_BAR_LINES (f); ++i)\n    {\n      " (span (|@| (class "keyword") (id "F:561473")) "struct") " " (span (|@| (class "type") (id "F:561480")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:561491")) "row") " = it.glyph_row + i;\n      clear_glyph_row (row);\n      row->enabled_p = 1;\n      row->full_width_p = 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:561608")) "/* ") (span (|@| (class "comment") (id "F:561611")) "Display all items of the menu bar.  ") (span (|@| (class "comment-delimiter") (id "F:561647")) "*/") "\n  items = FRAME_MENU_BAR_ITEMS (it.f);\n  " (span (|@| (class "keyword") (id "F:561691")) "for") " (i = 0; i < XVECTOR (items)->size; i += 4)\n    {\n      " (span (|@| (class "type") (id "F:561750")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:561762")) "string") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:561777")) "/* ") (span (|@| (class "comment") (id "F:561780")) "Stop at nil string.  ") (span (|@| (class "comment-delimiter") (id "F:561801")) "*/") "\n      string = AREF (items, i + 1);\n      " (span (|@| (class "keyword") (id "F:561846")) "if") " (NILP (string))\n        " (span (|@| (class "keyword") (id "F:561866")) "break") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:561880")) "/* ") (span (|@| (class "comment") (id "F:561883")) "Remember where item was displayed.  ") (span (|@| (class "comment-delimiter") (id "F:561919")) "*/") "\n      ASET (items, i + 3, make_number (it.hpos));\n\n      " (span (|@| (class "comment-delimiter") (id "F:561979")) "/* ") (span (|@| (class "comment") (id "F:561982")) "Display the item, pad with one space.  ") (span (|@| (class "comment-delimiter") (id "F:562021")) "*/") "\n      " (span (|@| (class "keyword") (id "F:562030")) "if") " (it.current_x < it.last_visible_x)\n        display_string (" (span (|@| (class "constant") (id "F:562085")) "NULL") ", string, Qnil, 0, 0, &it,\n                        SCHARS (string) + 1, 0, 0, -1);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:562160")) "/* ") (span (|@| (class "comment") (id "F:562163")) "Fill out the line with spaces.  ") (span (|@| (class "comment-delimiter") (id "F:562195")) "*/") "\n  " (span (|@| (class "keyword") (id "F:562200")) "if") " (it.current_x < it.last_visible_x)\n    display_string (" (span (|@| (class "string") (id "F:562258")) "\"\"") ", Qnil, Qnil, 0, 0, &it, -1, 0, 0, -1);\n\n  " (span (|@| (class "comment-delimiter") (id "F:562303")) "/* ") (span (|@| (class "comment") (id "F:562306")) "Compute the total height of the lines.  ") (span (|@| (class "comment-delimiter") (id "F:562346")) "*/") "\n  compute_line_metrics (&it);\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:562385")) "/***********************************************************************") (span (|@| (class "comment") (id "F:562457")) "\n                              Mode Line\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:562548")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:562552")) "/* ") (span (|@| (class "comment") (id "F:562555")) "Redisplay mode lines in the window tree whose root is WINDOW.  If\n   FORCE is non-zero, redisplay mode lines unconditionally.\n   Otherwise, redisplay only mode lines that are garbaged.  Value is\n   the number of windows whose mode lines were redisplayed.  ") (span (|@| (class "comment-delimiter") (id "F:562811")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:562815")) "static") " " (span (|@| (class "type") (id "F:562822")) "int") "\n" (span (|@| (class "function-name") (id "F:562826")) "redisplay_mode_lines") " (" (span (|@| (class "type") (id "F:562848")) "window") ", force)\n     " (span (|@| (class "type") (id "F:562868")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:562880")) "window") ";\n     " (span (|@| (class "type") (id "F:562893")) "int") " " (span (|@| (class "variable-name") (id "F:562897")) "force") ";\n{\n  " (span (|@| (class "type") (id "F:562908")) "int") " " (span (|@| (class "variable-name") (id "F:562912")) "nwindows") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:562929")) "while") " (" (span (|@| (class "negation-char") (id "F:562936")) "!") "NILP (window))\n    {\n      " (span (|@| (class "keyword") (id "F:562964")) "struct") " " (span (|@| (class "type") (id "F:562971")) "window") " *" (span (|@| (class "variable-name") (id "F:562979")) "w") " = XWINDOW (window);\n\n      " (span (|@| (class "keyword") (id "F:563008")) "if") " (WINDOWP (w->hchild))\n        nwindows += redisplay_mode_lines (w->hchild, force);\n      " (span (|@| (class "keyword") (id "F:563093")) "else") " " (span (|@| (class "keyword") (id "F:563098")) "if") " (WINDOWP (w->vchild))\n        nwindows += redisplay_mode_lines (w->vchild, force);\n      " (span (|@| (class "keyword") (id "F:563183")) "else") " " (span (|@| (class "keyword") (id "F:563188")) "if") " (force\n               || FRAME_GARBAGED_P (XFRAME (w->frame))\n               || " (span (|@| (class "negation-char") (id "F:563257")) "!") "MATRIX_MODE_LINE_ROW (w->current_matrix)->enabled_p)\n        {\n          " (span (|@| (class "keyword") (id "F:563317")) "struct") " " (span (|@| (class "type") (id "F:563324")) "text_pos") " " (span (|@| (class "variable-name") (id "F:563333")) "lpoint") ";\n          " (span (|@| (class "keyword") (id "F:563344")) "struct") " " (span (|@| (class "type") (id "F:563351")) "buffer") " *" (span (|@| (class "variable-name") (id "F:563359")) "old") " = current_buffer;\n\n          " (span (|@| (class "comment-delimiter") (id "F:563385")) "/* ") (span (|@| (class "comment") (id "F:563388")) "Set the window's buffer for the mode line display.  ") (span (|@| (class "comment-delimiter") (id "F:563440")) "*/") "\n          SET_TEXT_POS (lpoint, PT, PT_BYTE);\n          set_buffer_internal_1 (XBUFFER (w->buffer));\n\n          " (span (|@| (class "comment-delimiter") (id "F:563534")) "/* ") (span (|@| (class "comment") (id "F:563537")) "Point refers normally to the selected window.  For any\n             other window, set up appropriate value.  ") (span (|@| (class "comment-delimiter") (id "F:563639")) "*/") "\n          " (span (|@| (class "keyword") (id "F:563645")) "if") " (" (span (|@| (class "negation-char") (id "F:563649")) "!") "EQ (window, selected_window))\n            {\n              " (span (|@| (class "keyword") (id "F:563694")) "struct") " " (span (|@| (class "type") (id "F:563701")) "text_pos") " " (span (|@| (class "variable-name") (id "F:563710")) "pt") ";\n\n              SET_TEXT_POS_FROM_MARKER (pt, w->pointm);\n              " (span (|@| (class "keyword") (id "F:563771")) "if") " (CHARPOS (pt) < BEGV)\n                TEMP_SET_PT_BOTH (BEGV, BEGV_BYTE);\n              " (span (|@| (class "keyword") (id "F:563841")) "else") " " (span (|@| (class "keyword") (id "F:563846")) "if") " (CHARPOS (pt) > (ZV - 1))\n                TEMP_SET_PT_BOTH (ZV, ZV_BYTE);\n              " (span (|@| (class "keyword") (id "F:563916")) "else") "\n                TEMP_SET_PT_BOTH (CHARPOS (pt), BYTEPOS (pt));\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:563981")) "/* ") (span (|@| (class "comment") (id "F:563984")) "Display mode lines.  ") (span (|@| (class "comment-delimiter") (id "F:564005")) "*/") "\n          clear_glyph_matrix (w->desired_matrix);\n          " (span (|@| (class "keyword") (id "F:564054")) "if") " (display_mode_lines (w))\n            {\n              ++nwindows;\n              w->must_be_updated_p = 1;\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:564152")) "/* ") (span (|@| (class "comment") (id "F:564155")) "Restore old settings.  ") (span (|@| (class "comment-delimiter") (id "F:564178")) "*/") "\n          set_buffer_internal_1 (old);\n          TEMP_SET_PT_BOTH (CHARPOS (lpoint), BYTEPOS (lpoint));\n        }\n\n      window = w->next;\n    }\n\n  " (span (|@| (class "keyword") (id "F:564308")) "return") " nwindows;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:564329")) "/* ") (span (|@| (class "comment") (id "F:564332")) "Display the mode and/or header line of window W.  Value is the\n   sum number of mode lines and header lines displayed.  ") (span (|@| (class "comment-delimiter") (id "F:564452")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:564456")) "static") " " (span (|@| (class "type") (id "F:564463")) "int") "\n" (span (|@| (class "function-name") (id "F:564467")) "display_mode_lines") " (w)\n     " (span (|@| (class "keyword") (id "F:564495")) "struct") " " (span (|@| (class "type") (id "F:564502")) "window") " *" (span (|@| (class "variable-name") (id "F:564510")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:564517")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:564529")) "old_selected_window") ", " (span (|@| (class "variable-name") (id "F:564550")) "old_selected_frame") ";\n  " (span (|@| (class "type") (id "F:564572")) "int") " " (span (|@| (class "variable-name") (id "F:564576")) "n") " = 0;\n\n  old_selected_frame = selected_frame;\n  selected_frame = w->frame;\n  old_selected_window = selected_window;\n  XSETWINDOW (selected_window, w);\n\n  " (span (|@| (class "comment-delimiter") (id "F:564731")) "/* ") (span (|@| (class "comment") (id "F:564734")) "These will be set while the mode line specs are processed.  ") (span (|@| (class "comment-delimiter") (id "F:564794")) "*/") "\n  line_number_displayed = 0;\n  w->column_number_displayed = Qnil;\n\n  " (span (|@| (class "keyword") (id "F:564866")) "if") " (WINDOW_WANTS_MODELINE_P (w))\n    {\n      " (span (|@| (class "keyword") (id "F:564911")) "struct") " " (span (|@| (class "type") (id "F:564918")) "window") " *" (span (|@| (class "variable-name") (id "F:564926")) "sel_w") " = XWINDOW (old_selected_window);\n\n      " (span (|@| (class "comment-delimiter") (id "F:564972")) "/* ") (span (|@| (class "comment") (id "F:564975")) "Select mode line face based on the real selected window.  ") (span (|@| (class "comment-delimiter") (id "F:565033")) "*/") "\n      display_mode_line (w, CURRENT_MODE_LINE_FACE_ID_3 (sel_w, sel_w, w),\n                         current_buffer->mode_line_format);\n      ++n;\n    }\n\n  " (span (|@| (class "keyword") (id "F:565170")) "if") " (WINDOW_WANTS_HEADER_LINE_P (w))\n    {\n      display_mode_line (w, HEADER_LINE_FACE_ID,\n                         current_buffer->header_line_format);\n      ++n;\n    }\n\n  selected_frame = old_selected_frame;\n  selected_window = old_selected_window;\n  " (span (|@| (class "keyword") (id "F:565402")) "return") " n;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:565416")) "/* ") (span (|@| (class "comment") (id "F:565419")) "Display mode or header line of window W.  FACE_ID specifies which\n   line to display; it is either MODE_LINE_FACE_ID or\n   HEADER_LINE_FACE_ID.  FORMAT is the mode/header line format to\n   display.  Value is the pixel height of the mode/header line\n   displayed.  ") (span (|@| (class "comment-delimiter") (id "F:565683")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:565687")) "static") " " (span (|@| (class "type") (id "F:565694")) "int") "\n" (span (|@| (class "function-name") (id "F:565698")) "display_mode_line") " (w, " (span (|@| (class "type") (id "F:565720")) "face_id") ", format)\n     " (span (|@| (class "keyword") (id "F:565742")) "struct") " " (span (|@| (class "type") (id "F:565749")) "window") " *" (span (|@| (class "variable-name") (id "F:565757")) "w") ";\n     " (span (|@| (class "keyword") (id "F:565765")) "enum") " " (span (|@| (class "type") (id "F:565770")) "face_id") " " (span (|@| (class "variable-name") (id "F:565778")) "face_id") ";\n     " (span (|@| (class "type") (id "F:565792")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:565804")) "format") ";\n{\n  " (span (|@| (class "keyword") (id "F:565816")) "struct") " " (span (|@| (class "type") (id "F:565823")) "it") " " (span (|@| (class "variable-name") (id "F:565826")) "it") ";\n  " (span (|@| (class "keyword") (id "F:565832")) "struct") " " (span (|@| (class "type") (id "F:565839")) "face") " *" (span (|@| (class "variable-name") (id "F:565845")) "face") ";\n  " (span (|@| (class "type") (id "F:565853")) "int") " " (span (|@| (class "variable-name") (id "F:565857")) "count") " = SPECPDL_INDEX ();\n\n  init_iterator (&it, w, -1, -1, " (span (|@| (class "constant") (id "F:565917")) "NULL") ", face_id);\n  " (span (|@| (class "comment-delimiter") (id "F:565935")) "/* ") (span (|@| (class "comment") (id "F:565938")) "Don't extend on a previously drawn mode-line.\n     This may happen if called from pos_visible_p.  ") (span (|@| (class "comment-delimiter") (id "F:566036")) "*/") "\n  it.glyph_row->enabled_p = 0;\n  prepare_desired_row (it.glyph_row);\n\n  it.glyph_row->mode_line_p = 1;\n\n  " (span (|@| (class "keyword") (id "F:566145")) "if") " (" (span (|@| (class "negation-char") (id "F:566149")) "!") " mode_line_inverse_video)\n    " (span (|@| (class "comment-delimiter") (id "F:566180")) "/* ") (span (|@| (class "comment") (id "F:566183")) "Force the mode-line to be displayed in the default face.  ") (span (|@| (class "comment-delimiter") (id "F:566241")) "*/") "\n    it.base_face_id = it.face_id = DEFAULT_FACE_ID;\n\n  record_unwind_protect (unwind_format_mode_line,\n                         format_mode_line_unwind_data (" (span (|@| (class "constant") (id "F:566381")) "NULL") ", Qnil, 0));\n\n  mode_line_target = MODE_LINE_DISPLAY;\n\n  " (span (|@| (class "comment-delimiter") (id "F:566442")) "/* ") (span (|@| (class "comment") (id "F:566445")) "Temporarily make frame's keyboard the current kboard so that\n     kboard-local variables in the mode_line_format will get the right\n     values.  ") (span (|@| (class "comment-delimiter") (id "F:566591")) "*/") "\n  push_kboard (FRAME_KBOARD (it.f));\n  record_unwind_save_match_data ();\n  display_mode_element (&it, 0, 0, 0, format, Qnil, 0);\n  pop_kboard ();\n\n  unbind_to (count, Qnil);\n\n  " (span (|@| (class "comment-delimiter") (id "F:566771")) "/* ") (span (|@| (class "comment") (id "F:566774")) "Fill up with spaces.  ") (span (|@| (class "comment-delimiter") (id "F:566796")) "*/") "\n  display_string (" (span (|@| (class "string") (id "F:566817")) "\" \"") ", Qnil, Qnil, 0, 0, &it, 10000, -1, -1, 0);\n\n  compute_line_metrics (&it);\n  it.glyph_row->full_width_p = 1;\n  it.glyph_row->continued_p = 0;\n  it.glyph_row->truncated_on_left_p = 0;\n  it.glyph_row->truncated_on_right_p = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:567048")) "/* ") (span (|@| (class "comment") (id "F:567051")) "Make a 3D mode-line have a shadow at its right end.  ") (span (|@| (class "comment-delimiter") (id "F:567104")) "*/") "\n  face = FACE_FROM_ID (it.f, face_id);\n  extend_face_to_end_of_line (&it);\n  " (span (|@| (class "keyword") (id "F:567184")) "if") " (face->box != FACE_NO_BOX)\n    {\n      " (span (|@| (class "keyword") (id "F:567226")) "struct") " " (span (|@| (class "type") (id "F:567233")) "glyph") " *" (span (|@| (class "variable-name") (id "F:567240")) "last") " = (it.glyph_row->glyphs[TEXT_AREA]\n                            + it.glyph_row->used[TEXT_AREA] - 1);\n      last->right_box_line_p = 1;\n    }\n\n  " (span (|@| (class "keyword") (id "F:567368")) "return") " it.glyph_row->height;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:567400")) "/* ") (span (|@| (class "comment") (id "F:567403")) "Move element ELT in LIST to the front of LIST.\n   Return the updated list.  ") (span (|@| (class "comment-delimiter") (id "F:567479")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:567483")) "static") " " (span (|@| (class "type") (id "F:567490")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:567502")) "move_elt_to_front") " (elt, list)\n     " (span (|@| (class "type") (id "F:567537")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:567549")) "elt") ", " (span (|@| (class "variable-name") (id "F:567554")) "list") ";\n{\n  " (span (|@| (class "keyword") (id "F:567564")) "register") " " (span (|@| (class "type") (id "F:567573")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:567585")) "tail") ", " (span (|@| (class "variable-name") (id "F:567591")) "prev") ";\n  " (span (|@| (class "keyword") (id "F:567599")) "register") " " (span (|@| (class "type") (id "F:567608")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:567620")) "tem") ";\n\n  tail = list;\n  prev = Qnil;\n  " (span (|@| (class "keyword") (id "F:567658")) "while") " (CONSP (tail))\n    {\n      tem = XCAR (tail);\n\n      " (span (|@| (class "keyword") (id "F:567717")) "if") " (EQ (elt, tem))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:567742")) "/* ") (span (|@| (class "comment") (id "F:567745")) "Splice out the link TAIL.  ") (span (|@| (class "comment-delimiter") (id "F:567772")) "*/") "\n          " (span (|@| (class "keyword") (id "F:567778")) "if") " (NILP (prev))\n            list = XCDR (tail);\n          " (span (|@| (class "keyword") (id "F:567823")) "else") "\n            Fsetcdr (prev, XCDR (tail));\n\n          " (span (|@| (class "comment-delimiter") (id "F:567866")) "/* ") (span (|@| (class "comment") (id "F:567869")) "Now make it the first.  ") (span (|@| (class "comment-delimiter") (id "F:567893")) "*/") "\n          Fsetcdr (tail, list);\n          " (span (|@| (class "keyword") (id "F:567924")) "return") " tail;\n        }\n      " (span (|@| (class "keyword") (id "F:567946")) "else") "\n        prev = tail;\n      tail = XCDR (tail);\n      QUIT;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:568012")) "/* ") (span (|@| (class "comment") (id "F:568015")) "Not found--return unchanged LIST.  ") (span (|@| (class "comment-delimiter") (id "F:568050")) "*/") "\n  " (span (|@| (class "keyword") (id "F:568055")) "return") " list;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:568071")) "/* ") (span (|@| (class "comment") (id "F:568074")) "Contribute ELT to the mode line for window IT->w.  How it\n   translates into text depends on its data type.\n\n   IT describes the display environment in which we display, as usual.\n\n   DEPTH is the depth in recursion.  It is used to prevent\n   infinite recursion here.\n\n   FIELD_WIDTH is the number of characters the display of ELT should\n   occupy in the mode line, and PRECISION is the maximum number of\n   characters to display from ELT's representation.  See\n   display_string for details.\n\n   Returns the hpos of the end of the text generated by ELT.\n\n   PROPS is a property list to add to any string we encounter.\n\n   If RISKY is nonzero, remove (disregard) any properties in any string\n   we encounter, and ignore :eval and :propertize.\n\n   The global variable `mode_line_target' determines whether the\n   output is passed to `store_mode_line_noprop',\n   `store_mode_line_string', or `display_string'.  ") (span (|@| (class "comment-delimiter") (id "F:568983")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:568987")) "static") " " (span (|@| (class "type") (id "F:568994")) "int") "\n" (span (|@| (class "function-name") (id "F:568998")) "display_mode_element") " (" (span (|@| (class "type") (id "F:569020")) "it") ", depth, field_width, precision, elt, " (span (|@| (class "type") (id "F:569060")) "props") ", risky)\n     " (span (|@| (class "keyword") (id "F:569079")) "struct") " " (span (|@| (class "type") (id "F:569086")) "it") " *" (span (|@| (class "variable-name") (id "F:569090")) "it") ";\n     " (span (|@| (class "type") (id "F:569099")) "int") " " (span (|@| (class "variable-name") (id "F:569103")) "depth") ";\n     " (span (|@| (class "type") (id "F:569115")) "int") " " (span (|@| (class "variable-name") (id "F:569119")) "field_width") ", " (span (|@| (class "variable-name") (id "F:569132")) "precision") ";\n     " (span (|@| (class "type") (id "F:569148")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:569160")) "elt") ", " (span (|@| (class "variable-name") (id "F:569165")) "props") ";\n     " (span (|@| (class "type") (id "F:569177")) "int") " " (span (|@| (class "variable-name") (id "F:569181")) "risky") ";\n{\n  " (span (|@| (class "type") (id "F:569192")) "int") " " (span (|@| (class "variable-name") (id "F:569196")) "n") " = 0, " (span (|@| (class "variable-name") (id "F:569203")) "field") ", " (span (|@| (class "variable-name") (id "F:569210")) "prec") ";\n  " (span (|@| (class "type") (id "F:569218")) "int") " " (span (|@| (class "variable-name") (id "F:569222")) "literal") " = 0;\n\n " (span (|@| (class "constant") (id "F:569237")) "tail_recurse") ":\n  " (span (|@| (class "keyword") (id "F:569253")) "if") " (depth > 100)\n    elt = build_string (" (span (|@| (class "string") (id "F:569294")) "\"*too-deep*\"") ");\n\n  depth++;\n\n  " (span (|@| (class "keyword") (id "F:569324")) "switch") " (SWITCH_ENUM_CAST (XTYPE (elt)))\n    {\n    " (span (|@| (class "keyword") (id "F:569374")) "case") " Lisp_String:\n      {\n        " (span (|@| (class "comment-delimiter") (id "F:569401")) "/* ") (span (|@| (class "comment") (id "F:569404")) "A string: output it and check for %-constructs within it.  ") (span (|@| (class "comment-delimiter") (id "F:569463")) "*/") "\n        " (span (|@| (class "type") (id "F:569467")) "unsigned") " " (span (|@| (class "type") (id "F:569476")) "char") " " (span (|@| (class "variable-name") (id "F:569481")) "c") ";\n        " (span (|@| (class "type") (id "F:569485")) "int") " " (span (|@| (class "variable-name") (id "F:569489")) "offset") " = 0;\n\n        " (span (|@| (class "keyword") (id "F:569503")) "if") " (SCHARS (elt) > 0\n            && (" (span (|@| (class "negation-char") (id "F:569533")) "!") "NILP (props) || risky))\n          {\n            " (span (|@| (class "type") (id "F:569568")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:569580")) "oprops") ", " (span (|@| (class "variable-name") (id "F:569588")) "aelt") ";\n            oprops = Ftext_properties_at (make_number (0), elt);\n\n            " (span (|@| (class "comment-delimiter") (id "F:569658")) "/* ") (span (|@| (class "comment") (id "F:569661")) "If the starting string's properties are not what\n               we want, translate the string.  Also, if the string\n               is risky, do that anyway.  ") (span (|@| (class "comment-delimiter") (id "F:569805")) "*/") "\n\n            " (span (|@| (class "keyword") (id "F:569814")) "if") " (NILP (Fequal (props, oprops)) || risky)\n              {\n                " (span (|@| (class "comment-delimiter") (id "F:569869")) "/* ") (span (|@| (class "comment") (id "F:569872")) "If the starting string has properties,\n                   merge the specified ones onto the existing ones.  ") (span (|@| (class "comment-delimiter") (id "F:569966")) "*/") "\n                " (span (|@| (class "keyword") (id "F:569971")) "if") " (" (span (|@| (class "negation-char") (id "F:569975")) "!") " NILP (oprops) && " (span (|@| (class "negation-char") (id "F:569994")) "!") "risky)\n                  {\n                    " (span (|@| (class "type") (id "F:570014")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:570026")) "tem") ";\n\n                    oprops = Fcopy_sequence (oprops);\n                    tem = props;\n                    " (span (|@| (class "keyword") (id "F:570097")) "while") " (CONSP (tem))\n                      {\n                        oprops = Fplist_put (oprops, XCAR (tem),\n                                             XCAR (XCDR (tem)));\n                        tem = XCDR (XCDR (tem));\n                      }\n                    props = oprops;\n                  }\n\n                aelt = Fassoc (elt, mode_line_proptrans_alist);\n                " (span (|@| (class "keyword") (id "F:570320")) "if") " (" (span (|@| (class "negation-char") (id "F:570324")) "!") " NILP (aelt) && " (span (|@| (class "negation-char") (id "F:570341")) "!") "NILP (Fequal (props, XCDR (aelt))))\n                  {\n                    " (span (|@| (class "comment-delimiter") (id "F:570390")) "/* ") (span (|@| (class "comment") (id "F:570393")) "AELT is what we want.  Move it to the front\n                       without consing.  ") (span (|@| (class "comment-delimiter") (id "F:570464")) "*/") "\n                    elt = XCAR (aelt);\n                    mode_line_proptrans_alist\n                      = move_elt_to_front (aelt, mode_line_proptrans_alist);\n                  }\n                " (span (|@| (class "keyword") (id "F:570595")) "else") "\n                  {\n                    " (span (|@| (class "type") (id "F:570612")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:570624")) "tem") ";\n\n                    " (span (|@| (class "comment-delimiter") (id "F:570636")) "/* ") (span (|@| (class "comment") (id "F:570639")) "If AELT has the wrong props, it is useless.\n                       so get rid of it.  ") (span (|@| (class "comment-delimiter") (id "F:570711")) "*/") "\n                    " (span (|@| (class "keyword") (id "F:570720")) "if") " (" (span (|@| (class "negation-char") (id "F:570724")) "!") " NILP (aelt))\n                      mode_line_proptrans_alist\n                        = Fdelq (aelt, mode_line_proptrans_alist);\n\n                    elt = Fcopy_sequence (elt);\n                    Fset_text_properties (make_number (0), Flength (elt),\n                                          props, elt);\n                    " (span (|@| (class "comment-delimiter") (id "F:570940")) "/* ") (span (|@| (class "comment") (id "F:570943")) "Add this item to mode_line_proptrans_alist.  ") (span (|@| (class "comment-delimiter") (id "F:570988")) "*/") "\n                    mode_line_proptrans_alist\n                      = Fcons (Fcons (elt, props),\n                               mode_line_proptrans_alist);\n                    " (span (|@| (class "comment-delimiter") (id "F:571104")) "/* ") (span (|@| (class "comment") (id "F:571107")) "Truncate mode_line_proptrans_alist\n                       to at most 50 elements.  ") (span (|@| (class "comment-delimiter") (id "F:571176")) "*/") "\n                    tem = Fnthcdr (make_number (50),\n                                   mode_line_proptrans_alist);\n                    " (span (|@| (class "keyword") (id "F:571259")) "if") " (" (span (|@| (class "negation-char") (id "F:571263")) "!") " NILP (tem))\n                      XSETCDR (tem, Qnil);\n                  }\n              }\n          }\n\n        offset = 0;\n\n        " (span (|@| (class "keyword") (id "F:571342")) "if") " (literal)\n          {\n            prec = precision - n;\n            " (span (|@| (class "keyword") (id "F:571392")) "switch") " (mode_line_target)\n              {\n              " (span (|@| (class "keyword") (id "F:571434")) "case") " MODE_LINE_NOPROP:\n              " (span (|@| (class "keyword") (id "F:571464")) "case") " MODE_LINE_TITLE:\n                n += store_mode_line_noprop (SDATA (elt), -1, prec);\n                " (span (|@| (class "keyword") (id "F:571543")) "break") ";\n              " (span (|@| (class "keyword") (id "F:571557")) "case") " MODE_LINE_STRING:\n                n += store_mode_line_string (" (span (|@| (class "constant") (id "F:571611")) "NULL") ", elt, 1, 0, prec, Qnil);\n                " (span (|@| (class "keyword") (id "F:571643")) "break") ";\n              " (span (|@| (class "keyword") (id "F:571657")) "case") " MODE_LINE_DISPLAY:\n                n += display_string (" (span (|@| (class "constant") (id "F:571704")) "NULL") ", elt, Qnil, 0, 0, it,\n                                     0, prec, 0, STRING_MULTIBYTE (elt));\n                " (span (|@| (class "keyword") (id "F:571779")) "break") ";\n              }\n\n            " (span (|@| (class "keyword") (id "F:571801")) "break") ";\n          }\n\n        " (span (|@| (class "comment-delimiter") (id "F:571815")) "/* ") (span (|@| (class "comment") (id "F:571818")) "Handle the non-literal case.  ") (span (|@| (class "comment-delimiter") (id "F:571848")) "*/") "\n\n        " (span (|@| (class "keyword") (id "F:571853")) "while") " ((precision <= 0 || n < precision)\n               && SREF (elt, offset) != 0\n               && (mode_line_target != MODE_LINE_DISPLAY\n                   || it->current_x < it->last_visible_x))\n          {\n            " (span (|@| (class "type") (id "F:572034")) "int") " " (span (|@| (class "variable-name") (id "F:572038")) "last_offset") " = offset;\n\n            " (span (|@| (class "comment-delimiter") (id "F:572066")) "/* ") (span (|@| (class "comment") (id "F:572069")) "Advance to end of string or next format specifier.  ") (span (|@| (class "comment-delimiter") (id "F:572121")) "*/") "\n            " (span (|@| (class "keyword") (id "F:572129")) "while") " ((c = SREF (elt, offset++)) != " (span (|@| (class "string") (id "F:572166")) "'\\0'") " && c != " (span (|@| (class "string") (id "F:572179")) "'%'") ")\n              ;\n\n            " (span (|@| (class "keyword") (id "F:572199")) "if") " (offset - 1 != last_offset)\n              {\n                " (span (|@| (class "type") (id "F:572241")) "int") " " (span (|@| (class "variable-name") (id "F:572245")) "nchars") ", " (span (|@| (class "variable-name") (id "F:572253")) "nbytes") ";\n\n                " (span (|@| (class "comment-delimiter") (id "F:572264")) "/* ") (span (|@| (class "comment") (id "F:572267")) "Output to end of string or up to '%'.  Field width\n                   is length of string.  Don't output more than\n                   PRECISION allows us.  ") (span (|@| (class "comment-delimiter") (id "F:572395")) "*/") "\n                offset--;\n\n                prec = c_string_width (SDATA (elt) + last_offset,\n                                       offset - last_offset, precision - n,\n                                       &nchars, &nbytes);\n\n                " (span (|@| (class "keyword") (id "F:572544")) "switch") " (mode_line_target)\n                  {\n                  " (span (|@| (class "keyword") (id "F:572580")) "case") " MODE_LINE_NOPROP:\n                  " (span (|@| (class "keyword") (id "F:572607")) "case") " MODE_LINE_TITLE:\n                    n += store_mode_line_noprop (SDATA (elt) + last_offset, 0, prec);\n                    " (span (|@| (class "keyword") (id "F:572707")) "break") ";\n                  " (span (|@| (class "keyword") (id "F:572718")) "case") " MODE_LINE_STRING:\n                    {\n                      " (span (|@| (class "type") (id "F:572757")) "int") " " (span (|@| (class "variable-name") (id "F:572761")) "bytepos") " = last_offset;\n                      " (span (|@| (class "type") (id "F:572792")) "int") " " (span (|@| (class "variable-name") (id "F:572796")) "charpos") " = string_byte_to_char (elt, bytepos);\n                      " (span (|@| (class "type") (id "F:572850")) "int") " " (span (|@| (class "variable-name") (id "F:572854")) "endpos") " = (precision <= 0\n                                    ? string_byte_to_char (elt, offset)\n                                    : charpos + nchars);\n\n                      n += store_mode_line_string (" (span (|@| (class "constant") (id "F:572990")) "NULL") ",\n                                                   Fsubstring (elt, make_number (charpos),\n                                                               make_number (endpos)),\n                                                   0, 0, 0, Qnil);\n                    }\n                    " (span (|@| (class "keyword") (id "F:573121")) "break") ";\n                  " (span (|@| (class "keyword") (id "F:573132")) "case") " MODE_LINE_DISPLAY:\n                    {\n                      " (span (|@| (class "type") (id "F:573172")) "int") " " (span (|@| (class "variable-name") (id "F:573176")) "bytepos") " = last_offset;\n                      " (span (|@| (class "type") (id "F:573207")) "int") " " (span (|@| (class "variable-name") (id "F:573211")) "charpos") " = string_byte_to_char (elt, bytepos);\n\n                      " (span (|@| (class "keyword") (id "F:573266")) "if") " (precision <= 0)\n                        nchars = string_byte_to_char (elt, offset) - charpos;\n                      n += display_string (" (span (|@| (class "constant") (id "F:573372")) "NULL") ", elt, Qnil, 0, charpos,\n                                           it, 0, nchars, 0,\n                                           STRING_MULTIBYTE (elt));\n                    }\n                    " (span (|@| (class "keyword") (id "F:573474")) "break") ";\n                  }\n              }\n            " (span (|@| (class "keyword") (id "F:573501")) "else") " " (span (|@| (class "comment-delimiter") (id "F:573506")) "/* ") (span (|@| (class "comment") (id "F:573509")) "c == '%' ") (span (|@| (class "comment-delimiter") (id "F:573518")) "*/") "\n              {\n                " (span (|@| (class "type") (id "F:573532")) "int") " " (span (|@| (class "variable-name") (id "F:573536")) "percent_position") " = offset;\n\n                " (span (|@| (class "comment-delimiter") (id "F:573566")) "/* ") (span (|@| (class "comment") (id "F:573569")) "Get the specified minimum width.  Zero means\n                   don't pad.  ") (span (|@| (class "comment-delimiter") (id "F:573631")) "*/") "\n                field = 0;\n                " (span (|@| (class "keyword") (id "F:573649")) "while") " ((c = SREF (elt, offset++)) >= " (span (|@| (class "string") (id "F:573686")) "'0'") " && c <= " (span (|@| (class "string") (id "F:573698")) "'9'") ")\n                  field = field * 10 + c - " (span (|@| (class "string") (id "F:573732")) "'0'") ";\n\n                " (span (|@| (class "comment-delimiter") (id "F:573740")) "/* ") (span (|@| (class "comment") (id "F:573743")) "Don't pad beyond the total padding allowed.  ") (span (|@| (class "comment-delimiter") (id "F:573788")) "*/") "\n                " (span (|@| (class "keyword") (id "F:573793")) "if") " (field_width - n > 0 && field > field_width - n)\n                  field = field_width - n;\n\n                " (span (|@| (class "comment-delimiter") (id "F:573877")) "/* ") (span (|@| (class "comment") (id "F:573880")) "Note that either PRECISION <= 0 or N < PRECISION.  ") (span (|@| (class "comment-delimiter") (id "F:573931")) "*/") "\n                prec = precision - n;\n\n                " (span (|@| (class "keyword") (id "F:573961")) "if") " (c == " (span (|@| (class "string") (id "F:573970")) "'M'") ")\n                  n += display_mode_element (it, depth, field, prec,\n                                             Vglobal_mode_string, props,\n                                             risky);\n                " (span (|@| (class "keyword") (id "F:574088")) "else") " " (span (|@| (class "keyword") (id "F:574093")) "if") " (c != 0)\n                  {\n                    " (span (|@| (class "type") (id "F:574117")) "int") " " (span (|@| (class "variable-name") (id "F:574121")) "multibyte") ";\n                    " (span (|@| (class "type") (id "F:574138")) "int") " " (span (|@| (class "variable-name") (id "F:574142")) "bytepos") ", " (span (|@| (class "variable-name") (id "F:574151")) "charpos") ";\n                    " (span (|@| (class "type") (id "F:574166")) "unsigned") " " (span (|@| (class "type") (id "F:574175")) "char") " *" (span (|@| (class "variable-name") (id "F:574181")) "spec") ";\n                    " (span (|@| (class "type") (id "F:574193")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:574205")) "string") ";\n\n                    bytepos = percent_position;\n                    charpos = (STRING_MULTIBYTE (elt)\n                               ? string_byte_to_char (elt, bytepos)\n                               : bytepos);\n                    spec = decode_mode_spec (it->w, c, field, prec, &string);\n                    multibyte = STRINGP (string) && STRING_MULTIBYTE (string);\n\n                    " (span (|@| (class "keyword") (id "F:574493")) "switch") " (mode_line_target)\n                      {\n                      " (span (|@| (class "keyword") (id "F:574537")) "case") " MODE_LINE_NOPROP:\n                      " (span (|@| (class "keyword") (id "F:574568")) "case") " MODE_LINE_TITLE:\n                        n += store_mode_line_noprop (spec, field, prec);\n                        " (span (|@| (class "keyword") (id "F:574645")) "break") ";\n                      " (span (|@| (class "keyword") (id "F:574660")) "case") " MODE_LINE_STRING:\n                        {\n                          " (span (|@| (class "type") (id "F:574693")) "int") " " (span (|@| (class "variable-name") (id "F:574697")) "len") " = strlen (spec);\n                          " (span (|@| (class "type") (id "F:574723")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:574735")) "tem") " = make_string (spec, len);\n                          props = Ftext_properties_at (make_number (charpos), elt);\n                          " (span (|@| (class "comment-delimiter") (id "F:574834")) "/* ") (span (|@| (class "comment") (id "F:574837")) "Should only keep face property in props ") (span (|@| (class "comment-delimiter") (id "F:574877")) "*/") "\n                          n += store_mode_line_string (" (span (|@| (class "constant") (id "F:574914")) "NULL") ", tem, 0, field, prec, props);\n                        }\n                        " (span (|@| (class "keyword") (id "F:574957")) "break") ";\n                      " (span (|@| (class "keyword") (id "F:574972")) "case") " MODE_LINE_DISPLAY:\n                        {\n                          " (span (|@| (class "type") (id "F:575006")) "int") " " (span (|@| (class "variable-name") (id "F:575010")) "nglyphs_before") ", " (span (|@| (class "variable-name") (id "F:575026")) "nwritten") ";\n\n                          nglyphs_before = it->glyph_row->used[TEXT_AREA];\n                          nwritten = display_string (spec, string, elt,\n                                                     charpos, 0, it,\n                                                     field, prec, 0,\n                                                     multibyte);\n\n                          " (span (|@| (class "comment-delimiter") (id "F:575225")) "/* ") (span (|@| (class "comment") (id "F:575228")) "Assign to the glyphs written above the\n                             string where the `%x' came from, position\n                             of the `%'.  ") (span (|@| (class "comment-delimiter") (id "F:575338")) "*/") "\n                          " (span (|@| (class "keyword") (id "F:575346")) "if") " (nwritten > 0)\n                            {\n                              " (span (|@| (class "keyword") (id "F:575382")) "struct") " " (span (|@| (class "type") (id "F:575389")) "glyph") " *" (span (|@| (class "variable-name") (id "F:575396")) "glyph") "\n                                = (it->glyph_row->glyphs[TEXT_AREA]\n                                   + nglyphs_before);\n                              " (span (|@| (class "type") (id "F:575477")) "int") " " (span (|@| (class "variable-name") (id "F:575481")) "i") ";\n\n                              " (span (|@| (class "keyword") (id "F:575494")) "for") " (i = 0; i < nwritten; ++i)\n                                {\n                                  glyph[i].object = elt;\n                                  glyph[i].charpos = charpos;\n                                }\n\n                              n += nwritten;\n                            }\n                        }\n                        " (span (|@| (class "keyword") (id "F:575642")) "break") ";\n                      }\n                  }\n                " (span (|@| (class "keyword") (id "F:575667")) "else") " " (span (|@| (class "comment-delimiter") (id "F:575672")) "/* ") (span (|@| (class "comment") (id "F:575675")) "c == 0 ") (span (|@| (class "comment-delimiter") (id "F:575682")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:575689")) "break") ";\n              }\n          }\n      }\n      " (span (|@| (class "keyword") (id "F:575724")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:575736")) "case") " Lisp_Symbol:\n      " (span (|@| (class "comment-delimiter") (id "F:575760")) "/* ") (span (|@| (class "comment") (id "F:575763")) "A symbol: process the value of the symbol recursively\n         as if it appeared here directly.  Avoid error if symbol void.\n         Special case: if value of symbol is a string, output the string\n         literally.  ") (span (|@| (class "comment-delimiter") (id "F:575961")) "*/") "\n      {\n        " (span (|@| (class "keyword") (id "F:575973")) "register") " " (span (|@| (class "type") (id "F:575982")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:575994")) "tem") ";\n\n        " (span (|@| (class "comment-delimiter") (id "F:576001")) "/* ") (span (|@| (class "comment") (id "F:576004")) "If the variable is not marked as risky to set\n           then its contents are risky to use.  ") (span (|@| (class "comment-delimiter") (id "F:576091")) "*/") "\n        " (span (|@| (class "keyword") (id "F:576095")) "if") " (NILP (Fget (elt, Qrisky_local_variable)))\n          risky = 1;\n\n        tem = Fboundp (elt);\n        " (span (|@| (class "keyword") (id "F:576179")) "if") " (" (span (|@| (class "negation-char") (id "F:576183")) "!") "NILP (tem))\n          {\n            tem = Fsymbol_value (elt);\n            " (span (|@| (class "comment-delimiter") (id "F:576238")) "/* ") (span (|@| (class "comment") (id "F:576241")) "If value is a string, output that string literally:\n               don't check for % within it.  ") (span (|@| (class "comment-delimiter") (id "F:576331")) "*/") "\n            " (span (|@| (class "keyword") (id "F:576339")) "if") " (STRINGP (tem))\n              literal = 1;\n\n            " (span (|@| (class "keyword") (id "F:576384")) "if") " (" (span (|@| (class "negation-char") (id "F:576388")) "!") "EQ (tem, elt))\n              {\n                " (span (|@| (class "comment-delimiter") (id "F:576415")) "/* ") (span (|@| (class "comment") (id "F:576418")) "Give up right away for nil or t.  ") (span (|@| (class "comment-delimiter") (id "F:576452")) "*/") "\n                elt = tem;\n                " (span (|@| (class "keyword") (id "F:576470")) "goto") " " (span (|@| (class "constant") (id "F:576475")) "tail_recurse") ";\n              }\n          }\n      }\n      " (span (|@| (class "keyword") (id "F:576517")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:576529")) "case") " Lisp_Cons:\n      {\n        " (span (|@| (class "keyword") (id "F:576554")) "register") " " (span (|@| (class "type") (id "F:576563")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:576575")) "car") ", " (span (|@| (class "variable-name") (id "F:576580")) "tem") ";\n\n        " (span (|@| (class "comment-delimiter") (id "F:576587")) "/* ") (span (|@| (class "comment") (id "F:576590")) "A cons cell: five distinct cases.\n           If first element is :eval or :propertize, do something special.\n           If first element is a string or a cons, process all the elements\n           and effectively concatenate them.\n           If first element is a negative number, truncate displaying cdr to\n           at most that many characters.  If positive, pad (with spaces)\n           to at least that many characters.\n           If first element is a symbol, process the cadr or caddr recursively\n           according to whether the symbol's value is non-nil or nil.  ") (span (|@| (class "comment-delimiter") (id "F:577109")) "*/") "\n        car = XCAR (elt);\n        " (span (|@| (class "keyword") (id "F:577132")) "if") " (EQ (car, QCeval))\n          {\n            " (span (|@| (class "comment-delimiter") (id "F:577164")) "/* ") (span (|@| (class "comment") (id "F:577167")) "An element of the form (:eval FORM) means evaluate FORM\n               and use the result as mode line elements.  ") (span (|@| (class "comment-delimiter") (id "F:577274")) "*/") "\n\n            " (span (|@| (class "keyword") (id "F:577283")) "if") " (risky)\n              " (span (|@| (class "keyword") (id "F:577301")) "break") ";\n\n            " (span (|@| (class "keyword") (id "F:577314")) "if") " (CONSP (XCDR (elt)))\n              {\n                " (span (|@| (class "type") (id "F:577349")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:577361")) "spec") ";\n                spec = safe_eval (XCAR (XCDR (elt)));\n                n += display_mode_element (it, depth, field_width - n,\n                                           precision - n, spec, props,\n                                           risky);\n              }\n          }\n        " (span (|@| (class "keyword") (id "F:577531")) "else") " " (span (|@| (class "keyword") (id "F:577536")) "if") " (EQ (car, QCpropertize))\n          {\n            " (span (|@| (class "comment-delimiter") (id "F:577574")) "/* ") (span (|@| (class "comment") (id "F:577577")) "An element of the form (:propertize ELT PROPS...)\n               means display ELT but applying properties PROPS.  ") (span (|@| (class "comment-delimiter") (id "F:577685")) "*/") "\n\n            " (span (|@| (class "keyword") (id "F:577694")) "if") " (risky)\n              " (span (|@| (class "keyword") (id "F:577712")) "break") ";\n\n            " (span (|@| (class "keyword") (id "F:577725")) "if") " (CONSP (XCDR (elt)))\n              n += display_mode_element (it, depth, field_width - n,\n                                         precision - n, XCAR (XCDR (elt)),\n                                         XCDR (XCDR (elt)), risky);\n          }\n        " (span (|@| (class "keyword") (id "F:577890")) "else") " " (span (|@| (class "keyword") (id "F:577895")) "if") " (SYMBOLP (car))\n          {\n            tem = Fboundp (car);\n            elt = XCDR (elt);\n            " (span (|@| (class "keyword") (id "F:577973")) "if") " (" (span (|@| (class "negation-char") (id "F:577977")) "!") "CONSP (elt))\n              " (span (|@| (class "keyword") (id "F:577998")) "goto") " " (span (|@| (class "constant") (id "F:578003")) "invalid") ";\n            " (span (|@| (class "comment-delimiter") (id "F:578017")) "/* ") (span (|@| (class "comment") (id "F:578020")) "elt is now the cdr, and we know it is a cons cell.\n               Use its car if CAR has a non-nil value.  ") (span (|@| (class "comment-delimiter") (id "F:578120")) "*/") "\n            " (span (|@| (class "keyword") (id "F:578128")) "if") " (" (span (|@| (class "negation-char") (id "F:578132")) "!") "NILP (tem))\n              {\n                tem = Fsymbol_value (car);\n                " (span (|@| (class "keyword") (id "F:578185")) "if") " (" (span (|@| (class "negation-char") (id "F:578189")) "!") "NILP (tem))\n                  {\n                    elt = XCAR (elt);\n                    " (span (|@| (class "keyword") (id "F:578238")) "goto") " " (span (|@| (class "constant") (id "F:578243")) "tail_recurse") ";\n                  }\n              }\n            " (span (|@| (class "comment-delimiter") (id "F:578277")) "/* ") (span (|@| (class "comment") (id "F:578280")) "Symbol's value is nil (or symbol is unbound)\n               Get the cddr of the original list\n               and if possible find the caddr and use that.  ") (span (|@| (class "comment-delimiter") (id "F:578421")) "*/") "\n            elt = XCDR (elt);\n            " (span (|@| (class "keyword") (id "F:578452")) "if") " (NILP (elt))\n              " (span (|@| (class "keyword") (id "F:578475")) "break") ";\n            " (span (|@| (class "keyword") (id "F:578487")) "else") " " (span (|@| (class "keyword") (id "F:578492")) "if") " (" (span (|@| (class "negation-char") (id "F:578496")) "!") "CONSP (elt))\n              " (span (|@| (class "keyword") (id "F:578517")) "goto") " " (span (|@| (class "constant") (id "F:578522")) "invalid") ";\n            elt = XCAR (elt);\n            " (span (|@| (class "keyword") (id "F:578559")) "goto") " " (span (|@| (class "constant") (id "F:578564")) "tail_recurse") ";\n          }\n        " (span (|@| (class "keyword") (id "F:578584")) "else") " " (span (|@| (class "keyword") (id "F:578589")) "if") " (INTEGERP (car))\n          {\n            " (span (|@| (class "keyword") (id "F:578619")) "register") " " (span (|@| (class "type") (id "F:578628")) "int") " " (span (|@| (class "variable-name") (id "F:578632")) "lim") " = XINT (car);\n            elt = XCDR (elt);\n            " (span (|@| (class "keyword") (id "F:578678")) "if") " (lim < 0)\n              {\n                " (span (|@| (class "comment-delimiter") (id "F:578702")) "/* ") (span (|@| (class "comment") (id "F:578705")) "Negative int means reduce maximum width.  ") (span (|@| (class "comment-delimiter") (id "F:578747")) "*/") "\n                " (span (|@| (class "keyword") (id "F:578752")) "if") " (precision <= 0)\n                  precision = -lim;\n                " (span (|@| (class "keyword") (id "F:578796")) "else") "\n                  precision = min (precision, -lim);\n              }\n            " (span (|@| (class "keyword") (id "F:578854")) "else") " " (span (|@| (class "keyword") (id "F:578859")) "if") " (lim > 0)\n              {\n                " (span (|@| (class "comment-delimiter") (id "F:578883")) "/* ") (span (|@| (class "comment") (id "F:578886")) "Padding specified.  Don't let it be more than\n                   current maximum.  ") (span (|@| (class "comment-delimiter") (id "F:578955")) "*/") "\n                " (span (|@| (class "keyword") (id "F:578960")) "if") " (precision > 0)\n                  lim = min (precision, lim);\n\n                " (span (|@| (class "comment-delimiter") (id "F:579014")) "/* ") (span (|@| (class "comment") (id "F:579017")) "If that's more padding than already wanted, queue it.\n                   But don't reduce padding already specified even if\n                   that is beyond the current truncation point.  ") (span (|@| (class "comment-delimiter") (id "F:579178")) "*/") "\n                field_width = max (lim, field_width);\n              }\n            " (span (|@| (class "keyword") (id "F:579235")) "goto") " " (span (|@| (class "constant") (id "F:579240")) "tail_recurse") ";\n          }\n        " (span (|@| (class "keyword") (id "F:579260")) "else") " " (span (|@| (class "keyword") (id "F:579265")) "if") " (STRINGP (car) || CONSP (car))\n          {\n            " (span (|@| (class "type") (id "F:579309")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:579321")) "halftail") " = elt;\n            " (span (|@| (class "type") (id "F:579342")) "int") " " (span (|@| (class "variable-name") (id "F:579346")) "len") " = 0;\n\n            " (span (|@| (class "keyword") (id "F:579361")) "while") " (CONSP (elt)\n                   && (precision <= 0 || n < precision))\n              {\n                n += display_mode_element (it, depth,\n                                           " (span (|@| (class "comment-delimiter") (id "F:579480")) "/* ") (span (|@| (class "comment") (id "F:579483")) "Do padding only after the last\n                                              element in the list.  ") (span (|@| (class "comment-delimiter") (id "F:579547")) "*/") "\n                                           (" (span (|@| (class "negation-char") (id "F:579559")) "!") " CONSP (XCDR (elt))\n                                            ? field_width - n\n                                            : 0),\n                                           precision - n, XCAR (elt),\n                                           props, risky);\n                elt = XCDR (elt);\n                len++;\n                " (span (|@| (class "keyword") (id "F:579711")) "if") " ((len & 1) == 0)\n                  halftail = XCDR (halftail);\n                " (span (|@| (class "comment-delimiter") (id "F:579765")) "/* ") (span (|@| (class "comment") (id "F:579768")) "Check for cycle.  ") (span (|@| (class "comment-delimiter") (id "F:579786")) "*/") "\n                " (span (|@| (class "keyword") (id "F:579791")) "if") " (EQ (halftail, elt))\n                  " (span (|@| (class "keyword") (id "F:579819")) "break") ";\n              }\n          }\n      }\n      " (span (|@| (class "keyword") (id "F:579854")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:579866")) "default") ":\n    " (span (|@| (class "constant") (id "F:579879")) "invalid") ":\n      elt = build_string (" (span (|@| (class "string") (id "F:579914")) "\"*invalid*\"") ");\n      " (span (|@| (class "keyword") (id "F:579934")) "goto") " " (span (|@| (class "constant") (id "F:579939")) "tail_recurse") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:579962")) "/* ") (span (|@| (class "comment") (id "F:579965")) "Pad to FIELD_WIDTH.  ") (span (|@| (class "comment-delimiter") (id "F:579986")) "*/") "\n  " (span (|@| (class "keyword") (id "F:579991")) "if") " (field_width > 0 && n < field_width)\n    {\n      " (span (|@| (class "keyword") (id "F:580043")) "switch") " (mode_line_target)\n        {\n        " (span (|@| (class "keyword") (id "F:580073")) "case") " MODE_LINE_NOPROP:\n        " (span (|@| (class "keyword") (id "F:580097")) "case") " MODE_LINE_TITLE:\n          n += store_mode_line_noprop (" (span (|@| (class "string") (id "F:580151")) "\"\"") ", field_width - n, 0);\n          " (span (|@| (class "keyword") (id "F:580179")) "break") ";\n        " (span (|@| (class "keyword") (id "F:580187")) "case") " MODE_LINE_STRING:\n          n += store_mode_line_string (" (span (|@| (class "string") (id "F:580242")) "\"\"") ", Qnil, 0, field_width - n, 0, Qnil);\n          " (span (|@| (class "keyword") (id "F:580285")) "break") ";\n        " (span (|@| (class "keyword") (id "F:580293")) "case") " MODE_LINE_DISPLAY:\n          n += display_string (" (span (|@| (class "string") (id "F:580341")) "\"\"") ", Qnil, Qnil, 0, 0, it, field_width - n,\n                               0, 0, 0);\n          " (span (|@| (class "keyword") (id "F:580407")) "break") ";\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:580426")) "return") " n;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:580439")) "/* ") (span (|@| (class "comment") (id "F:580442")) "Store a mode-line string element in mode_line_string_list.\n\n   If STRING is non-null, display that C string.  Otherwise, the Lisp\n   string LISP_STRING is displayed.\n\n   FIELD_WIDTH is the minimum number of output glyphs to produce.\n   If STRING has fewer characters than FIELD_WIDTH, pad to the right\n   with spaces.  FIELD_WIDTH <= 0 means don't pad.\n\n   PRECISION is the maximum number of characters to output from\n   STRING.  PRECISION <= 0  means don't truncate the string.\n\n   If COPY_STRING is non-zero, make a copy of LISP_STRING before adding\n   properties to the string.\n\n   PROPS are the properties to add to the string.\n   The mode_line_string_face face property is always added to the string.\n ") (span (|@| (class "comment-delimiter") (id "F:581149")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:581153")) "static") " " (span (|@| (class "type") (id "F:581160")) "int") "\n" (span (|@| (class "function-name") (id "F:581164")) "store_mode_line_string") " (string, lisp_string, copy_string, field_width, precision, " (span (|@| (class "type") (id "F:581246")) "props") ")\n     " (span (|@| (class "type") (id "F:581258")) "char") " *" (span (|@| (class "variable-name") (id "F:581264")) "string") ";\n     " (span (|@| (class "type") (id "F:581277")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:581289")) "lisp_string") ";\n     " (span (|@| (class "type") (id "F:581307")) "int") " " (span (|@| (class "variable-name") (id "F:581311")) "copy_string") ";\n     " (span (|@| (class "type") (id "F:581329")) "int") " " (span (|@| (class "variable-name") (id "F:581333")) "field_width") ";\n     " (span (|@| (class "type") (id "F:581351")) "int") " " (span (|@| (class "variable-name") (id "F:581355")) "precision") ";\n     " (span (|@| (class "type") (id "F:581371")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:581383")) "props") ";\n{\n  " (span (|@| (class "type") (id "F:581394")) "int") " " (span (|@| (class "variable-name") (id "F:581398")) "len") ";\n  " (span (|@| (class "type") (id "F:581405")) "int") " " (span (|@| (class "variable-name") (id "F:581409")) "n") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:581419")) "if") " (string != " (span (|@| (class "constant") (id "F:581433")) "NULL") ")\n    {\n      len = strlen (string);\n      " (span (|@| (class "keyword") (id "F:581480")) "if") " (precision > 0 && len > precision)\n        len = precision;\n      lisp_string = make_string (string, len);\n      " (span (|@| (class "keyword") (id "F:581589")) "if") " (NILP (props))\n        props = mode_line_string_face_prop;\n      " (span (|@| (class "keyword") (id "F:581650")) "else") " " (span (|@| (class "keyword") (id "F:581655")) "if") " (" (span (|@| (class "negation-char") (id "F:581659")) "!") "NILP (mode_line_string_face))\n        {\n          " (span (|@| (class "type") (id "F:581696")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:581708")) "face") " = Fplist_get (props, Qface);\n          props = Fcopy_sequence (props);\n          " (span (|@| (class "keyword") (id "F:581780")) "if") " (NILP (face))\n            face = mode_line_string_face;\n          " (span (|@| (class "keyword") (id "F:581835")) "else") "\n            face = Fcons (face, Fcons (mode_line_string_face, Qnil));\n          props = Fplist_put (props, Qface, face);\n        }\n      Fadd_text_properties (make_number (0), make_number (len),\n                            props, lisp_string);\n    }\n  " (span (|@| (class "keyword") (id "F:582050")) "else") "\n    {\n      len = XFASTINT (Flength (lisp_string));\n      " (span (|@| (class "keyword") (id "F:582113")) "if") " (precision > 0 && len > precision)\n        {\n          len = precision;\n          lisp_string = Fsubstring (lisp_string, make_number (0), make_number (len));\n          precision = -1;\n        }\n      " (span (|@| (class "keyword") (id "F:582281")) "if") " (" (span (|@| (class "negation-char") (id "F:582285")) "!") "NILP (mode_line_string_face))\n        {\n          " (span (|@| (class "type") (id "F:582322")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:582334")) "face") ";\n          " (span (|@| (class "keyword") (id "F:582343")) "if") " (NILP (props))\n            props = Ftext_properties_at (make_number (0), lisp_string);\n          face = Fplist_get (props, Qface);\n          " (span (|@| (class "keyword") (id "F:582466")) "if") " (NILP (face))\n            face = mode_line_string_face;\n          " (span (|@| (class "keyword") (id "F:582521")) "else") "\n            face = Fcons (face, Fcons (mode_line_string_face, Qnil));\n          props = Fcons (Qface, Fcons (face, Qnil));\n          " (span (|@| (class "keyword") (id "F:582638")) "if") " (copy_string)\n            lisp_string = Fcopy_sequence (lisp_string);\n        }\n      " (span (|@| (class "keyword") (id "F:582713")) "if") " (" (span (|@| (class "negation-char") (id "F:582717")) "!") "NILP (props))\n        Fadd_text_properties (make_number (0), make_number (len),\n                              props, lisp_string);\n    }\n\n  " (span (|@| (class "keyword") (id "F:582830")) "if") " (len > 0)\n    {\n      mode_line_string_list = Fcons (lisp_string, mode_line_string_list);\n      n += len;\n    }\n\n  " (span (|@| (class "keyword") (id "F:582948")) "if") " (field_width > len)\n    {\n      field_width -= len;\n      lisp_string = Fmake_string (make_number (field_width), make_number (" (span (|@| (class "string") (id "F:583077")) "' '") "));\n      " (span (|@| (class "keyword") (id "F:583090")) "if") " (" (span (|@| (class "negation-char") (id "F:583094")) "!") "NILP (props))\n        Fadd_text_properties (make_number (0), make_number (field_width),\n                              props, lisp_string);\n      mode_line_string_list = Fcons (lisp_string, mode_line_string_list);\n      n += field_width;\n    }\n\n  " (span (|@| (class "keyword") (id "F:583313")) "return") " n;\n}\n\n\nDEFUN (" (span (|@| (class "string") (id "F:583334")) "\"format-mode-line\"") ", Fformat_mode_line, Sformat_mode_line,\n       1, 4, 0,\n       doc: " (span (|@| (class "comment-delimiter") (id "F:583420")) "/* ") (span (|@| (class "comment") (id "F:583423")) "Format a string out of a mode line format specification.\nFirst arg FORMAT specifies the mode line format (see `mode-line-format'\nfor details) to use.\n\nOptional second arg FACE specifies the face property to put\non all characters for which no face is specified.\nThe value t means whatever face the window's mode line currently uses\n\\(either `mode-line' or `mode-line-inactive', depending).\nA value of nil means the default is no face property.\nIf FACE is an integer, the value string has no text properties.\n\nOptional third and fourth args WINDOW and BUFFER specify the window\nand buffer to use as the context for the formatting (defaults\nare the selected window and the window's buffer).  ") (span (|@| (class "comment-delimiter") (id "F:584112")) "*/") ")\n     (format, face, window, buffer)\n     " (span (|@| (class "type") (id "F:584157")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:584169")) "format") ", " (span (|@| (class "variable-name") (id "F:584177")) "face") ", " (span (|@| (class "variable-name") (id "F:584183")) "window") ", " (span (|@| (class "variable-name") (id "F:584191")) "buffer") ";\n{\n  " (span (|@| (class "keyword") (id "F:584203")) "struct") " " (span (|@| (class "type") (id "F:584210")) "it") " " (span (|@| (class "variable-name") (id "F:584213")) "it") ";\n  " (span (|@| (class "type") (id "F:584219")) "int") " " (span (|@| (class "variable-name") (id "F:584223")) "len") ";\n  " (span (|@| (class "keyword") (id "F:584230")) "struct") " " (span (|@| (class "type") (id "F:584237")) "window") " *" (span (|@| (class "variable-name") (id "F:584245")) "w") ";\n  " (span (|@| (class "keyword") (id "F:584250")) "struct") " " (span (|@| (class "type") (id "F:584257")) "buffer") " *" (span (|@| (class "variable-name") (id "F:584265")) "old_buffer") " = " (span (|@| (class "constant") (id "F:584278")) "NULL") ";\n  " (span (|@| (class "type") (id "F:584286")) "int") " " (span (|@| (class "variable-name") (id "F:584290")) "face_id") " = -1;\n  " (span (|@| (class "type") (id "F:584306")) "int") " " (span (|@| (class "variable-name") (id "F:584310")) "no_props") " = INTEGERP (face);\n  " (span (|@| (class "type") (id "F:584340")) "int") " " (span (|@| (class "variable-name") (id "F:584344")) "count") " = SPECPDL_INDEX ();\n  " (span (|@| (class "type") (id "F:584372")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:584384")) "str") ";\n  " (span (|@| (class "type") (id "F:584391")) "int") " " (span (|@| (class "variable-name") (id "F:584395")) "string_start") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:584416")) "if") " (NILP (window))\n    window = selected_window;\n  CHECK_WINDOW (window);\n  w = XWINDOW (window);\n\n  " (span (|@| (class "keyword") (id "F:584517")) "if") " (NILP (buffer))\n    buffer = w->buffer;\n  CHECK_BUFFER (buffer);\n\n  " (span (|@| (class "comment-delimiter") (id "F:584588")) "/* ") (span (|@| (class "comment") (id "F:584591")) "Make formatting the modeline a non-op when noninteractive, otherwise\n     there will be problems later caused by a partially initialized frame.  ") (span (|@| (class "comment-delimiter") (id "F:584736")) "*/") "\n  " (span (|@| (class "keyword") (id "F:584741")) "if") " (NILP (format) || noninteractive)\n    " (span (|@| (class "keyword") (id "F:584782")) "return") " empty_unibyte_string;\n\n  " (span (|@| (class "keyword") (id "F:584814")) "if") " (no_props)\n    face = Qnil;\n\n  " (span (|@| (class "keyword") (id "F:584848")) "if") " (" (span (|@| (class "negation-char") (id "F:584852")) "!") "NILP (face))\n    {\n      " (span (|@| (class "keyword") (id "F:584878")) "if") " (EQ (face, Qt))\n        face = (EQ (window, selected_window) ? Qmode_line : Qmode_line_inactive);\n      face_id = lookup_named_face (XFRAME (WINDOW_FRAME (w)), face, 0);\n    }\n\n  " (span (|@| (class "keyword") (id "F:585053")) "if") " (face_id < 0)\n    face_id = DEFAULT_FACE_ID;\n\n  " (span (|@| (class "keyword") (id "F:585104")) "if") " (XBUFFER (buffer) != current_buffer)\n    old_buffer = current_buffer;\n\n  " (span (|@| (class "comment-delimiter") (id "F:585180")) "/* ") (span (|@| (class "comment") (id "F:585183")) "Save things including mode_line_proptrans_alist,\n     and set that to nil so that we don't alter the outer value.  ") (span (|@| (class "comment-delimiter") (id "F:585298")) "*/") "\n  record_unwind_protect (unwind_format_mode_line,\n                         format_mode_line_unwind_data\n                             (old_buffer, selected_window, 1));\n  mode_line_proptrans_alist = Qnil;\n\n  Fselect_window (window, Qt);\n  " (span (|@| (class "keyword") (id "F:585497")) "if") " (old_buffer)\n    set_buffer_internal_1 (XBUFFER (buffer));\n\n  init_iterator (&it, w, -1, -1, " (span (|@| (class "constant") (id "F:585593")) "NULL") ", face_id);\n\n  " (span (|@| (class "keyword") (id "F:585612")) "if") " (no_props)\n    {\n      mode_line_target = MODE_LINE_NOPROP;\n      mode_line_string_face_prop = Qnil;\n      mode_line_string_list = Qnil;\n      string_start = MODE_LINE_NOPROP_LEN (0);\n    }\n  " (span (|@| (class "keyword") (id "F:585807")) "else") "\n    {\n      mode_line_target = MODE_LINE_STRING;\n      mode_line_string_list = Qnil;\n      mode_line_string_face = face;\n      mode_line_string_face_prop\n        = (NILP (face) ? Qnil : Fcons (Qface, Fcons (face, Qnil)));\n    }\n\n  push_kboard (FRAME_KBOARD (it.f));\n  display_mode_element (&it, 0, 0, 0, format, Qnil, 0);\n  pop_kboard ();\n\n  " (span (|@| (class "keyword") (id "F:586147")) "if") " (no_props)\n    {\n      len = MODE_LINE_NOPROP_LEN (string_start);\n      str = make_string (mode_line_noprop_buf + string_start, len);\n    }\n  " (span (|@| (class "keyword") (id "F:586292")) "else") "\n    {\n      mode_line_string_list = Fnreverse (mode_line_string_list);\n      str = Fmapconcat (intern (" (span (|@| (class "string") (id "F:586400")) "\"identity\"") "), mode_line_string_list,\n                        empty_unibyte_string);\n    }\n\n  unbind_to (count, Qnil);\n  " (span (|@| (class "keyword") (id "F:586498")) "return") " str;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:586513")) "/* ") (span (|@| (class "comment") (id "F:586516")) "Write a null-terminated, right justified decimal representation of\n   the positive integer D to BUF using a minimal field width WIDTH.  ") (span (|@| (class "comment-delimiter") (id "F:586652")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:586656")) "static") " " (span (|@| (class "type") (id "F:586663")) "void") "\n" (span (|@| (class "function-name") (id "F:586668")) "pint2str") " (buf, width, d)\n     " (span (|@| (class "keyword") (id "F:586698")) "register") " " (span (|@| (class "type") (id "F:586707")) "char") " *" (span (|@| (class "variable-name") (id "F:586713")) "buf") ";\n     " (span (|@| (class "keyword") (id "F:586723")) "register") " " (span (|@| (class "type") (id "F:586732")) "int") " " (span (|@| (class "variable-name") (id "F:586736")) "width") ";\n     " (span (|@| (class "keyword") (id "F:586748")) "register") " " (span (|@| (class "type") (id "F:586757")) "int") " " (span (|@| (class "variable-name") (id "F:586761")) "d") ";\n{\n  " (span (|@| (class "keyword") (id "F:586768")) "register") " " (span (|@| (class "type") (id "F:586777")) "char") " *" (span (|@| (class "variable-name") (id "F:586783")) "p") " = buf;\n\n  " (span (|@| (class "keyword") (id "F:586795")) "if") " (d <= 0)\n    *p++ = " (span (|@| (class "string") (id "F:586818")) "'0'") ";\n  " (span (|@| (class "keyword") (id "F:586825")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:586842")) "while") " (d > 0)\n        {\n          *p++ = d % 10 + " (span (|@| (class "string") (id "F:586878")) "'0'") ";\n          d /= 10;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:586907")) "for") " (width -= (" (span (|@| (class "type") (id "F:586922")) "int") ") (p - buf); width > 0; --width)\n    *p++ = " (span (|@| (class "string") (id "F:586969")) "' '") ";\n  *p-- = " (span (|@| (class "string") (id "F:586983")) "'\\0'") ";\n  " (span (|@| (class "keyword") (id "F:586991")) "while") " (p > buf)\n    {\n      d = *buf;\n      *buf++ = *p;\n      *p-- = d;\n    }\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:587073")) "/* ") (span (|@| (class "comment") (id "F:587076")) "Write a null-terminated, right justified decimal and \"human\n   readable\" representation of the nonnegative integer D to BUF using\n   a minimal field width WIDTH.  D should be smaller than 999.5e24. ") (span (|@| (class "comment-delimiter") (id "F:587274")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:587278")) "static") " " (span (|@| (class "keyword") (id "F:587285")) "const") " " (span (|@| (class "type") (id "F:587291")) "char") " " (span (|@| (class "variable-name") (id "F:587296")) "power_letter") "[] =\n  {\n    0,   " (span (|@| (class "comment-delimiter") (id "F:587325")) "/* ") (span (|@| (class "comment") (id "F:587328")) "not used ") (span (|@| (class "comment-delimiter") (id "F:587337")) "*/") "\n    " (span (|@| (class "string") (id "F:587344")) "'k'") ", " (span (|@| (class "comment-delimiter") (id "F:587349")) "/* ") (span (|@| (class "comment") (id "F:587352")) "kilo ") (span (|@| (class "comment-delimiter") (id "F:587357")) "*/") "\n    " (span (|@| (class "string") (id "F:587364")) "'M'") ", " (span (|@| (class "comment-delimiter") (id "F:587369")) "/* ") (span (|@| (class "comment") (id "F:587372")) "mega ") (span (|@| (class "comment-delimiter") (id "F:587377")) "*/") "\n    " (span (|@| (class "string") (id "F:587384")) "'G'") ", " (span (|@| (class "comment-delimiter") (id "F:587389")) "/* ") (span (|@| (class "comment") (id "F:587392")) "giga ") (span (|@| (class "comment-delimiter") (id "F:587397")) "*/") "\n    " (span (|@| (class "string") (id "F:587404")) "'T'") ", " (span (|@| (class "comment-delimiter") (id "F:587409")) "/* ") (span (|@| (class "comment") (id "F:587412")) "tera ") (span (|@| (class "comment-delimiter") (id "F:587417")) "*/") "\n    " (span (|@| (class "string") (id "F:587424")) "'P'") ", " (span (|@| (class "comment-delimiter") (id "F:587429")) "/* ") (span (|@| (class "comment") (id "F:587432")) "peta ") (span (|@| (class "comment-delimiter") (id "F:587437")) "*/") "\n    " (span (|@| (class "string") (id "F:587444")) "'E'") ", " (span (|@| (class "comment-delimiter") (id "F:587449")) "/* ") (span (|@| (class "comment") (id "F:587452")) "exa ") (span (|@| (class "comment-delimiter") (id "F:587456")) "*/") "\n    " (span (|@| (class "string") (id "F:587463")) "'Z'") ", " (span (|@| (class "comment-delimiter") (id "F:587468")) "/* ") (span (|@| (class "comment") (id "F:587471")) "zetta ") (span (|@| (class "comment-delimiter") (id "F:587477")) "*/") "\n    " (span (|@| (class "string") (id "F:587484")) "'Y'") "  " (span (|@| (class "comment-delimiter") (id "F:587489")) "/* ") (span (|@| (class "comment") (id "F:587492")) "yotta ") (span (|@| (class "comment-delimiter") (id "F:587498")) "*/") "\n  };\n\n" (span (|@| (class "keyword") (id "F:587507")) "static") " " (span (|@| (class "type") (id "F:587514")) "void") "\n" (span (|@| (class "function-name") (id "F:587519")) "pint2hrstr") " (buf, width, d)\n     " (span (|@| (class "type") (id "F:587551")) "char") " *" (span (|@| (class "variable-name") (id "F:587557")) "buf") ";\n     " (span (|@| (class "type") (id "F:587567")) "int") " " (span (|@| (class "variable-name") (id "F:587571")) "width") ";\n     " (span (|@| (class "type") (id "F:587583")) "int") " " (span (|@| (class "variable-name") (id "F:587587")) "d") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:587594")) "/* ") (span (|@| (class "comment") (id "F:587597")) "We aim to represent the nonnegative integer D as\n     QUOTIENT.TENTHS * 10 ^ (3 * EXPONENT). ") (span (|@| (class "comment-delimiter") (id "F:587690")) "*/") "\n  " (span (|@| (class "type") (id "F:587695")) "int") " " (span (|@| (class "variable-name") (id "F:587699")) "quotient") " = d;\n  " (span (|@| (class "type") (id "F:587715")) "int") " " (span (|@| (class "variable-name") (id "F:587719")) "remainder") " = 0;\n  " (span (|@| (class "comment-delimiter") (id "F:587736")) "/* ") (span (|@| (class "comment") (id "F:587739")) "-1 means: do not use TENTHS. ") (span (|@| (class "comment-delimiter") (id "F:587768")) "*/") "\n  " (span (|@| (class "type") (id "F:587773")) "int") " " (span (|@| (class "variable-name") (id "F:587777")) "tenths") " = -1;\n  " (span (|@| (class "type") (id "F:587792")) "int") " " (span (|@| (class "variable-name") (id "F:587796")) "exponent") " = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:587813")) "/* ") (span (|@| (class "comment") (id "F:587816")) "Length of QUOTIENT.TENTHS as a string. ") (span (|@| (class "comment-delimiter") (id "F:587855")) "*/") "\n  " (span (|@| (class "type") (id "F:587860")) "int") " " (span (|@| (class "variable-name") (id "F:587864")) "length") ";\n\n  " (span (|@| (class "type") (id "F:587875")) "char") " * " (span (|@| (class "variable-name") (id "F:587882")) "psuffix") ";\n  " (span (|@| (class "type") (id "F:587893")) "char") " * " (span (|@| (class "variable-name") (id "F:587900")) "p") ";\n\n  " (span (|@| (class "keyword") (id "F:587906")) "if") " (1000 <= quotient)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:587940")) "/* ") (span (|@| (class "comment") (id "F:587943")) "Scale to the appropriate EXPONENT. ") (span (|@| (class "comment-delimiter") (id "F:587978")) "*/") "\n      " (span (|@| (class "keyword") (id "F:587987")) "do") "\n        {\n          remainder = quotient % 1000;\n          quotient /= 1000;\n          exponent++;\n        }\n      " (span (|@| (class "keyword") (id "F:588070")) "while") " (1000 <= quotient);\n\n      " (span (|@| (class "comment-delimiter") (id "F:588103")) "/* ") (span (|@| (class "comment") (id "F:588106")) "Round to nearest and decide whether to use TENTHS or not. ") (span (|@| (class "comment-delimiter") (id "F:588164")) "*/") "\n      " (span (|@| (class "keyword") (id "F:588173")) "if") " (quotient <= 9)\n        {\n          tenths = remainder / 100;\n          " (span (|@| (class "keyword") (id "F:588227")) "if") " (50 <= remainder % 100)\n            {\n              " (span (|@| (class "keyword") (id "F:588268")) "if") " (tenths < 9)\n                tenths++;\n              " (span (|@| (class "keyword") (id "F:588303")) "else") "\n                {\n                  quotient++;\n                  " (span (|@| (class "keyword") (id "F:588332")) "if") " (quotient == 10)\n                    tenths = -1;\n                  " (span (|@| (class "keyword") (id "F:588375")) "else") "\n                    tenths = 0;\n                }\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:588418")) "else") "\n        " (span (|@| (class "keyword") (id "F:588424")) "if") " (500 <= remainder)\n          {\n            " (span (|@| (class "keyword") (id "F:588456")) "if") " (quotient < 999)\n              quotient++;\n            " (span (|@| (class "keyword") (id "F:588500")) "else") "\n              {\n                quotient = 1;\n                exponent++;\n                tenths = 0;\n              }\n          }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:588581")) "/* ") (span (|@| (class "comment") (id "F:588584")) "Calculate the LENGTH of QUOTIENT.TENTHS as a string. ") (span (|@| (class "comment-delimiter") (id "F:588637")) "*/") "\n  " (span (|@| (class "keyword") (id "F:588642")) "if") " (tenths == -1 && quotient <= 99)\n    " (span (|@| (class "keyword") (id "F:588682")) "if") " (quotient <= 9)\n      length = 1;\n    " (span (|@| (class "keyword") (id "F:588723")) "else") "\n      length = 2;\n  " (span (|@| (class "keyword") (id "F:588748")) "else") "\n    length = 3;\n  p = psuffix = buf + max (width, length);\n\n  " (span (|@| (class "comment-delimiter") (id "F:588815")) "/* ") (span (|@| (class "comment") (id "F:588818")) "Print EXPONENT. ") (span (|@| (class "comment-delimiter") (id "F:588834")) "*/") "\n  " (span (|@| (class "keyword") (id "F:588839")) "if") " (exponent)\n    *psuffix++ = power_letter[exponent];\n  *psuffix = " (span (|@| (class "string") (id "F:588907")) "'\\0'") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:588916")) "/* ") (span (|@| (class "comment") (id "F:588919")) "Print TENTHS. ") (span (|@| (class "comment-delimiter") (id "F:588933")) "*/") "\n  " (span (|@| (class "keyword") (id "F:588938")) "if") " (tenths >= 0)\n    {\n      *--p = " (span (|@| (class "string") (id "F:588974")) "'0'") " + tenths;\n      *--p = " (span (|@| (class "string") (id "F:589001")) "'.'") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:589015")) "/* ") (span (|@| (class "comment") (id "F:589018")) "Print QUOTIENT. ") (span (|@| (class "comment-delimiter") (id "F:589034")) "*/") "\n  " (span (|@| (class "keyword") (id "F:589039")) "do") "\n    {\n      " (span (|@| (class "type") (id "F:589054")) "int") " " (span (|@| (class "variable-name") (id "F:589058")) "digit") " = quotient % 10;\n      *--p =  " (span (|@| (class "string") (id "F:589095")) "'0'") " + digit;\n    }\n  " (span (|@| (class "keyword") (id "F:589116")) "while") " ((quotient /= 10) != 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:589150")) "/* ") (span (|@| (class "comment") (id "F:589153")) "Print leading spaces. ") (span (|@| (class "comment-delimiter") (id "F:589175")) "*/") "\n  " (span (|@| (class "keyword") (id "F:589180")) "while") " (buf < p)\n    *--p = " (span (|@| (class "string") (id "F:589207")) "' '") ";\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:589215")) "/* ") (span (|@| (class "comment") (id "F:589218")) "Set a mnemonic character for coding_system (Lisp symbol) in BUF.\n   If EOL_FLAG is 1, set also a mnemonic character for end-of-line\n   type of CODING_SYSTEM.  Return updated pointer into BUF.  ") (span (|@| (class "comment-delimiter") (id "F:589411")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:589415")) "static") " " (span (|@| (class "type") (id "F:589422")) "unsigned") " " (span (|@| (class "type") (id "F:589431")) "char") " " (span (|@| (class "variable-name") (id "F:589436")) "invalid_eol_type") "[] = " (span (|@| (class "string") (id "F:589457")) "\"(*invalid*)\"") ";\n\n" (span (|@| (class "keyword") (id "F:589473")) "static") " " (span (|@| (class "type") (id "F:589480")) "char") " *\n" (span (|@| (class "function-name") (id "F:589487")) "decode_mode_spec_coding") " (coding_system, buf, eol_flag)\n     " (span (|@| (class "type") (id "F:589547")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:589559")) "coding_system") ";\n     " (span (|@| (class "keyword") (id "F:589579")) "register") " " (span (|@| (class "type") (id "F:589588")) "char") " *" (span (|@| (class "variable-name") (id "F:589594")) "buf") ";\n     " (span (|@| (class "type") (id "F:589604")) "int") " " (span (|@| (class "variable-name") (id "F:589608")) "eol_flag") ";\n{\n  " (span (|@| (class "type") (id "F:589622")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:589634")) "val") ";\n  " (span (|@| (class "type") (id "F:589641")) "int") " " (span (|@| (class "variable-name") (id "F:589645")) "multibyte") " = " (span (|@| (class "negation-char") (id "F:589657")) "!") "NILP (current_buffer->enable_multibyte_characters);\n  " (span (|@| (class "keyword") (id "F:589712")) "const") " " (span (|@| (class "type") (id "F:589718")) "unsigned") " " (span (|@| (class "type") (id "F:589727")) "char") " *" (span (|@| (class "variable-name") (id "F:589733")) "eol_str") ";\n  " (span (|@| (class "type") (id "F:589744")) "int") " " (span (|@| (class "variable-name") (id "F:589748")) "eol_str_len") ";\n  " (span (|@| (class "comment-delimiter") (id "F:589763")) "/* ") (span (|@| (class "comment") (id "F:589766")) "The EOL conversion we are using.  ") (span (|@| (class "comment-delimiter") (id "F:589800")) "*/") "\n  " (span (|@| (class "type") (id "F:589805")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:589817")) "eoltype") ";\n\n  val = CODING_SYSTEM_SPEC (coding_system);\n  eoltype = Qnil;\n\n  " (span (|@| (class "keyword") (id "F:589892")) "if") " (" (span (|@| (class "negation-char") (id "F:589896")) "!") "VECTORP (val))           " (span (|@| (class "comment-delimiter") (id "F:589913")) "/* ") (span (|@| (class "comment") (id "F:589916")) "Not yet decided.  ") (span (|@| (class "comment-delimiter") (id "F:589934")) "*/") "\n    {\n      " (span (|@| (class "keyword") (id "F:589949")) "if") " (multibyte)\n        *buf++ = " (span (|@| (class "string") (id "F:589974")) "'-'") ";\n      " (span (|@| (class "keyword") (id "F:589985")) "if") " (eol_flag)\n        eoltype = eol_mnemonic_undecided;\n      " (span (|@| (class "comment-delimiter") (id "F:590040")) "/* ") (span (|@| (class "comment") (id "F:590043")) "Don't mention EOL conversion if it isn't decided.  ") (span (|@| (class "comment-delimiter") (id "F:590094")) "*/") "\n    }\n  " (span (|@| (class "keyword") (id "F:590105")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:590122")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:590134")) "attrs") ";\n      " (span (|@| (class "type") (id "F:590147")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:590159")) "eolvalue") ";\n\n      attrs = AREF (val, 0);\n      eolvalue = AREF (val, 2);\n\n      " (span (|@| (class "keyword") (id "F:590238")) "if") " (multibyte)\n        *buf++ = XFASTINT (CODING_ATTR_MNEMONIC (attrs));\n\n      " (span (|@| (class "keyword") (id "F:590311")) "if") " (eol_flag)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:590331")) "/* ") (span (|@| (class "comment") (id "F:590334")) "The EOL conversion that is normal on this system.  ") (span (|@| (class "comment-delimiter") (id "F:590385")) "*/") "\n\n          " (span (|@| (class "keyword") (id "F:590392")) "if") " (NILP (eolvalue))  " (span (|@| (class "comment-delimiter") (id "F:590413")) "/* ") (span (|@| (class "comment") (id "F:590416")) "Not yet decided.  ") (span (|@| (class "comment-delimiter") (id "F:590434")) "*/") "\n            eoltype = eol_mnemonic_undecided;\n          " (span (|@| (class "keyword") (id "F:590479")) "else") " " (span (|@| (class "keyword") (id "F:590484")) "if") " (VECTORP (eolvalue)) " (span (|@| (class "comment-delimiter") (id "F:590508")) "/* ") (span (|@| (class "comment") (id "F:590511")) "Not yet decided.  ") (span (|@| (class "comment-delimiter") (id "F:590529")) "*/") "\n            eoltype = eol_mnemonic_undecided;\n          " (span (|@| (class "keyword") (id "F:590574")) "else") "                  " (span (|@| (class "comment-delimiter") (id "F:590581")) "/* ") (span (|@| (class "comment") (id "F:590584")) "eolvalue is Qunix, Qdos, or Qmac.  ") (span (|@| (class "comment-delimiter") (id "F:590619")) "*/") "\n            eoltype = (EQ (eolvalue, Qunix)\n                       ? eol_mnemonic_unix\n                       : (EQ (eolvalue, Qdos) == 1\n                          ? eol_mnemonic_dos : eol_mnemonic_mac));\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:590783")) "if") " (eol_flag)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:590809")) "/* ") (span (|@| (class "comment") (id "F:590812")) "Mention the EOL conversion if it is not the usual one.  ") (span (|@| (class "comment-delimiter") (id "F:590868")) "*/") "\n      " (span (|@| (class "keyword") (id "F:590877")) "if") " (STRINGP (eoltype))\n        {\n          eol_str = SDATA (eoltype);\n          eol_str_len = SBYTES (eoltype);\n        }\n      " (span (|@| (class "keyword") (id "F:590977")) "else") " " (span (|@| (class "keyword") (id "F:590982")) "if") " (CHARACTERP (eoltype))\n        {\n          " (span (|@| (class "type") (id "F:591014")) "unsigned") " " (span (|@| (class "type") (id "F:591023")) "char") " *" (span (|@| (class "variable-name") (id "F:591029")) "tmp") " = (" (span (|@| (class "type") (id "F:591036")) "unsigned") " " (span (|@| (class "type") (id "F:591045")) "char") " *) alloca (MAX_MULTIBYTE_LENGTH);\n          eol_str_len = CHAR_STRING (XINT (eoltype), tmp);\n          eol_str = tmp;\n        }\n      " (span (|@| (class "keyword") (id "F:591163")) "else") "\n        {\n          eol_str = invalid_eol_type;\n          eol_str_len = " (span (|@| (class "keyword") (id "F:591219")) "sizeof") " (invalid_eol_type) - 1;\n        }\n      bcopy (eol_str, buf, eol_str_len);\n      buf += eol_str_len;\n    }\n\n  " (span (|@| (class "keyword") (id "F:591329")) "return") " buf;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:591344")) "/* ") (span (|@| (class "comment") (id "F:591347")) "Return a string for the output of a mode line %-spec for window W,\n   generated by character C.  PRECISION >= 0 means don't return a\n   string longer than that value.  FIELD_WIDTH > 0 means pad the\n   string returned with spaces to that value.  Return a Lisp string in\n   *STRING if the resulting string is taken from that Lisp string.\n\n   Note we operate on the current buffer for most purposes,\n   the exception being w->base_line_pos.  ") (span (|@| (class "comment-delimiter") (id "F:591786")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:591790")) "static") " " (span (|@| (class "type") (id "F:591797")) "char") " " (span (|@| (class "variable-name") (id "F:591802")) "lots_of_dashes") "[] = " (span (|@| (class "string") (id "F:591821")) "\"--------------------------------------------------------------------------------------------------------------------------------------------\"") ";\n\n" (span (|@| (class "keyword") (id "F:591966")) "static") " " (span (|@| (class "type") (id "F:591973")) "char") " *\n" (span (|@| (class "function-name") (id "F:591980")) "decode_mode_spec") " (w, c, field_width, precision, string)\n     " (span (|@| (class "keyword") (id "F:592041")) "struct") " " (span (|@| (class "type") (id "F:592048")) "window") " *" (span (|@| (class "variable-name") (id "F:592056")) "w") ";\n     " (span (|@| (class "keyword") (id "F:592064")) "register") " " (span (|@| (class "type") (id "F:592073")) "int") " " (span (|@| (class "variable-name") (id "F:592077")) "c") ";\n     " (span (|@| (class "type") (id "F:592085")) "int") " " (span (|@| (class "variable-name") (id "F:592089")) "field_width") ", " (span (|@| (class "variable-name") (id "F:592102")) "precision") ";\n     " (span (|@| (class "type") (id "F:592118")) "Lisp_Object") " *" (span (|@| (class "variable-name") (id "F:592131")) "string") ";\n{\n  " (span (|@| (class "type") (id "F:592143")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:592155")) "obj") ";\n  " (span (|@| (class "keyword") (id "F:592162")) "struct") " " (span (|@| (class "type") (id "F:592169")) "frame") " *" (span (|@| (class "variable-name") (id "F:592176")) "f") " = XFRAME (WINDOW_FRAME (w));\n  " (span (|@| (class "type") (id "F:592209")) "char") " *" (span (|@| (class "variable-name") (id "F:592215")) "decode_mode_spec_buf") " = f->decode_mode_spec_buffer;\n  " (span (|@| (class "keyword") (id "F:592268")) "struct") " " (span (|@| (class "type") (id "F:592275")) "buffer") " *" (span (|@| (class "variable-name") (id "F:592283")) "b") " = current_buffer;\n\n  obj = Qnil;\n  *string = Qnil;\n\n  " (span (|@| (class "keyword") (id "F:592339")) "switch") " (c)\n    {\n    " (span (|@| (class "keyword") (id "F:592360")) "case") " " (span (|@| (class "string") (id "F:592365")) "'*'") ":\n      " (span (|@| (class "keyword") (id "F:592376")) "if") " (" (span (|@| (class "negation-char") (id "F:592380")) "!") "NILP (b->read_only))\n        " (span (|@| (class "keyword") (id "F:592403")) "return") " " (span (|@| (class "string") (id "F:592410")) "\"%\"") ";\n      " (span (|@| (class "keyword") (id "F:592421")) "if") " (BUF_MODIFF (b) > BUF_SAVE_MODIFF (b))\n        " (span (|@| (class "keyword") (id "F:592464")) "return") " " (span (|@| (class "string") (id "F:592471")) "\"*\"") ";\n      " (span (|@| (class "keyword") (id "F:592482")) "return") " " (span (|@| (class "string") (id "F:592489")) "\"-\"") ";\n\n    " (span (|@| (class "keyword") (id "F:592499")) "case") " " (span (|@| (class "string") (id "F:592504")) "'+'") ":\n      " (span (|@| (class "comment-delimiter") (id "F:592515")) "/* ") (span (|@| (class "comment") (id "F:592518")) "This differs from %* only for a modified read-only buffer.  ") (span (|@| (class "comment-delimiter") (id "F:592578")) "*/") "\n      " (span (|@| (class "keyword") (id "F:592587")) "if") " (BUF_MODIFF (b) > BUF_SAVE_MODIFF (b))\n        " (span (|@| (class "keyword") (id "F:592630")) "return") " " (span (|@| (class "string") (id "F:592637")) "\"*\"") ";\n      " (span (|@| (class "keyword") (id "F:592648")) "if") " (" (span (|@| (class "negation-char") (id "F:592652")) "!") "NILP (b->read_only))\n        " (span (|@| (class "keyword") (id "F:592675")) "return") " " (span (|@| (class "string") (id "F:592682")) "\"%\"") ";\n      " (span (|@| (class "keyword") (id "F:592693")) "return") " " (span (|@| (class "string") (id "F:592700")) "\"-\"") ";\n\n    " (span (|@| (class "keyword") (id "F:592710")) "case") " " (span (|@| (class "string") (id "F:592715")) "'&'") ":\n      " (span (|@| (class "comment-delimiter") (id "F:592726")) "/* ") (span (|@| (class "comment") (id "F:592729")) "This differs from %* in ignoring read-only-ness.  ") (span (|@| (class "comment-delimiter") (id "F:592779")) "*/") "\n      " (span (|@| (class "keyword") (id "F:592788")) "if") " (BUF_MODIFF (b) > BUF_SAVE_MODIFF (b))\n        " (span (|@| (class "keyword") (id "F:592831")) "return") " " (span (|@| (class "string") (id "F:592838")) "\"*\"") ";\n      " (span (|@| (class "keyword") (id "F:592849")) "return") " " (span (|@| (class "string") (id "F:592856")) "\"-\"") ";\n\n    " (span (|@| (class "keyword") (id "F:592866")) "case") " " (span (|@| (class "string") (id "F:592871")) "'%'") ":\n      " (span (|@| (class "keyword") (id "F:592882")) "return") " " (span (|@| (class "string") (id "F:592889")) "\"%\"") ";\n\n    " (span (|@| (class "keyword") (id "F:592899")) "case") " " (span (|@| (class "string") (id "F:592904")) "'['") ":\n      {\n        " (span (|@| (class "type") (id "F:592918")) "int") " " (span (|@| (class "variable-name") (id "F:592922")) "i") ";\n        " (span (|@| (class "type") (id "F:592926")) "char") " *" (span (|@| (class "variable-name") (id "F:592932")) "p") ";\n\n        " (span (|@| (class "keyword") (id "F:592937")) "if") " (command_loop_level > 5)\n          " (span (|@| (class "keyword") (id "F:592968")) "return") " " (span (|@| (class "string") (id "F:592975")) "\"[[[... \"") ";\n        p = decode_mode_spec_buf;\n        " (span (|@| (class "keyword") (id "F:593014")) "for") " (i = 0; i < command_loop_level; i++)\n          *p++ = " (span (|@| (class "string") (id "F:593065")) "'['") ";\n        *p = 0;\n        " (span (|@| (class "keyword") (id "F:593080")) "return") " decode_mode_spec_buf;\n      }\n\n    " (span (|@| (class "keyword") (id "F:593122")) "case") " " (span (|@| (class "string") (id "F:593127")) "']'") ":\n      {\n        " (span (|@| (class "type") (id "F:593141")) "int") " " (span (|@| (class "variable-name") (id "F:593145")) "i") ";\n        " (span (|@| (class "type") (id "F:593149")) "char") " *" (span (|@| (class "variable-name") (id "F:593155")) "p") ";\n\n        " (span (|@| (class "keyword") (id "F:593160")) "if") " (command_loop_level > 5)\n          " (span (|@| (class "keyword") (id "F:593191")) "return") " " (span (|@| (class "string") (id "F:593198")) "\" ...]]]\"") ";\n        p = decode_mode_spec_buf;\n        " (span (|@| (class "keyword") (id "F:593237")) "for") " (i = 0; i < command_loop_level; i++)\n          *p++ = " (span (|@| (class "string") (id "F:593288")) "']'") ";\n        *p = 0;\n        " (span (|@| (class "keyword") (id "F:593303")) "return") " decode_mode_spec_buf;\n      }\n\n    " (span (|@| (class "keyword") (id "F:593345")) "case") " " (span (|@| (class "string") (id "F:593350")) "'-'") ":\n      {\n        " (span (|@| (class "keyword") (id "F:593364")) "register") " " (span (|@| (class "type") (id "F:593373")) "int") " " (span (|@| (class "variable-name") (id "F:593377")) "i") ";\n\n        " (span (|@| (class "comment-delimiter") (id "F:593382")) "/* ") (span (|@| (class "comment") (id "F:593385")) "Let lots_of_dashes be a string of infinite length.  ") (span (|@| (class "comment-delimiter") (id "F:593437")) "*/") "\n        " (span (|@| (class "keyword") (id "F:593441")) "if") " (mode_line_target == MODE_LINE_NOPROP ||\n            mode_line_target == MODE_LINE_STRING)\n          " (span (|@| (class "keyword") (id "F:593531")) "return") " " (span (|@| (class "string") (id "F:593538")) "\"--\"") ";\n        " (span (|@| (class "keyword") (id "F:593545")) "if") " (field_width <= 0\n            || field_width > " (span (|@| (class "keyword") (id "F:593588")) "sizeof") " (lots_of_dashes))\n          {\n            " (span (|@| (class "keyword") (id "F:593623")) "for") " (i = 0; i < FRAME_MESSAGE_BUF_SIZE (f) - 1; ++i)\n              decode_mode_spec_buf[i] = " (span (|@| (class "string") (id "F:593709")) "'-'") ";\n            decode_mode_spec_buf[i] = " (span (|@| (class "string") (id "F:593745")) "'\\0'") ";\n            " (span (|@| (class "keyword") (id "F:593756")) "return") " decode_mode_spec_buf;\n          }\n        " (span (|@| (class "keyword") (id "F:593791")) "else") "\n          " (span (|@| (class "keyword") (id "F:593799")) "return") " lots_of_dashes;\n      }\n\n    " (span (|@| (class "keyword") (id "F:593835")) "case") " " (span (|@| (class "string") (id "F:593840")) "'b'") ":\n      obj = b->name;\n      " (span (|@| (class "keyword") (id "F:593872")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:593884")) "case") " " (span (|@| (class "string") (id "F:593889")) "'c'") ":\n      " (span (|@| (class "comment-delimiter") (id "F:593900")) "/* ") (span (|@| (class "comment") (id "F:593903")) "%c and %l are ignored in `frame-title-format'.\n         (In redisplay_internal, the frame title is drawn _before_ the\n         windows are updated, so the stuff which depends on actual\n         window contents (such as %l) may fail to render properly, or\n         even crash emacs.)  ") (span (|@| (class "comment-delimiter") (id "F:594187")) "*/") "\n      " (span (|@| (class "keyword") (id "F:594196")) "if") " (mode_line_target == MODE_LINE_TITLE)\n        " (span (|@| (class "keyword") (id "F:594238")) "return") " " (span (|@| (class "string") (id "F:594245")) "\"\"") ";\n      " (span (|@| (class "keyword") (id "F:594255")) "else") "\n        {\n          " (span (|@| (class "type") (id "F:594266")) "int") " " (span (|@| (class "variable-name") (id "F:594270")) "col") " = (" (span (|@| (class "type") (id "F:594277")) "int") ") current_column (); " (span (|@| (class "comment-delimiter") (id "F:594301")) "/* ") (span (|@| (class "comment") (id "F:594304")) "iftc ") (span (|@| (class "comment-delimiter") (id "F:594309")) "*/") "\n          w->column_number_displayed = make_number (col);\n          pint2str (decode_mode_spec_buf, field_width, col);\n          " (span (|@| (class "keyword") (id "F:594420")) "return") " decode_mode_spec_buf;\n        }\n\n    " (span (|@| (class "keyword") (id "F:594457")) "case") " " (span (|@| (class "string") (id "F:594462")) "'e'") ":\n" (span (|@| (class "preprocessor") (id "F:594467")) "#if") (span (|@| (class "negation-char") (id "F:594470")) (span (|@| (class "preprocessor") (id "F:594470")) "n")) (span (|@| (class "preprocessor") (id "F:594471")) "def") " SYSTEM_MALLOC\n      {\n        " (span (|@| (class "keyword") (id "F:594498")) "if") " (NILP (Vmemory_full))\n          " (span (|@| (class "keyword") (id "F:594526")) "return") " " (span (|@| (class "string") (id "F:594533")) "\"\"") ";\n        " (span (|@| (class "keyword") (id "F:594538")) "else") "\n          " (span (|@| (class "keyword") (id "F:594546")) "return") " " (span (|@| (class "string") (id "F:594553")) "\"!MEM FULL! \"") ";\n      }\n" (span (|@| (class "preprocessor") (id "F:594576")) "#else") "\n      " (span (|@| (class "keyword") (id "F:594588")) "return") " " (span (|@| (class "string") (id "F:594595")) "\"\"") ";\n" (span (|@| (class "preprocessor") (id "F:594599")) "#endif") "\n\n    " (span (|@| (class "keyword") (id "F:594611")) "case") " " (span (|@| (class "string") (id "F:594616")) "'F'") ":\n      " (span (|@| (class "comment-delimiter") (id "F:594627")) "/* ") (span (|@| (class "comment") (id "F:594630")) "%F displays the frame name.  ") (span (|@| (class "comment-delimiter") (id "F:594659")) "*/") "\n      " (span (|@| (class "keyword") (id "F:594668")) "if") " (" (span (|@| (class "negation-char") (id "F:594672")) "!") "NILP (f->title))\n        " (span (|@| (class "keyword") (id "F:594691")) "return") " (" (span (|@| (class "type") (id "F:594699")) "char") " *) SDATA (f->title);\n      " (span (|@| (class "keyword") (id "F:594731")) "if") " (f->explicit_name || " (span (|@| (class "negation-char") (id "F:594755")) "!") " FRAME_WINDOW_P (f))\n        " (span (|@| (class "keyword") (id "F:594778")) "return") " (" (span (|@| (class "type") (id "F:594786")) "char") " *) SDATA (f->name);\n      " (span (|@| (class "keyword") (id "F:594817")) "return") " " (span (|@| (class "string") (id "F:594824")) "\"Emacs\"") ";\n\n    " (span (|@| (class "keyword") (id "F:594838")) "case") " " (span (|@| (class "string") (id "F:594843")) "'f'") ":\n      obj = b->filename;\n      " (span (|@| (class "keyword") (id "F:594879")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:594891")) "case") " " (span (|@| (class "string") (id "F:594896")) "'i'") ":\n      {\n        " (span (|@| (class "type") (id "F:594910")) "int") " " (span (|@| (class "variable-name") (id "F:594914")) "size") " = ZV - BEGV;\n        pint2str (decode_mode_spec_buf, field_width, size);\n        " (span (|@| (class "keyword") (id "F:594986")) "return") " decode_mode_spec_buf;\n      }\n\n    " (span (|@| (class "keyword") (id "F:595028")) "case") " " (span (|@| (class "string") (id "F:595033")) "'I'") ":\n      {\n        " (span (|@| (class "type") (id "F:595047")) "int") " " (span (|@| (class "variable-name") (id "F:595051")) "size") " = ZV - BEGV;\n        pint2hrstr (decode_mode_spec_buf, field_width, size);\n        " (span (|@| (class "keyword") (id "F:595125")) "return") " decode_mode_spec_buf;\n      }\n\n    " (span (|@| (class "keyword") (id "F:595167")) "case") " " (span (|@| (class "string") (id "F:595172")) "'l'") ":\n      {\n        " (span (|@| (class "type") (id "F:595186")) "int") " " (span (|@| (class "variable-name") (id "F:595190")) "startpos") ", " (span (|@| (class "variable-name") (id "F:595200")) "startpos_byte") ", " (span (|@| (class "variable-name") (id "F:595215")) "line") ", " (span (|@| (class "variable-name") (id "F:595221")) "linepos") ", " (span (|@| (class "variable-name") (id "F:595230")) "linepos_byte") ";\n        " (span (|@| (class "type") (id "F:595245")) "int") " " (span (|@| (class "variable-name") (id "F:595249")) "topline") ", " (span (|@| (class "variable-name") (id "F:595258")) "nlines") ", " (span (|@| (class "variable-name") (id "F:595266")) "junk") ", " (span (|@| (class "variable-name") (id "F:595272")) "height") ";\n\n        " (span (|@| (class "comment-delimiter") (id "F:595282")) "/* ") (span (|@| (class "comment") (id "F:595285")) "%c and %l are ignored in `frame-title-format'.  ") (span (|@| (class "comment-delimiter") (id "F:595333")) "*/") "\n        " (span (|@| (class "keyword") (id "F:595337")) "if") " (mode_line_target == MODE_LINE_TITLE)\n          " (span (|@| (class "keyword") (id "F:595381")) "return") " " (span (|@| (class "string") (id "F:595388")) "\"\"") ";\n\n        startpos = XMARKER (w->start)->charpos;\n        startpos_byte = marker_byte_position (w->start);\n        height = WINDOW_TOTAL_LINES (w);\n\n        " (span (|@| (class "comment-delimiter") (id "F:595520")) "/* ") (span (|@| (class "comment") (id "F:595523")) "If we decided that this buffer isn't suitable for line numbers,\n           don't forget that too fast.  ") (span (|@| (class "comment-delimiter") (id "F:595620")) "*/") "\n        " (span (|@| (class "keyword") (id "F:595624")) "if") " (EQ (w->base_line_pos, w->buffer))\n          " (span (|@| (class "keyword") (id "F:595665")) "goto") " " (span (|@| (class "constant") (id "F:595670")) "no_value") ";\n        " (span (|@| (class "comment-delimiter") (id "F:595681")) "/* ") (span (|@| (class "comment") (id "F:595684")) "But do forget it, if the window shows a different buffer now.  ") (span (|@| (class "comment-delimiter") (id "F:595747")) "*/") "\n        " (span (|@| (class "keyword") (id "F:595751")) "else") " " (span (|@| (class "keyword") (id "F:595756")) "if") " (BUFFERP (w->base_line_pos))\n          w->base_line_pos = Qnil;\n\n        " (span (|@| (class "comment-delimiter") (id "F:595818")) "/* ") (span (|@| (class "comment") (id "F:595821")) "If the buffer is very big, don't waste time.  ") (span (|@| (class "comment-delimiter") (id "F:595867")) "*/") "\n        " (span (|@| (class "keyword") (id "F:595871")) "if") " (INTEGERP (Vline_number_display_limit)\n            && BUF_ZV (b) - BUF_BEGV (b) > XINT (Vline_number_display_limit))\n          {\n            w->base_line_pos = Qnil;\n            w->base_line_number = Qnil;\n            " (span (|@| (class "keyword") (id "F:596057")) "goto") " " (span (|@| (class "constant") (id "F:596062")) "no_value") ";\n          }\n\n        " (span (|@| (class "keyword") (id "F:596079")) "if") " (INTEGERP (w->base_line_number)\n            && INTEGERP (w->base_line_pos)\n            && XFASTINT (w->base_line_pos) <= startpos)\n          {\n            line = XFASTINT (w->base_line_number);\n            linepos = XFASTINT (w->base_line_pos);\n            linepos_byte = buf_charpos_to_bytepos (b, linepos);\n          }\n        " (span (|@| (class "keyword") (id "F:596355")) "else") "\n          {\n            line = 1;\n            linepos = BUF_BEGV (b);\n            linepos_byte = BUF_BEGV_BYTE (b);\n          }\n\n        " (span (|@| (class "comment-delimiter") (id "F:596455")) "/* ") (span (|@| (class "comment") (id "F:596458")) "Count lines from base line to window start position.  ") (span (|@| (class "comment-delimiter") (id "F:596512")) "*/") "\n        nlines = display_count_lines (linepos, linepos_byte,\n                                      startpos_byte,\n                                      startpos, &junk);\n\n        topline = nlines + line;\n\n        " (span (|@| (class "comment-delimiter") (id "F:596651")) "/* ") (span (|@| (class "comment") (id "F:596654")) "Determine a new base line, if the old one is too close\n           or too far away, or if we did not have one.\n           \"Too close\" means it's plausible a scroll-down would\n           go back past it.  ") (span (|@| (class "comment-delimiter") (id "F:596836")) "*/") "\n        " (span (|@| (class "keyword") (id "F:596840")) "if") " (startpos == BUF_BEGV (b))\n          {\n            w->base_line_number = make_number (topline);\n            w->base_line_pos = make_number (BUF_BEGV (b));\n          }\n        " (span (|@| (class "keyword") (id "F:596983")) "else") " " (span (|@| (class "keyword") (id "F:596988")) "if") " (nlines < height + 25 || nlines > height * 3 + 50\n                 || linepos == BUF_BEGV (b))\n          {\n            " (span (|@| (class "type") (id "F:597082")) "int") " " (span (|@| (class "variable-name") (id "F:597086")) "limit") " = BUF_BEGV (b);\n            " (span (|@| (class "type") (id "F:597113")) "int") " " (span (|@| (class "variable-name") (id "F:597117")) "limit_byte") " = BUF_BEGV_BYTE (b);\n            " (span (|@| (class "type") (id "F:597154")) "int") " " (span (|@| (class "variable-name") (id "F:597158")) "position") ";\n            " (span (|@| (class "type") (id "F:597173")) "int") " " (span (|@| (class "variable-name") (id "F:597177")) "distance") " = (height * 2 + 30) * line_number_display_limit_width;\n\n            " (span (|@| (class "keyword") (id "F:597247")) "if") " (startpos - distance > limit)\n              {\n                limit = startpos - distance;\n                limit_byte = CHAR_TO_BYTE (limit);\n              }\n\n            nlines = display_count_lines (startpos, startpos_byte,\n                                          limit_byte,\n                                          - (height * 2 + 30),\n                                          &position);\n            " (span (|@| (class "comment-delimiter") (id "F:597498")) "/* ") (span (|@| (class "comment") (id "F:597501")) "If we couldn't find the lines we wanted within\n               line_number_display_limit_width chars per line,\n               give up on line numbers for this window.  ") (span (|@| (class "comment-delimiter") (id "F:597654")) "*/") "\n            " (span (|@| (class "keyword") (id "F:597662")) "if") " (position == limit_byte && limit == startpos - distance)\n              {\n                w->base_line_pos = w->buffer;\n                w->base_line_number = Qnil;\n                " (span (|@| (class "keyword") (id "F:597795")) "goto") " " (span (|@| (class "constant") (id "F:597800")) "no_value") ";\n              }\n\n            w->base_line_number = make_number (topline - nlines);\n            w->base_line_pos = make_number (BYTE_TO_CHAR (position));\n          }\n\n        " (span (|@| (class "comment-delimiter") (id "F:597949")) "/* ") (span (|@| (class "comment") (id "F:597952")) "Now count lines from the start pos to point.  ") (span (|@| (class "comment-delimiter") (id "F:597998")) "*/") "\n        nlines = display_count_lines (startpos, startpos_byte,\n                                      PT_BYTE, PT, &junk);\n\n        " (span (|@| (class "comment-delimiter") (id "F:598090")) "/* ") (span (|@| (class "comment") (id "F:598093")) "Record that we did display the line number.  ") (span (|@| (class "comment-delimiter") (id "F:598138")) "*/") "\n        line_number_displayed = 1;\n\n        " (span (|@| (class "comment-delimiter") (id "F:598171")) "/* ") (span (|@| (class "comment") (id "F:598174")) "Make the string to show.  ") (span (|@| (class "comment-delimiter") (id "F:598200")) "*/") "\n        pint2str (decode_mode_spec_buf, field_width, topline + nlines);\n        " (span (|@| (class "keyword") (id "F:598269")) "return") " decode_mode_spec_buf;\n    " (span (|@| (class "constant") (id "F:598302")) "no_value") ":\n        {\n          " (span (|@| (class "type") (id "F:598325")) "char") "* " (span (|@| (class "variable-name") (id "F:598331")) "p") " = decode_mode_spec_buf;\n          " (span (|@| (class "type") (id "F:598360")) "int") " " (span (|@| (class "variable-name") (id "F:598364")) "pad") " = field_width - 2;\n          " (span (|@| (class "keyword") (id "F:598390")) "while") " (pad-- > 0)\n            *p++ = " (span (|@| (class "string") (id "F:598420")) "' '") ";\n          *p++ = " (span (|@| (class "string") (id "F:598435")) "'?'") ";\n          *p++ = " (span (|@| (class "string") (id "F:598450")) "'?'") ";\n          *p = " (span (|@| (class "string") (id "F:598463")) "'\\0'") ";\n          " (span (|@| (class "keyword") (id "F:598472")) "return") " decode_mode_spec_buf;\n        }\n      }\n      " (span (|@| (class "keyword") (id "F:598518")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:598530")) "case") " " (span (|@| (class "string") (id "F:598535")) "'m'") ":\n      obj = b->mode_name;\n      " (span (|@| (class "keyword") (id "F:598572")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:598584")) "case") " " (span (|@| (class "string") (id "F:598589")) "'n'") ":\n      " (span (|@| (class "keyword") (id "F:598600")) "if") " (BUF_BEGV (b) > BUF_BEG (b) || BUF_ZV (b) < BUF_Z (b))\n        " (span (|@| (class "keyword") (id "F:598659")) "return") " " (span (|@| (class "string") (id "F:598666")) "\" Narrow\"") ";\n      " (span (|@| (class "keyword") (id "F:598683")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:598695")) "case") " " (span (|@| (class "string") (id "F:598700")) "'p'") ":\n      {\n        " (span (|@| (class "type") (id "F:598714")) "int") " " (span (|@| (class "variable-name") (id "F:598718")) "pos") " = marker_position (w->start);\n        " (span (|@| (class "type") (id "F:598753")) "int") " " (span (|@| (class "variable-name") (id "F:598757")) "total") " = BUF_ZV (b) - BUF_BEGV (b);\n\n        " (span (|@| (class "keyword") (id "F:598794")) "if") " (XFASTINT (w->window_end_pos) <= BUF_Z (b) - BUF_ZV (b))\n          {\n            " (span (|@| (class "keyword") (id "F:598864")) "if") " (pos <= BUF_BEGV (b))\n              " (span (|@| (class "keyword") (id "F:598896")) "return") " " (span (|@| (class "string") (id "F:598903")) "\"All\"") ";\n            " (span (|@| (class "keyword") (id "F:598915")) "else") "\n              " (span (|@| (class "keyword") (id "F:598927")) "return") " " (span (|@| (class "string") (id "F:598934")) "\"Bottom\"") ";\n          }\n        " (span (|@| (class "keyword") (id "F:598950")) "else") " " (span (|@| (class "keyword") (id "F:598955")) "if") " (pos <= BUF_BEGV (b))\n          " (span (|@| (class "keyword") (id "F:598983")) "return") " " (span (|@| (class "string") (id "F:598990")) "\"Top\"") ";\n        " (span (|@| (class "keyword") (id "F:598998")) "else") "\n          {\n            " (span (|@| (class "keyword") (id "F:599013")) "if") " (total > 1000000)\n              " (span (|@| (class "comment-delimiter") (id "F:599041")) "/* ") (span (|@| (class "comment") (id "F:599044")) "Do it differently for a large value, to avoid overflow.  ") (span (|@| (class "comment-delimiter") (id "F:599101")) "*/") "\n              total = ((pos - BUF_BEGV (b)) + (total / 100) - 1) / (total / 100);\n            " (span (|@| (class "keyword") (id "F:599184")) "else") "\n              total = ((pos - BUF_BEGV (b)) * 100 + total - 1) / total;\n            " (span (|@| (class "comment-delimiter") (id "F:599259")) "/* ") (span (|@| (class "comment") (id "F:599262")) "We can't normally display a 3-digit number,\n               so get us a 2-digit number that is close.  ") (span (|@| (class "comment-delimiter") (id "F:599357")) "*/") "\n            " (span (|@| (class "keyword") (id "F:599365")) "if") " (total == 100)\n              total = 99;\n            sprintf (decode_mode_spec_buf, " (span (|@| (class "string") (id "F:599438")) "\"%2d%%\"") ", total);\n            " (span (|@| (class "keyword") (id "F:599460")) "return") " decode_mode_spec_buf;\n          }\n      }\n\n      " (span (|@| (class "comment-delimiter") (id "F:599509")) "/* ") (span (|@| (class "comment") (id "F:599512")) "Display percentage of size above the bottom of the screen.  ") (span (|@| (class "comment-delimiter") (id "F:599572")) "*/") "\n    " (span (|@| (class "keyword") (id "F:599579")) "case") " " (span (|@| (class "string") (id "F:599584")) "'P'") ":\n      {\n        " (span (|@| (class "type") (id "F:599598")) "int") " " (span (|@| (class "variable-name") (id "F:599602")) "toppos") " = marker_position (w->start);\n        " (span (|@| (class "type") (id "F:599640")) "int") " " (span (|@| (class "variable-name") (id "F:599644")) "botpos") " = BUF_Z (b) - XFASTINT (w->window_end_pos);\n        " (span (|@| (class "type") (id "F:599696")) "int") " " (span (|@| (class "variable-name") (id "F:599700")) "total") " = BUF_ZV (b) - BUF_BEGV (b);\n\n        " (span (|@| (class "keyword") (id "F:599737")) "if") " (botpos >= BUF_ZV (b))\n          {\n            " (span (|@| (class "keyword") (id "F:599773")) "if") " (toppos <= BUF_BEGV (b))\n              " (span (|@| (class "keyword") (id "F:599808")) "return") " " (span (|@| (class "string") (id "F:599815")) "\"All\"") ";\n            " (span (|@| (class "keyword") (id "F:599827")) "else") "\n              " (span (|@| (class "keyword") (id "F:599839")) "return") " " (span (|@| (class "string") (id "F:599846")) "\"Bottom\"") ";\n          }\n        " (span (|@| (class "keyword") (id "F:599862")) "else") "\n          {\n            " (span (|@| (class "keyword") (id "F:599877")) "if") " (total > 1000000)\n              " (span (|@| (class "comment-delimiter") (id "F:599905")) "/* ") (span (|@| (class "comment") (id "F:599908")) "Do it differently for a large value, to avoid overflow.  ") (span (|@| (class "comment-delimiter") (id "F:599965")) "*/") "\n              total = ((botpos - BUF_BEGV (b)) + (total / 100) - 1) / (total / 100);\n            " (span (|@| (class "keyword") (id "F:600051")) "else") "\n              total = ((botpos - BUF_BEGV (b)) * 100 + total - 1) / total;\n            " (span (|@| (class "comment-delimiter") (id "F:600129")) "/* ") (span (|@| (class "comment") (id "F:600132")) "We can't normally display a 3-digit number,\n               so get us a 2-digit number that is close.  ") (span (|@| (class "comment-delimiter") (id "F:600227")) "*/") "\n            " (span (|@| (class "keyword") (id "F:600235")) "if") " (total == 100)\n              total = 99;\n            " (span (|@| (class "keyword") (id "F:600277")) "if") " (toppos <= BUF_BEGV (b))\n              sprintf (decode_mode_spec_buf, " (span (|@| (class "string") (id "F:600343")) "\"Top%2d%%\"") ", total);\n            " (span (|@| (class "keyword") (id "F:600368")) "else") "\n              sprintf (decode_mode_spec_buf, " (span (|@| (class "string") (id "F:600411")) "\"%2d%%\"") ", total);\n            " (span (|@| (class "keyword") (id "F:600433")) "return") " decode_mode_spec_buf;\n          }\n      }\n\n    " (span (|@| (class "keyword") (id "F:600480")) "case") " " (span (|@| (class "string") (id "F:600485")) "'s'") ":\n      " (span (|@| (class "comment-delimiter") (id "F:600496")) "/* ") (span (|@| (class "comment") (id "F:600499")) "status of process ") (span (|@| (class "comment-delimiter") (id "F:600517")) "*/") "\n      obj = Fget_buffer_process (Fcurrent_buffer ());\n      " (span (|@| (class "keyword") (id "F:600580")) "if") " (NILP (obj))\n        " (span (|@| (class "keyword") (id "F:600597")) "return") " " (span (|@| (class "string") (id "F:600604")) "\"no process\"") ";\n" (span (|@| (class "preprocessor") (id "F:600618")) "#ifdef") " subprocesses\n      obj = Fsymbol_name (Fprocess_status (obj));\n" (span (|@| (class "preprocessor") (id "F:600688")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:600701")) "break") ";\n\n    " (span (|@| (class "keyword") (id "F:600713")) "case") " " (span (|@| (class "string") (id "F:600718")) "'@'") ":\n      {\n        " (span (|@| (class "type") (id "F:600732")) "int") " " (span (|@| (class "variable-name") (id "F:600736")) "count") " = inhibit_garbage_collection ();\n        " (span (|@| (class "type") (id "F:600776")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:600788")) "val") " = call1 (intern (" (span (|@| (class "string") (id "F:600809")) "\"file-remote-p\"") "),\n                                 current_buffer->directory);\n        unbind_to (count, Qnil);\n\n        " (span (|@| (class "keyword") (id "F:600888")) "if") " (NILP (val))\n          " (span (|@| (class "keyword") (id "F:600907")) "return") " " (span (|@| (class "string") (id "F:600914")) "\"-\"") ";\n        " (span (|@| (class "keyword") (id "F:600920")) "else") "\n          " (span (|@| (class "keyword") (id "F:600928")) "return") " " (span (|@| (class "string") (id "F:600935")) "\"@\"") ";\n      }\n\n    " (span (|@| (class "keyword") (id "F:600953")) "case") " " (span (|@| (class "string") (id "F:600958")) "'t'") ":                   " (span (|@| (class "comment-delimiter") (id "F:600965")) "/* ") (span (|@| (class "comment") (id "F:600968")) "indicate TEXT or BINARY ") (span (|@| (class "comment-delimiter") (id "F:600992")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:600995")) "#ifdef") " MODE_LINE_BINARY_TEXT\n      " (span (|@| (class "keyword") (id "F:601030")) "return") " MODE_LINE_BINARY_TEXT (b);\n" (span (|@| (class "preprocessor") (id "F:601064")) "#else") "\n      " (span (|@| (class "keyword") (id "F:601076")) "return") " " (span (|@| (class "string") (id "F:601083")) "\"T\"") ";\n" (span (|@| (class "preprocessor") (id "F:601088")) "#endif") "\n\n    " (span (|@| (class "keyword") (id "F:601100")) "case") " " (span (|@| (class "string") (id "F:601105")) "'z'") ":\n      " (span (|@| (class "comment-delimiter") (id "F:601116")) "/* ") (span (|@| (class "comment") (id "F:601119")) "coding-system (not including end-of-line format) ") (span (|@| (class "comment-delimiter") (id "F:601168")) "*/") "\n    " (span (|@| (class "keyword") (id "F:601175")) "case") " " (span (|@| (class "string") (id "F:601180")) "'Z'") ":\n      " (span (|@| (class "comment-delimiter") (id "F:601191")) "/* ") (span (|@| (class "comment") (id "F:601194")) "coding-system (including end-of-line type) ") (span (|@| (class "comment-delimiter") (id "F:601237")) "*/") "\n      {\n        " (span (|@| (class "type") (id "F:601249")) "int") " " (span (|@| (class "variable-name") (id "F:601253")) "eol_flag") " = (c == " (span (|@| (class "string") (id "F:601270")) "'Z'") ");\n        " (span (|@| (class "type") (id "F:601277")) "char") " *" (span (|@| (class "variable-name") (id "F:601283")) "p") " = decode_mode_spec_buf;\n\n        " (span (|@| (class "keyword") (id "F:601311")) "if") " (" (span (|@| (class "negation-char") (id "F:601315")) "!") " FRAME_WINDOW_P (f))\n          {\n            " (span (|@| (class "comment-delimiter") (id "F:601347")) "/* ") (span (|@| (class "comment") (id "F:601350")) "No need to mention EOL here--the terminal never needs\n               to do EOL conversion.  ") (span (|@| (class "comment-delimiter") (id "F:601435")) "*/") "\n            p = decode_mode_spec_coding (CODING_ID_NAME\n                                         (FRAME_KEYBOARD_CODING (f)->id),\n                                         p, 0);\n            p = decode_mode_spec_coding (CODING_ID_NAME\n                                         (FRAME_TERMINAL_CODING (f)->id),\n                                         p, 0);\n          }\n        p = decode_mode_spec_coding (b->buffer_file_coding_system,\n                                     p, eol_flag);\n\n" (span (|@| (class "preprocessor") (id "F:601729")) "#if") " 0 " (span (|@| (class "comment-delimiter") (id "F:601735")) "/* ") (span (|@| (class "comment") (id "F:601738")) "This proves to be annoying; I think we can do without.  -- rms.  ") (span (|@| (class "comment-delimiter") (id "F:601803")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:601806")) "#ifdef") " subprocesses\n        obj = Fget_buffer_process (Fcurrent_buffer ());\n        " (span (|@| (class "keyword") (id "F:601876")) "if") " (PROCESSP (obj))\n          {\n            p = decode_mode_spec_coding (XPROCESS (obj)->decode_coding_system,\n                                         p, eol_flag);\n            p = decode_mode_spec_coding (XPROCESS (obj)->encode_coding_system,\n                                         p, eol_flag);\n          }\n" (span (|@| (class "preprocessor") (id "F:602090")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:602097")) "/* ") (span (|@| (class "comment") (id "F:602100")) "subprocesses ") (span (|@| (class "comment-delimiter") (id "F:602113")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:602116")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:602123")) "/* ") (span (|@| (class "comment") (id "F:602126")) "0 ") (span (|@| (class "comment-delimiter") (id "F:602128")) "*/") "\n        *p = 0;\n        " (span (|@| (class "keyword") (id "F:602141")) "return") " decode_mode_spec_buf;\n      }\n    }\n\n  " (span (|@| (class "keyword") (id "F:602187")) "if") " (STRINGP (obj))\n    {\n      *string = obj;\n      " (span (|@| (class "keyword") (id "F:602239")) "return") " (" (span (|@| (class "type") (id "F:602247")) "char") " *) SDATA (obj);\n    }\n  " (span (|@| (class "keyword") (id "F:602276")) "else") "\n    " (span (|@| (class "keyword") (id "F:602285")) "return") " " (span (|@| (class "string") (id "F:602292")) "\"\"") ";\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:602300")) "/* ") (span (|@| (class "comment") (id "F:602303")) "Count up to COUNT lines starting from START / START_BYTE.\n   But don't go beyond LIMIT_BYTE.\n   Return the number of lines thus found (always nonnegative).\n\n   Set *BYTE_POS_PTR to 1 if we found COUNT lines, 0 if we hit LIMIT.  ") (span (|@| (class "comment-delimiter") (id "F:602531")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:602535")) "static") " " (span (|@| (class "type") (id "F:602542")) "int") "\n" (span (|@| (class "function-name") (id "F:602546")) "display_count_lines") " (start, start_byte, limit_byte, count, byte_pos_ptr)\n     " (span (|@| (class "type") (id "F:602624")) "int") " " (span (|@| (class "variable-name") (id "F:602628")) "start") ", " (span (|@| (class "variable-name") (id "F:602635")) "start_byte") ", " (span (|@| (class "variable-name") (id "F:602647")) "limit_byte") ", " (span (|@| (class "variable-name") (id "F:602659")) "count") ";\n     " (span (|@| (class "type") (id "F:602671")) "int") " *" (span (|@| (class "variable-name") (id "F:602676")) "byte_pos_ptr") ";\n{\n  " (span (|@| (class "keyword") (id "F:602694")) "register") " " (span (|@| (class "type") (id "F:602703")) "unsigned") " " (span (|@| (class "type") (id "F:602712")) "char") " *" (span (|@| (class "variable-name") (id "F:602718")) "cursor") ";\n  " (span (|@| (class "type") (id "F:602728")) "unsigned") " " (span (|@| (class "type") (id "F:602737")) "char") " *" (span (|@| (class "variable-name") (id "F:602743")) "base") ";\n\n  " (span (|@| (class "keyword") (id "F:602752")) "register") " " (span (|@| (class "type") (id "F:602761")) "int") " " (span (|@| (class "variable-name") (id "F:602765")) "ceiling") ";\n  " (span (|@| (class "keyword") (id "F:602776")) "register") " " (span (|@| (class "type") (id "F:602785")) "unsigned") " " (span (|@| (class "type") (id "F:602794")) "char") " *" (span (|@| (class "variable-name") (id "F:602800")) "ceiling_addr") ";\n  " (span (|@| (class "type") (id "F:602816")) "int") " " (span (|@| (class "variable-name") (id "F:602820")) "orig_count") " = count;\n\n  " (span (|@| (class "comment-delimiter") (id "F:602843")) "/* ") (span (|@| (class "comment") (id "F:602846")) "If we are not in selective display mode,\n     check only for newlines.  ") (span (|@| (class "comment-delimiter") (id "F:602918")) "*/") "\n  " (span (|@| (class "type") (id "F:602923")) "int") " " (span (|@| (class "variable-name") (id "F:602927")) "selective_display") " = (" (span (|@| (class "negation-char") (id "F:602948")) "!") "NILP (current_buffer->selective_display)\n                           && " (span (|@| (class "negation-char") (id "F:602999")) "!") "INTEGERP (current_buffer->selective_display));\n\n  " (span (|@| (class "keyword") (id "F:603050")) "if") " (count > 0)\n    {\n      " (span (|@| (class "keyword") (id "F:603077")) "while") " (start_byte < limit_byte)\n        {\n          ceiling =  BUFFER_CEILING_OF (start_byte);\n          ceiling = min (limit_byte - 1, ceiling);\n          ceiling_addr = BYTE_POS_ADDR (ceiling) + 1;\n          base = (cursor = BYTE_POS_ADDR (start_byte));\n          " (span (|@| (class "keyword") (id "F:603301")) "while") " (1)\n            {\n              " (span (|@| (class "keyword") (id "F:603325")) "if") " (selective_display)\n                " (span (|@| (class "keyword") (id "F:603350")) "while") " (*cursor != " (span (|@| (class "string") (id "F:603368")) "'\\n'") " && *cursor != 015 && ++cursor != ceiling_addr)\n                  ;\n              " (span (|@| (class "keyword") (id "F:603433")) "else") "\n                " (span (|@| (class "keyword") (id "F:603440")) "while") " (*cursor != " (span (|@| (class "string") (id "F:603458")) "'\\n'") " && ++cursor != ceiling_addr)\n                  ;\n\n              " (span (|@| (class "keyword") (id "F:603506")) "if") " (cursor != ceiling_addr)\n                {\n                  " (span (|@| (class "keyword") (id "F:603542")) "if") " (--count == 0)\n                    {\n                      start_byte += cursor - base + 1;\n                      *byte_pos_ptr = start_byte;\n                      " (span (|@| (class "keyword") (id "F:603653")) "return") " orig_count;\n                    }\n                  " (span (|@| (class "keyword") (id "F:603684")) "else") "\n                    " (span (|@| (class "keyword") (id "F:603695")) "if") " (++cursor == ceiling_addr)\n                      " (span (|@| (class "keyword") (id "F:603733")) "break") ";\n                }\n              " (span (|@| (class "keyword") (id "F:603751")) "else") "\n                " (span (|@| (class "keyword") (id "F:603758")) "break") ";\n            }\n          start_byte += cursor - base;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:603815")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:603832")) "while") " (start_byte > limit_byte)\n        {\n          ceiling = BUFFER_FLOOR_OF (start_byte - 1);\n          ceiling = max (limit_byte, ceiling);\n          ceiling_addr = BYTE_POS_ADDR (ceiling) - 1;\n          base = (cursor = BYTE_POS_ADDR (start_byte - 1) + 1);\n          " (span (|@| (class "keyword") (id "F:604061")) "while") " (1)\n            {\n              " (span (|@| (class "keyword") (id "F:604085")) "if") " (selective_display)\n                " (span (|@| (class "keyword") (id "F:604110")) "while") " (--cursor != ceiling_addr\n                       && *cursor != " (span (|@| (class "string") (id "F:604165")) "'\\n'") " && *cursor != 015)\n                  ;\n              " (span (|@| (class "keyword") (id "F:604202")) "else") "\n                " (span (|@| (class "keyword") (id "F:604209")) "while") " (--cursor != ceiling_addr && *cursor != " (span (|@| (class "string") (id "F:604255")) "'\\n'") ")\n                  ;\n\n              " (span (|@| (class "keyword") (id "F:604275")) "if") " (cursor != ceiling_addr)\n                {\n                  " (span (|@| (class "keyword") (id "F:604311")) "if") " (++count == 0)\n                    {\n                      start_byte += cursor - base + 1;\n                      *byte_pos_ptr = start_byte;\n                      " (span (|@| (class "comment-delimiter") (id "F:604422")) "/* ") (span (|@| (class "comment") (id "F:604425")) "When scanning backwards, we should\n                         not count the newline posterior to which we stop.  ") (span (|@| (class "comment-delimiter") (id "F:604515")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:604526")) "return") " - orig_count - 1;\n                    }\n                }\n              " (span (|@| (class "keyword") (id "F:604570")) "else") "\n                " (span (|@| (class "keyword") (id "F:604577")) "break") ";\n            }\n          " (span (|@| (class "comment-delimiter") (id "F:604594")) "/* ") (span (|@| (class "comment") (id "F:604597")) "Here we add 1 to compensate for the last decrement\n             of CURSOR, which took it past the valid range.  ") (span (|@| (class "comment-delimiter") (id "F:604702")) "*/") "\n          start_byte += cursor - base + 1;\n        }\n    }\n\n  *byte_pos_ptr = limit_byte;\n\n  " (span (|@| (class "keyword") (id "F:604784")) "if") " (count < 0)\n    " (span (|@| (class "keyword") (id "F:604803")) "return") " - orig_count + count;\n  " (span (|@| (class "keyword") (id "F:604834")) "return") " orig_count - count;\n\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:604868")) "/***********************************************************************") (span (|@| (class "comment") (id "F:604940")) "\n                         Displaying strings\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:605035")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:605039")) "/* ") (span (|@| (class "comment") (id "F:605042")) "Display a NUL-terminated string, starting with index START.\n\n   If STRING is non-null, display that C string.  Otherwise, the Lisp\n   string LISP_STRING is displayed.  There's a case that STRING is\n   non-null and LISP_STRING is not nil.  It means STRING is a string\n   data of LISP_STRING.  In that case, we display LISP_STRING while\n   ignoring its text properties.\n\n   If FACE_STRING is not nil, FACE_STRING_POS is a position in\n   FACE_STRING.  Display STRING or LISP_STRING with the face at\n   FACE_STRING_POS in FACE_STRING:\n\n   Display the string in the environment given by IT, but use the\n   standard display table, temporarily.\n\n   FIELD_WIDTH is the minimum number of output glyphs to produce.\n   If STRING has fewer characters than FIELD_WIDTH, pad to the right\n   with spaces.  If STRING has more characters, more than FIELD_WIDTH\n   glyphs will be produced.  FIELD_WIDTH <= 0 means don't pad.\n\n   PRECISION is the maximum number of characters to output from\n   STRING.  PRECISION < 0  means don't truncate the string.\n\n   This is roughly equivalent to printf format specifiers:\n\n   FIELD_WIDTH  PRECISION       PRINTF\n   ----------------------------------------\n   -1           -1              %s\n   -1           10              %.10s\n   10           -1              %10s\n   20           10              %20.10s\n\n   MULTIBYTE zero means do not display multibyte chars, > 0 means do\n   display them, and < 0 means obey the current buffer's value of\n   enable_multibyte_characters.\n\n   Value is the number of columns displayed.  ") (span (|@| (class "comment-delimiter") (id "F:606492")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:606496")) "static") " " (span (|@| (class "type") (id "F:606503")) "int") "\n" (span (|@| (class "function-name") (id "F:606507")) "display_string") " (string, lisp_string, face_string, face_string_pos,\n                start, " (span (|@| (class "type") (id "F:606583")) "it") ", field_width, precision, max_x, multibyte)\n     " (span (|@| (class "type") (id "F:606634")) "unsigned") " " (span (|@| (class "type") (id "F:606643")) "char") " *" (span (|@| (class "variable-name") (id "F:606649")) "string") ";\n     " (span (|@| (class "type") (id "F:606662")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:606674")) "lisp_string") ";\n     " (span (|@| (class "type") (id "F:606692")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:606704")) "face_string") ";\n     " (span (|@| (class "type") (id "F:606722")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:606732")) "face_string_pos") ";\n     " (span (|@| (class "type") (id "F:606754")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:606764")) "start") ";\n     " (span (|@| (class "keyword") (id "F:606776")) "struct") " " (span (|@| (class "type") (id "F:606783")) "it") " *" (span (|@| (class "variable-name") (id "F:606787")) "it") ";\n     " (span (|@| (class "type") (id "F:606796")) "int") " " (span (|@| (class "variable-name") (id "F:606800")) "field_width") ", " (span (|@| (class "variable-name") (id "F:606813")) "precision") ", " (span (|@| (class "variable-name") (id "F:606824")) "max_x") ";\n     " (span (|@| (class "type") (id "F:606836")) "int") " " (span (|@| (class "variable-name") (id "F:606840")) "multibyte") ";\n{\n  " (span (|@| (class "type") (id "F:606855")) "int") " " (span (|@| (class "variable-name") (id "F:606859")) "hpos_at_start") " = it->hpos;\n  " (span (|@| (class "type") (id "F:606887")) "int") " " (span (|@| (class "variable-name") (id "F:606891")) "saved_face_id") " = it->face_id;\n  " (span (|@| (class "keyword") (id "F:606922")) "struct") " " (span (|@| (class "type") (id "F:606929")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:606940")) "row") " = it->glyph_row;\n\n  " (span (|@| (class "comment-delimiter") (id "F:606964")) "/* ") (span (|@| (class "comment") (id "F:606967")) "Initialize the iterator IT for iteration over STRING beginning\n     with index START.  ") (span (|@| (class "comment-delimiter") (id "F:607054")) "*/") "\n  reseat_to_string (it, NILP (lisp_string) ? string : " (span (|@| (class "constant") (id "F:607111")) "NULL") ", lisp_string, start,\n                    precision, field_width, multibyte);\n  " (span (|@| (class "keyword") (id "F:607181")) "if") " (string && STRINGP (lisp_string)) \n    " (span (|@| (class "comment-delimiter") (id "F:607223")) "/* ") (span (|@| (class "comment") (id "F:607226")) "LISP_STRING is the one returned by decode_mode_spec.  We should\n       ignore its text properties.  ") (span (|@| (class "comment-delimiter") (id "F:607326")) "*/") "\n    it->stop_charpos = -1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:607359")) "/* ") (span (|@| (class "comment") (id "F:607362")) "If displaying STRING, set up the face of the iterator\n     from LISP_STRING, if that's given.  ") (span (|@| (class "comment-delimiter") (id "F:607457")) "*/") "\n  " (span (|@| (class "keyword") (id "F:607462")) "if") " (STRINGP (face_string))\n    {\n      " (span (|@| (class "type") (id "F:607501")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:607511")) "endptr") ";\n      " (span (|@| (class "keyword") (id "F:607525")) "struct") " " (span (|@| (class "type") (id "F:607532")) "face") " *" (span (|@| (class "variable-name") (id "F:607538")) "face") ";\n\n      it->face_id\n        = face_at_string_position (it->w, face_string, face_string_pos,\n                                   0, it->region_beg_charpos,\n                                   it->region_end_charpos,\n                                   &endptr, it->base_face_id, 0);\n      face = FACE_FROM_ID (it->f, it->face_id);\n      it->face_box_p = face->box != FACE_NO_BOX;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:607837")) "/* ") (span (|@| (class "comment") (id "F:607840")) "Set max_x to the maximum allowed X position.  Don't let it go\n     beyond the right edge of the window.  ") (span (|@| (class "comment-delimiter") (id "F:607945")) "*/") "\n  " (span (|@| (class "keyword") (id "F:607950")) "if") " (max_x <= 0)\n    max_x = it->last_visible_x;\n  " (span (|@| (class "keyword") (id "F:608000")) "else") "\n    max_x = min (max_x, it->last_visible_x);\n\n  " (span (|@| (class "comment-delimiter") (id "F:608053")) "/* ") (span (|@| (class "comment") (id "F:608056")) "Skip over display elements that are not visible. because IT->w is\n     hscrolled.  ") (span (|@| (class "comment-delimiter") (id "F:608139")) "*/") "\n  " (span (|@| (class "keyword") (id "F:608144")) "if") " (it->current_x < it->first_visible_x)\n    move_it_in_display_line_to (it, 100000, it->first_visible_x,\n                                MOVE_TO_POS | MOVE_TO_X);\n\n  row->ascent = it->max_ascent;\n  row->height = it->max_ascent + it->max_descent;\n  row->phys_ascent = it->max_phys_ascent;\n  row->phys_height = it->max_phys_ascent + it->max_phys_descent;\n  row->extra_line_spacing = it->max_extra_line_spacing;\n\n  " (span (|@| (class "comment-delimiter") (id "F:608529")) "/* ") (span (|@| (class "comment") (id "F:608532")) "This condition is for the case that we are called with current_x\n     past last_visible_x.  ") (span (|@| (class "comment-delimiter") (id "F:608624")) "*/") "\n  " (span (|@| (class "keyword") (id "F:608629")) "while") " (it->current_x < max_x)\n    {\n      " (span (|@| (class "type") (id "F:608671")) "int") " " (span (|@| (class "variable-name") (id "F:608675")) "x_before") ", " (span (|@| (class "variable-name") (id "F:608685")) "x") ", " (span (|@| (class "variable-name") (id "F:608688")) "n_glyphs_before") ", " (span (|@| (class "variable-name") (id "F:608705")) "i") ", " (span (|@| (class "variable-name") (id "F:608708")) "nglyphs") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:608724")) "/* ") (span (|@| (class "comment") (id "F:608727")) "Get the next display element.  ") (span (|@| (class "comment-delimiter") (id "F:608758")) "*/") "\n      " (span (|@| (class "keyword") (id "F:608767")) "if") " (" (span (|@| (class "negation-char") (id "F:608771")) "!") "get_next_display_element (it))\n        " (span (|@| (class "keyword") (id "F:608804")) "break") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:608818")) "/* ") (span (|@| (class "comment") (id "F:608821")) "Produce glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:608838")) "*/") "\n      x_before = it->current_x;\n      n_glyphs_before = it->glyph_row->used[TEXT_AREA];\n      PRODUCE_GLYPHS (it);\n\n      nglyphs = it->glyph_row->used[TEXT_AREA] - n_glyphs_before;\n      i = 0;\n      x = x_before;\n      " (span (|@| (class "keyword") (id "F:609062")) "while") " (i < nglyphs)\n        {\n          " (span (|@| (class "keyword") (id "F:609088")) "struct") " " (span (|@| (class "type") (id "F:609095")) "glyph") " *" (span (|@| (class "variable-name") (id "F:609102")) "glyph") " = row->glyphs[TEXT_AREA] + n_glyphs_before + i;\n\n          " (span (|@| (class "keyword") (id "F:609160")) "if") " (it->line_wrap != TRUNCATE\n              && x + glyph->pixel_width > max_x)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:609246")) "/* ") (span (|@| (class "comment") (id "F:609249")) "End of continued line or max_x reached.  ") (span (|@| (class "comment-delimiter") (id "F:609290")) "*/") "\n              " (span (|@| (class "keyword") (id "F:609300")) "if") " (CHAR_GLYPH_PADDING_P (*glyph))\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:609343")) "/* ") (span (|@| (class "comment") (id "F:609346")) "A wide character is unbreakable.  ") (span (|@| (class "comment-delimiter") (id "F:609380")) "*/") "\n                  it->glyph_row->used[TEXT_AREA] = n_glyphs_before;\n                  it->current_x = x_before;\n                }\n              " (span (|@| (class "keyword") (id "F:609478")) "else") "\n                {\n                  it->glyph_row->used[TEXT_AREA] = n_glyphs_before + i;\n                  it->current_x = x;\n                }\n              " (span (|@| (class "keyword") (id "F:609579")) "break") ";\n            }\n          " (span (|@| (class "keyword") (id "F:609596")) "else") " " (span (|@| (class "keyword") (id "F:609601")) "if") " (x + glyph->pixel_width >= it->first_visible_x)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:609666")) "/* ") (span (|@| (class "comment") (id "F:609669")) "Glyph is at least partially visible.  ") (span (|@| (class "comment-delimiter") (id "F:609707")) "*/") "\n              ++it->hpos;\n              " (span (|@| (class "keyword") (id "F:609736")) "if") " (x < it->first_visible_x)\n                it->glyph_row->x = x - it->first_visible_x;\n            }\n          " (span (|@| (class "keyword") (id "F:609821")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:609840")) "/* ") (span (|@| (class "comment") (id "F:609843")) "Glyph is off the left margin of the display area.\n                 Should not happen.  ") (span (|@| (class "comment-delimiter") (id "F:609916")) "*/") "\n              abort ();\n            }\n\n          row->ascent = max (row->ascent, it->max_ascent);\n          row->height = max (row->height, it->max_ascent + it->max_descent);\n          row->phys_ascent = max (row->phys_ascent, it->max_phys_ascent);\n          row->phys_height = max (row->phys_height,\n                                  it->max_phys_ascent + it->max_phys_descent);\n          row->extra_line_spacing = max (row->extra_line_spacing,\n                                         it->max_extra_line_spacing);\n          x += glyph->pixel_width;\n          ++i;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:610369")) "/* ") (span (|@| (class "comment") (id "F:610372")) "Stop if max_x reached.  ") (span (|@| (class "comment-delimiter") (id "F:610396")) "*/") "\n      " (span (|@| (class "keyword") (id "F:610405")) "if") " (i < nglyphs)\n        " (span (|@| (class "keyword") (id "F:610423")) "break") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:610437")) "/* ") (span (|@| (class "comment") (id "F:610440")) "Stop at line ends.  ") (span (|@| (class "comment-delimiter") (id "F:610460")) "*/") "\n      " (span (|@| (class "keyword") (id "F:610469")) "if") " (ITERATOR_AT_END_OF_LINE_P (it))\n        {\n          it->continuation_lines_width = 0;\n          " (span (|@| (class "keyword") (id "F:610548")) "break") ";\n        }\n\n      set_iterator_to_next (it, 1);\n\n      " (span (|@| (class "comment-delimiter") (id "F:610602")) "/* ") (span (|@| (class "comment") (id "F:610605")) "Stop if truncating at the right edge.  ") (span (|@| (class "comment-delimiter") (id "F:610644")) "*/") "\n      " (span (|@| (class "keyword") (id "F:610653")) "if") " (it->line_wrap == TRUNCATE\n          && it->current_x >= it->last_visible_x)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:610732")) "/* ") (span (|@| (class "comment") (id "F:610735")) "Add truncation mark, but don't do it if the line is\n             truncated at a padding space.  ") (span (|@| (class "comment-delimiter") (id "F:610824")) "*/") "\n          " (span (|@| (class "keyword") (id "F:610830")) "if") " (IT_CHARPOS (*it) < it->string_nchars)\n            {\n              " (span (|@| (class "keyword") (id "F:610886")) "if") " (" (span (|@| (class "negation-char") (id "F:610890")) "!") "FRAME_WINDOW_P (it->f))\n                {\n                  " (span (|@| (class "type") (id "F:610923")) "int") " " (span (|@| (class "variable-name") (id "F:610927")) "i") ", " (span (|@| (class "variable-name") (id "F:610930")) "n") ";\n\n                  " (span (|@| (class "keyword") (id "F:610938")) "if") " (it->current_x > it->last_visible_x)\n                    {\n                      " (span (|@| (class "keyword") (id "F:610994")) "for") " (i = row->used[TEXT_AREA] - 1; i > 0; --i)\n                        " (span (|@| (class "keyword") (id "F:611044")) "if") " (" (span (|@| (class "negation-char") (id "F:611048")) "!") "CHAR_GLYPH_PADDING_P (row->glyphs[TEXT_AREA][i]))\n                          " (span (|@| (class "keyword") (id "F:611104")) "break") ";\n                      " (span (|@| (class "keyword") (id "F:611119")) "for") " (n = row->used[TEXT_AREA]; i < n; ++i)\n                        {\n                          row->used[TEXT_AREA] = i;\n                          produce_special_glyphs (it, IT_TRUNCATION);\n                        }\n                    }\n                  produce_special_glyphs (it, IT_TRUNCATION);\n                }\n              it->glyph_row->truncated_on_right_p = 1;\n            }\n          " (span (|@| (class "keyword") (id "F:611370")) "break") ";\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:611389")) "/* ") (span (|@| (class "comment") (id "F:611392")) "Maybe insert a truncation at the left.  ") (span (|@| (class "comment-delimiter") (id "F:611432")) "*/") "\n  " (span (|@| (class "keyword") (id "F:611437")) "if") " (it->first_visible_x\n      && IT_CHARPOS (*it) > 0)\n    {\n      " (span (|@| (class "keyword") (id "F:611504")) "if") " (" (span (|@| (class "negation-char") (id "F:611508")) "!") "FRAME_WINDOW_P (it->f))\n        insert_left_trunc_glyphs (it);\n      it->glyph_row->truncated_on_left_p = 1;\n    }\n\n  it->face_id = saved_face_id;\n\n  " (span (|@| (class "comment-delimiter") (id "F:611652")) "/* ") (span (|@| (class "comment") (id "F:611655")) "Value is number of columns displayed.  ") (span (|@| (class "comment-delimiter") (id "F:611694")) "*/") "\n  " (span (|@| (class "keyword") (id "F:611699")) "return") " it->hpos - hpos_at_start;\n}\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:611738")) "/* ") (span (|@| (class "comment") (id "F:611741")) "This is like a combination of memq and assq.  Return 1/2 if PROPVAL\n   appears as an element of LIST or as the car of an element of LIST.\n   If PROPVAL is a list, compare each element against LIST in that\n   way, and return 1/2 if any element of PROPVAL is found in LIST.\n   Otherwise return 0.  This function cannot quit.\n   The return value is 2 if the text is invisible but with an ellipsis\n   and 1 if it's invisible and without an ellipsis.  ") (span (|@| (class "comment-delimiter") (id "F:612188")) "*/") "\n\n" (span (|@| (class "type") (id "F:612192")) "int") "\n" (span (|@| (class "function-name") (id "F:612196")) "invisible_p") " (propval, list)\n     " (span (|@| (class "keyword") (id "F:612229")) "register") " " (span (|@| (class "type") (id "F:612238")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:612250")) "propval") ";\n     " (span (|@| (class "type") (id "F:612264")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:612276")) "list") ";\n{\n  " (span (|@| (class "keyword") (id "F:612286")) "register") " " (span (|@| (class "type") (id "F:612295")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:612307")) "tail") ", " (span (|@| (class "variable-name") (id "F:612313")) "proptail") ";\n\n  " (span (|@| (class "keyword") (id "F:612326")) "for") " (tail = list; CONSP (tail); tail = XCDR (tail))\n    {\n      " (span (|@| (class "keyword") (id "F:612390")) "register") " " (span (|@| (class "type") (id "F:612399")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:612411")) "tem") ";\n      tem = XCAR (tail);\n      " (span (|@| (class "keyword") (id "F:612447")) "if") " (EQ (propval, tem))\n        " (span (|@| (class "keyword") (id "F:612471")) "return") " 1;\n      " (span (|@| (class "keyword") (id "F:612487")) "if") " (CONSP (tem) && EQ (propval, XCAR (tem)))\n        " (span (|@| (class "keyword") (id "F:612533")) "return") " NILP (XCDR (tem)) ? 1 : 2;\n    }\n\n  " (span (|@| (class "keyword") (id "F:612576")) "if") " (CONSP (propval))\n    {\n      " (span (|@| (class "keyword") (id "F:612609")) "for") " (proptail = propval; CONSP (proptail); proptail = XCDR (proptail))\n        {\n          " (span (|@| (class "type") (id "F:612686")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:612698")) "propelt") ";\n          propelt = XCAR (proptail);\n          " (span (|@| (class "keyword") (id "F:612740")) "for") " (tail = list; CONSP (tail); tail = XCDR (tail))\n            {\n              " (span (|@| (class "keyword") (id "F:612806")) "register") " " (span (|@| (class "type") (id "F:612815")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:612827")) "tem") ";\n              tem = XCAR (tail);\n              " (span (|@| (class "keyword") (id "F:612865")) "if") " (EQ (propelt, tem))\n                " (span (|@| (class "keyword") (id "F:612890")) "return") " 1;\n              " (span (|@| (class "keyword") (id "F:612907")) "if") " (CONSP (tem) && EQ (propelt, XCAR (tem)))\n                " (span (|@| (class "keyword") (id "F:612954")) "return") " NILP (XCDR (tem)) ? 1 : 2;\n            }\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:613007")) "return") " 0;\n}\n\nDEFUN (" (span (|@| (class "string") (id "F:613027")) "\"invisible-p\"") ", Finvisible_p, Sinvisible_p, 1, 1, 0,\n       doc: " (span (|@| (class "comment-delimiter") (id "F:613091")) "/* ") (span (|@| (class "comment") (id "F:613094")) "Non-nil if the property makes the text invisible.\nPOS-OR-PROP can be a marker or number, in which case it is taken to be\na position in the current buffer and the value of the `invisible' property\nis checked; or it can be some other value, which is then presumed to be the\nvalue of the `invisible' property of the text of interest.\nThe non-nil value returned can be t for truly invisible text or something\nelse if the text is replaced by an ellipsis.  ") (span (|@| (class "comment-delimiter") (id "F:613545")) "*/") ")\n     (pos_or_prop)\n     " (span (|@| (class "type") (id "F:613573")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:613585")) "pos_or_prop") ";\n{\n  " (span (|@| (class "type") (id "F:613602")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:613614")) "prop") "\n    = (NATNUMP (pos_or_prop) || MARKERP (pos_or_prop)\n       ? Fget_char_property (pos_or_prop, Qinvisible, Qnil)\n       : pos_or_prop);\n  " (span (|@| (class "type") (id "F:613758")) "int") " " (span (|@| (class "variable-name") (id "F:613762")) "invis") " = TEXT_PROP_MEANS_INVISIBLE (prop);\n  " (span (|@| (class "keyword") (id "F:613806")) "return") " (invis == 0 ? Qnil\n          : invis == 1 ? Qt\n          : make_number (invis));\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:613883")) "/* ") (span (|@| (class "comment") (id "F:613886")) "Calculate a width or height in pixels from a specification using\n   the following elements:\n\n   SPEC ::=\n     NUM      - a (fractional) multiple of the default font width/height\n     (NUM)    - specifies exactly NUM pixels\n     UNIT     - a fixed number of pixels, see below.\n     ELEMENT  - size of a display element in pixels, see below.\n     (NUM . SPEC) - equals NUM * SPEC\n     (+ SPEC SPEC ...)  - add pixel values\n     (- SPEC SPEC ...)  - subtract pixel values\n     (- SPEC)           - negate pixel value\n\n   NUM ::=\n     INT or FLOAT   - a number constant\n     SYMBOL         - use symbol's (buffer local) variable binding.\n\n   UNIT ::=\n     in       - pixels per inch  *)\n     mm       - pixels per 1/1000 meter  *)\n     cm       - pixels per 1/100 meter   *)\n     width    - width of current font in pixels.\n     height   - height of current font in pixels.\n\n     *) using the ratio(s) defined in display-pixels-per-inch.\n\n   ELEMENT ::=\n\n     left-fringe          - left fringe width in pixels\n     right-fringe         - right fringe width in pixels\n\n     left-margin          - left margin width in pixels\n     right-margin         - right margin width in pixels\n\n     scroll-bar           - scroll-bar area width in pixels\n\n   Examples:\n\n   Pixels corresponding to 5 inches:\n     (5 . in)\n\n   Total width of non-text areas on left side of window (if scroll-bar is on left):\n     '(space :width (+ left-fringe left-margin scroll-bar))\n\n   Align to first text column (in header line):\n     '(space :align-to 0)\n\n   Align to middle of text area minus half the width of variable `my-image'\n   containing a loaded image:\n     '(space :align-to (0.5 . (- text my-image)))\n\n   Width of left margin minus width of 1 character in the default font:\n     '(space :width (- left-margin 1))\n\n   Width of left margin minus width of 2 characters in the current font:\n     '(space :width (- left-margin (2 . width)))\n\n   Center 1 character over left-margin (in header line):\n     '(space :align-to (+ left-margin (0.5 . left-margin) -0.5))\n\n   Different ways to express width of left fringe plus left margin minus one pixel:\n     '(space :width (- (+ left-fringe left-margin) (1)))\n     '(space :width (+ left-fringe left-margin (- (1))))\n     '(space :width (+ left-fringe left-margin (-1)))\n\n") (span (|@| (class "comment-delimiter") (id "F:616180")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:616184")) "#define") " " (span (|@| (class "function-name") (id "F:616192")) "NUMVAL") "(" (span (|@| (class "variable-name") (id "F:616199")) "X") ")                               \\\n     ((INTEGERP (X) || FLOATP (X))              \\\n      ? XFLOATINT (X)                           \\\n      : - 1)\n\n" (span (|@| (class "type") (id "F:616286")) "int") "\n" (span (|@| (class "function-name") (id "F:616290")) "calc_pixel_width_or_height") " (res, " (span (|@| (class "type") (id "F:616323")) "it") ", prop, " (span (|@| (class "type") (id "F:616333")) "font") ", width_p, align_to)\n     " (span (|@| (class "type") (id "F:616363")) "double") " *" (span (|@| (class "variable-name") (id "F:616371")) "res") ";\n     " (span (|@| (class "keyword") (id "F:616381")) "struct") " " (span (|@| (class "type") (id "F:616388")) "it") " *" (span (|@| (class "variable-name") (id "F:616392")) "it") ";\n     " (span (|@| (class "type") (id "F:616401")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:616413")) "prop") ";\n     " (span (|@| (class "keyword") (id "F:616424")) "struct") " " (span (|@| (class "type") (id "F:616431")) "font") " *" (span (|@| (class "variable-name") (id "F:616437")) "font") ";\n     " (span (|@| (class "type") (id "F:616448")) "int") " " (span (|@| (class "variable-name") (id "F:616452")) "width_p") ", *" (span (|@| (class "variable-name") (id "F:616462")) "align_to") ";\n{\n  " (span (|@| (class "type") (id "F:616476")) "double") " " (span (|@| (class "variable-name") (id "F:616483")) "pixels") ";\n\n" (span (|@| (class "preprocessor") (id "F:616492")) "#define") " " (span (|@| (class "function-name") (id "F:616500")) "OK_PIXELS") "(" (span (|@| (class "variable-name") (id "F:616510")) "val") ") ((*res = (" (span (|@| (class "type") (id "F:616525")) "double") ")(val)), 1)\n" (span (|@| (class "preprocessor") (id "F:616543")) "#define") " " (span (|@| (class "function-name") (id "F:616551")) "OK_ALIGN_TO") "(" (span (|@| (class "variable-name") (id "F:616563")) "val") ") ((*align_to = (" (span (|@| (class "type") (id "F:616583")) "int") ")(val)), 1)\n\n  " (span (|@| (class "keyword") (id "F:616601")) "if") " (NILP (prop))\n    " (span (|@| (class "keyword") (id "F:616622")) "return") " OK_PIXELS (0);\n\n  xassert (FRAME_LIVE_P (it->f));\n\n  " (span (|@| (class "keyword") (id "F:616682")) "if") " (SYMBOLP (prop))\n    {\n      " (span (|@| (class "keyword") (id "F:616714")) "if") " (SCHARS (SYMBOL_NAME (prop)) == 2)\n        {\n          " (span (|@| (class "type") (id "F:616758")) "char") " *" (span (|@| (class "variable-name") (id "F:616764")) "unit") " =  SDATA (SYMBOL_NAME (prop));\n\n          " (span (|@| (class "keyword") (id "F:616804")) "if") " (unit[0] == " (span (|@| (class "string") (id "F:616819")) "'i'") " && unit[1] == " (span (|@| (class "string") (id "F:616837")) "'n'") ")\n            pixels = 1.0;\n          " (span (|@| (class "keyword") (id "F:616864")) "else") " " (span (|@| (class "keyword") (id "F:616869")) "if") " (unit[0] == " (span (|@| (class "string") (id "F:616884")) "'m'") " && unit[1] == " (span (|@| (class "string") (id "F:616902")) "'m'") ")\n            pixels = 25.4;\n          " (span (|@| (class "keyword") (id "F:616930")) "else") " " (span (|@| (class "keyword") (id "F:616935")) "if") " (unit[0] == " (span (|@| (class "string") (id "F:616950")) "'c'") " && unit[1] == " (span (|@| (class "string") (id "F:616968")) "'m'") ")\n            pixels = 2.54;\n          " (span (|@| (class "keyword") (id "F:616996")) "else") "\n            pixels = 0;\n          " (span (|@| (class "keyword") (id "F:617021")) "if") " (pixels > 0)\n            {\n              " (span (|@| (class "type") (id "F:617051")) "double") " " (span (|@| (class "variable-name") (id "F:617058")) "ppi") ";\n" (span (|@| (class "preprocessor") (id "F:617063")) "#ifdef") " HAVE_WINDOW_SYSTEM\n              " (span (|@| (class "keyword") (id "F:617096")) "if") " (FRAME_WINDOW_P (it->f)\n                  && (ppi = (width_p\n                             ? FRAME_X_DISPLAY_INFO (it->f)->resx\n                             : FRAME_X_DISPLAY_INFO (it->f)->resy),\n                      ppi > 0))\n                " (span (|@| (class "keyword") (id "F:617258")) "return") " OK_PIXELS (ppi / pixels);\n" (span (|@| (class "preprocessor") (id "F:617291")) "#endif") "\n\n              " (span (|@| (class "keyword") (id "F:617306")) "if") " ((ppi = NUMVAL (Vdisplay_pixels_per_inch), ppi > 0)\n                  || (CONSP (Vdisplay_pixels_per_inch)\n                      && (ppi = (width_p\n                                 ? NUMVAL (XCAR (Vdisplay_pixels_per_inch))\n                                 : NUMVAL (XCDR (Vdisplay_pixels_per_inch))),\n                          ppi > 0)))\n                " (span (|@| (class "keyword") (id "F:617545")) "return") " OK_PIXELS (ppi / pixels);\n\n              " (span (|@| (class "keyword") (id "F:617586")) "return") " 0;\n            }\n        }\n\n" (span (|@| (class "preprocessor") (id "F:617607")) "#ifdef") " HAVE_WINDOW_SYSTEM\n      " (span (|@| (class "keyword") (id "F:617639")) "if") " (EQ (prop, Qheight))\n        " (span (|@| (class "keyword") (id "F:617664")) "return") " OK_PIXELS (font ? FONT_HEIGHT (font) : FRAME_LINE_HEIGHT (it->f));\n      " (span (|@| (class "keyword") (id "F:617744")) "if") " (EQ (prop, Qwidth))\n        " (span (|@| (class "keyword") (id "F:617768")) "return") " OK_PIXELS (font ? FONT_WIDTH (font) : FRAME_COLUMN_WIDTH (it->f));\n" (span (|@| (class "preprocessor") (id "F:617842")) "#else") "\n      " (span (|@| (class "keyword") (id "F:617854")) "if") " (EQ (prop, Qheight) || EQ (prop, Qwidth))\n        " (span (|@| (class "keyword") (id "F:617900")) "return") " OK_PIXELS (1);\n" (span (|@| (class "preprocessor") (id "F:617922")) "#endif") "\n\n      " (span (|@| (class "keyword") (id "F:617936")) "if") " (EQ (prop, Qtext))\n          " (span (|@| (class "keyword") (id "F:617961")) "return") " OK_PIXELS (width_p\n                            ? window_box_width (it->w, TEXT_AREA)\n                            : WINDOW_BOX_HEIGHT_NO_MODE_LINE (it->w));\n\n      " (span (|@| (class "keyword") (id "F:618089")) "if") " (align_to && *align_to < 0)\n        {\n          *res = 0;\n          " (span (|@| (class "keyword") (id "F:618139")) "if") " (EQ (prop, Qleft))\n            " (span (|@| (class "keyword") (id "F:618166")) "return") " OK_ALIGN_TO (window_box_left_offset (it->w, TEXT_AREA));\n          " (span (|@| (class "keyword") (id "F:618233")) "if") " (EQ (prop, Qright))\n            " (span (|@| (class "keyword") (id "F:618261")) "return") " OK_ALIGN_TO (window_box_right_offset (it->w, TEXT_AREA));\n          " (span (|@| (class "keyword") (id "F:618329")) "if") " (EQ (prop, Qcenter))\n            " (span (|@| (class "keyword") (id "F:618358")) "return") " OK_ALIGN_TO (window_box_left_offset (it->w, TEXT_AREA)\n                                + window_box_width (it->w, TEXT_AREA) / 2);\n          " (span (|@| (class "keyword") (id "F:618471")) "if") " (EQ (prop, Qleft_fringe))\n            " (span (|@| (class "keyword") (id "F:618505")) "return") " OK_ALIGN_TO (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (it->w)\n                                ? WINDOW_LEFT_SCROLL_BAR_AREA_WIDTH (it->w)\n                                : window_box_right_offset (it->w, LEFT_MARGIN_AREA));\n          " (span (|@| (class "keyword") (id "F:618677")) "if") " (EQ (prop, Qright_fringe))\n            " (span (|@| (class "keyword") (id "F:618712")) "return") " OK_ALIGN_TO (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (it->w)\n                                ? window_box_right_offset (it->w, RIGHT_MARGIN_AREA)\n                                : window_box_right_offset (it->w, TEXT_AREA));\n          " (span (|@| (class "keyword") (id "F:618886")) "if") " (EQ (prop, Qleft_margin))\n            " (span (|@| (class "keyword") (id "F:618920")) "return") " OK_ALIGN_TO (window_box_left_offset (it->w, LEFT_MARGIN_AREA));\n          " (span (|@| (class "keyword") (id "F:618994")) "if") " (EQ (prop, Qright_margin))\n            " (span (|@| (class "keyword") (id "F:619029")) "return") " OK_ALIGN_TO (window_box_left_offset (it->w, RIGHT_MARGIN_AREA));\n          " (span (|@| (class "keyword") (id "F:619104")) "if") " (EQ (prop, Qscroll_bar))\n            " (span (|@| (class "keyword") (id "F:619137")) "return") " OK_ALIGN_TO (WINDOW_HAS_VERTICAL_SCROLL_BAR_ON_LEFT (it->w)\n                                ? 0\n                                : (window_box_right_offset (it->w, RIGHT_MARGIN_AREA)\n                                   + (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (it->w)\n                                      ? WINDOW_RIGHT_FRINGE_WIDTH (it->w)\n                                      : 0)));\n        }\n      " (span (|@| (class "keyword") (id "F:619396")) "else") "\n        {\n          " (span (|@| (class "keyword") (id "F:619407")) "if") " (EQ (prop, Qleft_fringe))\n            " (span (|@| (class "keyword") (id "F:619441")) "return") " OK_PIXELS (WINDOW_LEFT_FRINGE_WIDTH (it->w));\n          " (span (|@| (class "keyword") (id "F:619497")) "if") " (EQ (prop, Qright_fringe))\n            " (span (|@| (class "keyword") (id "F:619532")) "return") " OK_PIXELS (WINDOW_RIGHT_FRINGE_WIDTH (it->w));\n          " (span (|@| (class "keyword") (id "F:619589")) "if") " (EQ (prop, Qleft_margin))\n            " (span (|@| (class "keyword") (id "F:619623")) "return") " OK_PIXELS (WINDOW_LEFT_MARGIN_WIDTH (it->w));\n          " (span (|@| (class "keyword") (id "F:619679")) "if") " (EQ (prop, Qright_margin))\n            " (span (|@| (class "keyword") (id "F:619714")) "return") " OK_PIXELS (WINDOW_RIGHT_MARGIN_WIDTH (it->w));\n          " (span (|@| (class "keyword") (id "F:619771")) "if") " (EQ (prop, Qscroll_bar))\n            " (span (|@| (class "keyword") (id "F:619804")) "return") " OK_PIXELS (WINDOW_SCROLL_BAR_AREA_WIDTH (it->w));\n        }\n\n      prop = Fbuffer_local_value (prop, it->w->buffer);\n    }\n\n  " (span (|@| (class "keyword") (id "F:619930")) "if") " (INTEGERP (prop) || FLOATP (prop))\n    {\n      " (span (|@| (class "type") (id "F:619980")) "int") " " (span (|@| (class "variable-name") (id "F:619984")) "base_unit") " = (width_p\n                       ? FRAME_COLUMN_WIDTH (it->f)\n                       : FRAME_LINE_HEIGHT (it->f));\n      " (span (|@| (class "keyword") (id "F:620088")) "return") " OK_PIXELS (XFLOATINT (prop) * base_unit);\n    }\n\n  " (span (|@| (class "keyword") (id "F:620146")) "if") " (CONSP (prop))\n    {\n      " (span (|@| (class "type") (id "F:620176")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:620188")) "car") " = XCAR (prop);\n      " (span (|@| (class "type") (id "F:620213")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:620225")) "cdr") " = XCDR (prop);\n\n      " (span (|@| (class "keyword") (id "F:620251")) "if") " (SYMBOLP (car))\n        {\n" (span (|@| (class "preprocessor") (id "F:620273")) "#ifdef") " HAVE_WINDOW_SYSTEM\n          " (span (|@| (class "keyword") (id "F:620302")) "if") " (FRAME_WINDOW_P (it->f)\n              && valid_image_p (prop))\n            {\n              " (span (|@| (class "type") (id "F:620375")) "int") " " (span (|@| (class "variable-name") (id "F:620379")) "id") " = lookup_image (it->f, prop);\n              " (span (|@| (class "keyword") (id "F:620419")) "struct") " " (span (|@| (class "type") (id "F:620426")) "image") " *" (span (|@| (class "variable-name") (id "F:620433")) "img") " = IMAGE_FROM_ID (it->f, id);\n\n              " (span (|@| (class "keyword") (id "F:620474")) "return") " OK_PIXELS (width_p ? img->width : img->height);\n            }\n" (span (|@| (class "preprocessor") (id "F:620536")) "#endif") "\n          " (span (|@| (class "keyword") (id "F:620546")) "if") " (EQ (car, Qplus) || EQ (car, Qminus))\n            {\n              " (span (|@| (class "type") (id "F:620601")) "int") " " (span (|@| (class "variable-name") (id "F:620605")) "first") " = 1;\n              " (span (|@| (class "type") (id "F:620623")) "double") " " (span (|@| (class "variable-name") (id "F:620630")) "px") ";\n\n              pixels = 0;\n              " (span (|@| (class "keyword") (id "F:620661")) "while") " (CONSP (cdr))\n                {\n                  " (span (|@| (class "keyword") (id "F:620689")) "if") " (" (span (|@| (class "negation-char") (id "F:620693")) "!") "calc_pixel_width_or_height (&px, it, XCAR (cdr),\n                                                   font, width_p, align_to))\n                    " (span (|@| (class "keyword") (id "F:620784")) "return") " 0;\n                  " (span (|@| (class "keyword") (id "F:620798")) "if") " (first)\n                    pixels = (EQ (car, Qplus) ? px : -px), first = 0;\n                  " (span (|@| (class "keyword") (id "F:620869")) "else") "\n                    pixels += px;\n                  cdr = XCDR (cdr);\n                }\n              " (span (|@| (class "keyword") (id "F:620927")) "if") " (EQ (car, Qminus))\n                pixels = -pixels;\n              " (span (|@| (class "keyword") (id "F:620976")) "return") " OK_PIXELS (pixels);\n            }\n\n          car = Fbuffer_local_value (car, it->w->buffer);\n        }\n\n      " (span (|@| (class "keyword") (id "F:621072")) "if") " (INTEGERP (car) || FLOATP (car))\n        {\n          " (span (|@| (class "type") (id "F:621114")) "double") " " (span (|@| (class "variable-name") (id "F:621121")) "fact") ";\n          pixels = XFLOATINT (car);\n          " (span (|@| (class "keyword") (id "F:621159")) "if") " (NILP (cdr))\n            " (span (|@| (class "keyword") (id "F:621180")) "return") " OK_PIXELS (pixels);\n          " (span (|@| (class "keyword") (id "F:621210")) "if") " (calc_pixel_width_or_height (&fact, it, cdr,\n                                          font, width_p, align_to))\n            " (span (|@| (class "keyword") (id "F:621296")) "return") " OK_PIXELS (pixels * fact);\n          " (span (|@| (class "keyword") (id "F:621333")) "return") " 0;\n        }\n\n      " (span (|@| (class "keyword") (id "F:621353")) "return") " 0;\n    }\n\n  " (span (|@| (class "keyword") (id "F:621372")) "return") " 0;\n}\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:621387")) "/***********************************************************************") (span (|@| (class "comment") (id "F:621459")) "\n                             Glyph Display\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:621553")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:621557")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "preprocessor") (id "F:621584")) "#if") " GLYPH_DEBUG\n\n" (span (|@| (class "type") (id "F:621601")) "void") "\n" (span (|@| (class "function-name") (id "F:621606")) "dump_glyph_string") " (s)\n     " (span (|@| (class "keyword") (id "F:621633")) "struct") " " (span (|@| (class "type") (id "F:621640")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:621654")) "s") ";\n{\n  fprintf (stderr, " (span (|@| (class "string") (id "F:621678")) "\"glyph string\\n\"") ");\n  fprintf (stderr, " (span (|@| (class "string") (id "F:621716")) "\"  x, y, w, h = %d, %d, %d, %d\\n\"") ",\n           s->x, s->y, s->width, s->height);\n  fprintf (stderr, " (span (|@| (class "string") (id "F:621808")) "\"  ybase = %d\\n\"") ", s->ybase);\n  fprintf (stderr, " (span (|@| (class "string") (id "F:621856")) "\"  hl = %d\\n\"") ", s->hl);\n  fprintf (stderr, " (span (|@| (class "string") (id "F:621898")) "\"  left overhang = %d, right = %d\\n\"") ",\n           s->left_overhang, s->right_overhang);\n  fprintf (stderr, " (span (|@| (class "string") (id "F:621997")) "\"  nchars = %d\\n\"") ", s->nchars);\n  fprintf (stderr, " (span (|@| (class "string") (id "F:622047")) "\"  extends to end of line = %d\\n\"") ",\n           s->extends_to_end_of_line_p);\n  fprintf (stderr, " (span (|@| (class "string") (id "F:622135")) "\"  font height = %d\\n\"") ", FONT_HEIGHT (s->font));\n  fprintf (stderr, " (span (|@| (class "string") (id "F:622202")) "\"  bg width = %d\\n\"") ", s->background_width);\n}\n\n" (span (|@| (class "preprocessor") (id "F:622248")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:622255")) "/* ") (span (|@| (class "comment") (id "F:622258")) "GLYPH_DEBUG ") (span (|@| (class "comment-delimiter") (id "F:622270")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:622274")) "/* ") (span (|@| (class "comment") (id "F:622277")) "Initialize glyph string S.  CHAR2B is a suitably allocated vector\n   of XChar2b structures for S; it can't be allocated in\n   init_glyph_string because it must be allocated via `alloca'.  W\n   is the window on which S is drawn.  ROW and AREA are the glyph row\n   and area within the row from which S is constructed.  START is the\n   index of the first glyph structure covered by S.  HL is a\n   face-override for drawing S.  ") (span (|@| (class "comment-delimiter") (id "F:622701")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:622705")) "#ifdef") " HAVE_NTGUI\n" (span (|@| (class "preprocessor") (id "F:622723")) "#define") " " (span (|@| (class "function-name") (id "F:622731")) "OPTIONAL_HDC") "(" (span (|@| (class "variable-name") (id "F:622744")) "hdc") ")  hdc,\n" (span (|@| (class "preprocessor") (id "F:622755")) "#define") " " (span (|@| (class "function-name") (id "F:622763")) "DECLARE_HDC") "(" (span (|@| (class "variable-name") (id "F:622775")) "hdc") ")   " (span (|@| (class "type") (id "F:622782")) "HDC") " " (span (|@| (class "variable-name") (id "F:622786")) "hdc") ";\n" (span (|@| (class "preprocessor") (id "F:622791")) "#define") " " (span (|@| (class "function-name") (id "F:622799")) "ALLOCATE_HDC") "(" (span (|@| (class "variable-name") (id "F:622812")) "hdc") ", " (span (|@| (class "variable-name") (id "F:622817")) "f") ") hdc = get_frame_dc ((f))\n" (span (|@| (class "preprocessor") (id "F:622845")) "#define") " " (span (|@| (class "function-name") (id "F:622853")) "RELEASE_HDC") "(" (span (|@| (class "variable-name") (id "F:622865")) "hdc") ", " (span (|@| (class "variable-name") (id "F:622870")) "f") ")  release_frame_dc ((f), (hdc))\n" (span (|@| (class "preprocessor") (id "F:622904")) "#endif") "\n\n" (span (|@| (class "preprocessor") (id "F:622912")) "#if") (span (|@| (class "negation-char") (id "F:622915")) (span (|@| (class "preprocessor") (id "F:622915")) "n")) (span (|@| (class "preprocessor") (id "F:622916")) "def") " OPTIONAL_HDC\n" (span (|@| (class "preprocessor") (id "F:622933")) "#define") " " (span (|@| (class "function-name") (id "F:622941")) "OPTIONAL_HDC") "(" (span (|@| (class "variable-name") (id "F:622954")) "hdc") ")\n" (span (|@| (class "preprocessor") (id "F:622959")) "#define") " " (span (|@| (class "function-name") (id "F:622967")) "DECLARE_HDC") "(" (span (|@| (class "variable-name") (id "F:622979")) "hdc") ")\n" (span (|@| (class "preprocessor") (id "F:622984")) "#define") " " (span (|@| (class "function-name") (id "F:622992")) "ALLOCATE_HDC") "(" (span (|@| (class "variable-name") (id "F:623005")) "hdc") ", " (span (|@| (class "variable-name") (id "F:623010")) "f") ")\n" (span (|@| (class "preprocessor") (id "F:623013")) "#define") " " (span (|@| (class "function-name") (id "F:623021")) "RELEASE_HDC") "(" (span (|@| (class "variable-name") (id "F:623033")) "hdc") ", " (span (|@| (class "variable-name") (id "F:623038")) "f") ")\n" (span (|@| (class "preprocessor") (id "F:623041")) "#endif") "\n\n" (span (|@| (class "keyword") (id "F:623049")) "static") " " (span (|@| (class "type") (id "F:623056")) "void") "\n" (span (|@| (class "function-name") (id "F:623061")) "init_glyph_string") " (s, OPTIONAL_HDC (hdc) char2b, w, row, area, start, hl)\n     " (span (|@| (class "keyword") (id "F:623140")) "struct") " " (span (|@| (class "type") (id "F:623147")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:623161")) "s") ";\n     DECLARE_HDC (hdc)\n     " (span (|@| (class "type") (id "F:623192")) "XChar2b") " *" (span (|@| (class "variable-name") (id "F:623201")) "char2b") ";\n     " (span (|@| (class "keyword") (id "F:623214")) "struct") " " (span (|@| (class "type") (id "F:623221")) "window") " *" (span (|@| (class "variable-name") (id "F:623229")) "w") ";\n     " (span (|@| (class "keyword") (id "F:623237")) "struct") " " (span (|@| (class "type") (id "F:623244")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:623255")) "row") ";\n     " (span (|@| (class "keyword") (id "F:623265")) "enum") " " (span (|@| (class "type") (id "F:623270")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:623285")) "area") ";\n     " (span (|@| (class "type") (id "F:623296")) "int") " " (span (|@| (class "variable-name") (id "F:623300")) "start") ";\n     " (span (|@| (class "keyword") (id "F:623312")) "enum") " " (span (|@| (class "type") (id "F:623317")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:623334")) "hl") ";\n{\n  bzero (s, " (span (|@| (class "keyword") (id "F:623352")) "sizeof") " *s);\n  s->w = w;\n  s->f = XFRAME (w->frame);\n" (span (|@| (class "preprocessor") (id "F:623404")) "#ifdef") " HAVE_NTGUI\n  s->hdc = hdc;\n" (span (|@| (class "preprocessor") (id "F:623438")) "#endif") "\n  s->display = FRAME_X_DISPLAY (s->f);\n  s->window = FRAME_X_WINDOW (s->f);\n  s->char2b = char2b;\n  s->hl = hl;\n  s->row = row;\n  s->area = area;\n  s->first_glyph = row->glyphs[area] + start;\n  s->height = row->height;\n  s->y = WINDOW_TO_FRAME_PIXEL_Y (w, row->y);\n  s->ybase = s->y + row->ascent;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:623747")) "/* ") (span (|@| (class "comment") (id "F:623750")) "Append the list of glyph strings with head H and tail T to the list\n   with head *HEAD and tail *TAIL.  Set *HEAD and *TAIL to the result.  ") (span (|@| (class "comment-delimiter") (id "F:623890")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:623894")) "static") " INLINE " (span (|@| (class "type") (id "F:623908")) "void") "\n" (span (|@| (class "function-name") (id "F:623913")) "append_glyph_string_lists") " (head, tail, h, t)\n     " (span (|@| (class "keyword") (id "F:623963")) "struct") " " (span (|@| (class "type") (id "F:623970")) "glyph_string") " **" (span (|@| (class "variable-name") (id "F:623985")) "head") ", **" (span (|@| (class "variable-name") (id "F:623993")) "tail") ";\n     " (span (|@| (class "keyword") (id "F:624004")) "struct") " " (span (|@| (class "type") (id "F:624011")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:624025")) "h") ", *" (span (|@| (class "variable-name") (id "F:624029")) "t") ";\n{\n  " (span (|@| (class "keyword") (id "F:624036")) "if") " (h)\n    {\n      " (span (|@| (class "keyword") (id "F:624055")) "if") " (*head)\n        (*tail)->next = h;\n      " (span (|@| (class "keyword") (id "F:624092")) "else") "\n        *head = h;\n      h->prev = *tail;\n      *tail = t;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:624159")) "/* ") (span (|@| (class "comment") (id "F:624162")) "Prepend the list of glyph strings with head H and tail T to the\n   list with head *HEAD and tail *TAIL.  Set *HEAD and *TAIL to the\n   result.  ") (span (|@| (class "comment-delimiter") (id "F:624306")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:624310")) "static") " INLINE " (span (|@| (class "type") (id "F:624324")) "void") "\n" (span (|@| (class "function-name") (id "F:624329")) "prepend_glyph_string_lists") " (head, tail, h, t)\n     " (span (|@| (class "keyword") (id "F:624380")) "struct") " " (span (|@| (class "type") (id "F:624387")) "glyph_string") " **" (span (|@| (class "variable-name") (id "F:624402")) "head") ", **" (span (|@| (class "variable-name") (id "F:624410")) "tail") ";\n     " (span (|@| (class "keyword") (id "F:624421")) "struct") " " (span (|@| (class "type") (id "F:624428")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:624442")) "h") ", *" (span (|@| (class "variable-name") (id "F:624446")) "t") ";\n{\n  " (span (|@| (class "keyword") (id "F:624453")) "if") " (h)\n    {\n      " (span (|@| (class "keyword") (id "F:624472")) "if") " (*head)\n        (*head)->prev = t;\n      " (span (|@| (class "keyword") (id "F:624509")) "else") "\n        *tail = t;\n      t->next = *head;\n      *head = h;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:624576")) "/* ") (span (|@| (class "comment") (id "F:624579")) "Append glyph string S to the list with head *HEAD and tail *TAIL.\n   Set *HEAD and *TAIL to the resulting list.  ") (span (|@| (class "comment-delimiter") (id "F:624692")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:624696")) "static") " INLINE " (span (|@| (class "type") (id "F:624710")) "void") "\n" (span (|@| (class "function-name") (id "F:624715")) "append_glyph_string") " (head, tail, s)\n     " (span (|@| (class "keyword") (id "F:624756")) "struct") " " (span (|@| (class "type") (id "F:624763")) "glyph_string") " **" (span (|@| (class "variable-name") (id "F:624778")) "head") ", **" (span (|@| (class "variable-name") (id "F:624786")) "tail") ";\n     " (span (|@| (class "keyword") (id "F:624797")) "struct") " " (span (|@| (class "type") (id "F:624804")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:624818")) "s") ";\n{\n  s->next = s->prev = " (span (|@| (class "constant") (id "F:624845")) "NULL") ";\n  append_glyph_string_lists (head, tail, s, s);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:624903")) "/* ") (span (|@| (class "comment") (id "F:624906")) "Get face and two-byte form of character C in face FACE_ID on frame\n   F.  The encoding of C is returned in *CHAR2B.  MULTIBYTE_P non-zero\n   means we want to display multibyte text.  DISPLAY_P non-zero means\n   make sure that X resources for the face returned are allocated.\n   Value is a pointer to a realized face that is ready for display if\n   DISPLAY_P is non-zero.  ") (span (|@| (class "comment-delimiter") (id "F:625278")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:625282")) "static") " INLINE " (span (|@| (class "keyword") (id "F:625296")) "struct") " " (span (|@| (class "type") (id "F:625303")) "face") " *\n" (span (|@| (class "function-name") (id "F:625310")) "get_char_face_and_encoding") " (f, c, " (span (|@| (class "type") (id "F:625344")) "face_id") ", char2b, multibyte_p, display_p)\n     " (span (|@| (class "keyword") (id "F:625390")) "struct") " " (span (|@| (class "type") (id "F:625397")) "frame") " *" (span (|@| (class "variable-name") (id "F:625404")) "f") ";\n     " (span (|@| (class "type") (id "F:625412")) "int") " " (span (|@| (class "variable-name") (id "F:625416")) "c") ", " (span (|@| (class "variable-name") (id "F:625419")) "face_id") ";\n     " (span (|@| (class "type") (id "F:625433")) "XChar2b") " *" (span (|@| (class "variable-name") (id "F:625442")) "char2b") ";\n     " (span (|@| (class "type") (id "F:625455")) "int") " " (span (|@| (class "variable-name") (id "F:625459")) "multibyte_p") ", " (span (|@| (class "variable-name") (id "F:625472")) "display_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:625487")) "struct") " " (span (|@| (class "type") (id "F:625494")) "face") " *" (span (|@| (class "variable-name") (id "F:625500")) "face") " = FACE_FROM_ID (f, face_id);\n\n  " (span (|@| (class "keyword") (id "F:625537")) "if") " (face->font)\n    {\n      " (span (|@| (class "type") (id "F:625565")) "unsigned") " " (span (|@| (class "variable-name") (id "F:625574")) "code") " = face->font->driver->encode_char (face->font, c);\n\n      " (span (|@| (class "keyword") (id "F:625637")) "if") " (code != FONT_INVALID_CODE)\n        STORE_XCHAR2B (char2b, (code >> 8), (code & 0xFF));\n      " (span (|@| (class "keyword") (id "F:625727")) "else") "\n        STORE_XCHAR2B (char2b, 0, 0);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:625772")) "/* ") (span (|@| (class "comment") (id "F:625775")) "Make sure X resources of the face are allocated.  ") (span (|@| (class "comment-delimiter") (id "F:625825")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:625828")) "#ifdef") " HAVE_X_WINDOWS\n  " (span (|@| (class "keyword") (id "F:625852")) "if") " (display_p)\n" (span (|@| (class "preprocessor") (id "F:625867")) "#endif") "\n    {\n      xassert (face != " (span (|@| (class "constant") (id "F:625903")) "NULL") ");\n      PREPARE_FACE_FOR_DISPLAY (f, face);\n    }\n\n  " (span (|@| (class "keyword") (id "F:625961")) "return") " face;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:625978")) "/* ") (span (|@| (class "comment") (id "F:625981")) "Get face and two-byte form of character glyph GLYPH on frame F.\n   The encoding of GLYPH->u.ch is returned in *CHAR2B.  Value is\n   a pointer to a realized face that is ready for display.  ") (span (|@| (class "comment-delimiter") (id "F:626170")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:626174")) "static") " INLINE " (span (|@| (class "keyword") (id "F:626188")) "struct") " " (span (|@| (class "type") (id "F:626195")) "face") " *\n" (span (|@| (class "function-name") (id "F:626202")) "get_glyph_face_and_encoding") " (f, " (span (|@| (class "type") (id "F:626234")) "glyph") ", char2b, two_byte_p)\n     " (span (|@| (class "keyword") (id "F:626266")) "struct") " " (span (|@| (class "type") (id "F:626273")) "frame") " *" (span (|@| (class "variable-name") (id "F:626280")) "f") ";\n     " (span (|@| (class "keyword") (id "F:626288")) "struct") " " (span (|@| (class "type") (id "F:626295")) "glyph") " *" (span (|@| (class "variable-name") (id "F:626302")) "glyph") ";\n     " (span (|@| (class "type") (id "F:626314")) "XChar2b") " *" (span (|@| (class "variable-name") (id "F:626323")) "char2b") ";\n     " (span (|@| (class "type") (id "F:626336")) "int") " *" (span (|@| (class "variable-name") (id "F:626341")) "two_byte_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:626357")) "struct") " " (span (|@| (class "type") (id "F:626364")) "face") " *" (span (|@| (class "variable-name") (id "F:626370")) "face") ";\n\n  xassert (glyph->type == CHAR_GLYPH);\n  face = FACE_FROM_ID (f, glyph->face_id);\n\n  " (span (|@| (class "keyword") (id "F:626462")) "if") " (two_byte_p)\n    *two_byte_p = 0;\n\n  " (span (|@| (class "keyword") (id "F:626502")) "if") " (face->font)\n    {\n      " (span (|@| (class "type") (id "F:626530")) "unsigned") " " (span (|@| (class "variable-name") (id "F:626539")) "code") " = face->font->driver->encode_char (face->font, glyph->u.ch);\n\n      " (span (|@| (class "keyword") (id "F:626612")) "if") " (code != FONT_INVALID_CODE)\n        STORE_XCHAR2B (char2b, (code >> 8), (code & 0xFF));\n      " (span (|@| (class "keyword") (id "F:626702")) "else") "\n        STORE_XCHAR2B (char2b, 0, 0);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:626747")) "/* ") (span (|@| (class "comment") (id "F:626750")) "Make sure X resources of the face are allocated.  ") (span (|@| (class "comment-delimiter") (id "F:626800")) "*/") "\n  xassert (face != " (span (|@| (class "constant") (id "F:626822")) "NULL") ");\n  PREPARE_FACE_FOR_DISPLAY (f, face);\n  " (span (|@| (class "keyword") (id "F:626869")) "return") " face;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:626886")) "/* ") (span (|@| (class "comment") (id "F:626889")) "Fill glyph string S with composition components specified by S->cmp.\n\n   BASE_FACE is the base face of the composition.\n   S->cmp_from is the index of the first component for S.\n\n   OVERLAPS non-zero means S should draw the foreground only, and use\n   its physical height for clipping.  See also draw_glyphs.\n\n   Value is the index of a component not in S.  ") (span (|@| (class "comment-delimiter") (id "F:627247")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:627251")) "static") " " (span (|@| (class "type") (id "F:627258")) "int") "\n" (span (|@| (class "function-name") (id "F:627262")) "fill_composite_glyph_string") " (s, base_face, overlaps)\n     " (span (|@| (class "keyword") (id "F:627320")) "struct") " " (span (|@| (class "type") (id "F:627327")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:627341")) "s") ";\n     " (span (|@| (class "keyword") (id "F:627349")) "struct") " " (span (|@| (class "type") (id "F:627356")) "face") " *" (span (|@| (class "variable-name") (id "F:627362")) "base_face") ";\n     " (span (|@| (class "type") (id "F:627378")) "int") " " (span (|@| (class "variable-name") (id "F:627382")) "overlaps") ";\n{\n  " (span (|@| (class "type") (id "F:627396")) "int") " " (span (|@| (class "variable-name") (id "F:627400")) "i") ";\n  " (span (|@| (class "comment-delimiter") (id "F:627405")) "/* ") (span (|@| (class "comment") (id "F:627408")) "For all glyphs of this composition, starting at the offset\n     S->cmp_from, until we reach the end of the definition or encounter a\n     glyph that requires the different face, add it to S.  ") (span (|@| (class "comment-delimiter") (id "F:627600")) "*/") "\n  " (span (|@| (class "keyword") (id "F:627605")) "struct") " " (span (|@| (class "type") (id "F:627612")) "face") " *" (span (|@| (class "variable-name") (id "F:627618")) "face") ";\n\n  xassert (s);\n\n  s->for_overlaps = overlaps;\n  s->face = " (span (|@| (class "constant") (id "F:627683")) "NULL") ";\n  s->font = " (span (|@| (class "constant") (id "F:627701")) "NULL") ";\n  " (span (|@| (class "keyword") (id "F:627709")) "for") " (i = s->cmp_from; i < s->cmp->glyph_len; i++)\n    {\n      " (span (|@| (class "type") (id "F:627771")) "int") " " (span (|@| (class "variable-name") (id "F:627775")) "c") " = COMPOSITION_GLYPH (s->cmp, i);\n\n      " (span (|@| (class "keyword") (id "F:627817")) "if") " (c != " (span (|@| (class "string") (id "F:627826")) "'\\t'") ")\n        {\n          " (span (|@| (class "type") (id "F:627838")) "int") " " (span (|@| (class "variable-name") (id "F:627842")) "face_id") " = FACE_FOR_CHAR (s->f, base_face->ascii_face, c,\n                                       -1, Qnil);\n\n          face = get_char_face_and_encoding (s->f, c, face_id,\n                                             s->char2b + i, 1, 1);\n          " (span (|@| (class "keyword") (id "F:628013")) "if") " (face)\n            {\n              " (span (|@| (class "keyword") (id "F:628037")) "if") " (" (span (|@| (class "negation-char") (id "F:628041")) "!") " s->face)\n                {\n                  s->face = face;\n                  s->font = s->face->font;\n                }\n              " (span (|@| (class "keyword") (id "F:628116")) "else") " " (span (|@| (class "keyword") (id "F:628121")) "if") " (s->face != face)\n                " (span (|@| (class "keyword") (id "F:628144")) "break") ";\n            }\n        }\n      ++s->nchars;\n    }\n  s->cmp_to = i;\n\n  " (span (|@| (class "comment-delimiter") (id "F:628206")) "/* ") (span (|@| (class "comment") (id "F:628209")) "All glyph strings for the same composition has the same width,\n     i.e. the width set for the first component of the composition.  ") (span (|@| (class "comment-delimiter") (id "F:628341")) "*/") "\n  s->width = s->first_glyph->pixel_width;\n\n  " (span (|@| (class "comment-delimiter") (id "F:628389")) "/* ") (span (|@| (class "comment") (id "F:628392")) "If the specified font could not be loaded, use the frame's\n     default font, but record the fact that we couldn't load it in\n     the glyph string so that we can draw rectangles for the\n     characters of the glyph string.  ") (span (|@| (class "comment-delimiter") (id "F:628617")) "*/") "\n  " (span (|@| (class "keyword") (id "F:628622")) "if") " (s->font == " (span (|@| (class "constant") (id "F:628637")) "NULL") ")\n    {\n      s->font_not_found_p = 1;\n      s->font = FRAME_FONT (s->f);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:628724")) "/* ") (span (|@| (class "comment") (id "F:628727")) "Adjust base line for subscript/superscript text.  ") (span (|@| (class "comment-delimiter") (id "F:628777")) "*/") "\n  s->ybase += s->first_glyph->voffset;\n\n  " (span (|@| (class "comment-delimiter") (id "F:628822")) "/* ") (span (|@| (class "comment") (id "F:628825")) "This glyph string must always be drawn with 16-bit functions.  ") (span (|@| (class "comment-delimiter") (id "F:628888")) "*/") "\n  s->two_byte_p = 1;\n\n  " (span (|@| (class "keyword") (id "F:628915")) "return") " s->cmp_to;\n}\n\n" (span (|@| (class "keyword") (id "F:628936")) "static") " " (span (|@| (class "type") (id "F:628943")) "int") "\n" (span (|@| (class "function-name") (id "F:628947")) "fill_gstring_glyph_string") " (s, " (span (|@| (class "type") (id "F:628977")) "face_id") ", start, end, overlaps)\n     " (span (|@| (class "keyword") (id "F:629013")) "struct") " " (span (|@| (class "type") (id "F:629020")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:629034")) "s") ";\n     " (span (|@| (class "type") (id "F:629042")) "int") " " (span (|@| (class "variable-name") (id "F:629046")) "face_id") ";\n     " (span (|@| (class "type") (id "F:629060")) "int") " " (span (|@| (class "variable-name") (id "F:629064")) "start") ", " (span (|@| (class "variable-name") (id "F:629071")) "end") ", " (span (|@| (class "variable-name") (id "F:629076")) "overlaps") ";\n{\n  " (span (|@| (class "keyword") (id "F:629090")) "struct") " " (span (|@| (class "type") (id "F:629097")) "glyph") " *" (span (|@| (class "variable-name") (id "F:629104")) "glyph") ", *" (span (|@| (class "variable-name") (id "F:629112")) "last") ";\n  " (span (|@| (class "type") (id "F:629120")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:629132")) "lgstring") ";\n  " (span (|@| (class "type") (id "F:629144")) "int") " " (span (|@| (class "variable-name") (id "F:629148")) "i") ";\n\n  s->for_overlaps = overlaps;\n  glyph = s->row->glyphs[s->area] + start;\n  last = s->row->glyphs[s->area] + end;\n  s->cmp_id = glyph->u.cmp.id;\n  s->cmp_from = glyph->u.cmp.from;\n  s->cmp_to = glyph->u.cmp.to + 1;\n  s->face = FACE_FROM_ID (s->f, face_id);\n  lgstring = composition_gstring_from_id (s->cmp_id);\n  s->font = XFONT_OBJECT (LGSTRING_FONT (lgstring));\n  glyph++;\n  " (span (|@| (class "keyword") (id "F:629528")) "while") " (glyph < last\n         && glyph->u.cmp.automatic\n         && glyph->u.cmp.id == s->cmp_id\n         && s->cmp_to == glyph->u.cmp.from)\n    s->cmp_to = (glyph++)->u.cmp.to + 1;\n\n  " (span (|@| (class "keyword") (id "F:629691")) "for") " (i = s->cmp_from; i < s->cmp_to; i++)\n    {\n      " (span (|@| (class "type") (id "F:629745")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:629757")) "lglyph") " = LGSTRING_GLYPH (lgstring, i);\n      " (span (|@| (class "type") (id "F:629802")) "unsigned") " " (span (|@| (class "variable-name") (id "F:629811")) "code") " = LGLYPH_CODE (lglyph);\n\n      STORE_XCHAR2B ((s->char2b + i), code >> 8, code & 0xFF);\n    }\n  s->width = composition_gstring_width (lgstring, s->cmp_from, s->cmp_to, " (span (|@| (class "constant") (id "F:629984")) "NULL") ");\n  " (span (|@| (class "keyword") (id "F:629993")) "return") " glyph - s->row->glyphs[s->area];\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:630037")) "/* ") (span (|@| (class "comment") (id "F:630040")) "Fill glyph string S from a sequence of character glyphs.\n\n   FACE_ID is the face id of the string.  START is the index of the\n   first glyph to consider, END is the index of the last + 1.\n   OVERLAPS non-zero means S should draw the foreground only, and use\n   its physical height for clipping.  See also draw_glyphs.\n\n   Value is the index of the first glyph not in S.  ") (span (|@| (class "comment-delimiter") (id "F:630411")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:630415")) "static") " " (span (|@| (class "type") (id "F:630422")) "int") "\n" (span (|@| (class "function-name") (id "F:630426")) "fill_glyph_string") " (s, " (span (|@| (class "type") (id "F:630448")) "face_id") ", start, end, overlaps)\n     " (span (|@| (class "keyword") (id "F:630484")) "struct") " " (span (|@| (class "type") (id "F:630491")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:630505")) "s") ";\n     " (span (|@| (class "type") (id "F:630513")) "int") " " (span (|@| (class "variable-name") (id "F:630517")) "face_id") ";\n     " (span (|@| (class "type") (id "F:630531")) "int") " " (span (|@| (class "variable-name") (id "F:630535")) "start") ", " (span (|@| (class "variable-name") (id "F:630542")) "end") ", " (span (|@| (class "variable-name") (id "F:630547")) "overlaps") ";\n{\n  " (span (|@| (class "keyword") (id "F:630561")) "struct") " " (span (|@| (class "type") (id "F:630568")) "glyph") " *" (span (|@| (class "variable-name") (id "F:630575")) "glyph") ", *" (span (|@| (class "variable-name") (id "F:630583")) "last") ";\n  " (span (|@| (class "type") (id "F:630591")) "int") " " (span (|@| (class "variable-name") (id "F:630595")) "voffset") ";\n  " (span (|@| (class "type") (id "F:630606")) "int") " " (span (|@| (class "variable-name") (id "F:630610")) "glyph_not_available_p") ";\n\n  xassert (s->f == XFRAME (s->w->frame));\n  xassert (s->nchars == 0);\n  xassert (start >= 0 && end > start);\n\n  s->for_overlaps = overlaps;\n  glyph = s->row->glyphs[s->area] + start;\n  last = s->row->glyphs[s->area] + end;\n  voffset = glyph->voffset;\n  s->padding_p = glyph->padding_p;\n  glyph_not_available_p = glyph->glyph_not_available_p;\n\n  " (span (|@| (class "keyword") (id "F:630979")) "while") " (glyph < last\n         && glyph->type == CHAR_GLYPH\n         && glyph->voffset == voffset\n         " (span (|@| (class "comment-delimiter") (id "F:631063")) "/* ") (span (|@| (class "comment") (id "F:631066")) "Same face id implies same font, nowadays.  ") (span (|@| (class "comment-delimiter") (id "F:631109")) "*/") "\n         && glyph->face_id == face_id\n         && glyph->glyph_not_available_p == glyph_not_available_p)\n    {\n      " (span (|@| (class "type") (id "F:631215")) "int") " " (span (|@| (class "variable-name") (id "F:631219")) "two_byte_p") ";\n\n      s->face = get_glyph_face_and_encoding (s->f, glyph,\n                                               s->char2b + s->nchars,\n                                               &two_byte_p);\n      s->two_byte_p = two_byte_p;\n      ++s->nchars;\n      xassert (s->nchars <= end - start);\n      s->width += glyph->pixel_width;\n      " (span (|@| (class "keyword") (id "F:631490")) "if") " (glyph++->padding_p != s->padding_p)\n        " (span (|@| (class "keyword") (id "F:631531")) "break") ";\n    }\n\n  s->font = s->face->font;\n\n  " (span (|@| (class "comment-delimiter") (id "F:631575")) "/* ") (span (|@| (class "comment") (id "F:631578")) "If the specified font could not be loaded, use the frame's font,\n     but record the fact that we couldn't load it in\n     S->font_not_found_p so that we can draw rectangles for the\n     characters of the glyph string.  ") (span (|@| (class "comment-delimiter") (id "F:631798")) "*/") "\n  " (span (|@| (class "keyword") (id "F:631803")) "if") " (s->font == " (span (|@| (class "constant") (id "F:631818")) "NULL") " || glyph_not_available_p)\n    {\n      s->font_not_found_p = 1;\n      s->font = FRAME_FONT (s->f);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:631930")) "/* ") (span (|@| (class "comment") (id "F:631933")) "Adjust base line for subscript/superscript text.  ") (span (|@| (class "comment-delimiter") (id "F:631983")) "*/") "\n  s->ybase += voffset;\n\n  xassert (s->face && s->face->gc);\n  " (span (|@| (class "keyword") (id "F:632048")) "return") " glyph - s->row->glyphs[s->area];\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:632092")) "/* ") (span (|@| (class "comment") (id "F:632095")) "Fill glyph string S from image glyph S->first_glyph.  ") (span (|@| (class "comment-delimiter") (id "F:632149")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:632153")) "static") " " (span (|@| (class "type") (id "F:632160")) "void") "\n" (span (|@| (class "function-name") (id "F:632165")) "fill_image_glyph_string") " (s)\n     " (span (|@| (class "keyword") (id "F:632198")) "struct") " " (span (|@| (class "type") (id "F:632205")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:632219")) "s") ";\n{\n  xassert (s->first_glyph->type == IMAGE_GLYPH);\n  s->img = IMAGE_FROM_ID (s->f, s->first_glyph->u.img_id);\n  xassert (s->img);\n  s->slice = s->first_glyph->slice;\n  s->face = FACE_FROM_ID (s->f, s->first_glyph->face_id);\n  s->font = s->face->font;\n  s->width = s->first_glyph->pixel_width;\n\n  " (span (|@| (class "comment-delimiter") (id "F:632518")) "/* ") (span (|@| (class "comment") (id "F:632521")) "Adjust base line for subscript/superscript text.  ") (span (|@| (class "comment-delimiter") (id "F:632571")) "*/") "\n  s->ybase += s->first_glyph->voffset;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:632617")) "/* ") (span (|@| (class "comment") (id "F:632620")) "Fill glyph string S from a sequence of stretch glyphs.\n\n   ROW is the glyph row in which the glyphs are found, AREA is the\n   area within the row.  START is the index of the first glyph to\n   consider, END is the index of the last + 1.\n\n   Value is the index of the first glyph not in S.  ") (span (|@| (class "comment-delimiter") (id "F:632909")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:632913")) "static") " " (span (|@| (class "type") (id "F:632920")) "int") "\n" (span (|@| (class "function-name") (id "F:632924")) "fill_stretch_glyph_string") " (s, row, area, start, end)\n     " (span (|@| (class "keyword") (id "F:632982")) "struct") " " (span (|@| (class "type") (id "F:632989")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:633003")) "s") ";\n     " (span (|@| (class "keyword") (id "F:633011")) "struct") " " (span (|@| (class "type") (id "F:633018")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:633029")) "row") ";\n     " (span (|@| (class "keyword") (id "F:633039")) "enum") " " (span (|@| (class "type") (id "F:633044")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:633059")) "area") ";\n     " (span (|@| (class "type") (id "F:633070")) "int") " " (span (|@| (class "variable-name") (id "F:633074")) "start") ", " (span (|@| (class "variable-name") (id "F:633081")) "end") ";\n{\n  " (span (|@| (class "keyword") (id "F:633090")) "struct") " " (span (|@| (class "type") (id "F:633097")) "glyph") " *" (span (|@| (class "variable-name") (id "F:633104")) "glyph") ", *" (span (|@| (class "variable-name") (id "F:633112")) "last") ";\n  " (span (|@| (class "type") (id "F:633120")) "int") " " (span (|@| (class "variable-name") (id "F:633124")) "voffset") ", " (span (|@| (class "variable-name") (id "F:633133")) "face_id") ";\n\n  xassert (s->first_glyph->type == STRETCH_GLYPH);\n\n  glyph = s->row->glyphs[s->area] + start;\n  last = s->row->glyphs[s->area] + end;\n  face_id = glyph->face_id;\n  s->face = FACE_FROM_ID (s->f, face_id);\n  s->font = s->face->font;\n  s->width = glyph->pixel_width;\n  s->nchars = 1;\n  voffset = glyph->voffset;\n\n  " (span (|@| (class "keyword") (id "F:633456")) "for") " (++glyph;\n       (glyph < last\n        && glyph->type == STRETCH_GLYPH\n        && glyph->voffset == voffset\n        && glyph->face_id == face_id);\n       ++glyph)\n    s->width += glyph->pixel_width;\n\n  " (span (|@| (class "comment-delimiter") (id "F:633641")) "/* ") (span (|@| (class "comment") (id "F:633644")) "Adjust base line for subscript/superscript text.  ") (span (|@| (class "comment-delimiter") (id "F:633694")) "*/") "\n  s->ybase += voffset;\n\n  " (span (|@| (class "comment-delimiter") (id "F:633723")) "/* ") (span (|@| (class "comment") (id "F:633726")) "The case that face->gc == 0 is handled when drawing the glyph\n     string by calling PREPARE_FACE_FOR_DISPLAY.  ") (span (|@| (class "comment-delimiter") (id "F:633838")) "*/") "\n  xassert (s->face);\n  " (span (|@| (class "keyword") (id "F:633864")) "return") " glyph - s->row->glyphs[s->area];\n}\n\n" (span (|@| (class "keyword") (id "F:633907")) "static") " " (span (|@| (class "keyword") (id "F:633914")) "struct") " " (span (|@| (class "type") (id "F:633921")) "font_metrics") " *\n" (span (|@| (class "function-name") (id "F:633936")) "get_per_char_metric") " (f, " (span (|@| (class "type") (id "F:633960")) "font") ", char2b)\n     " (span (|@| (class "keyword") (id "F:633979")) "struct") " " (span (|@| (class "type") (id "F:633986")) "frame") " *" (span (|@| (class "variable-name") (id "F:633993")) "f") ";\n     " (span (|@| (class "keyword") (id "F:634001")) "struct") " " (span (|@| (class "type") (id "F:634008")) "font") " *" (span (|@| (class "variable-name") (id "F:634014")) "font") ";\n     " (span (|@| (class "type") (id "F:634025")) "XChar2b") " *" (span (|@| (class "variable-name") (id "F:634034")) "char2b") ";\n{\n  " (span (|@| (class "keyword") (id "F:634046")) "static") " " (span (|@| (class "keyword") (id "F:634053")) "struct") " " (span (|@| (class "type") (id "F:634060")) "font_metrics") " " (span (|@| (class "variable-name") (id "F:634073")) "metrics") ";\n  " (span (|@| (class "type") (id "F:634084")) "unsigned") " " (span (|@| (class "variable-name") (id "F:634093")) "code") " = (XCHAR2B_BYTE1 (char2b) << 8) | XCHAR2B_BYTE2 (char2b);\n\n  " (span (|@| (class "keyword") (id "F:634159")) "if") " (" (span (|@| (class "negation-char") (id "F:634163")) "!") " font || code == FONT_INVALID_CODE)\n    " (span (|@| (class "keyword") (id "F:634204")) "return") " " (span (|@| (class "constant") (id "F:634211")) "NULL") ";\n  font->driver->text_extents (font, &code, 1, &metrics);\n  " (span (|@| (class "keyword") (id "F:634276")) "return") " &metrics;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:634296")) "/* ") (span (|@| (class "comment") (id "F:634299")) "EXPORT for RIF:\n   Set *LEFT and *RIGHT to the left and right overhang of GLYPH on\n   frame F.  Overhangs of glyphs other than type CHAR_GLYPH are\n   assumed to be zero.  ") (span (|@| (class "comment-delimiter") (id "F:634470")) "*/") "\n\n" (span (|@| (class "type") (id "F:634474")) "void") "\n" (span (|@| (class "function-name") (id "F:634479")) "x_get_glyph_overhangs") " (" (span (|@| (class "type") (id "F:634502")) "glyph") ", f, left, right)\n     " (span (|@| (class "keyword") (id "F:634530")) "struct") " " (span (|@| (class "type") (id "F:634537")) "glyph") " *" (span (|@| (class "variable-name") (id "F:634544")) "glyph") ";\n     " (span (|@| (class "keyword") (id "F:634556")) "struct") " " (span (|@| (class "type") (id "F:634563")) "frame") " *" (span (|@| (class "variable-name") (id "F:634570")) "f") ";\n     " (span (|@| (class "type") (id "F:634578")) "int") " *" (span (|@| (class "variable-name") (id "F:634583")) "left") ", *" (span (|@| (class "variable-name") (id "F:634590")) "right") ";\n{\n  *left = *right = 0;\n\n  " (span (|@| (class "keyword") (id "F:634624")) "if") " (glyph->type == CHAR_GLYPH)\n    {\n      " (span (|@| (class "keyword") (id "F:634667")) "struct") " " (span (|@| (class "type") (id "F:634674")) "face") " *" (span (|@| (class "variable-name") (id "F:634680")) "face") ";\n      " (span (|@| (class "type") (id "F:634692")) "XChar2b") " " (span (|@| (class "variable-name") (id "F:634700")) "char2b") ";\n      " (span (|@| (class "keyword") (id "F:634714")) "struct") " " (span (|@| (class "type") (id "F:634721")) "font_metrics") " *" (span (|@| (class "variable-name") (id "F:634735")) "pcm") ";\n\n      face = get_glyph_face_and_encoding (f, glyph, &char2b, " (span (|@| (class "constant") (id "F:634802")) "NULL") ");\n      " (span (|@| (class "keyword") (id "F:634815")) "if") " (face->font && (pcm = get_per_char_metric (f, face->font, &char2b)))\n        {\n          " (span (|@| (class "keyword") (id "F:634893")) "if") " (pcm->rbearing > pcm->width)\n            *right = pcm->rbearing - pcm->width;\n          " (span (|@| (class "keyword") (id "F:634970")) "if") " (pcm->lbearing < 0)\n            *left = -pcm->lbearing;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:635033")) "else") " " (span (|@| (class "keyword") (id "F:635038")) "if") " (glyph->type == COMPOSITE_GLYPH)\n    {\n      " (span (|@| (class "keyword") (id "F:635086")) "if") " (" (span (|@| (class "negation-char") (id "F:635090")) "!") " glyph->u.cmp.automatic)\n        {\n          " (span (|@| (class "keyword") (id "F:635122")) "struct") " " (span (|@| (class "type") (id "F:635129")) "composition") " *" (span (|@| (class "variable-name") (id "F:635142")) "cmp") " = composition_table[glyph->u.cmp.id];\n\n          " (span (|@| (class "keyword") (id "F:635188")) "if") " (cmp->rbearing > cmp->pixel_width)\n            *right = cmp->rbearing - cmp->pixel_width;\n          " (span (|@| (class "keyword") (id "F:635277")) "if") " (cmp->lbearing < 0)\n            *left = - cmp->lbearing;\n        }\n      " (span (|@| (class "keyword") (id "F:635339")) "else") "\n        {\n          " (span (|@| (class "type") (id "F:635350")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:635362")) "gstring") " = composition_gstring_from_id (glyph->u.cmp.id);\n          " (span (|@| (class "keyword") (id "F:635422")) "struct") " " (span (|@| (class "type") (id "F:635429")) "font_metrics") " " (span (|@| (class "variable-name") (id "F:635442")) "metrics") ";\n\n          composition_gstring_width (gstring, glyph->u.cmp.from,\n                                     glyph->u.cmp.to + 1, &metrics);\n          " (span (|@| (class "keyword") (id "F:635554")) "if") " (metrics.rbearing > metrics.width)\n            *right = metrics.rbearing - metrics.width;\n          " (span (|@| (class "keyword") (id "F:635643")) "if") " (metrics.lbearing < 0)\n            *left = - metrics.lbearing;\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:635715")) "/* ") (span (|@| (class "comment") (id "F:635718")) "Return the index of the first glyph preceding glyph string S that\n   is overwritten by S because of S's left overhang.  Value is -1\n   if no glyphs are overwritten.  ") (span (|@| (class "comment-delimiter") (id "F:635884")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:635888")) "static") " " (span (|@| (class "type") (id "F:635895")) "int") "\n" (span (|@| (class "function-name") (id "F:635899")) "left_overwritten") " (s)\n     " (span (|@| (class "keyword") (id "F:635925")) "struct") " " (span (|@| (class "type") (id "F:635932")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:635946")) "s") ";\n{\n  " (span (|@| (class "type") (id "F:635953")) "int") " " (span (|@| (class "variable-name") (id "F:635957")) "k") ";\n\n  " (span (|@| (class "keyword") (id "F:635963")) "if") " (s->left_overhang)\n    {\n      " (span (|@| (class "type") (id "F:635997")) "int") " " (span (|@| (class "variable-name") (id "F:636001")) "x") " = 0, " (span (|@| (class "variable-name") (id "F:636008")) "i") ";\n      " (span (|@| (class "keyword") (id "F:636017")) "struct") " " (span (|@| (class "type") (id "F:636024")) "glyph") " *" (span (|@| (class "variable-name") (id "F:636031")) "glyphs") " = s->row->glyphs[s->area];\n      " (span (|@| (class "type") (id "F:636071")) "int") " " (span (|@| (class "variable-name") (id "F:636075")) "first") " = s->first_glyph - glyphs;\n\n      " (span (|@| (class "keyword") (id "F:636115")) "for") " (i = first - 1; i >= 0 && x > -s->left_overhang; --i)\n        x -= glyphs[i].pixel_width;\n\n      k = i + 1;\n    }\n  " (span (|@| (class "keyword") (id "F:636228")) "else") "\n    k = -1;\n\n  " (span (|@| (class "keyword") (id "F:636248")) "return") " k;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:636262")) "/* ") (span (|@| (class "comment") (id "F:636265")) "Return the index of the first glyph preceding glyph string S that\n   is overwriting S because of its right overhang.  Value is -1 if no\n   glyph in front of S overwrites S.  ") (span (|@| (class "comment-delimiter") (id "F:636439")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:636443")) "static") " " (span (|@| (class "type") (id "F:636450")) "int") "\n" (span (|@| (class "function-name") (id "F:636454")) "left_overwriting") " (s)\n     " (span (|@| (class "keyword") (id "F:636480")) "struct") " " (span (|@| (class "type") (id "F:636487")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:636501")) "s") ";\n{\n  " (span (|@| (class "type") (id "F:636508")) "int") " " (span (|@| (class "variable-name") (id "F:636512")) "i") ", " (span (|@| (class "variable-name") (id "F:636515")) "k") ", " (span (|@| (class "variable-name") (id "F:636518")) "x") ";\n  " (span (|@| (class "keyword") (id "F:636523")) "struct") " " (span (|@| (class "type") (id "F:636530")) "glyph") " *" (span (|@| (class "variable-name") (id "F:636537")) "glyphs") " = s->row->glyphs[s->area];\n  " (span (|@| (class "type") (id "F:636573")) "int") " " (span (|@| (class "variable-name") (id "F:636577")) "first") " = s->first_glyph - glyphs;\n\n  k = -1;\n  x = 0;\n  " (span (|@| (class "keyword") (id "F:636632")) "for") " (i = first - 1; i >= 0; --i)\n    {\n      " (span (|@| (class "type") (id "F:636677")) "int") " " (span (|@| (class "variable-name") (id "F:636681")) "left") ", " (span (|@| (class "variable-name") (id "F:636687")) "right") ";\n      x_get_glyph_overhangs (glyphs + i, s->f, &left, &right);\n      " (span (|@| (class "keyword") (id "F:636763")) "if") " (x + right > 0)\n        k = i;\n      x -= glyphs[i].pixel_width;\n    }\n\n  " (span (|@| (class "keyword") (id "F:636833")) "return") " k;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:636847")) "/* ") (span (|@| (class "comment") (id "F:636850")) "Return the index of the last glyph following glyph string S that is\n   overwritten by S because of S's right overhang.  Value is -1 if\n   no such glyph is found.  ") (span (|@| (class "comment-delimiter") (id "F:637013")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:637017")) "static") " " (span (|@| (class "type") (id "F:637024")) "int") "\n" (span (|@| (class "function-name") (id "F:637028")) "right_overwritten") " (s)\n     " (span (|@| (class "keyword") (id "F:637055")) "struct") " " (span (|@| (class "type") (id "F:637062")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:637076")) "s") ";\n{\n  " (span (|@| (class "type") (id "F:637083")) "int") " " (span (|@| (class "variable-name") (id "F:637087")) "k") " = -1;\n\n  " (span (|@| (class "keyword") (id "F:637098")) "if") " (s->right_overhang)\n    {\n      " (span (|@| (class "type") (id "F:637133")) "int") " " (span (|@| (class "variable-name") (id "F:637137")) "x") " = 0, " (span (|@| (class "variable-name") (id "F:637144")) "i") ";\n      " (span (|@| (class "keyword") (id "F:637153")) "struct") " " (span (|@| (class "type") (id "F:637160")) "glyph") " *" (span (|@| (class "variable-name") (id "F:637167")) "glyphs") " = s->row->glyphs[s->area];\n      " (span (|@| (class "type") (id "F:637207")) "int") " " (span (|@| (class "variable-name") (id "F:637211")) "first") " = (s->first_glyph - glyphs) + (s->cmp ? 1 : s->nchars);\n      " (span (|@| (class "type") (id "F:637279")) "int") " " (span (|@| (class "variable-name") (id "F:637283")) "end") " = s->row->used[s->area];\n\n      " (span (|@| (class "keyword") (id "F:637319")) "for") " (i = first; i < end && s->right_overhang > x; ++i)\n        x += glyphs[i].pixel_width;\n\n      k = i;\n    }\n\n  " (span (|@| (class "keyword") (id "F:637426")) "return") " k;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:637440")) "/* ") (span (|@| (class "comment") (id "F:637443")) "Return the index of the last glyph following glyph string S that\n   overwrites S because of its left overhang.  Value is negative\n   if no such glyph is found.  ") (span (|@| (class "comment-delimiter") (id "F:637604")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:637608")) "static") " " (span (|@| (class "type") (id "F:637615")) "int") "\n" (span (|@| (class "function-name") (id "F:637619")) "right_overwriting") " (s)\n     " (span (|@| (class "keyword") (id "F:637646")) "struct") " " (span (|@| (class "type") (id "F:637653")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:637667")) "s") ";\n{\n  " (span (|@| (class "type") (id "F:637674")) "int") " " (span (|@| (class "variable-name") (id "F:637678")) "i") ", " (span (|@| (class "variable-name") (id "F:637681")) "k") ", " (span (|@| (class "variable-name") (id "F:637684")) "x") ";\n  " (span (|@| (class "type") (id "F:637689")) "int") " " (span (|@| (class "variable-name") (id "F:637693")) "end") " = s->row->used[s->area];\n  " (span (|@| (class "keyword") (id "F:637724")) "struct") " " (span (|@| (class "type") (id "F:637731")) "glyph") " *" (span (|@| (class "variable-name") (id "F:637738")) "glyphs") " = s->row->glyphs[s->area];\n  " (span (|@| (class "type") (id "F:637774")) "int") " " (span (|@| (class "variable-name") (id "F:637778")) "first") " = (s->first_glyph - glyphs) + (s->cmp ? 1 : s->nchars);\n\n  k = -1;\n  x = 0;\n  " (span (|@| (class "keyword") (id "F:637862")) "for") " (i = first; i < end; ++i)\n    {\n      " (span (|@| (class "type") (id "F:637904")) "int") " " (span (|@| (class "variable-name") (id "F:637908")) "left") ", " (span (|@| (class "variable-name") (id "F:637914")) "right") ";\n      x_get_glyph_overhangs (glyphs + i, s->f, &left, &right);\n      " (span (|@| (class "keyword") (id "F:637990")) "if") " (x - left < 0)\n        k = i;\n      x += glyphs[i].pixel_width;\n    }\n\n  " (span (|@| (class "keyword") (id "F:638059")) "return") " k;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:638073")) "/* ") (span (|@| (class "comment") (id "F:638076")) "Set background width of glyph string S.  START is the index of the\n   first glyph following S.  LAST_X is the right-most x-position + 1\n   in the drawing area.  ") (span (|@| (class "comment-delimiter") (id "F:638237")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:638241")) "static") " INLINE " (span (|@| (class "type") (id "F:638255")) "void") "\n" (span (|@| (class "function-name") (id "F:638260")) "set_glyph_string_background_width") " (s, start, last_x)\n     " (span (|@| (class "keyword") (id "F:638318")) "struct") " " (span (|@| (class "type") (id "F:638325")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:638339")) "s") ";\n     " (span (|@| (class "type") (id "F:638347")) "int") " " (span (|@| (class "variable-name") (id "F:638351")) "start") ";\n     " (span (|@| (class "type") (id "F:638363")) "int") " " (span (|@| (class "variable-name") (id "F:638367")) "last_x") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:638379")) "/* ") (span (|@| (class "comment") (id "F:638382")) "If the face of this glyph string has to be drawn to the end of\n     the drawing area, set S->extends_to_end_of_line_p.  ") (span (|@| (class "comment-delimiter") (id "F:638502")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:638508")) "if") " (start == s->row->used[s->area]\n      && s->area == TEXT_AREA\n      && ((s->row->fill_line_p\n           && (s->hl == DRAW_NORMAL_TEXT\n               || s->hl == DRAW_IMAGE_RAISED\n               || s->hl == DRAW_IMAGE_SUNKEN))\n          || s->hl == DRAW_MOUSE_FACE))\n    s->extends_to_end_of_line_p = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:638789")) "/* ") (span (|@| (class "comment") (id "F:638792")) "If S extends its face to the end of the line, set its\n     background_width to the distance to the right edge of the drawing\n     area.  ") (span (|@| (class "comment-delimiter") (id "F:638929")) "*/") "\n  " (span (|@| (class "keyword") (id "F:638934")) "if") " (s->extends_to_end_of_line_p)\n    s->background_width = last_x - s->x + 1;\n  " (span (|@| (class "keyword") (id "F:639014")) "else") "\n    s->background_width = s->width;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:639059")) "/* ") (span (|@| (class "comment") (id "F:639062")) "Compute overhangs and x-positions for glyph string S and its\n   predecessors, or successors.  X is the starting x-position for S.\n   BACKWARD_P non-zero means process predecessors.  ") (span (|@| (class "comment-delimiter") (id "F:639244")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:639248")) "static") " " (span (|@| (class "type") (id "F:639255")) "void") "\n" (span (|@| (class "function-name") (id "F:639260")) "compute_overhangs_and_x") " (s, x, backward_p)\n     " (span (|@| (class "keyword") (id "F:639308")) "struct") " " (span (|@| (class "type") (id "F:639315")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:639329")) "s") ";\n     " (span (|@| (class "type") (id "F:639337")) "int") " " (span (|@| (class "variable-name") (id "F:639341")) "x") ";\n     " (span (|@| (class "type") (id "F:639349")) "int") " " (span (|@| (class "variable-name") (id "F:639353")) "backward_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:639369")) "if") " (backward_p)\n    {\n      " (span (|@| (class "keyword") (id "F:639397")) "while") " (s)\n        {\n          " (span (|@| (class "keyword") (id "F:639413")) "if") " (FRAME_RIF (s->f)->compute_glyph_string_overhangs)\n            FRAME_RIF (s->f)->compute_glyph_string_overhangs (s);\n          x -= s->width;\n          s->x = x;\n          s = s->prev;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:639584")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:639601")) "while") " (s)\n        {\n          " (span (|@| (class "keyword") (id "F:639617")) "if") " (FRAME_RIF (s->f)->compute_glyph_string_overhangs)\n            FRAME_RIF (s->f)->compute_glyph_string_overhangs (s);\n          s->x = x;\n          x += s->width;\n          s = s->next;\n        }\n    }\n}\n\n\n\n" (span (|@| (class "comment-delimiter") (id "F:639791")) "/* ") (span (|@| (class "comment") (id "F:639794")) "The following macros are only called from draw_glyphs below.\n   They reference the following parameters of that function directly:\n     `w', `row', `area', and `overlap_p'\n   as well as the following local variables:\n     `s', `f', and `hdc' (in W32)  ") (span (|@| (class "comment-delimiter") (id "F:640046")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:640050")) "#ifdef") " HAVE_NTGUI\n" (span (|@| (class "comment-delimiter") (id "F:640068")) "/* ") (span (|@| (class "comment") (id "F:640071")) "On W32, silently add local `hdc' variable to argument list of\n   init_glyph_string.  ") (span (|@| (class "comment-delimiter") (id "F:640156")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:640159")) "#define") " " (span (|@| (class "function-name") (id "F:640167")) "INIT_GLYPH_STRING") "(" (span (|@| (class "variable-name") (id "F:640185")) "s") ", " (span (|@| (class "variable-name") (id "F:640188")) "char2b") ", " (span (|@| (class "variable-name") (id "F:640196")) "w") ", " (span (|@| (class "variable-name") (id "F:640199")) "row") ", " (span (|@| (class "variable-name") (id "F:640204")) "area") ", " (span (|@| (class "variable-name") (id "F:640210")) "start") ", " (span (|@| (class "variable-name") (id "F:640217")) "hl") ") \\\n  init_glyph_string (s, hdc, char2b, w, row, area, start, hl)\n" (span (|@| (class "preprocessor") (id "F:640285")) "#else") "\n" (span (|@| (class "preprocessor") (id "F:640291")) "#define") " " (span (|@| (class "function-name") (id "F:640299")) "INIT_GLYPH_STRING") "(" (span (|@| (class "variable-name") (id "F:640317")) "s") ", " (span (|@| (class "variable-name") (id "F:640320")) "char2b") ", " (span (|@| (class "variable-name") (id "F:640328")) "w") ", " (span (|@| (class "variable-name") (id "F:640331")) "row") ", " (span (|@| (class "variable-name") (id "F:640336")) "area") ", " (span (|@| (class "variable-name") (id "F:640342")) "start") ", " (span (|@| (class "variable-name") (id "F:640349")) "hl") ") \\\n  init_glyph_string (s, char2b, w, row, area, start, hl)\n" (span (|@| (class "preprocessor") (id "F:640412")) "#endif") "\n\n" (span (|@| (class "comment-delimiter") (id "F:640420")) "/* ") (span (|@| (class "comment") (id "F:640423")) "Add a glyph string for a stretch glyph to the list of strings\n   between HEAD and TAIL.  START is the index of the stretch glyph in\n   row area AREA of glyph row ROW.  END is the index of the last glyph\n   in that glyph row area.  X is the current output position assigned\n   to the new glyph string constructed.  HL overrides that face of the\n   glyph; e.g. it is DRAW_CURSOR if a cursor has to be drawn.  LAST_X\n   is the right-most x-position of the drawing area.  ") (span (|@| (class "comment-delimiter") (id "F:640891")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:640895")) "/* ") (span (|@| (class "comment") (id "F:640898")) "SunOS 4 bundled cc, barfed on continuations in the arg lists here\n   and below -- keep them on one line.  ") (span (|@| (class "comment-delimiter") (id "F:641004")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:641007")) "#define") " " (span (|@| (class "function-name") (id "F:641015")) "BUILD_STRETCH_GLYPH_STRING") "(" (span (|@| (class "variable-name") (id "F:641042")) "START") ", " (span (|@| (class "variable-name") (id "F:641049")) "END") ", " (span (|@| (class "variable-name") (id "F:641054")) "HEAD") ", " (span (|@| (class "variable-name") (id "F:641060")) "TAIL") ", " (span (|@| (class "variable-name") (id "F:641066")) "HL") ", " (span (|@| (class "variable-name") (id "F:641070")) "X") ", " (span (|@| (class "variable-name") (id "F:641073")) "LAST_X") ")   \\\n     " (span (|@| (class "keyword") (id "F:641090")) "do") "                                                                     \\\n       {                                                                    \\\n         s = (" (span (|@| (class "keyword") (id "F:641136")) "struct") " " (span (|@| (class "type") (id "F:641143")) "glyph_string") " *) alloca (" (span (|@| (class "keyword") (id "F:641167")) "sizeof") " *s);                    \\\n         INIT_GLYPH_STRING (s, " (span (|@| (class "constant") (id "F:641210")) "NULL") ", w, row, area, START, HL);              \\\n         START = fill_stretch_glyph_string (s, row, area, START, END);      \\\n         append_glyph_string (&HEAD, &TAIL, s);                             \\\n         s->x = (X);                                                        \\\n       }                                                                    \\\n     " (span (|@| (class "keyword") (id "F:641429")) "while") " (0)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:641441")) "/* ") (span (|@| (class "comment") (id "F:641444")) "Add a glyph string for an image glyph to the list of strings\n   between HEAD and TAIL.  START is the index of the image glyph in\n   row area AREA of glyph row ROW.  END is the index of the last glyph\n   in that glyph row area.  X is the current output position assigned\n   to the new glyph string constructed.  HL overrides that face of the\n   glyph; e.g. it is DRAW_CURSOR if a cursor has to be drawn.  LAST_X\n   is the right-most x-position of the drawing area.  ") (span (|@| (class "comment-delimiter") (id "F:641909")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:641913")) "#define") " " (span (|@| (class "function-name") (id "F:641921")) "BUILD_IMAGE_GLYPH_STRING") "(" (span (|@| (class "variable-name") (id "F:641946")) "START") ", " (span (|@| (class "variable-name") (id "F:641953")) "END") ", " (span (|@| (class "variable-name") (id "F:641958")) "HEAD") ", " (span (|@| (class "variable-name") (id "F:641964")) "TAIL") ", " (span (|@| (class "variable-name") (id "F:641970")) "HL") ", " (span (|@| (class "variable-name") (id "F:641974")) "X") ", " (span (|@| (class "variable-name") (id "F:641977")) "LAST_X") ") \\\n     " (span (|@| (class "keyword") (id "F:641992")) "do") "                                                                 \\\n       {                                                                \\\n         s = (" (span (|@| (class "keyword") (id "F:642030")) "struct") " " (span (|@| (class "type") (id "F:642037")) "glyph_string") " *) alloca (" (span (|@| (class "keyword") (id "F:642061")) "sizeof") " *s);                \\\n         INIT_GLYPH_STRING (s, " (span (|@| (class "constant") (id "F:642100")) "NULL") ", w, row, area, START, HL);          \\\n         fill_image_glyph_string (s);                                   \\\n         append_glyph_string (&HEAD, &TAIL, s);                         \\\n         ++START;                                                       \\\n         s->x = (X);                                                    \\\n       }                                                                \\\n     " (span (|@| (class "keyword") (id "F:642289")) "while") " (0)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:642301")) "/* ") (span (|@| (class "comment") (id "F:642304")) "Add a glyph string for a sequence of character glyphs to the list\n   of strings between HEAD and TAIL.  START is the index of the first\n   glyph in row area AREA of glyph row ROW that is part of the new\n   glyph string.  END is the index of the last glyph in that glyph row\n   area.  X is the current output position assigned to the new glyph\n   string constructed.  HL overrides that face of the glyph; e.g. it\n   is DRAW_CURSOR if a cursor has to be drawn.  LAST_X is the\n   right-most x-position of the drawing area.  ") (span (|@| (class "comment-delimiter") (id "F:642825")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:642829")) "#define") " " (span (|@| (class "function-name") (id "F:642837")) "BUILD_CHAR_GLYPH_STRINGS") "(" (span (|@| (class "variable-name") (id "F:642862")) "START") ", " (span (|@| (class "variable-name") (id "F:642869")) "END") ", " (span (|@| (class "variable-name") (id "F:642874")) "HEAD") ", " (span (|@| (class "variable-name") (id "F:642880")) "TAIL") ", " (span (|@| (class "variable-name") (id "F:642886")) "HL") ", " (span (|@| (class "variable-name") (id "F:642890")) "X") ", " (span (|@| (class "variable-name") (id "F:642893")) "LAST_X") ")    \\\n     " (span (|@| (class "keyword") (id "F:642911")) "do") "                                                                    \\\n       {                                                                   \\\n         " (span (|@| (class "type") (id "F:642950")) "int") " " (span (|@| (class "variable-name") (id "F:642954")) "face_id") ";                                                      \\\n         " (span (|@| (class "type") (id "F:642976")) "XChar2b") " *" (span (|@| (class "variable-name") (id "F:642985")) "char2b") ";                                                  \\\n                                                                           \\\n         face_id = (row)->glyphs[area][START].face_id;                     \\\n                                                                           \\\n         s = (" (span (|@| (class "keyword") (id "F:643093")) "struct") " " (span (|@| (class "type") (id "F:643100")) "glyph_string") " *) alloca (" (span (|@| (class "keyword") (id "F:643124")) "sizeof") " *s);                   \\\n         char2b = (" (span (|@| (class "type") (id "F:643154")) "XChar2b") " *) alloca ((END - START) * " (span (|@| (class "keyword") (id "F:643189")) "sizeof") " *char2b);     \\\n         INIT_GLYPH_STRING (s, char2b, w, row, area, START, HL);           \\\n         append_glyph_string (&HEAD, &TAIL, s);                            \\\n         s->x = (X);                                                       \\\n         START = fill_glyph_string (s, face_id, START, END, overlaps);     \\\n       }                                                                   \\\n     " (span (|@| (class "keyword") (id "F:643443")) "while") " (0)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:643455")) "/* ") (span (|@| (class "comment") (id "F:643458")) "Add a glyph string for a composite sequence to the list of strings\n   between HEAD and TAIL.  START is the index of the first glyph in\n   row area AREA of glyph row ROW that is part of the new glyph\n   string.  END is the index of the last glyph in that glyph row area.\n   X is the current output position assigned to the new glyph string\n   constructed.  HL overrides that face of the glyph; e.g. it is\n   DRAW_CURSOR if a cursor has to be drawn.  LAST_X is the right-most\n   x-position of the drawing area.  ") (span (|@| (class "comment-delimiter") (id "F:643968")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:643972")) "#define") " " (span (|@| (class "function-name") (id "F:643980")) "BUILD_COMPOSITE_GLYPH_STRING") "(" (span (|@| (class "variable-name") (id "F:644009")) "START") ", " (span (|@| (class "variable-name") (id "F:644016")) "END") ", " (span (|@| (class "variable-name") (id "F:644021")) "HEAD") ", " (span (|@| (class "variable-name") (id "F:644027")) "TAIL") ", " (span (|@| (class "variable-name") (id "F:644033")) "HL") ", " (span (|@| (class "variable-name") (id "F:644037")) "X") ", " (span (|@| (class "variable-name") (id "F:644040")) "LAST_X") ") \\\n  " (span (|@| (class "keyword") (id "F:644052")) "do") " {                                                                      \\\n    " (span (|@| (class "type") (id "F:644075")) "int") " " (span (|@| (class "variable-name") (id "F:644079")) "face_id") " = (row)->glyphs[area][START].face_id;                       \\\n    " (span (|@| (class "keyword") (id "F:644137")) "struct") " " (span (|@| (class "type") (id "F:644144")) "face") " *" (span (|@| (class "variable-name") (id "F:644150")) "base_face") " = FACE_FROM_ID (f, face_id);                     \\\n    " (span (|@| (class "type") (id "F:644201")) "int") " " (span (|@| (class "variable-name") (id "F:644205")) "cmp_id") " = (row)->glyphs[area][START].u.cmp.id;                       \\\n    " (span (|@| (class "keyword") (id "F:644263")) "struct") " " (span (|@| (class "type") (id "F:644270")) "composition") " *" (span (|@| (class "variable-name") (id "F:644283")) "cmp") " = composition_table[cmp_id];                    \\\n    " (span (|@| (class "type") (id "F:644327")) "XChar2b") " *" (span (|@| (class "variable-name") (id "F:644336")) "char2b") ";                                                        \\\n    " (span (|@| (class "keyword") (id "F:644360")) "struct") " " (span (|@| (class "type") (id "F:644367")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:644381")) "first_s") ";                                           \\\n    " (span (|@| (class "type") (id "F:644404")) "int") " " (span (|@| (class "variable-name") (id "F:644408")) "n") ";                                                                  \\\n                                                                            \\\n    char2b = (" (span (|@| (class "type") (id "F:644457")) "XChar2b") " *) alloca ((" (span (|@| (class "keyword") (id "F:644477")) "sizeof") " *char2b) * cmp->glyph_len);        \\\n                                                                            \\\n    " (span (|@| (class "comment-delimiter") (id "F:644541")) "/* ") (span (|@| (class "comment") (id "F:644544")) "Make glyph_strings for each glyph sequence that is drawable by       \\\n       the same face, and append them to HEAD/TAIL.  ") (span (|@| (class "comment-delimiter") (id "F:644666")) "*/") "                     \\\n    " (span (|@| (class "keyword") (id "F:644681")) "for") " (n = 0; n < cmp->glyph_len;)                                        \\\n      {                                                                     \\\n        s = (" (span (|@| (class "keyword") (id "F:644752")) "struct") " " (span (|@| (class "type") (id "F:644759")) "glyph_string") " *) alloca (" (span (|@| (class "keyword") (id "F:644783")) "sizeof") " *s);                     \\\n        INIT_GLYPH_STRING (s, char2b, w, row, area, START, HL);             \\\n        append_glyph_string (&(HEAD), &(TAIL), s);                          \\\n        s->cmp = cmp;                                                       \\\n        s->cmp_from = n;                                                    \\\n        s->x = (X);                                                         \\\n        " (span (|@| (class "keyword") (id "F:645001")) "if") " (n == 0)                                                         \\\n          first_s = s;                                                      \\\n        n = fill_composite_glyph_string (s, base_face, overlaps);           \\\n      }                                                                     \\\n                                                                            \\\n    ++START;                                                                \\\n    s = first_s;                                                            \\\n  } " (span (|@| (class "keyword") (id "F:645218")) "while") " (0)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:645230")) "/* ") (span (|@| (class "comment") (id "F:645233")) "Add a glyph string for a glyph-string sequence to the list of strings\n   between HEAD and TAIL.  ") (span (|@| (class "comment-delimiter") (id "F:645330")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:645334")) "#define") " " (span (|@| (class "function-name") (id "F:645342")) "BUILD_GSTRING_GLYPH_STRING") "(" (span (|@| (class "variable-name") (id "F:645369")) "START") ", " (span (|@| (class "variable-name") (id "F:645376")) "END") ", " (span (|@| (class "variable-name") (id "F:645381")) "HEAD") ", " (span (|@| (class "variable-name") (id "F:645387")) "TAIL") ", " (span (|@| (class "variable-name") (id "F:645393")) "HL") ", " (span (|@| (class "variable-name") (id "F:645397")) "X") ", " (span (|@| (class "variable-name") (id "F:645400")) "LAST_X") ") \\\n  " (span (|@| (class "keyword") (id "F:645412")) "do") " {                                                                    \\\n    " (span (|@| (class "type") (id "F:645433")) "int") " " (span (|@| (class "variable-name") (id "F:645437")) "face_id") ";                                                          \\\n    " (span (|@| (class "type") (id "F:645460")) "XChar2b") " *" (span (|@| (class "variable-name") (id "F:645469")) "char2b") ";                                                      \\\n    " (span (|@| (class "type") (id "F:645491")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:645503")) "gstring") ";                                                  \\\n                                                                          \\\n    face_id = (row)->glyphs[area][START].face_id;                         \\\n    gstring = (composition_gstring_from_id                                \\\n               ((row)->glyphs[area][START].u.cmp.id));                    \\\n    s = (" (span (|@| (class "keyword") (id "F:645707")) "struct") " " (span (|@| (class "type") (id "F:645714")) "glyph_string") " *) alloca (" (span (|@| (class "keyword") (id "F:645738")) "sizeof") " *s);                       \\\n    char2b = (" (span (|@| (class "type") (id "F:645770")) "XChar2b") " *) alloca ((" (span (|@| (class "keyword") (id "F:645790")) "sizeof") " *char2b)                         \\\n                                 * LGSTRING_GLYPH_LEN (gstring));         \\\n    INIT_GLYPH_STRING (s, char2b, w, row, area, START, HL);               \\\n    append_glyph_string (&(HEAD), &(TAIL), s);                            \\\n    s->x = (X);                                                           \\\n    START = fill_gstring_glyph_string (s, face_id, START, END, overlaps); \\\n  } " (span (|@| (class "keyword") (id "F:646080")) "while") " (0)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:646092")) "/* ") (span (|@| (class "comment") (id "F:646095")) "Build a list of glyph strings between HEAD and TAIL for the glyphs\n   of AREA of glyph row ROW on window W between indices START and END.\n   HL overrides the face for drawing glyph strings, e.g. it is\n   DRAW_CURSOR to draw a cursor.  X and LAST_X are start and end\n   x-positions of the drawing area.\n\n   This is an ugly monster macro construct because we must use alloca\n   to allocate glyph strings (because draw_glyphs can be called\n   asynchronously).  ") (span (|@| (class "comment-delimiter") (id "F:646553")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:646557")) "#define") " " (span (|@| (class "function-name") (id "F:646565")) "BUILD_GLYPH_STRINGS") "(" (span (|@| (class "variable-name") (id "F:646585")) "START") ", " (span (|@| (class "variable-name") (id "F:646592")) "END") ", " (span (|@| (class "variable-name") (id "F:646597")) "HEAD") ", " (span (|@| (class "variable-name") (id "F:646603")) "TAIL") ", " (span (|@| (class "variable-name") (id "F:646609")) "HL") ", " (span (|@| (class "variable-name") (id "F:646613")) "X") ", " (span (|@| (class "variable-name") (id "F:646616")) "LAST_X") ")      \\\n  " (span (|@| (class "keyword") (id "F:646628")) "do") "                                                                    \\\n    {                                                                   \\\n      HEAD = TAIL = " (span (|@| (class "constant") (id "F:646677")) "NULL") ";                                               \\\n      " (span (|@| (class "keyword") (id "F:646696")) "while") " (START < END)                                               \\\n        {                                                               \\\n          " (span (|@| (class "keyword") (id "F:646738")) "struct") " " (span (|@| (class "type") (id "F:646745")) "glyph") " *" (span (|@| (class "variable-name") (id "F:646752")) "first_glyph") " = (row)->glyphs[area] + START;      \\\n          " (span (|@| (class "keyword") (id "F:646800")) "switch") " (first_glyph->type)                                    \\\n            {                                                           \\\n            " (span (|@| (class "keyword") (id "F:646854")) "case") " CHAR_GLYPH:                                            \\\n              BUILD_CHAR_GLYPH_STRINGS (START, END, HEAD, TAIL,         \\\n                                        HL, X, LAST_X);                 \\\n              " (span (|@| (class "keyword") (id "F:646970")) "break") ";                                                    \\\n                                                                        \\\n            " (span (|@| (class "keyword") (id "F:647007")) "case") " COMPOSITE_GLYPH:                                       \\\n              " (span (|@| (class "keyword") (id "F:647042")) "if") " (first_glyph->u.cmp.automatic)                         \\\n                BUILD_GSTRING_GLYPH_STRING (START, END, HEAD, TAIL,     \\\n                                            HL, X, LAST_X);             \\\n              " (span (|@| (class "keyword") (id "F:647172")) "else") "                                                      \\\n                BUILD_COMPOSITE_GLYPH_STRING (START, END, HEAD, TAIL,   \\\n                                              HL, X, LAST_X);           \\\n              " (span (|@| (class "keyword") (id "F:647280")) "break") ";                                                    \\\n                                                                        \\\n            " (span (|@| (class "keyword") (id "F:647317")) "case") " STRETCH_GLYPH:                                         \\\n              BUILD_STRETCH_GLYPH_STRING (START, END, HEAD, TAIL,       \\\n                                          HL, X, LAST_X);               \\\n              " (span (|@| (class "keyword") (id "F:647438")) "break") ";                                                    \\\n                                                                        \\\n            " (span (|@| (class "keyword") (id "F:647475")) "case") " IMAGE_GLYPH:                                           \\\n              BUILD_IMAGE_GLYPH_STRING (START, END, HEAD, TAIL,         \\\n                                        HL, X, LAST_X);                 \\\n              " (span (|@| (class "keyword") (id "F:647592")) "break") ";                                                    \\\n                                                                        \\\n            " (span (|@| (class "keyword") (id "F:647629")) "default") ":                                                    \\\n              abort ();                                                 \\\n            }                                                           \\\n                                                                        \\\n          " (span (|@| (class "keyword") (id "F:647703")) "if") " (s)                                                        \\\n            {                                                           \\\n              set_glyph_string_background_width (s, START, LAST_X);     \\\n              (X) += s->width;                                          \\\n            }                                                           \\\n        }                                                               \\\n    } " (span (|@| (class "keyword") (id "F:647862")) "while") " (0)\n\n\n" (span (|@| (class "comment-delimiter") (id "F:647874")) "/* ") (span (|@| (class "comment") (id "F:647877")) "Draw glyphs between START and END in AREA of ROW on window W,\n   starting at x-position X.  X is relative to AREA in W.  HL is a\n   face-override with the following meaning:\n\n   DRAW_NORMAL_TEXT     draw normally\n   DRAW_CURSOR          draw in cursor face\n   DRAW_MOUSE_FACE      draw in mouse face.\n   DRAW_INVERSE_VIDEO   draw in mode line face\n   DRAW_IMAGE_SUNKEN    draw an image with a sunken relief around it\n   DRAW_IMAGE_RAISED    draw an image with a raised relief around it\n\n   If OVERLAPS is non-zero, draw only the foreground of characters and\n   clip to the physical height of ROW.  Non-zero value also defines\n   the overlapping part to be drawn:\n\n   OVERLAPS_PRED                overlap with preceding rows\n   OVERLAPS_SUCC                overlap with succeeding rows\n   OVERLAPS_BOTH                overlap with both preceding/succeeding rows\n   OVERLAPS_ERASED_CURSOR       overlap with erased cursor area\n\n   Value is the x-position reached, relative to AREA of W.  ") (span (|@| (class "comment-delimiter") (id "F:648790")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:648794")) "static") " " (span (|@| (class "type") (id "F:648801")) "int") "\n" (span (|@| (class "function-name") (id "F:648805")) "draw_glyphs") " (w, x, row, area, start, end, hl, overlaps)\n     " (span (|@| (class "keyword") (id "F:648866")) "struct") " " (span (|@| (class "type") (id "F:648873")) "window") " *" (span (|@| (class "variable-name") (id "F:648881")) "w") ";\n     " (span (|@| (class "type") (id "F:648889")) "int") " " (span (|@| (class "variable-name") (id "F:648893")) "x") ";\n     " (span (|@| (class "keyword") (id "F:648901")) "struct") " " (span (|@| (class "type") (id "F:648908")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:648919")) "row") ";\n     " (span (|@| (class "keyword") (id "F:648929")) "enum") " " (span (|@| (class "type") (id "F:648934")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:648949")) "area") ";\n     " (span (|@| (class "type") (id "F:648960")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:648970")) "start") ", " (span (|@| (class "variable-name") (id "F:648977")) "end") ";\n     " (span (|@| (class "keyword") (id "F:648987")) "enum") " " (span (|@| (class "type") (id "F:648992")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:649009")) "hl") ";\n     " (span (|@| (class "type") (id "F:649018")) "int") " " (span (|@| (class "variable-name") (id "F:649022")) "overlaps") ";\n{\n  " (span (|@| (class "keyword") (id "F:649036")) "struct") " " (span (|@| (class "type") (id "F:649043")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:649057")) "head") ", *" (span (|@| (class "variable-name") (id "F:649064")) "tail") ";\n  " (span (|@| (class "keyword") (id "F:649072")) "struct") " " (span (|@| (class "type") (id "F:649079")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:649093")) "s") ";\n  " (span (|@| (class "keyword") (id "F:649098")) "struct") " " (span (|@| (class "type") (id "F:649105")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:649119")) "clip_head") " = " (span (|@| (class "constant") (id "F:649131")) "NULL") ", *" (span (|@| (class "variable-name") (id "F:649138")) "clip_tail") " = " (span (|@| (class "constant") (id "F:649150")) "NULL") ";\n  " (span (|@| (class "type") (id "F:649158")) "int") " " (span (|@| (class "variable-name") (id "F:649162")) "i") ", " (span (|@| (class "variable-name") (id "F:649165")) "j") ", " (span (|@| (class "variable-name") (id "F:649168")) "x_reached") ", " (span (|@| (class "variable-name") (id "F:649179")) "last_x") ", " (span (|@| (class "variable-name") (id "F:649187")) "area_left") " = 0;\n  " (span (|@| (class "keyword") (id "F:649204")) "struct") " " (span (|@| (class "type") (id "F:649211")) "frame") " *" (span (|@| (class "variable-name") (id "F:649218")) "f") " = XFRAME (WINDOW_FRAME (w));\n  DECLARE_HDC (hdc);\n\n  ALLOCATE_HDC (hdc, f);\n\n  " (span (|@| (class "comment-delimiter") (id "F:649299")) "/* ") (span (|@| (class "comment") (id "F:649302")) "Let's rather be paranoid than getting a SEGV.  ") (span (|@| (class "comment-delimiter") (id "F:649349")) "*/") "\n  end = min (end, row->used[area]);\n  start = max (0, start);\n  start = min (end, start);\n\n  " (span (|@| (class "comment-delimiter") (id "F:649445")) "/* ") (span (|@| (class "comment") (id "F:649448")) "Translate X to frame coordinates.  Set last_x to the right\n     end of the drawing area.  ") (span (|@| (class "comment-delimiter") (id "F:649538")) "*/") "\n  " (span (|@| (class "keyword") (id "F:649543")) "if") " (row->full_width_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:649578")) "/* ") (span (|@| (class "comment") (id "F:649581")) "X is relative to the left edge of W, without scroll bars\n         or fringes.  ") (span (|@| (class "comment-delimiter") (id "F:649653")) "*/") "\n      area_left = WINDOW_LEFT_EDGE_X (w);\n      last_x = WINDOW_LEFT_EDGE_X (w) + WINDOW_TOTAL_WIDTH (w);\n    }\n  " (span (|@| (class "keyword") (id "F:649770")) "else") "\n    {\n      area_left = window_box_left (w, area);\n      last_x = area_left + window_box_width (w, area);\n    }\n  x += area_left;\n\n  " (span (|@| (class "comment-delimiter") (id "F:649908")) "/* ") (span (|@| (class "comment") (id "F:649911")) "Build a doubly-linked list of glyph_string structures between\n     head and tail from what we have to draw.  Note that the macro\n     BUILD_GLYPH_STRINGS will modify its start parameter.  That's\n     the reason we use a separate variable `i'.  ") (span (|@| (class "comment-delimiter") (id "F:650155")) "*/") "\n  i = start;\n  BUILD_GLYPH_STRINGS (i, end, head, tail, hl, x, last_x);\n  " (span (|@| (class "keyword") (id "F:650232")) "if") " (tail)\n    x_reached = tail->x + tail->background_width;\n  " (span (|@| (class "keyword") (id "F:650294")) "else") "\n    x_reached = x;\n\n  " (span (|@| (class "comment-delimiter") (id "F:650321")) "/* ") (span (|@| (class "comment") (id "F:650324")) "If there are any glyphs with lbearing < 0 or rbearing > width in\n     the row, redraw some glyphs in front or following the glyph\n     strings built above.  ") (span (|@| (class "comment-delimiter") (id "F:650481")) "*/") "\n  " (span (|@| (class "keyword") (id "F:650486")) "if") " (head && " (span (|@| (class "negation-char") (id "F:650498")) "!") "overlaps && row->contains_overlapping_glyphs_p)\n    {\n      " (span (|@| (class "keyword") (id "F:650559")) "struct") " " (span (|@| (class "type") (id "F:650566")) "glyph_string") " *" (span (|@| (class "variable-name") (id "F:650580")) "h") ", *" (span (|@| (class "variable-name") (id "F:650584")) "t") ";\n      " (span (|@| (class "type") (id "F:650593")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:650607")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n      " (span (|@| (class "type") (id "F:650649")) "int") " " (span (|@| (class "variable-name") (id "F:650653")) "mouse_beg_col") ", " (span (|@| (class "variable-name") (id "F:650668")) "mouse_end_col") ", " (span (|@| (class "variable-name") (id "F:650683")) "check_mouse_face") " = 0;\n      " (span (|@| (class "type") (id "F:650711")) "int") " " (span (|@| (class "variable-name") (id "F:650715")) "dummy_x") " = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:650735")) "/* ") (span (|@| (class "comment") (id "F:650738")) "If mouse highlighting is on, we may need to draw adjacent\n         glyphs using mouse-face highlighting.  ") (span (|@| (class "comment-delimiter") (id "F:650837")) "*/") "\n      " (span (|@| (class "keyword") (id "F:650846")) "if") " (area == TEXT_AREA && row->mouse_face_p)\n        {\n          " (span (|@| (class "keyword") (id "F:650896")) "struct") " " (span (|@| (class "type") (id "F:650903")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:650914")) "mouse_beg_row") ", *" (span (|@| (class "variable-name") (id "F:650930")) "mouse_end_row") ";\n\n          mouse_beg_row = MATRIX_ROW (w->current_matrix, dpyinfo->mouse_face_beg_row);\n          mouse_end_row = MATRIX_ROW (w->current_matrix, dpyinfo->mouse_face_end_row);\n\n          " (span (|@| (class "keyword") (id "F:651110")) "if") " (row >= mouse_beg_row && row <= mouse_end_row)\n            {\n              check_mouse_face = 1;\n              mouse_beg_col = (row == mouse_beg_row)\n                ? dpyinfo->mouse_face_beg_col : 0;\n              mouse_end_col = (row == mouse_end_row)\n                ? dpyinfo->mouse_face_end_col\n                : row->used[TEXT_AREA];\n            }\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:651400")) "/* ") (span (|@| (class "comment") (id "F:651403")) "Compute overhangs for all glyph strings.  ") (span (|@| (class "comment-delimiter") (id "F:651445")) "*/") "\n      " (span (|@| (class "keyword") (id "F:651454")) "if") " (FRAME_RIF (f)->compute_glyph_string_overhangs)\n        " (span (|@| (class "keyword") (id "F:651506")) "for") " (s = head; s; s = s->next)\n          FRAME_RIF (f)->compute_glyph_string_overhangs (s);\n\n      " (span (|@| (class "comment-delimiter") (id "F:651598")) "/* ") (span (|@| (class "comment") (id "F:651601")) "Prepend glyph strings for glyphs in front of the first glyph\n         string that are overwritten because of the first glyph\n         string's left overhang.  The background of all strings\n         prepended must be drawn because the first glyph string\n         draws over it.  ") (span (|@| (class "comment-delimiter") (id "F:651851")) "*/") "\n      i = left_overwritten (head);\n      " (span (|@| (class "keyword") (id "F:651895")) "if") " (i >= 0)\n        {\n          " (span (|@| (class "keyword") (id "F:651913")) "enum") " " (span (|@| (class "type") (id "F:651918")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:651935")) "overlap_hl") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:651951")) "/* ") (span (|@| (class "comment") (id "F:651954")) "If this row contains mouse highlighting, attempt to draw\n             the overlapped glyphs with the correct highlight.  This\n             code fails if the overlap encompasses more than one glyph\n             and mouse-highlight spans only some of these glyphs.\n             However, making it work perfectly involves a lot more\n             code, and I don't know if the pathological case occurs in\n             practice, so we'll stick to this for now.  --- cyd  ") (span (|@| (class "comment-delimiter") (id "F:652378")) "*/") "\n          " (span (|@| (class "keyword") (id "F:652384")) "if") " (check_mouse_face\n              && mouse_beg_col < start && mouse_end_col > i)\n            overlap_hl = DRAW_MOUSE_FACE;\n          " (span (|@| (class "keyword") (id "F:652497")) "else") "\n            overlap_hl = DRAW_NORMAL_TEXT;\n\n          j = i;\n          BUILD_GLYPH_STRINGS (j, start, h, t,\n                               overlap_hl, dummy_x, last_x);\n          start = i;\n          compute_overhangs_and_x (t, head->x, 1);\n          prepend_glyph_string_lists (&head, &tail, h, t);\n          clip_head = head;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:652770")) "/* ") (span (|@| (class "comment") (id "F:652773")) "Prepend glyph strings for glyphs in front of the first glyph\n         string that overwrite that glyph string because of their\n         right overhang.  For these strings, only the foreground must\n         be drawn, because it draws over the glyph string at `head'.\n         The background must not be drawn because this would overwrite\n         right overhangs of preceding glyphs for which no glyph\n         strings exist.  ") (span (|@| (class "comment-delimiter") (id "F:653157")) "*/") "\n      i = left_overwriting (head);\n      " (span (|@| (class "keyword") (id "F:653201")) "if") " (i >= 0)\n        {\n          " (span (|@| (class "keyword") (id "F:653219")) "enum") " " (span (|@| (class "type") (id "F:653224")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:653241")) "overlap_hl") ";\n\n          " (span (|@| (class "keyword") (id "F:653257")) "if") " (check_mouse_face\n              && mouse_beg_col < start && mouse_end_col > i)\n            overlap_hl = DRAW_MOUSE_FACE;\n          " (span (|@| (class "keyword") (id "F:653370")) "else") "\n            overlap_hl = DRAW_NORMAL_TEXT;\n\n          clip_head = head;\n          BUILD_GLYPH_STRINGS (i, start, h, t,\n                               overlap_hl, dummy_x, last_x);\n          " (span (|@| (class "keyword") (id "F:653516")) "for") " (s = h; s; s = s->next)\n            s->background_filled_p = 1;\n          compute_overhangs_and_x (t, head->x, 1);\n          prepend_glyph_string_lists (&head, &tail, h, t);\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:653683")) "/* ") (span (|@| (class "comment") (id "F:653686")) "Append glyphs strings for glyphs following the last glyph\n         string tail that are overwritten by tail.  The background of\n         these strings has to be drawn because tail's foreground draws\n         over it.  ") (span (|@| (class "comment-delimiter") (id "F:653883")) "*/") "\n      i = right_overwritten (tail);\n      " (span (|@| (class "keyword") (id "F:653928")) "if") " (i >= 0)\n        {\n          " (span (|@| (class "keyword") (id "F:653946")) "enum") " " (span (|@| (class "type") (id "F:653951")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:653968")) "overlap_hl") ";\n\n          " (span (|@| (class "keyword") (id "F:653984")) "if") " (check_mouse_face\n              && mouse_beg_col < i && mouse_end_col > end)\n            overlap_hl = DRAW_MOUSE_FACE;\n          " (span (|@| (class "keyword") (id "F:654095")) "else") "\n            overlap_hl = DRAW_NORMAL_TEXT;\n\n          BUILD_GLYPH_STRINGS (end, i, h, t,\n                               overlap_hl, x, last_x);\n          " (span (|@| (class "comment-delimiter") (id "F:654212")) "/* ") (span (|@| (class "comment") (id "F:654215")) "Because BUILD_GLYPH_STRINGS updates the first argument,\n             we don't have `end = i;' here.  ") (span (|@| (class "comment-delimiter") (id "F:654309")) "*/") "\n          compute_overhangs_and_x (h, tail->x + tail->width, 0);\n          append_glyph_string_lists (&head, &tail, h, t);\n          clip_tail = tail;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:654452")) "/* ") (span (|@| (class "comment") (id "F:654455")) "Append glyph strings for glyphs following the last glyph\n         string tail that overwrite tail.  The foreground of such\n         glyphs has to be drawn because it writes into the background\n         of tail.  The background must not be drawn because it could\n         paint over the foreground of following glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:654746")) "*/") "\n      i = right_overwriting (tail);\n      " (span (|@| (class "keyword") (id "F:654791")) "if") " (i >= 0)\n        {\n          " (span (|@| (class "keyword") (id "F:654809")) "enum") " " (span (|@| (class "type") (id "F:654814")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:654831")) "overlap_hl") ";\n          " (span (|@| (class "keyword") (id "F:654846")) "if") " (check_mouse_face\n              && mouse_beg_col < i && mouse_end_col > end)\n            overlap_hl = DRAW_MOUSE_FACE;\n          " (span (|@| (class "keyword") (id "F:654957")) "else") "\n            overlap_hl = DRAW_NORMAL_TEXT;\n\n          clip_tail = tail;\n          i++;                  " (span (|@| (class "comment-delimiter") (id "F:655030")) "/* ") (span (|@| (class "comment") (id "F:655033")) "We must include the Ith glyph.  ") (span (|@| (class "comment-delimiter") (id "F:655065")) "*/") "\n          BUILD_GLYPH_STRINGS (end, i, h, t,\n                               overlap_hl, x, last_x);\n          " (span (|@| (class "keyword") (id "F:655143")) "for") " (s = h; s; s = s->next)\n            s->background_filled_p = 1;\n          compute_overhangs_and_x (h, tail->x + tail->width, 0);\n          append_glyph_string_lists (&head, &tail, h, t);\n        }\n      " (span (|@| (class "keyword") (id "F:655322")) "if") " (clip_head || clip_tail)\n        " (span (|@| (class "keyword") (id "F:655351")) "for") " (s = head; s; s = s->next)\n          {\n            s->clip_head = clip_head;\n            s->clip_tail = clip_tail;\n          }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:655463")) "/* ") (span (|@| (class "comment") (id "F:655466")) "Draw all strings.  ") (span (|@| (class "comment-delimiter") (id "F:655485")) "*/") "\n  " (span (|@| (class "keyword") (id "F:655490")) "for") " (s = head; s; s = s->next)\n    FRAME_RIF (f)->draw_glyph_string (s);\n\n" (span (|@| (class "preprocessor") (id "F:655564")) "#if") (span (|@| (class "negation-char") (id "F:655567")) (span (|@| (class "preprocessor") (id "F:655567")) "n")) (span (|@| (class "preprocessor") (id "F:655568")) "def") " HAVE_NS\n  " (span (|@| (class "comment-delimiter") (id "F:655582")) "/* ") (span (|@| (class "comment") (id "F:655585")) "When focus a sole frame and move horizontally, this sets on_p to 0\n     causing a failure to erase prev cursor position. ") (span (|@| (class "comment-delimiter") (id "F:655706")) "*/") "\n  " (span (|@| (class "keyword") (id "F:655711")) "if") " (area == TEXT_AREA\n      && " (span (|@| (class "negation-char") (id "F:655742")) "!") "row->full_width_p\n      " (span (|@| (class "comment-delimiter") (id "F:655767")) "/* ") (span (|@| (class "comment") (id "F:655770")) "When drawing overlapping rows, only the glyph strings'\n         foreground is drawn, which doesn't erase a cursor\n         completely. ") (span (|@| (class "comment-delimiter") (id "F:655891")) "*/") "\n      && " (span (|@| (class "negation-char") (id "F:655903")) "!") "overlaps)\n    {\n      " (span (|@| (class "type") (id "F:655926")) "int") " " (span (|@| (class "variable-name") (id "F:655930")) "x0") " = clip_head ? clip_head->x : (head ? head->x : x);\n      " (span (|@| (class "type") (id "F:655990")) "int") " " (span (|@| (class "variable-name") (id "F:655994")) "x1") " = (clip_tail ? clip_tail->x + clip_tail->background_width\n                : (tail ? tail->x + tail->background_width : x));\n      x0 -= area_left;\n      x1 -= area_left;\n\n      notice_overwritten_cursor (w, TEXT_AREA, x0, x1,\n                                 row->y, MATRIX_ROW_BOTTOM_Y (row));\n    }\n" (span (|@| (class "preprocessor") (id "F:656256")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:656266")) "/* ") (span (|@| (class "comment") (id "F:656269")) "Value is the x-position up to which drawn, relative to AREA of W.\n     This doesn't include parts drawn because of overhangs.  ") (span (|@| (class "comment-delimiter") (id "F:656396")) "*/") "\n  " (span (|@| (class "keyword") (id "F:656401")) "if") " (row->full_width_p)\n    x_reached = FRAME_TO_WINDOW_PIXEL_X (w, x_reached);\n  " (span (|@| (class "keyword") (id "F:656482")) "else") "\n    x_reached -= area_left;\n\n  RELEASE_HDC (hdc, f);\n\n  " (span (|@| (class "keyword") (id "F:656543")) "return") " x_reached;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:656564")) "/* ") (span (|@| (class "comment") (id "F:656567")) "Expand row matrix if too narrow.  Don't expand if area\n   is not present.  ") (span (|@| (class "comment-delimiter") (id "F:656642")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:656646")) "#define") " " (span (|@| (class "function-name") (id "F:656654")) "IT_EXPAND_MATRIX_WIDTH") "(" (span (|@| (class "variable-name") (id "F:656677")) "it") ", " (span (|@| (class "variable-name") (id "F:656681")) "area") ")                \\\n  {                                                     \\\n    " (span (|@| (class "keyword") (id "F:656706")) "if") " (" (span (|@| (class "negation-char") (id "F:656710")) "!") "fonts_changed_p                                \\\n        && (it->glyph_row->glyphs[area]                 \\\n            < it->glyph_row->glyphs[area + 1]))         \\\n      {                                                 \\\n        it->w->ncols_scale_factor++;                    \\\n        fonts_changed_p = 1;                            \\\n      }                                                 \\\n  }\n\n" (span (|@| (class "comment-delimiter") (id "F:656911")) "/* ") (span (|@| (class "comment") (id "F:656914")) "Store one glyph for IT->char_to_display in IT->glyph_row.\n   Called from x_produce_glyphs when IT->glyph_row is non-null.  ") (span (|@| (class "comment-delimiter") (id "F:657037")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:657041")) "static") " INLINE " (span (|@| (class "type") (id "F:657055")) "void") "\n" (span (|@| (class "function-name") (id "F:657060")) "append_glyph") " (" (span (|@| (class "type") (id "F:657074")) "it") ")\n     " (span (|@| (class "keyword") (id "F:657083")) "struct") " " (span (|@| (class "type") (id "F:657090")) "it") " *" (span (|@| (class "variable-name") (id "F:657094")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:657102")) "struct") " " (span (|@| (class "type") (id "F:657109")) "glyph") " *" (span (|@| (class "variable-name") (id "F:657116")) "glyph") ";\n  " (span (|@| (class "keyword") (id "F:657125")) "enum") " " (span (|@| (class "type") (id "F:657130")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:657145")) "area") " = it->area;\n\n  xassert (it->glyph_row);\n  xassert (it->char_to_display != " (span (|@| (class "string") (id "F:657224")) "'\\n'") " && it->char_to_display != " (span (|@| (class "string") (id "F:657255")) "'\\t'") ");\n\n  glyph = it->glyph_row->glyphs[area] + it->glyph_row->used[area];\n  " (span (|@| (class "keyword") (id "F:657332")) "if") " (glyph < it->glyph_row->glyphs[area + 1])\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:657389")) "/* ") (span (|@| (class "comment") (id "F:657392")) "If the glyph row is reversed, we need to prepend the glyph\n         rather than append it.  ") (span (|@| (class "comment-delimiter") (id "F:657477")) "*/") "\n      " (span (|@| (class "keyword") (id "F:657486")) "if") " (it->glyph_row->reversed_p && area == TEXT_AREA)\n        {\n          " (span (|@| (class "keyword") (id "F:657544")) "struct") " " (span (|@| (class "type") (id "F:657551")) "glyph") " *" (span (|@| (class "variable-name") (id "F:657558")) "g") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:657565")) "/* ") (span (|@| (class "comment") (id "F:657568")) "Make room for the additional glyph.  ") (span (|@| (class "comment-delimiter") (id "F:657605")) "*/") "\n          " (span (|@| (class "keyword") (id "F:657611")) "for") " (g = glyph - 1; g >= it->glyph_row->glyphs[area]; g--)\n            g[1] = *g;\n          glyph = it->glyph_row->glyphs[area];\n        }\n      glyph->charpos = CHARPOS (it->position);\n      glyph->object = it->object;\n      " (span (|@| (class "keyword") (id "F:657816")) "if") " (it->pixel_width > 0)\n        {\n          glyph->pixel_width = it->pixel_width;\n          glyph->padding_p = 0;\n        }\n      " (span (|@| (class "keyword") (id "F:657919")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:657930")) "/* ") (span (|@| (class "comment") (id "F:657933")) "Assure at least 1-pixel width.  Otherwise, cursor can't\n             be displayed correctly.  ") (span (|@| (class "comment-delimiter") (id "F:658020")) "*/") "\n          glyph->pixel_width = 1;\n          glyph->padding_p = 1;\n        }\n      glyph->ascent = it->ascent;\n      glyph->descent = it->descent;\n      glyph->voffset = it->voffset;\n      glyph->type = CHAR_GLYPH;\n      glyph->avoid_cursor_p = it->avoid_cursor_p;\n      glyph->multibyte_p = it->multibyte_p;\n      glyph->left_box_line_p = it->start_of_box_run_p;\n      glyph->right_box_line_p = it->end_of_box_run_p;\n      glyph->overlaps_vertically_p = (it->phys_ascent > it->ascent\n                                      || it->phys_descent > it->descent);\n      glyph->glyph_not_available_p = it->glyph_not_available_p;\n      glyph->face_id = it->face_id;\n      glyph->u.ch = it->char_to_display;\n      glyph->slice = null_glyph_slice;\n      glyph->font_type = FONT_TYPE_UNKNOWN;\n      " (span (|@| (class "keyword") (id "F:658762")) "if") " (it->bidi_p)\n        {\n          glyph->resolved_level = it->bidi_it.resolved_level;\n          " (span (|@| (class "keyword") (id "F:658839")) "if") " ((it->bidi_it.type & 7) != it->bidi_it.type)\n            abort ();\n          glyph->bidi_type = it->bidi_it.type;\n        }\n      " (span (|@| (class "keyword") (id "F:658951")) "else") "\n        {\n          glyph->resolved_level = 0;\n          glyph->bidi_type = UNKNOWN_BT;\n        }\n      ++it->glyph_row->used[area];\n    }\n  " (span (|@| (class "keyword") (id "F:659069")) "else") "\n    IT_EXPAND_MATRIX_WIDTH (it, area);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:659116")) "/* ") (span (|@| (class "comment") (id "F:659119")) "Store one glyph for the composition IT->cmp_it.id in\n   IT->glyph_row.  Called from x_produce_glyphs when IT->glyph_row is\n   non-null.  ") (span (|@| (class "comment-delimiter") (id "F:659256")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:659260")) "static") " INLINE " (span (|@| (class "type") (id "F:659274")) "void") "\n" (span (|@| (class "function-name") (id "F:659279")) "append_composite_glyph") " (" (span (|@| (class "type") (id "F:659303")) "it") ")\n     " (span (|@| (class "keyword") (id "F:659312")) "struct") " " (span (|@| (class "type") (id "F:659319")) "it") " *" (span (|@| (class "variable-name") (id "F:659323")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:659331")) "struct") " " (span (|@| (class "type") (id "F:659338")) "glyph") " *" (span (|@| (class "variable-name") (id "F:659345")) "glyph") ";\n  " (span (|@| (class "keyword") (id "F:659354")) "enum") " " (span (|@| (class "type") (id "F:659359")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:659374")) "area") " = it->area;\n\n  xassert (it->glyph_row);\n\n  glyph = it->glyph_row->glyphs[area] + it->glyph_row->used[area];\n  " (span (|@| (class "keyword") (id "F:659489")) "if") " (glyph < it->glyph_row->glyphs[area + 1])\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:659546")) "/* ") (span (|@| (class "comment") (id "F:659549")) "If the glyph row is reversed, we need to prepend the glyph\n         rather than append it.  ") (span (|@| (class "comment-delimiter") (id "F:659634")) "*/") "\n      " (span (|@| (class "keyword") (id "F:659643")) "if") " (it->glyph_row->reversed_p && it->area == TEXT_AREA)\n        {\n          " (span (|@| (class "keyword") (id "F:659705")) "struct") " " (span (|@| (class "type") (id "F:659712")) "glyph") " *" (span (|@| (class "variable-name") (id "F:659719")) "g") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:659726")) "/* ") (span (|@| (class "comment") (id "F:659729")) "Make room for the new glyph.  ") (span (|@| (class "comment-delimiter") (id "F:659759")) "*/") "\n          " (span (|@| (class "keyword") (id "F:659765")) "for") " (g = glyph - 1; g >= it->glyph_row->glyphs[it->area]; g--)\n            g[1] = *g;\n          glyph = it->glyph_row->glyphs[it->area];\n        }\n      glyph->charpos = it->cmp_it.charpos;\n      glyph->object = it->object;\n      glyph->pixel_width = it->pixel_width;\n      glyph->ascent = it->ascent;\n      glyph->descent = it->descent;\n      glyph->voffset = it->voffset;\n      glyph->type = COMPOSITE_GLYPH;\n      " (span (|@| (class "keyword") (id "F:660161")) "if") " (it->cmp_it.ch < 0)\n        {\n          glyph->u.cmp.automatic = 0;\n          glyph->u.cmp.id = it->cmp_it.id;\n        }\n      " (span (|@| (class "keyword") (id "F:660263")) "else") "\n        {\n          glyph->u.cmp.automatic = 1;\n          glyph->u.cmp.id = it->cmp_it.id;\n          glyph->u.cmp.from = it->cmp_it.from;\n          glyph->u.cmp.to = it->cmp_it.to - 1;\n        }\n      glyph->avoid_cursor_p = it->avoid_cursor_p;\n      glyph->multibyte_p = it->multibyte_p;\n      glyph->left_box_line_p = it->start_of_box_run_p;\n      glyph->right_box_line_p = it->end_of_box_run_p;\n      glyph->overlaps_vertically_p = (it->phys_ascent > it->ascent\n                                      || it->phys_descent > it->descent);\n      glyph->padding_p = 0;\n      glyph->glyph_not_available_p = 0;\n      glyph->face_id = it->face_id;\n      glyph->slice = null_glyph_slice;\n      glyph->font_type = FONT_TYPE_UNKNOWN;\n      " (span (|@| (class "keyword") (id "F:660930")) "if") " (it->bidi_p)\n        {\n          glyph->resolved_level = it->bidi_it.resolved_level;\n          " (span (|@| (class "keyword") (id "F:661007")) "if") " ((it->bidi_it.type & 7) != it->bidi_it.type)\n            abort ();\n          glyph->bidi_type = it->bidi_it.type;\n        }\n      ++it->glyph_row->used[area];\n    }\n  " (span (|@| (class "keyword") (id "F:661156")) "else") "\n    IT_EXPAND_MATRIX_WIDTH (it, area);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:661204")) "/* ") (span (|@| (class "comment") (id "F:661207")) "Change IT->ascent and IT->height according to the setting of\n   IT->voffset.  ") (span (|@| (class "comment-delimiter") (id "F:661285")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:661289")) "static") " INLINE " (span (|@| (class "type") (id "F:661303")) "void") "\n" (span (|@| (class "function-name") (id "F:661308")) "take_vertical_position_into_account") " (" (span (|@| (class "type") (id "F:661345")) "it") ")\n     " (span (|@| (class "keyword") (id "F:661354")) "struct") " " (span (|@| (class "type") (id "F:661361")) "it") " *" (span (|@| (class "variable-name") (id "F:661365")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:661373")) "if") " (it->voffset)\n    {\n      " (span (|@| (class "keyword") (id "F:661402")) "if") " (it->voffset < 0)\n        " (span (|@| (class "comment-delimiter") (id "F:661424")) "/* ") (span (|@| (class "comment") (id "F:661427")) "Increase the ascent so that we can display the text higher\n           in the line.  ") (span (|@| (class "comment-delimiter") (id "F:661504")) "*/") "\n        it->ascent -= it->voffset;\n      " (span (|@| (class "keyword") (id "F:661541")) "else") "\n        " (span (|@| (class "comment-delimiter") (id "F:661547")) "/* ") (span (|@| (class "comment") (id "F:661550")) "Increase the descent so that we can display the text lower\n           in the line.  ") (span (|@| (class "comment-delimiter") (id "F:661627")) "*/") "\n        it->descent += it->voffset;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:661669")) "/* ") (span (|@| (class "comment") (id "F:661672")) "Produce glyphs/get display metrics for the image IT is loaded with.\n   See the description of struct display_iterator in dispextern.h for\n   an overview of struct display_iterator.  ") (span (|@| (class "comment-delimiter") (id "F:661854")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:661858")) "static") " " (span (|@| (class "type") (id "F:661865")) "void") "\n" (span (|@| (class "function-name") (id "F:661870")) "produce_image_glyph") " (" (span (|@| (class "type") (id "F:661891")) "it") ")\n     " (span (|@| (class "keyword") (id "F:661900")) "struct") " " (span (|@| (class "type") (id "F:661907")) "it") " *" (span (|@| (class "variable-name") (id "F:661911")) "it") ";\n{\n  " (span (|@| (class "keyword") (id "F:661919")) "struct") " " (span (|@| (class "type") (id "F:661926")) "image") " *" (span (|@| (class "variable-name") (id "F:661933")) "img") ";\n  " (span (|@| (class "keyword") (id "F:661940")) "struct") " " (span (|@| (class "type") (id "F:661947")) "face") " *" (span (|@| (class "variable-name") (id "F:661953")) "face") ";\n  " (span (|@| (class "type") (id "F:661961")) "int") " " (span (|@| (class "variable-name") (id "F:661965")) "glyph_ascent") ", " (span (|@| (class "variable-name") (id "F:661979")) "crop") ";\n  " (span (|@| (class "keyword") (id "F:661987")) "struct") " " (span (|@| (class "type") (id "F:661994")) "glyph_slice") " " (span (|@| (class "variable-name") (id "F:662006")) "slice") ";\n\n  xassert (it->what == IT_IMAGE);\n\n  face = FACE_FROM_ID (it->f, it->face_id);\n  xassert (face);\n  " (span (|@| (class "comment-delimiter") (id "F:662113")) "/* ") (span (|@| (class "comment") (id "F:662116")) "Make sure X resources of the face is loaded.  ") (span (|@| (class "comment-delimiter") (id "F:662162")) "*/") "\n  PREPARE_FACE_FOR_DISPLAY (it->f, face);\n\n  " (span (|@| (class "keyword") (id "F:662210")) "if") " (it->image_id < 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:662244")) "/* ") (span (|@| (class "comment") (id "F:662247")) "Fringe bitmap.  ") (span (|@| (class "comment-delimiter") (id "F:662263")) "*/") "\n      it->ascent = it->phys_ascent = 0;\n      it->descent = it->phys_descent = 0;\n      it->pixel_width = 0;\n      it->nglyphs = 0;\n      " (span (|@| (class "keyword") (id "F:662404")) "return") ";\n    }\n\n  img = IMAGE_FROM_ID (it->f, it->image_id);\n  xassert (img);\n  " (span (|@| (class "comment-delimiter") (id "F:662483")) "/* ") (span (|@| (class "comment") (id "F:662486")) "Make sure X resources of the image is loaded.  ") (span (|@| (class "comment-delimiter") (id "F:662533")) "*/") "\n  prepare_image_for_display (it->f, img);\n\n  slice.x = slice.y = 0;\n  slice.width = img->width;\n  slice.height = img->height;\n\n  " (span (|@| (class "keyword") (id "F:662665")) "if") " (INTEGERP (it->slice.x))\n    slice.x = XINT (it->slice.x);\n  " (span (|@| (class "keyword") (id "F:662729")) "else") " " (span (|@| (class "keyword") (id "F:662734")) "if") " (FLOATP (it->slice.x))\n    slice.x = XFLOAT_DATA (it->slice.x) * img->width;\n\n  " (span (|@| (class "keyword") (id "F:662817")) "if") " (INTEGERP (it->slice.y))\n    slice.y = XINT (it->slice.y);\n  " (span (|@| (class "keyword") (id "F:662881")) "else") " " (span (|@| (class "keyword") (id "F:662886")) "if") " (FLOATP (it->slice.y))\n    slice.y = XFLOAT_DATA (it->slice.y) * img->height;\n\n  " (span (|@| (class "keyword") (id "F:662970")) "if") " (INTEGERP (it->slice.width))\n    slice.width = XINT (it->slice.width);\n  " (span (|@| (class "keyword") (id "F:663046")) "else") " " (span (|@| (class "keyword") (id "F:663051")) "if") " (FLOATP (it->slice.width))\n    slice.width = XFLOAT_DATA (it->slice.width) * img->width;\n\n  " (span (|@| (class "keyword") (id "F:663146")) "if") " (INTEGERP (it->slice.height))\n    slice.height = XINT (it->slice.height);\n  " (span (|@| (class "keyword") (id "F:663225")) "else") " " (span (|@| (class "keyword") (id "F:663230")) "if") " (FLOATP (it->slice.height))\n    slice.height = XFLOAT_DATA (it->slice.height) * img->height;\n\n  " (span (|@| (class "keyword") (id "F:663329")) "if") " (slice.x >= img->width)\n    slice.x = img->width;\n  " (span (|@| (class "keyword") (id "F:663384")) "if") " (slice.y >= img->height)\n    slice.y = img->height;\n  " (span (|@| (class "keyword") (id "F:663441")) "if") " (slice.x + slice.width >= img->width)\n    slice.width = img->width - slice.x;\n  " (span (|@| (class "keyword") (id "F:663524")) "if") " (slice.y + slice.height > img->height)\n    slice.height = img->height - slice.y;\n\n  " (span (|@| (class "keyword") (id "F:663611")) "if") " (slice.width == 0 || slice.height == 0)\n    " (span (|@| (class "keyword") (id "F:663658")) "return") ";\n\n  it->ascent = it->phys_ascent = glyph_ascent = image_ascent (img, face, &slice);\n\n  it->descent = slice.height - glyph_ascent;\n  " (span (|@| (class "keyword") (id "F:663797")) "if") " (slice.y == 0)\n    it->descent += img->vmargin;\n  " (span (|@| (class "keyword") (id "F:663850")) "if") " (slice.y + slice.height == img->height)\n    it->descent += img->vmargin;\n  it->phys_descent = it->descent;\n\n  it->pixel_width = slice.width;\n  " (span (|@| (class "keyword") (id "F:663996")) "if") " (slice.x == 0)\n    it->pixel_width += img->hmargin;\n  " (span (|@| (class "keyword") (id "F:664053")) "if") " (slice.x + slice.width == img->width)\n    it->pixel_width += img->hmargin;\n\n  " (span (|@| (class "comment-delimiter") (id "F:664134")) "/* ") (span (|@| (class "comment") (id "F:664137")) "It's quite possible for images to have an ascent greater than\n     their height, so don't get confused in that case.  ") (span (|@| (class "comment-delimiter") (id "F:664255")) "*/") "\n  " (span (|@| (class "keyword") (id "F:664260")) "if") " (it->descent < 0)\n    it->descent = 0;\n\n  it->nglyphs = 1;\n\n  " (span (|@| (class "keyword") (id "F:664325")) "if") " (face->box != FACE_NO_BOX)\n    {\n      " (span (|@| (class "keyword") (id "F:664367")) "if") " (face->box_line_width > 0)\n        {\n          " (span (|@| (class "keyword") (id "F:664403")) "if") " (slice.y == 0)\n            it->ascent += face->box_line_width;\n          " (span (|@| (class "keyword") (id "F:664465")) "if") " (slice.y + slice.height == img->height)\n            it->descent += face->box_line_width;\n        }\n\n      " (span (|@| (class "keyword") (id "F:664560")) "if") " (it->start_of_box_run_p && slice.x == 0)\n        it->pixel_width += eabs (face->box_line_width);\n      " (span (|@| (class "keyword") (id "F:664659")) "if") " (it->end_of_box_run_p && slice.x + slice.width == img->width)\n        it->pixel_width += eabs (face->box_line_width);\n    }\n\n  take_vertical_position_into_account (it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:664827")) "/* ") (span (|@| (class "comment") (id "F:664830")) "Automatically crop wide image glyphs at right edge so we can\n     draw the cursor on same display row.  ") (span (|@| (class "comment-delimiter") (id "F:664934")) "*/") "\n  " (span (|@| (class "keyword") (id "F:664939")) "if") " ((crop = it->pixel_width - (it->last_visible_x - it->current_x), crop > 0)\n      && (it->hpos == 0 || it->pixel_width > it->last_visible_x / 4))\n    {\n      it->pixel_width -= crop;\n      slice.width -= crop;\n    }\n\n  " (span (|@| (class "keyword") (id "F:665160")) "if") " (it->glyph_row)\n    {\n      " (span (|@| (class "keyword") (id "F:665191")) "struct") " " (span (|@| (class "type") (id "F:665198")) "glyph") " *" (span (|@| (class "variable-name") (id "F:665205")) "glyph") ";\n      " (span (|@| (class "keyword") (id "F:665218")) "enum") " " (span (|@| (class "type") (id "F:665223")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:665238")) "area") " = it->area;\n\n      glyph = it->glyph_row->glyphs[area] + it->glyph_row->used[area];\n      " (span (|@| (class "keyword") (id "F:665333")) "if") " (glyph < it->glyph_row->glyphs[area + 1])\n        {\n          glyph->charpos = CHARPOS (it->position);\n          glyph->object = it->object;\n          glyph->pixel_width = it->pixel_width;\n          glyph->ascent = glyph_ascent;\n          glyph->descent = it->descent;\n          glyph->voffset = it->voffset;\n          glyph->type = IMAGE_GLYPH;\n          glyph->avoid_cursor_p = it->avoid_cursor_p;\n          glyph->multibyte_p = it->multibyte_p;\n          glyph->left_box_line_p = it->start_of_box_run_p;\n          glyph->right_box_line_p = it->end_of_box_run_p;\n          glyph->overlaps_vertically_p = 0;\n          glyph->padding_p = 0;\n          glyph->glyph_not_available_p = 0;\n          glyph->face_id = it->face_id;\n          glyph->u.img_id = img->id;\n          glyph->slice = slice;\n          glyph->font_type = FONT_TYPE_UNKNOWN;\n          " (span (|@| (class "keyword") (id "F:666055")) "if") " (it->bidi_p)\n            {\n              glyph->resolved_level = it->bidi_it.resolved_level;\n              " (span (|@| (class "keyword") (id "F:666144")) "if") " ((it->bidi_it.type & 7) != it->bidi_it.type)\n                abort ();\n              glyph->bidi_type = it->bidi_it.type;\n            }\n          ++it->glyph_row->used[area];\n        }\n      " (span (|@| (class "keyword") (id "F:666296")) "else") "\n        IT_EXPAND_MATRIX_WIDTH (it, area);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:666347")) "/* ") (span (|@| (class "comment") (id "F:666350")) "Append a stretch glyph to IT->glyph_row.  OBJECT is the source\n   of the glyph, WIDTH and HEIGHT are the width and height of the\n   stretch.  ASCENT is the ascent of the glyph (0 <= ASCENT <= HEIGHT).  ") (span (|@| (class "comment-delimiter") (id "F:666552")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:666556")) "static") " " (span (|@| (class "type") (id "F:666563")) "void") "\n" (span (|@| (class "function-name") (id "F:666568")) "append_stretch_glyph") " (" (span (|@| (class "type") (id "F:666590")) "it") ", object, width, height, ascent)\n     " (span (|@| (class "keyword") (id "F:666630")) "struct") " " (span (|@| (class "type") (id "F:666637")) "it") " *" (span (|@| (class "variable-name") (id "F:666641")) "it") ";\n     " (span (|@| (class "type") (id "F:666650")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:666662")) "object") ";\n     " (span (|@| (class "type") (id "F:666675")) "int") " " (span (|@| (class "variable-name") (id "F:666679")) "width") ", " (span (|@| (class "variable-name") (id "F:666686")) "height") ";\n     " (span (|@| (class "type") (id "F:666699")) "int") " " (span (|@| (class "variable-name") (id "F:666703")) "ascent") ";\n{\n  " (span (|@| (class "keyword") (id "F:666715")) "struct") " " (span (|@| (class "type") (id "F:666722")) "glyph") " *" (span (|@| (class "variable-name") (id "F:666729")) "glyph") ";\n  " (span (|@| (class "keyword") (id "F:666738")) "enum") " " (span (|@| (class "type") (id "F:666743")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:666758")) "area") " = it->area;\n\n  xassert (ascent >= 0 && ascent <= height);\n\n  glyph = it->glyph_row->glyphs[area] + it->glyph_row->used[area];\n  " (span (|@| (class "keyword") (id "F:666891")) "if") " (glyph < it->glyph_row->glyphs[area + 1])\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:666948")) "/* ") (span (|@| (class "comment") (id "F:666951")) "If the glyph row is reversed, we need to prepend the glyph\n         rather than append it.  ") (span (|@| (class "comment-delimiter") (id "F:667036")) "*/") "\n      " (span (|@| (class "keyword") (id "F:667045")) "if") " (it->glyph_row->reversed_p && area == TEXT_AREA)\n        {\n          " (span (|@| (class "keyword") (id "F:667103")) "struct") " " (span (|@| (class "type") (id "F:667110")) "glyph") " *" (span (|@| (class "variable-name") (id "F:667117")) "g") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:667124")) "/* ") (span (|@| (class "comment") (id "F:667127")) "Make room for the additional glyph.  ") (span (|@| (class "comment-delimiter") (id "F:667164")) "*/") "\n          " (span (|@| (class "keyword") (id "F:667170")) "for") " (g = glyph - 1; g >= it->glyph_row->glyphs[area]; g--)\n            g[1] = *g;\n          glyph = it->glyph_row->glyphs[area];\n        }\n      glyph->charpos = CHARPOS (it->position);\n      glyph->object = object;\n      glyph->pixel_width = width;\n      glyph->ascent = ascent;\n      glyph->descent = height - ascent;\n      glyph->voffset = it->voffset;\n      glyph->type = STRETCH_GLYPH;\n      glyph->avoid_cursor_p = it->avoid_cursor_p;\n      glyph->multibyte_p = it->multibyte_p;\n      glyph->left_box_line_p = it->start_of_box_run_p;\n      glyph->right_box_line_p = it->end_of_box_run_p;\n      glyph->overlaps_vertically_p = 0;\n      glyph->padding_p = 0;\n      glyph->glyph_not_available_p = 0;\n      glyph->face_id = it->face_id;\n      glyph->u.stretch.ascent = ascent;\n      glyph->u.stretch.height = height;\n      glyph->slice = null_glyph_slice;\n      glyph->font_type = FONT_TYPE_UNKNOWN;\n      " (span (|@| (class "keyword") (id "F:668056")) "if") " (it->bidi_p)\n        {\n          glyph->resolved_level = it->bidi_it.resolved_level;\n          " (span (|@| (class "keyword") (id "F:668133")) "if") " ((it->bidi_it.type & 7) != it->bidi_it.type)\n            abort ();\n          glyph->bidi_type = it->bidi_it.type;\n        }\n      " (span (|@| (class "keyword") (id "F:668245")) "else") "\n        {\n          glyph->resolved_level = 0;\n          glyph->bidi_type = UNKNOWN_BT;\n        }\n      ++it->glyph_row->used[area];\n    }\n  " (span (|@| (class "keyword") (id "F:668363")) "else") "\n    IT_EXPAND_MATRIX_WIDTH (it, area);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:668411")) "/* ") (span (|@| (class "comment") (id "F:668414")) "Produce a stretch glyph for iterator IT.  IT->object is the value\n   of the glyph property displayed.  The value must be a list\n   `(space KEYWORD VALUE ...)' with the following KEYWORD/VALUE pairs\n   being recognized:\n\n   1. `:width WIDTH' specifies that the space should be WIDTH *\n   canonical char width wide.  WIDTH may be an integer or floating\n   point number.\n\n   2. `:relative-width FACTOR' specifies that the width of the stretch\n   should be computed from the width of the first character having the\n   `glyph' property, and should be FACTOR times that width.\n\n   3. `:align-to HPOS' specifies that the space should be wide enough\n   to reach HPOS, a value in canonical character units.\n\n   Exactly one of the above pairs must be present.\n\n   4. `:height HEIGHT' specifies that the height of the stretch produced\n   should be HEIGHT, measured in canonical character units.\n\n   5. `:relative-height FACTOR' specifies that the height of the\n   stretch should be FACTOR times the height of the characters having\n   the glyph property.\n\n   Either none or exactly one of 4 or 5 must be present.\n\n   6. `:ascent ASCENT'  specifies that ASCENT percent of the height\n   of the stretch should be used for the ascent of the stretch.\n   ASCENT must be in the range 0 <= ASCENT <= 100.  ") (span (|@| (class "comment-delimiter") (id "F:669700")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:669704")) "static") " " (span (|@| (class "type") (id "F:669711")) "void") "\n" (span (|@| (class "function-name") (id "F:669716")) "produce_stretch_glyph") " (" (span (|@| (class "type") (id "F:669739")) "it") ")\n     " (span (|@| (class "keyword") (id "F:669748")) "struct") " " (span (|@| (class "type") (id "F:669755")) "it") " *" (span (|@| (class "variable-name") (id "F:669759")) "it") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:669767")) "/* ") (span (|@| (class "comment") (id "F:669770")) "(space :width WIDTH :height HEIGHT ...)  ") (span (|@| (class "comment-delimiter") (id "F:669811")) "*/") "\n  " (span (|@| (class "type") (id "F:669816")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:669828")) "prop") ", " (span (|@| (class "variable-name") (id "F:669834")) "plist") ";\n  " (span (|@| (class "type") (id "F:669843")) "int") " " (span (|@| (class "variable-name") (id "F:669847")) "width") " = 0, " (span (|@| (class "variable-name") (id "F:669858")) "height") " = 0, " (span (|@| (class "variable-name") (id "F:669870")) "align_to") " = -1;\n  " (span (|@| (class "type") (id "F:669887")) "int") " " (span (|@| (class "variable-name") (id "F:669891")) "zero_width_ok_p") " = 0, " (span (|@| (class "variable-name") (id "F:669912")) "zero_height_ok_p") " = 0;\n  " (span (|@| (class "type") (id "F:669936")) "int") " " (span (|@| (class "variable-name") (id "F:669940")) "ascent") " = 0;\n  " (span (|@| (class "type") (id "F:669954")) "double") " " (span (|@| (class "variable-name") (id "F:669961")) "tem") ";\n  " (span (|@| (class "keyword") (id "F:669968")) "struct") " " (span (|@| (class "type") (id "F:669975")) "face") " *" (span (|@| (class "variable-name") (id "F:669981")) "face") " = FACE_FROM_ID (it->f, it->face_id);\n  " (span (|@| (class "keyword") (id "F:670025")) "struct") " " (span (|@| (class "type") (id "F:670032")) "font") " *" (span (|@| (class "variable-name") (id "F:670038")) "font") " = face->font ? face->font : FRAME_FONT (it->f);\n\n  PREPARE_FACE_FOR_DISPLAY (it->f, face);\n\n  " (span (|@| (class "comment-delimiter") (id "F:670137")) "/* ") (span (|@| (class "comment") (id "F:670140")) "List should start with `space'.  ") (span (|@| (class "comment-delimiter") (id "F:670173")) "*/") "\n  xassert (CONSP (it->object) && EQ (XCAR (it->object), Qspace));\n  plist = XCDR (it->object);\n\n  " (span (|@| (class "comment-delimiter") (id "F:670274")) "/* ") (span (|@| (class "comment") (id "F:670277")) "Compute the width of the stretch.  ") (span (|@| (class "comment-delimiter") (id "F:670312")) "*/") "\n  " (span (|@| (class "keyword") (id "F:670317")) "if") " ((prop = Fplist_get (plist, QCwidth), " (span (|@| (class "negation-char") (id "F:670358")) "!") "NILP (prop))\n      && calc_pixel_width_or_height (&tem, it, prop, font, 1, 0))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:670450")) "/* ") (span (|@| (class "comment") (id "F:670453")) "Absolute width `:width WIDTH' specified and valid.  ") (span (|@| (class "comment-delimiter") (id "F:670505")) "*/") "\n      zero_width_ok_p = 1;\n      width = (" (span (|@| (class "type") (id "F:670550")) "int") ")tem;\n    }\n  " (span (|@| (class "keyword") (id "F:670567")) "else") " " (span (|@| (class "keyword") (id "F:670572")) "if") " (prop = Fplist_get (plist, QCrelative_width),\n           NUMVAL (prop) > 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:670656")) "/* ") (span (|@| (class "comment") (id "F:670659")) "Relative width `:relative-width FACTOR' specified and valid.\n         Compute the width of the characters having the `glyph'\n         property.  ") (span (|@| (class "comment-delimiter") (id "F:670790")) "*/") "\n      " (span (|@| (class "keyword") (id "F:670799")) "struct") " " (span (|@| (class "type") (id "F:670806")) "it") " " (span (|@| (class "variable-name") (id "F:670809")) "it2") ";\n      " (span (|@| (class "type") (id "F:670820")) "unsigned") " " (span (|@| (class "type") (id "F:670829")) "char") " *" (span (|@| (class "variable-name") (id "F:670835")) "p") " = BYTE_POS_ADDR (IT_BYTEPOS (*it));\n\n      it2 = *it;\n      " (span (|@| (class "keyword") (id "F:670897")) "if") " (it->multibyte_p)\n        {\n          " (span (|@| (class "type") (id "F:670924")) "int") " " (span (|@| (class "variable-name") (id "F:670928")) "maxlen") " = ((IT_BYTEPOS (*it) >= GPT ? ZV : GPT)\n                        - IT_BYTEPOS (*it));\n          it2.c = STRING_CHAR_AND_LENGTH (p, it2.len);\n        }\n      " (span (|@| (class "keyword") (id "F:671056")) "else") "\n        it2.c = *p, it2.len = 1;\n\n      it2.glyph_row = " (span (|@| (class "constant") (id "F:671110")) "NULL") ";\n      it2.what = IT_CHARACTER;\n      x_produce_glyphs (&it2);\n      width = NUMVAL (prop) * it2.pixel_width;\n    }\n  " (span (|@| (class "keyword") (id "F:671233")) "else") " " (span (|@| (class "keyword") (id "F:671238")) "if") " ((prop = Fplist_get (plist, QCalign_to), " (span (|@| (class "negation-char") (id "F:671282")) "!") "NILP (prop))\n           && calc_pixel_width_or_height (&tem, it, prop, font, 1, &align_to))\n    {\n      " (span (|@| (class "keyword") (id "F:671380")) "if") " (it->glyph_row == " (span (|@| (class "constant") (id "F:671401")) "NULL") " || " (span (|@| (class "negation-char") (id "F:671409")) "!") "it->glyph_row->mode_line_p)\n        align_to = (align_to < 0\n                    ? 0\n                    : align_to - window_box_left_offset (it->w, TEXT_AREA));\n      " (span (|@| (class "keyword") (id "F:671543")) "else") " " (span (|@| (class "keyword") (id "F:671548")) "if") " (align_to < 0)\n        align_to = window_box_left_offset (it->w, TEXT_AREA);\n      width = max (0, (" (span (|@| (class "type") (id "F:671644")) "int") ")tem + align_to - it->current_x);\n      zero_width_ok_p = 1;\n    }\n  " (span (|@| (class "keyword") (id "F:671716")) "else") "\n    " (span (|@| (class "comment-delimiter") (id "F:671725")) "/* ") (span (|@| (class "comment") (id "F:671728")) "Nothing specified -> width defaults to canonical char width.  ") (span (|@| (class "comment-delimiter") (id "F:671790")) "*/") "\n    width = FRAME_COLUMN_WIDTH (it->f);\n\n  " (span (|@| (class "keyword") (id "F:671836")) "if") " (width <= 0 && (width < 0 || " (span (|@| (class "negation-char") (id "F:671868")) "!") "zero_width_ok_p))\n    width = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:671905")) "/* ") (span (|@| (class "comment") (id "F:671908")) "Compute height.  ") (span (|@| (class "comment-delimiter") (id "F:671925")) "*/") "\n  " (span (|@| (class "keyword") (id "F:671930")) "if") " ((prop = Fplist_get (plist, QCheight), " (span (|@| (class "negation-char") (id "F:671972")) "!") "NILP (prop))\n      && calc_pixel_width_or_height (&tem, it, prop, font, 0, 0))\n    {\n      height = (" (span (|@| (class "type") (id "F:672074")) "int") ")tem;\n      zero_height_ok_p = 1;\n    }\n  " (span (|@| (class "keyword") (id "F:672119")) "else") " " (span (|@| (class "keyword") (id "F:672124")) "if") " (prop = Fplist_get (plist, QCrelative_height),\n           NUMVAL (prop) > 0)\n    height = FONT_HEIGHT (font) * NUMVAL (prop);\n  " (span (|@| (class "keyword") (id "F:672248")) "else") "\n    height = FONT_HEIGHT (font);\n\n  " (span (|@| (class "keyword") (id "F:672289")) "if") " (height <= 0 && (height < 0 || " (span (|@| (class "negation-char") (id "F:672323")) "!") "zero_height_ok_p))\n    height = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:672362")) "/* ") (span (|@| (class "comment") (id "F:672365")) "Compute percentage of height used for ascent.  If\n     `:ascent ASCENT' is present and valid, use that.  Otherwise,\n     derive the ascent from the font in use.  ") (span (|@| (class "comment-delimiter") (id "F:672527")) "*/") "\n  " (span (|@| (class "keyword") (id "F:672532")) "if") " (prop = Fplist_get (plist, QCascent),\n      NUMVAL (prop) > 0 && NUMVAL (prop) <= 100)\n    ascent = height * NUMVAL (prop) / 100.0;\n  " (span (|@| (class "keyword") (id "F:672669")) "else") " " (span (|@| (class "keyword") (id "F:672674")) "if") " (" (span (|@| (class "negation-char") (id "F:672678")) "!") "NILP (prop)\n           && calc_pixel_width_or_height (&tem, it, prop, font, 0, 0))\n    ascent = min (max (0, (" (span (|@| (class "type") (id "F:672782")) "int") ")tem), height);\n  " (span (|@| (class "keyword") (id "F:672803")) "else") "\n    ascent = (height * FONT_BASE (font)) / FONT_HEIGHT (font);\n\n  " (span (|@| (class "keyword") (id "F:672874")) "if") " (width > 0 && it->line_wrap != TRUNCATE\n      && it->current_x + width > it->last_visible_x)\n    width = it->last_visible_x - it->current_x - 1;\n\n  " (span (|@| (class "keyword") (id "F:673025")) "if") " (width > 0 && height > 0 && it->glyph_row)\n    {\n      " (span (|@| (class "type") (id "F:673083")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:673095")) "object") " = it->stack[it->sp - 1].string;\n      " (span (|@| (class "keyword") (id "F:673140")) "if") " (" (span (|@| (class "negation-char") (id "F:673144")) "!") "STRINGP (object))\n        object = it->w->buffer;\n      append_stretch_glyph (it, object, width, height, ascent);\n    }\n\n  it->pixel_width = width;\n  it->ascent = it->phys_ascent = ascent;\n  it->descent = it->phys_descent = height - it->ascent;\n  it->nglyphs = width > 0 && height > 0 ? 1 : 0;\n\n  take_vertical_position_into_account (it);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:673480")) "/* ") (span (|@| (class "comment") (id "F:673483")) "Calculate line-height and line-spacing properties.\n   An integer value specifies explicit pixel value.\n   A float value specifies relative value to current face height.\n   A cons (float . face-name) specifies relative value to\n   height of specified face font.\n\n   Returns height in pixels, or nil.  ") (span (|@| (class "comment-delimiter") (id "F:673783")) "*/") "\n\n\n" (span (|@| (class "keyword") (id "F:673788")) "static") " " (span (|@| (class "type") (id "F:673795")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:673807")) "calc_line_height_property") " (" (span (|@| (class "type") (id "F:673834")) "it") ", val, " (span (|@| (class "type") (id "F:673843")) "font") ", boff, override)\n     " (span (|@| (class "keyword") (id "F:673870")) "struct") " " (span (|@| (class "type") (id "F:673877")) "it") " *" (span (|@| (class "variable-name") (id "F:673881")) "it") ";\n     " (span (|@| (class "type") (id "F:673890")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:673902")) "val") ";\n     " (span (|@| (class "keyword") (id "F:673912")) "struct") " " (span (|@| (class "type") (id "F:673919")) "font") " *" (span (|@| (class "variable-name") (id "F:673925")) "font") ";\n     " (span (|@| (class "type") (id "F:673936")) "int") " " (span (|@| (class "variable-name") (id "F:673940")) "boff") ", " (span (|@| (class "variable-name") (id "F:673946")) "override") ";\n{\n  " (span (|@| (class "type") (id "F:673960")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:673972")) "face_name") " = Qnil;\n  " (span (|@| (class "type") (id "F:673992")) "int") " " (span (|@| (class "variable-name") (id "F:673996")) "ascent") ", " (span (|@| (class "variable-name") (id "F:674004")) "descent") ", " (span (|@| (class "variable-name") (id "F:674013")) "height") ";\n\n  " (span (|@| (class "keyword") (id "F:674024")) "if") " (NILP (val) || INTEGERP (val) || (override && EQ (val, Qt)))\n    " (span (|@| (class "keyword") (id "F:674092")) "return") " val;\n\n  " (span (|@| (class "keyword") (id "F:674107")) "if") " (CONSP (val))\n    {\n      face_name = XCAR (val);\n      val = XCDR (val);\n      " (span (|@| (class "keyword") (id "F:674190")) "if") " (" (span (|@| (class "negation-char") (id "F:674194")) "!") "NUMBERP (val))\n        val = make_number (1);\n      " (span (|@| (class "keyword") (id "F:674240")) "if") " (NILP (face_name))\n        {\n          height = it->ascent + it->descent;\n          " (span (|@| (class "keyword") (id "F:674306")) "goto") " " (span (|@| (class "constant") (id "F:674311")) "scale") ";\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:674330")) "if") " (NILP (face_name))\n    {\n      font = FRAME_FONT (it->f);\n      boff = FRAME_BASELINE_OFFSET (it->f);\n    }\n  " (span (|@| (class "keyword") (id "F:674443")) "else") " " (span (|@| (class "keyword") (id "F:674448")) "if") " (EQ (face_name, Qt))\n    {\n      override = 0;\n    }\n  " (span (|@| (class "keyword") (id "F:674506")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:674523")) "int") " " (span (|@| (class "variable-name") (id "F:674527")) "face_id") ";\n      " (span (|@| (class "keyword") (id "F:674542")) "struct") " " (span (|@| (class "type") (id "F:674549")) "face") " *" (span (|@| (class "variable-name") (id "F:674555")) "face") ";\n\n      face_id = lookup_named_face (it->f, face_name, 0);\n      " (span (|@| (class "keyword") (id "F:674625")) "if") " (face_id < 0)\n        " (span (|@| (class "keyword") (id "F:674643")) "return") " make_number (-1);\n\n      face = FACE_FROM_ID (it->f, face_id);\n      font = face->font;\n      " (span (|@| (class "keyword") (id "F:674744")) "if") " (font == " (span (|@| (class "constant") (id "F:674756")) "NULL") ")\n        " (span (|@| (class "keyword") (id "F:674763")) "return") " make_number (-1);\n      boff = font->baseline_offset;\n      " (span (|@| (class "keyword") (id "F:674830")) "if") " (font->vertical_centering)\n        boff = VCENTER_BASELINE_OFFSET (font, it->f) - boff;\n    }\n\n  ascent = FONT_BASE (font) + boff;\n  descent = FONT_DESCENT (font) - boff;\n\n  " (span (|@| (class "keyword") (id "F:675000")) "if") " (override)\n    {\n      it->override_ascent = ascent;\n      it->override_descent = descent;\n      it->override_boff = boff;\n    }\n\n  height = ascent + descent;\n\n " (span (|@| (class "constant") (id "F:675164")) "scale") ":\n  " (span (|@| (class "keyword") (id "F:675173")) "if") " (FLOATP (val))\n    height = (" (span (|@| (class "type") (id "F:675205")) "int") ")(XFLOAT_DATA (val) * height);\n  " (span (|@| (class "keyword") (id "F:675241")) "else") " " (span (|@| (class "keyword") (id "F:675246")) "if") " (INTEGERP (val))\n    height *= XINT (val);\n\n  " (span (|@| (class "keyword") (id "F:675295")) "return") " make_number (height);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:675328")) "/* ") (span (|@| (class "comment") (id "F:675331")) "RIF:\n   Produce glyphs/get display metrics for the display element IT is\n   loaded with.  See the description of struct it in dispextern.h\n   for an overview of struct it.  ") (span (|@| (class "comment-delimiter") (id "F:675504")) "*/") "\n\n" (span (|@| (class "type") (id "F:675508")) "void") "\n" (span (|@| (class "function-name") (id "F:675513")) "x_produce_glyphs") " (" (span (|@| (class "type") (id "F:675531")) "it") ")\n     " (span (|@| (class "keyword") (id "F:675540")) "struct") " " (span (|@| (class "type") (id "F:675547")) "it") " *" (span (|@| (class "variable-name") (id "F:675551")) "it") ";\n{\n  " (span (|@| (class "type") (id "F:675559")) "int") " " (span (|@| (class "variable-name") (id "F:675563")) "extra_line_spacing") " = it->extra_line_spacing;\n\n  it->glyph_not_available_p = 0;\n\n  " (span (|@| (class "keyword") (id "F:675645")) "if") " (it->what == IT_CHARACTER)\n    {\n      " (span (|@| (class "type") (id "F:675687")) "XChar2b") " " (span (|@| (class "variable-name") (id "F:675695")) "char2b") ";\n      " (span (|@| (class "keyword") (id "F:675709")) "struct") " " (span (|@| (class "type") (id "F:675716")) "font") " *" (span (|@| (class "variable-name") (id "F:675722")) "font") ";\n      " (span (|@| (class "keyword") (id "F:675734")) "struct") " " (span (|@| (class "type") (id "F:675741")) "face") " *" (span (|@| (class "variable-name") (id "F:675747")) "face") " = FACE_FROM_ID (it->f, it->face_id);\n      " (span (|@| (class "keyword") (id "F:675795")) "struct") " " (span (|@| (class "type") (id "F:675802")) "font_metrics") " *" (span (|@| (class "variable-name") (id "F:675816")) "pcm") ";\n      " (span (|@| (class "type") (id "F:675827")) "int") " " (span (|@| (class "variable-name") (id "F:675831")) "font_not_found_p") ";\n      " (span (|@| (class "type") (id "F:675855")) "int") " " (span (|@| (class "variable-name") (id "F:675859")) "boff") ";                 " (span (|@| (class "comment-delimiter") (id "F:675867")) "/* ") (span (|@| (class "comment") (id "F:675870")) "baseline offset ") (span (|@| (class "comment-delimiter") (id "F:675886")) "*/") "\n      " (span (|@| (class "comment-delimiter") (id "F:675895")) "/* ") (span (|@| (class "comment") (id "F:675898")) "We may change it->multibyte_p upon unibyte<->multibyte\n         conversion.  So, save the current value now and restore it\n         later.\n\n         Note: It seems that we don't have to record multibyte_p in\n         struct glyph because the character code itself tells whether\n         or not the character is multibyte.  Thus, in the future, we\n         must consider eliminating the field `multibyte_p' in the\n         struct glyph.  ") (span (|@| (class "comment-delimiter") (id "F:676286")) "*/") "\n      " (span (|@| (class "type") (id "F:676295")) "int") " " (span (|@| (class "variable-name") (id "F:676299")) "saved_multibyte_p") " = it->multibyte_p;\n\n      " (span (|@| (class "comment-delimiter") (id "F:676343")) "/* ") (span (|@| (class "comment") (id "F:676346")) "Maybe translate single-byte characters to multibyte, or the\n         other way.  ") (span (|@| (class "comment-delimiter") (id "F:676420")) "*/") "\n      it->char_to_display = it->c;\n      " (span (|@| (class "keyword") (id "F:676464")) "if") " (" (span (|@| (class "negation-char") (id "F:676468")) "!") "ASCII_BYTE_P (it->c)\n          && " (span (|@| (class "negation-char") (id "F:676496")) "!") " it->multibyte_p)\n        {\n          " (span (|@| (class "keyword") (id "F:676521")) "if") " (SINGLE_BYTE_CHAR_P (it->c)\n              && unibyte_display_via_language_environment)\n            {\n              " (span (|@| (class "keyword") (id "F:676618")) "struct") " " (span (|@| (class "type") (id "F:676625")) "charset") " *" (span (|@| (class "variable-name") (id "F:676634")) "unibyte") " = CHARSET_FROM_ID (charset_unibyte);\n\n              " (span (|@| (class "comment-delimiter") (id "F:676687")) "/* ") (span (|@| (class "comment") (id "F:676690")) "get_next_display_element assures that this decoding\n                 never fails.  ") (span (|@| (class "comment-delimiter") (id "F:676759")) "*/") "\n              it->char_to_display = DECODE_CHAR (unibyte, it->c);\n              it->multibyte_p = 1;\n              it->face_id = FACE_FOR_CHAR (it->f, face, it->char_to_display,\n                                           -1, Qnil);\n              face = FACE_FROM_ID (it->f, it->face_id);\n            }\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:677004")) "/* ") (span (|@| (class "comment") (id "F:677007")) "Get font to use.  Encode IT->char_to_display.  ") (span (|@| (class "comment-delimiter") (id "F:677054")) "*/") "\n      get_char_face_and_encoding (it->f, it->char_to_display, it->face_id,\n                                  &char2b, it->multibyte_p, 0);\n      font = face->font;\n\n      font_not_found_p = font == " (span (|@| (class "constant") (id "F:677227")) "NULL") ";\n      " (span (|@| (class "keyword") (id "F:677239")) "if") " (font_not_found_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:677267")) "/* ") (span (|@| (class "comment") (id "F:677270")) "When no suitable font found, display an empty box based\n             on the metrics of the font of the default face (or what\n             remapped).  ") (span (|@| (class "comment-delimiter") (id "F:677406")) "*/") "\n          " (span (|@| (class "keyword") (id "F:677412")) "struct") " " (span (|@| (class "type") (id "F:677419")) "face") " *" (span (|@| (class "variable-name") (id "F:677425")) "no_font_face") "\n            = FACE_FROM_ID (it->f,\n                            NILP (Vface_remapping_alist) ? DEFAULT_FACE_ID\n                            : lookup_basic_face (it->f, DEFAULT_FACE_ID));\n          font = no_font_face->font;\n          boff = font->baseline_offset;\n        }\n      " (span (|@| (class "keyword") (id "F:677646")) "else") "\n        {\n          boff = font->baseline_offset;\n          " (span (|@| (class "keyword") (id "F:677690")) "if") " (font->vertical_centering)\n            boff = VCENTER_BASELINE_OFFSET (font, it->f) - boff;\n        }\n\n      " (span (|@| (class "keyword") (id "F:677788")) "if") " (it->char_to_display >= " (span (|@| (class "string") (id "F:677815")) "' '") "\n          && (" (span (|@| (class "negation-char") (id "F:677826")) "!") "it->multibyte_p || it->char_to_display < 128))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:677880")) "/* ") (span (|@| (class "comment") (id "F:677883")) "Either unibyte or ASCII.  ") (span (|@| (class "comment-delimiter") (id "F:677909")) "*/") "\n          " (span (|@| (class "type") (id "F:677915")) "int") " " (span (|@| (class "variable-name") (id "F:677919")) "stretched_p") ";\n\n          it->nglyphs = 1;\n\n          pcm = get_per_char_metric (it->f, font, &char2b);\n\n          " (span (|@| (class "keyword") (id "F:678012")) "if") " (it->override_ascent >= 0)\n            {\n              it->ascent = it->override_ascent;\n              it->descent = it->override_descent;\n              boff = it->override_boff;\n            }\n          " (span (|@| (class "keyword") (id "F:678182")) "else") "\n            {\n              it->ascent = FONT_BASE (font) + boff;\n              it->descent = FONT_DESCENT (font) - boff;\n            }\n\n          " (span (|@| (class "keyword") (id "F:678303")) "if") " (pcm)\n            {\n              it->phys_ascent = pcm->ascent + boff;\n              it->phys_descent = pcm->descent - boff;\n              it->pixel_width = pcm->width;\n            }\n          " (span (|@| (class "keyword") (id "F:678458")) "else") "\n            {\n              it->glyph_not_available_p = 1;\n              it->phys_ascent = it->ascent;\n              it->phys_descent = it->descent;\n              it->pixel_width = FONT_WIDTH (font);\n            }\n\n          " (span (|@| (class "keyword") (id "F:678639")) "if") " (it->constrain_row_ascent_descent_p)\n            {\n              " (span (|@| (class "keyword") (id "F:678693")) "if") " (it->descent > it->max_descent)\n                {\n                  it->ascent += it->descent - it->max_descent;\n                  it->descent = it->max_descent;\n                }\n              " (span (|@| (class "keyword") (id "F:678832")) "if") " (it->ascent > it->max_ascent)\n                {\n                  it->descent = min (it->max_descent, it->descent + it->ascent - it->max_ascent);\n                  it->ascent = it->max_ascent;\n                }\n              it->phys_ascent = min (it->phys_ascent, it->ascent);\n              it->phys_descent = min (it->phys_descent, it->descent);\n              extra_line_spacing = 0;\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:679164")) "/* ") (span (|@| (class "comment") (id "F:679167")) "If this is a space inside a region of text with\n             `space-width' property, change its width.  ") (span (|@| (class "comment-delimiter") (id "F:679264")) "*/") "\n          stretched_p = it->char_to_display == " (span (|@| (class "string") (id "F:679307")) "' '") " && " (span (|@| (class "negation-char") (id "F:679314")) "!") "NILP (it->space_width);\n          " (span (|@| (class "keyword") (id "F:679342")) "if") " (stretched_p)\n            it->pixel_width *= XFLOATINT (it->space_width);\n\n          " (span (|@| (class "comment-delimiter") (id "F:679416")) "/* ") (span (|@| (class "comment") (id "F:679419")) "If face has a box, add the box thickness to the character\n             height.  If character has a box line to the left and/or\n             right, add the box line width to the character's width.  ") (span (|@| (class "comment-delimiter") (id "F:679602")) "*/") "\n          " (span (|@| (class "keyword") (id "F:679608")) "if") " (face->box != FACE_NO_BOX)\n            {\n              " (span (|@| (class "type") (id "F:679652")) "int") " " (span (|@| (class "variable-name") (id "F:679656")) "thick") " = face->box_line_width;\n\n              " (span (|@| (class "keyword") (id "F:679694")) "if") " (thick > 0)\n                {\n                  it->ascent += thick;\n                  it->descent += thick;\n                }\n              " (span (|@| (class "keyword") (id "F:679775")) "else") "\n                thick = -thick;\n\n              " (span (|@| (class "keyword") (id "F:679806")) "if") " (it->start_of_box_run_p)\n                it->pixel_width += thick;\n              " (span (|@| (class "keyword") (id "F:679869")) "if") " (it->end_of_box_run_p)\n                it->pixel_width += thick;\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:679934")) "/* ") (span (|@| (class "comment") (id "F:679937")) "If face has an overline, add the height of the overline\n             (1 pixel) and a 1 pixel margin to the character height.  ") (span (|@| (class "comment-delimiter") (id "F:680056")) "*/") "\n          " (span (|@| (class "keyword") (id "F:680062")) "if") " (face->overline_p)\n            it->ascent += overline_margin;\n\n          " (span (|@| (class "keyword") (id "F:680124")) "if") " (it->constrain_row_ascent_descent_p)\n            {\n              " (span (|@| (class "keyword") (id "F:680178")) "if") " (it->ascent > it->max_ascent)\n                it->ascent = it->max_ascent;\n              " (span (|@| (class "keyword") (id "F:680249")) "if") " (it->descent > it->max_descent)\n                it->descent = it->max_descent;\n            }\n\n          take_vertical_position_into_account (it);\n\n          " (span (|@| (class "comment-delimiter") (id "F:680374")) "/* ") (span (|@| (class "comment") (id "F:680377")) "If we have to actually produce glyphs, do it.  ") (span (|@| (class "comment-delimiter") (id "F:680424")) "*/") "\n          " (span (|@| (class "keyword") (id "F:680430")) "if") " (it->glyph_row)\n            {\n              " (span (|@| (class "keyword") (id "F:680463")) "if") " (stretched_p)\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:680488")) "/* ") (span (|@| (class "comment") (id "F:680491")) "Translate a space with a `space-width' property\n                     into a stretch glyph.  ") (span (|@| (class "comment-delimiter") (id "F:680569")) "*/") "\n                  " (span (|@| (class "type") (id "F:680576")) "int") " " (span (|@| (class "variable-name") (id "F:680580")) "ascent") " = (((it->ascent + it->descent) * FONT_BASE (font))\n                                / FONT_HEIGHT (font));\n                  append_stretch_glyph (it, it->object, it->pixel_width,\n                                        it->ascent + it->descent, ascent);\n                }\n              " (span (|@| (class "keyword") (id "F:680775")) "else") "\n                append_glyph (it);\n\n              " (span (|@| (class "comment-delimiter") (id "F:680809")) "/* ") (span (|@| (class "comment") (id "F:680812")) "If characters with lbearing or rbearing are displayed\n                 in this line, record that fact in a flag of the\n                 glyph row.  This is used to optimize X output code.  ") (span (|@| (class "comment-delimiter") (id "F:680973")) "*/") "\n              " (span (|@| (class "keyword") (id "F:680983")) "if") " (pcm && (pcm->lbearing < 0 || pcm->rbearing > pcm->width))\n                it->glyph_row->contains_overlapping_glyphs_p = 1;\n            }\n          " (span (|@| (class "keyword") (id "F:681107")) "if") " (" (span (|@| (class "negation-char") (id "F:681111")) "!") " stretched_p && it->pixel_width == 0)\n            " (span (|@| (class "comment-delimiter") (id "F:681155")) "/* ") (span (|@| (class "comment") (id "F:681158")) "We assure that all visible glyphs have at least 1-pixel\n               width.  ") (span (|@| (class "comment-delimiter") (id "F:681230")) "*/") "\n            it->pixel_width = 1;\n        }\n      " (span (|@| (class "keyword") (id "F:681268")) "else") " " (span (|@| (class "keyword") (id "F:681273")) "if") " (it->char_to_display == " (span (|@| (class "string") (id "F:681300")) "'\\n'") ")\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:681312")) "/* ") (span (|@| (class "comment") (id "F:681315")) "A newline has no width, but we need the height of the\n             line.  But if previous part of the line sets a height,\n             don't increase that height ") (span (|@| (class "comment-delimiter") (id "F:681463")) "*/") "\n\n          " (span (|@| (class "type") (id "F:681470")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:681482")) "height") ";\n          " (span (|@| (class "type") (id "F:681493")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:681505")) "total_height") " = Qnil;\n\n          it->override_ascent = -1;\n          it->pixel_width = 0;\n          it->nglyphs = 0;\n\n          height = get_it_property(it, Qline_height);\n          " (span (|@| (class "comment-delimiter") (id "F:681651")) "/* ") (span (|@| (class "comment") (id "F:681654")) "Split (line-height total-height) list ") (span (|@| (class "comment-delimiter") (id "F:681692")) "*/") "\n          " (span (|@| (class "keyword") (id "F:681698")) "if") " (CONSP (height)\n              && CONSP (XCDR (height))\n              && NILP (XCDR (XCDR (height))))\n            {\n              total_height = XCAR (XCDR (height));\n              height = XCAR (height);\n            }\n          height = calc_line_height_property(it, height, font, boff, 1);\n\n          " (span (|@| (class "keyword") (id "F:681947")) "if") " (it->override_ascent >= 0)\n            {\n              it->ascent = it->override_ascent;\n              it->descent = it->override_descent;\n              boff = it->override_boff;\n            }\n          " (span (|@| (class "keyword") (id "F:682111")) "else") "\n            {\n              it->ascent = FONT_BASE (font) + boff;\n              it->descent = FONT_DESCENT (font) - boff;\n            }\n\n          " (span (|@| (class "keyword") (id "F:682228")) "if") " (EQ (height, Qt))\n            {\n              " (span (|@| (class "keyword") (id "F:682263")) "if") " (it->descent > it->max_descent)\n                {\n                  it->ascent += it->descent - it->max_descent;\n                  it->descent = it->max_descent;\n                }\n              " (span (|@| (class "keyword") (id "F:682397")) "if") " (it->ascent > it->max_ascent)\n                {\n                  it->descent = min (it->max_descent, it->descent + it->ascent - it->max_ascent);\n                  it->ascent = it->max_ascent;\n                }\n              it->phys_ascent = min (it->phys_ascent, it->ascent);\n              it->phys_descent = min (it->phys_descent, it->descent);\n              it->constrain_row_ascent_descent_p = 1;\n              extra_line_spacing = 0;\n            }\n          " (span (|@| (class "keyword") (id "F:682766")) "else") "\n            {\n              " (span (|@| (class "type") (id "F:682785")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:682797")) "spacing") ";\n\n              it->phys_ascent = it->ascent;\n              it->phys_descent = it->descent;\n\n              " (span (|@| (class "keyword") (id "F:682891")) "if") " ((it->max_ascent > 0 || it->max_descent > 0)\n                  && face->box != FACE_NO_BOX\n                  && face->box_line_width > 0)\n                {\n                  it->ascent += face->box_line_width;\n                  it->descent += face->box_line_width;\n                }\n              " (span (|@| (class "keyword") (id "F:683100")) "if") " (" (span (|@| (class "negation-char") (id "F:683104")) "!") "NILP (height)\n                  && XINT (height) > it->ascent + it->descent)\n                it->ascent = XINT (height) - it->descent;\n\n              " (span (|@| (class "keyword") (id "F:683220")) "if") " (" (span (|@| (class "negation-char") (id "F:683224")) "!") "NILP (total_height))\n                spacing = calc_line_height_property(it, total_height, font, boff, 0);\n              " (span (|@| (class "keyword") (id "F:683325")) "else") "\n                {\n                  spacing = get_it_property(it, Qline_spacing);\n                  spacing = calc_line_height_property(it, spacing, font, boff, 0);\n                }\n              " (span (|@| (class "keyword") (id "F:683464")) "if") " (INTEGERP (spacing))\n                {\n                  extra_line_spacing = XINT (spacing);\n                  " (span (|@| (class "keyword") (id "F:683537")) "if") " (" (span (|@| (class "negation-char") (id "F:683541")) "!") "NILP (total_height))\n                    extra_line_spacing -= (it->phys_ascent + it->phys_descent);\n                }\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:683649")) "else") " " (span (|@| (class "keyword") (id "F:683654")) "if") " (it->char_to_display == " (span (|@| (class "string") (id "F:683681")) "'\\t'") ")\n        {\n          " (span (|@| (class "keyword") (id "F:683693")) "if") " (font->space_width > 0)\n            {\n              " (span (|@| (class "type") (id "F:683734")) "int") " " (span (|@| (class "variable-name") (id "F:683738")) "tab_width") " = it->tab_width * font->space_width;\n              " (span (|@| (class "type") (id "F:683792")) "int") " " (span (|@| (class "variable-name") (id "F:683796")) "x") " = it->current_x + it->continuation_lines_width;\n              " (span (|@| (class "type") (id "F:683853")) "int") " " (span (|@| (class "variable-name") (id "F:683857")) "next_tab_x") " = ((1 + x + tab_width - 1) / tab_width) * tab_width;\n\n              " (span (|@| (class "comment-delimiter") (id "F:683929")) "/* ") (span (|@| (class "comment") (id "F:683932")) "If the distance from the current position to the next tab\n                 stop is less than a space character width, use the\n                 tab stop after that.  ") (span (|@| (class "comment-delimiter") (id "F:684069")) "*/") "\n              " (span (|@| (class "keyword") (id "F:684079")) "if") " (next_tab_x - x < font->space_width)\n                next_tab_x += tab_width;\n\n              it->pixel_width = next_tab_x - x;\n              it->nglyphs = 1;\n              it->ascent = it->phys_ascent = FONT_BASE (font) + boff;\n              it->descent = it->phys_descent = FONT_DESCENT (font) - boff;\n\n              " (span (|@| (class "keyword") (id "F:684351")) "if") " (it->glyph_row)\n                {\n                  append_stretch_glyph (it, it->object, it->pixel_width,\n                                        it->ascent + it->descent, it->ascent);\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:684491")) "else") "\n            {\n              it->pixel_width = 0;\n              it->nglyphs = 1;\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:684571")) "else") "\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:684582")) "/* ") (span (|@| (class "comment") (id "F:684585")) "A multi-byte character.  Assume that the display width of the\n             character is the width of the character multiplied by the\n             width of the font.  ") (span (|@| (class "comment-delimiter") (id "F:684737")) "*/") "\n\n          " (span (|@| (class "comment-delimiter") (id "F:684744")) "/* ") (span (|@| (class "comment") (id "F:684747")) "If we found a font, this font should give us the right\n             metrics.  If we didn't find a font, use the frame's\n             default font and calculate the width of the character by\n             multiplying the width of font by the width of the\n             character.  ") (span (|@| (class "comment-delimiter") (id "F:684997")) "*/") "\n\n          pcm = get_per_char_metric (it->f, font, &char2b);\n\n          " (span (|@| (class "keyword") (id "F:685058")) "if") " (font_not_found_p || " (span (|@| (class "negation-char") (id "F:685082")) "!") "pcm)\n            {\n              " (span (|@| (class "type") (id "F:685102")) "int") " " (span (|@| (class "variable-name") (id "F:685106")) "char_width") " = CHAR_WIDTH (it->char_to_display);\n\n              " (span (|@| (class "keyword") (id "F:685161")) "if") " (char_width == 0)\n                " (span (|@| (class "comment-delimiter") (id "F:685184")) "/* ") (span (|@| (class "comment") (id "F:685187")) "This is a non spacing character.  But, as we are\n                   going to display an empty box, the box must occupy\n                   at least one column.  ") (span (|@| (class "comment-delimiter") (id "F:685319")) "*/") "\n                char_width = 1;\n              it->glyph_not_available_p = 1;\n              it->pixel_width = font->space_width * char_width;\n              it->phys_ascent = FONT_BASE (font) + boff;\n              it->phys_descent = FONT_DESCENT (font) - boff;\n            }\n          " (span (|@| (class "keyword") (id "F:685549")) "else") "\n            {\n              it->pixel_width = pcm->width;\n              it->phys_ascent = pcm->ascent + boff;\n              it->phys_descent = pcm->descent - boff;\n              " (span (|@| (class "keyword") (id "F:685697")) "if") " (it->glyph_row\n                  && (pcm->lbearing < 0\n                      || pcm->rbearing > pcm->width))\n                it->glyph_row->contains_overlapping_glyphs_p = 1;\n            }\n          it->nglyphs = 1;\n          it->ascent = FONT_BASE (font) + boff;\n          it->descent = FONT_DESCENT (font) - boff;\n          " (span (|@| (class "keyword") (id "F:685963")) "if") " (face->box != FACE_NO_BOX)\n            {\n              " (span (|@| (class "type") (id "F:686007")) "int") " " (span (|@| (class "variable-name") (id "F:686011")) "thick") " = face->box_line_width;\n\n              " (span (|@| (class "keyword") (id "F:686049")) "if") " (thick > 0)\n                {\n                  it->ascent += thick;\n                  it->descent += thick;\n                }\n              " (span (|@| (class "keyword") (id "F:686130")) "else") "\n                thick = - thick;\n\n              " (span (|@| (class "keyword") (id "F:686162")) "if") " (it->start_of_box_run_p)\n                it->pixel_width += thick;\n              " (span (|@| (class "keyword") (id "F:686225")) "if") " (it->end_of_box_run_p)\n                it->pixel_width += thick;\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:686290")) "/* ") (span (|@| (class "comment") (id "F:686293")) "If face has an overline, add the height of the overline\n             (1 pixel) and a 1 pixel margin to the character height.  ") (span (|@| (class "comment-delimiter") (id "F:686412")) "*/") "\n          " (span (|@| (class "keyword") (id "F:686418")) "if") " (face->overline_p)\n            it->ascent += overline_margin;\n\n          take_vertical_position_into_account (it);\n\n          " (span (|@| (class "keyword") (id "F:686526")) "if") " (it->ascent < 0)\n            it->ascent = 0;\n          " (span (|@| (class "keyword") (id "F:686570")) "if") " (it->descent < 0)\n            it->descent = 0;\n\n          " (span (|@| (class "keyword") (id "F:686617")) "if") " (it->glyph_row)\n            append_glyph (it);\n          " (span (|@| (class "keyword") (id "F:686663")) "if") " (it->pixel_width == 0)\n            " (span (|@| (class "comment-delimiter") (id "F:686694")) "/* ") (span (|@| (class "comment") (id "F:686697")) "We assure that all visible glyphs have at least 1-pixel\n               width.  ") (span (|@| (class "comment-delimiter") (id "F:686769")) "*/") "\n            it->pixel_width = 1;\n        }\n      it->multibyte_p = saved_multibyte_p;\n    }\n  " (span (|@| (class "keyword") (id "F:686852")) "else") " " (span (|@| (class "keyword") (id "F:686857")) "if") " (it->what == IT_COMPOSITION && it->cmp_it.ch < 0)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:686922")) "/* ") (span (|@| (class "comment") (id "F:686925")) "A static composition.\n\n         Note: A composition is represented as one glyph in the\n         glyph matrix.  There are no padding glyphs.\n\n         Important note: pixel_width, ascent, and descent are the\n         values of what is drawn by draw_glyphs (i.e. the values of\n         the overall glyphs composed).  ") (span (|@| (class "comment-delimiter") (id "F:687205")) "*/") "\n      " (span (|@| (class "keyword") (id "F:687214")) "struct") " " (span (|@| (class "type") (id "F:687221")) "face") " *" (span (|@| (class "variable-name") (id "F:687227")) "face") " = FACE_FROM_ID (it->f, it->face_id);\n      " (span (|@| (class "type") (id "F:687275")) "int") " " (span (|@| (class "variable-name") (id "F:687279")) "boff") ";                 " (span (|@| (class "comment-delimiter") (id "F:687287")) "/* ") (span (|@| (class "comment") (id "F:687290")) "baseline offset ") (span (|@| (class "comment-delimiter") (id "F:687306")) "*/") "\n      " (span (|@| (class "keyword") (id "F:687315")) "struct") " " (span (|@| (class "type") (id "F:687322")) "composition") " *" (span (|@| (class "variable-name") (id "F:687335")) "cmp") " = composition_table[it->cmp_it.id];\n      " (span (|@| (class "type") (id "F:687381")) "int") " " (span (|@| (class "variable-name") (id "F:687385")) "glyph_len") " = cmp->glyph_len;\n      " (span (|@| (class "keyword") (id "F:687419")) "struct") " " (span (|@| (class "type") (id "F:687426")) "font") " *" (span (|@| (class "variable-name") (id "F:687432")) "font") " = face->font;\n\n      it->nglyphs = 1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:687482")) "/* ") (span (|@| (class "comment") (id "F:687485")) "If we have not yet calculated pixel size data of glyphs of\n         the composition for the current face font, calculate them\n         now.  Theoretically, we have to check all fonts for the\n         glyphs, but that requires much time and memory space.  So,\n         here we check only the font of the first glyph.  This may\n         lead to incorrect display, but it's very rare, and C-l\n         (recenter-top-bottom) can correct the display anyway.  ") (span (|@| (class "comment-delimiter") (id "F:687897")) "*/") "\n      " (span (|@| (class "keyword") (id "F:687906")) "if") " (" (span (|@| (class "negation-char") (id "F:687910")) "!") " cmp->font || cmp->font != font)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:687950")) "/* ") (span (|@| (class "comment") (id "F:687953")) "Ascent and descent of the font of the first character\n             of this composition (adjusted by baseline offset).\n             Ascent and descent of overall glyphs should not be less\n             than these, respectively.  ") (span (|@| (class "comment-delimiter") (id "F:688159")) "*/") "\n          " (span (|@| (class "type") (id "F:688165")) "int") " " (span (|@| (class "variable-name") (id "F:688169")) "font_ascent") ", " (span (|@| (class "variable-name") (id "F:688182")) "font_descent") ", " (span (|@| (class "variable-name") (id "F:688196")) "font_height") ";\n          " (span (|@| (class "comment-delimiter") (id "F:688212")) "/* ") (span (|@| (class "comment") (id "F:688215")) "Bounding box of the overall glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:688252")) "*/") "\n          " (span (|@| (class "type") (id "F:688258")) "int") " " (span (|@| (class "variable-name") (id "F:688262")) "leftmost") ", " (span (|@| (class "variable-name") (id "F:688272")) "rightmost") ", " (span (|@| (class "variable-name") (id "F:688283")) "lowest") ", " (span (|@| (class "variable-name") (id "F:688291")) "highest") ";\n          " (span (|@| (class "type") (id "F:688303")) "int") " " (span (|@| (class "variable-name") (id "F:688307")) "lbearing") ", " (span (|@| (class "variable-name") (id "F:688317")) "rbearing") ";\n          " (span (|@| (class "type") (id "F:688330")) "int") " " (span (|@| (class "variable-name") (id "F:688334")) "i") ", " (span (|@| (class "variable-name") (id "F:688337")) "width") ", " (span (|@| (class "variable-name") (id "F:688344")) "ascent") ", " (span (|@| (class "variable-name") (id "F:688352")) "descent") ";\n          " (span (|@| (class "type") (id "F:688364")) "int") " " (span (|@| (class "variable-name") (id "F:688368")) "left_padded") " = 0, " (span (|@| (class "variable-name") (id "F:688385")) "right_padded") " = 0;\n          " (span (|@| (class "type") (id "F:688406")) "int") " " (span (|@| (class "variable-name") (id "F:688410")) "c") ";\n          " (span (|@| (class "type") (id "F:688416")) "XChar2b") " " (span (|@| (class "variable-name") (id "F:688424")) "char2b") ";\n          " (span (|@| (class "keyword") (id "F:688435")) "struct") " " (span (|@| (class "type") (id "F:688442")) "font_metrics") " *" (span (|@| (class "variable-name") (id "F:688456")) "pcm") ";\n          " (span (|@| (class "type") (id "F:688464")) "int") " " (span (|@| (class "variable-name") (id "F:688468")) "font_not_found_p") ";\n          " (span (|@| (class "type") (id "F:688489")) "int") " " (span (|@| (class "variable-name") (id "F:688493")) "pos") ";\n\n          " (span (|@| (class "keyword") (id "F:688502")) "for") " (glyph_len = cmp->glyph_len; glyph_len > 0; glyph_len--)\n            " (span (|@| (class "keyword") (id "F:688568")) "if") " ((c = COMPOSITION_GLYPH (cmp, glyph_len - 1)) != " (span (|@| (class "string") (id "F:688620")) "'\\t'") ")\n              " (span (|@| (class "keyword") (id "F:688633")) "break") ";\n          " (span (|@| (class "keyword") (id "F:688643")) "if") " (glyph_len < cmp->glyph_len)\n            right_padded = 1;\n          " (span (|@| (class "keyword") (id "F:688701")) "for") " (i = 0; i < glyph_len; i++)\n            {\n              " (span (|@| (class "keyword") (id "F:688747")) "if") " ((c = COMPOSITION_GLYPH (cmp, i)) != " (span (|@| (class "string") (id "F:688787")) "'\\t'") ")\n                " (span (|@| (class "keyword") (id "F:688795")) "break") ";\n              cmp->offsets[i * 2] = cmp->offsets[i * 2 + 1] = 0;\n            }\n          " (span (|@| (class "keyword") (id "F:688870")) "if") " (i > 0)\n            left_padded = 1;\n\n          pos = (STRINGP (it->string) ? IT_STRING_CHARPOS (*it)\n                 : IT_CHARPOS (*it));\n          " (span (|@| (class "comment-delimiter") (id "F:688988")) "/* ") (span (|@| (class "comment") (id "F:688991")) "If no suitable font is found, use the default font.  ") (span (|@| (class "comment-delimiter") (id "F:689044")) "*/") "\n          font_not_found_p = font == " (span (|@| (class "constant") (id "F:689077")) "NULL") ";\n          " (span (|@| (class "keyword") (id "F:689086")) "if") " (font_not_found_p)\n            {\n              face = face->ascii_face;\n              font = face->font;\n            }\n          boff = font->baseline_offset;\n          " (span (|@| (class "keyword") (id "F:689216")) "if") " (font->vertical_centering)\n            boff = VCENTER_BASELINE_OFFSET (font, it->f) - boff;\n          font_ascent = FONT_BASE (font) + boff;\n          font_descent = FONT_DESCENT (font) - boff;\n          font_height = FONT_HEIGHT (font);\n\n          cmp->font = (" (span (|@| (class "type") (id "F:689446")) "void") " *) font;\n\n          pcm = " (span (|@| (class "constant") (id "F:689470")) "NULL") ";\n          " (span (|@| (class "keyword") (id "F:689479")) "if") " (" (span (|@| (class "negation-char") (id "F:689483")) "!") " font_not_found_p)\n            {\n              get_char_face_and_encoding (it->f, c, it->face_id,\n                                          &char2b, it->multibyte_p, 0);\n              pcm = get_per_char_metric (it->f, font, &char2b);\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:689673")) "/* ") (span (|@| (class "comment") (id "F:689676")) "Initialize the bounding box.  ") (span (|@| (class "comment-delimiter") (id "F:689706")) "*/") "\n          " (span (|@| (class "keyword") (id "F:689712")) "if") " (pcm)\n            {\n              width = pcm->width;\n              ascent = pcm->ascent;\n              descent = pcm->descent;\n              lbearing = pcm->lbearing;\n              rbearing = pcm->rbearing;\n            }\n          " (span (|@| (class "keyword") (id "F:689891")) "else") "\n            {\n              width = FONT_WIDTH (font);\n              ascent = FONT_BASE (font);\n              descent = FONT_DESCENT (font);\n              lbearing = 0;\n              rbearing = width;\n            }\n\n          rightmost = width;\n          leftmost = 0;\n          lowest = - descent + boff;\n          highest = ascent + boff;\n\n          " (span (|@| (class "keyword") (id "F:690164")) "if") " (" (span (|@| (class "negation-char") (id "F:690168")) "!") " font_not_found_p\n              && font->default_ascent\n              && CHAR_TABLE_P (Vuse_default_ascent)\n              && " (span (|@| (class "negation-char") (id "F:690273")) "!") "NILP (Faref (Vuse_default_ascent,\n                               make_number (it->char_to_display))))\n            highest = font->default_ascent + boff;\n\n          " (span (|@| (class "comment-delimiter") (id "F:690403")) "/* ") (span (|@| (class "comment") (id "F:690406")) "Draw the first glyph at the normal position.  It may be\n             shifted to right later if some other glyphs are drawn\n             at the left.  ") (span (|@| (class "comment-delimiter") (id "F:690542")) "*/") "\n          cmp->offsets[i * 2] = 0;\n          cmp->offsets[i * 2 + 1] = boff;\n          cmp->lbearing = lbearing;\n          cmp->rbearing = rbearing;\n\n          " (span (|@| (class "comment-delimiter") (id "F:690670")) "/* ") (span (|@| (class "comment") (id "F:690673")) "Set cmp->offsets for the remaining glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:690717")) "*/") "\n          " (span (|@| (class "keyword") (id "F:690723")) "for") " (i++; i < glyph_len; i++)\n            {\n              " (span (|@| (class "type") (id "F:690767")) "int") " " (span (|@| (class "variable-name") (id "F:690771")) "left") ", " (span (|@| (class "variable-name") (id "F:690777")) "right") ", " (span (|@| (class "variable-name") (id "F:690784")) "btm") ", " (span (|@| (class "variable-name") (id "F:690789")) "top") ";\n              " (span (|@| (class "type") (id "F:690801")) "int") " " (span (|@| (class "variable-name") (id "F:690805")) "ch") " = COMPOSITION_GLYPH (cmp, i);\n              " (span (|@| (class "type") (id "F:690845")) "int") " " (span (|@| (class "variable-name") (id "F:690849")) "face_id") ";\n              " (span (|@| (class "keyword") (id "F:690865")) "struct") " " (span (|@| (class "type") (id "F:690872")) "face") " *" (span (|@| (class "variable-name") (id "F:690878")) "this_face") ";\n              " (span (|@| (class "type") (id "F:690896")) "int") " " (span (|@| (class "variable-name") (id "F:690900")) "this_boff") ";\n\n              " (span (|@| (class "keyword") (id "F:690919")) "if") " (ch == " (span (|@| (class "string") (id "F:690929")) "'\\t'") ")\n                ch = " (span (|@| (class "string") (id "F:690942")) "' '") ";\n              face_id = FACE_FOR_CHAR (it->f, face, ch, pos, it->string);\n              this_face = FACE_FROM_ID (it->f, face_id);\n              font = this_face->font;\n\n              " (span (|@| (class "keyword") (id "F:691103")) "if") " (font == " (span (|@| (class "constant") (id "F:691115")) "NULL") ")\n                pcm = " (span (|@| (class "constant") (id "F:691129")) "NULL") ";\n              " (span (|@| (class "keyword") (id "F:691142")) "else") "\n                {\n                  this_boff = font->baseline_offset;\n                  " (span (|@| (class "keyword") (id "F:691194")) "if") " (font->vertical_centering)\n                    this_boff = VCENTER_BASELINE_OFFSET (font, it->f) - boff;\n                  get_char_face_and_encoding (it->f, ch, face_id,\n                                              &char2b, it->multibyte_p, 0);\n                  pcm = get_per_char_metric (it->f, font, &char2b);\n                }\n              " (span (|@| (class "keyword") (id "F:691446")) "if") " (" (span (|@| (class "negation-char") (id "F:691450")) "!") " pcm)\n                cmp->offsets[i * 2] = cmp->offsets[i * 2 + 1] = 0;\n              " (span (|@| (class "keyword") (id "F:691517")) "else") "\n                {\n                  width = pcm->width;\n                  ascent = pcm->ascent;\n                  descent = pcm->descent;\n                  lbearing = pcm->lbearing;\n                  rbearing = pcm->rbearing;\n                  " (span (|@| (class "keyword") (id "F:691668")) "if") " (cmp->method != COMPOSITION_WITH_RULE_ALTCHARS)\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:691735")) "/* ") (span (|@| (class "comment") (id "F:691738")) "Relative composition with or without\n                         alternate chars.  ") (span (|@| (class "comment-delimiter") (id "F:691797")) "*/") "\n                      left = (leftmost + rightmost - width) / 2;\n                      btm = - descent + boff;\n                      " (span (|@| (class "keyword") (id "F:691891")) "if") " (font->relative_compose\n                          && (" (span (|@| (class "negation-char") (id "F:691927")) "!") " CHAR_TABLE_P (Vignore_relative_composition)\n                              || NILP (Faref (Vignore_relative_composition,\n                                              make_number (ch)))))\n                        {\n\n                          " (span (|@| (class "keyword") (id "F:692071")) "if") " (- descent >= font->relative_compose)\n                            " (span (|@| (class "comment-delimiter") (id "F:692119")) "/* ") (span (|@| (class "comment") (id "F:692122")) "One extra pixel between two glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:692159")) "*/") "\n                            btm = highest + 1;\n                          " (span (|@| (class "keyword") (id "F:692193")) "else") " " (span (|@| (class "keyword") (id "F:692198")) "if") " (ascent <= 0)\n                            " (span (|@| (class "comment-delimiter") (id "F:692222")) "/* ") (span (|@| (class "comment") (id "F:692225")) "One extra pixel between two glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:692262")) "*/") "\n                            btm = lowest - 1 - ascent - descent;\n                        }\n                    }\n                  " (span (|@| (class "keyword") (id "F:692326")) "else") "\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:692347")) "/* ") (span (|@| (class "comment") (id "F:692350")) "A composition rule is specified by an integer\n                         value that encodes global and new reference\n                         points (GREF and NREF).  GREF and NREF are\n                         specified by numbers as below:\n\n                         0---1---2 -- ascent\n                         |       |\n                         |       |\n                         |       |\n                         9--10--11 -- center\n                         |       |\n                         ---3---4---5--- baseline\n                         |       |\n                         6---7---8 -- descent\n                      ") (span (|@| (class "comment-delimiter") (id "F:692707")) "*/") "\n                      " (span (|@| (class "type") (id "F:692718")) "int") " " (span (|@| (class "variable-name") (id "F:692722")) "rule") " = COMPOSITION_RULE (cmp, i);\n                      " (span (|@| (class "type") (id "F:692764")) "int") " " (span (|@| (class "variable-name") (id "F:692768")) "gref") ", " (span (|@| (class "variable-name") (id "F:692774")) "nref") ", " (span (|@| (class "variable-name") (id "F:692780")) "grefx") ", " (span (|@| (class "variable-name") (id "F:692787")) "grefy") ", " (span (|@| (class "variable-name") (id "F:692794")) "nrefx") ", " (span (|@| (class "variable-name") (id "F:692801")) "nrefy") ", " (span (|@| (class "variable-name") (id "F:692808")) "xoff") ", " (span (|@| (class "variable-name") (id "F:692814")) "yoff") ";\n\n                      COMPOSITION_DECODE_RULE (rule, gref, nref, xoff, yoff);\n                      grefx = gref % 3, nrefx = nref % 3;\n                      grefy = gref / 3, nrefy = nref / 3;\n                      " (span (|@| (class "keyword") (id "F:692981")) "if") " (xoff)\n                        xoff = font_height * (xoff - 128) / 256;\n                      " (span (|@| (class "keyword") (id "F:693043")) "if") " (yoff)\n                        yoff = font_height * (yoff - 128) / 256;\n\n                      left = (leftmost\n                              + grefx * (rightmost - leftmost) / 2\n                              - nrefx * width / 2\n                              + xoff);\n\n                      btm = ((grefy == 0 ? highest\n                              : grefy == 1 ? 0\n                              : grefy == 2 ? lowest\n                              : (highest + lowest) / 2)\n                             - (nrefy == 0 ? ascent + descent\n                                : nrefy == 1 ? descent - boff\n                                : nrefy == 2 ? 0\n                                : (ascent + descent) / 2)\n                             + yoff);\n                    }\n\n                  cmp->offsets[i * 2] = left;\n                  cmp->offsets[i * 2 + 1] = btm + descent;\n\n                  " (span (|@| (class "comment-delimiter") (id "F:693580")) "/* ") (span (|@| (class "comment") (id "F:693583")) "Update the bounding box of the overall glyphs. ") (span (|@| (class "comment-delimiter") (id "F:693630")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:693637")) "if") " (width > 0)\n                    {\n                      right = left + width;\n                      " (span (|@| (class "keyword") (id "F:693698")) "if") " (left < leftmost)\n                        leftmost = left;\n                      " (span (|@| (class "keyword") (id "F:693747")) "if") " (right > rightmost)\n                        rightmost = right;\n                    }\n                  top = btm + descent + ascent;\n                  " (span (|@| (class "keyword") (id "F:693838")) "if") " (top > highest)\n                    highest = top;\n                  " (span (|@| (class "keyword") (id "F:693882")) "if") " (btm < lowest)\n                    lowest = btm;\n\n                  " (span (|@| (class "keyword") (id "F:693925")) "if") " (cmp->lbearing > left + lbearing)\n                    cmp->lbearing = left + lbearing;\n                  " (span (|@| (class "keyword") (id "F:694005")) "if") " (cmp->rbearing < left + rbearing)\n                    cmp->rbearing = left + rbearing;\n                }\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:694096")) "/* ") (span (|@| (class "comment") (id "F:694099")) "If there are glyphs whose x-offsets are negative,\n             shift all glyphs to the right and make all x-offsets\n             non-negative.  ") (span (|@| (class "comment-delimiter") (id "F:694229")) "*/") "\n          " (span (|@| (class "keyword") (id "F:694235")) "if") " (leftmost < 0)\n            {\n              " (span (|@| (class "keyword") (id "F:694267")) "for") " (i = 0; i < cmp->glyph_len; i++)\n                cmp->offsets[i * 2] -= leftmost;\n              rightmost -= leftmost;\n              cmp->lbearing -= leftmost;\n              cmp->rbearing -= leftmost;\n            }\n\n          " (span (|@| (class "keyword") (id "F:694448")) "if") " (left_padded && cmp->lbearing < 0)\n            {\n              " (span (|@| (class "keyword") (id "F:694500")) "for") " (i = 0; i < cmp->glyph_len; i++)\n                cmp->offsets[i * 2] -= cmp->lbearing;\n              rightmost -= cmp->lbearing;\n              cmp->rbearing -= cmp->lbearing;\n              cmp->lbearing = 0;\n            }\n          " (span (|@| (class "keyword") (id "F:694687")) "if") " (right_padded && rightmost < cmp->rbearing)\n            {\n              rightmost = cmp->rbearing;\n            }\n\n          cmp->pixel_width = rightmost;\n          cmp->ascent = highest;\n          cmp->descent = - lowest;\n          " (span (|@| (class "keyword") (id "F:694873")) "if") " (cmp->ascent < font_ascent)\n            cmp->ascent = font_ascent;\n          " (span (|@| (class "keyword") (id "F:694939")) "if") " (cmp->descent < font_descent)\n            cmp->descent = font_descent;\n        }\n\n      " (span (|@| (class "keyword") (id "F:695016")) "if") " (it->glyph_row\n          && (cmp->lbearing < 0\n              || cmp->rbearing > cmp->pixel_width))\n        it->glyph_row->contains_overlapping_glyphs_p = 1;\n\n      it->pixel_width = cmp->pixel_width;\n      it->ascent = it->phys_ascent = cmp->ascent;\n      it->descent = it->phys_descent = cmp->descent;\n      " (span (|@| (class "keyword") (id "F:695307")) "if") " (face->box != FACE_NO_BOX)\n        {\n          " (span (|@| (class "type") (id "F:695343")) "int") " " (span (|@| (class "variable-name") (id "F:695347")) "thick") " = face->box_line_width;\n\n          " (span (|@| (class "keyword") (id "F:695381")) "if") " (thick > 0)\n            {\n              it->ascent += thick;\n              it->descent += thick;\n            }\n          " (span (|@| (class "keyword") (id "F:695470")) "else") "\n            thick = - thick;\n\n          " (span (|@| (class "keyword") (id "F:695501")) "if") " (it->start_of_box_run_p)\n            it->pixel_width += thick;\n          " (span (|@| (class "keyword") (id "F:695563")) "if") " (it->end_of_box_run_p)\n            it->pixel_width += thick;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:695630")) "/* ") (span (|@| (class "comment") (id "F:695633")) "If face has an overline, add the height of the overline\n         (1 pixel) and a 1 pixel margin to the character height.  ") (span (|@| (class "comment-delimiter") (id "F:695748")) "*/") "\n      " (span (|@| (class "keyword") (id "F:695757")) "if") " (face->overline_p)\n        it->ascent += overline_margin;\n\n      take_vertical_position_into_account (it);\n      " (span (|@| (class "keyword") (id "F:695866")) "if") " (it->ascent < 0)\n        it->ascent = 0;\n      " (span (|@| (class "keyword") (id "F:695909")) "if") " (it->descent < 0)\n        it->descent = 0;\n\n      " (span (|@| (class "keyword") (id "F:695955")) "if") " (it->glyph_row)\n        append_composite_glyph (it);\n    }\n  " (span (|@| (class "keyword") (id "F:696012")) "else") " " (span (|@| (class "keyword") (id "F:696017")) "if") " (it->what == IT_COMPOSITION)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:696061")) "/* ") (span (|@| (class "comment") (id "F:696064")) "A dynamic (automatic) composition.  ") (span (|@| (class "comment-delimiter") (id "F:696100")) "*/") "\n      " (span (|@| (class "keyword") (id "F:696109")) "struct") " " (span (|@| (class "type") (id "F:696116")) "face") " *" (span (|@| (class "variable-name") (id "F:696122")) "face") " = FACE_FROM_ID (it->f, it->face_id);\n      " (span (|@| (class "type") (id "F:696170")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:696182")) "gstring") ";\n      " (span (|@| (class "keyword") (id "F:696197")) "struct") " " (span (|@| (class "type") (id "F:696204")) "font_metrics") " " (span (|@| (class "variable-name") (id "F:696217")) "metrics") ";\n\n      gstring = composition_gstring_from_id (it->cmp_it.id);\n      it->pixel_width\n        = composition_gstring_width (gstring, it->cmp_it.from, it->cmp_it.to,\n                                     &metrics);\n      " (span (|@| (class "keyword") (id "F:696407")) "if") " (it->glyph_row\n          && (metrics.lbearing < 0 || metrics.rbearing > metrics.width))\n        it->glyph_row->contains_overlapping_glyphs_p = 1;\n      it->ascent = it->phys_ascent = metrics.ascent;\n      it->descent = it->phys_descent = metrics.descent;\n      " (span (|@| (class "keyword") (id "F:696657")) "if") " (face->box != FACE_NO_BOX)\n        {\n          " (span (|@| (class "type") (id "F:696693")) "int") " " (span (|@| (class "variable-name") (id "F:696697")) "thick") " = face->box_line_width;\n\n          " (span (|@| (class "keyword") (id "F:696731")) "if") " (thick > 0)\n            {\n              it->ascent += thick;\n              it->descent += thick;\n            }\n          " (span (|@| (class "keyword") (id "F:696820")) "else") "\n            thick = - thick;\n\n          " (span (|@| (class "keyword") (id "F:696851")) "if") " (it->start_of_box_run_p)\n            it->pixel_width += thick;\n          " (span (|@| (class "keyword") (id "F:696913")) "if") " (it->end_of_box_run_p)\n            it->pixel_width += thick;\n        }\n      " (span (|@| (class "comment-delimiter") (id "F:696979")) "/* ") (span (|@| (class "comment") (id "F:696982")) "If face has an overline, add the height of the overline\n         (1 pixel) and a 1 pixel margin to the character height.  ") (span (|@| (class "comment-delimiter") (id "F:697097")) "*/") "\n      " (span (|@| (class "keyword") (id "F:697106")) "if") " (face->overline_p)\n        it->ascent += overline_margin;\n      take_vertical_position_into_account (it);\n      " (span (|@| (class "keyword") (id "F:697214")) "if") " (it->ascent < 0)\n        it->ascent = 0;\n      " (span (|@| (class "keyword") (id "F:697257")) "if") " (it->descent < 0)\n        it->descent = 0;\n\n      " (span (|@| (class "keyword") (id "F:697303")) "if") " (it->glyph_row)\n        append_composite_glyph (it);\n    }\n  " (span (|@| (class "keyword") (id "F:697360")) "else") " " (span (|@| (class "keyword") (id "F:697365")) "if") " (it->what == IT_IMAGE)\n    produce_image_glyph (it);\n  " (span (|@| (class "keyword") (id "F:697423")) "else") " " (span (|@| (class "keyword") (id "F:697428")) "if") " (it->what == IT_STRETCH)\n    produce_stretch_glyph (it);\n\n  " (span (|@| (class "comment-delimiter") (id "F:697491")) "/* ") (span (|@| (class "comment") (id "F:697494")) "Accumulate dimensions.  Note: can't assume that it->descent > 0\n     because this isn't true for images with `:ascent 100'.  ") (span (|@| (class "comment-delimiter") (id "F:697619")) "*/") "\n  xassert (it->ascent >= 0 && it->descent >= 0);\n  " (span (|@| (class "keyword") (id "F:697673")) "if") " (it->area == TEXT_AREA)\n    it->current_x += it->pixel_width;\n\n  " (span (|@| (class "keyword") (id "F:697741")) "if") " (extra_line_spacing > 0)\n    {\n      it->descent += extra_line_spacing;\n      " (span (|@| (class "keyword") (id "F:697822")) "if") " (extra_line_spacing > it->max_extra_line_spacing)\n        it->max_extra_line_spacing = extra_line_spacing;\n    }\n\n  it->max_ascent = max (it->max_ascent, it->ascent);\n  it->max_descent = max (it->max_descent, it->descent);\n  it->max_phys_ascent = max (it->max_phys_ascent, it->phys_ascent);\n  it->max_phys_descent = max (it->max_phys_descent, it->phys_descent);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:698183")) "/* ") (span (|@| (class "comment") (id "F:698186")) "EXPORT for RIF:\n   Output LEN glyphs starting at START at the nominal cursor position.\n   Advance the nominal cursor over the text.  The global variable\n   updated_window contains the window being updated, updated_row is\n   the glyph row being updated, and updated_area is the area of that\n   row being updated.  ") (span (|@| (class "comment-delimiter") (id "F:698499")) "*/") "\n\n" (span (|@| (class "type") (id "F:698503")) "void") "\n" (span (|@| (class "function-name") (id "F:698508")) "x_write_glyphs") " (start, len)\n     " (span (|@| (class "keyword") (id "F:698541")) "struct") " " (span (|@| (class "type") (id "F:698548")) "glyph") " *" (span (|@| (class "variable-name") (id "F:698555")) "start") ";\n     " (span (|@| (class "type") (id "F:698567")) "int") " " (span (|@| (class "variable-name") (id "F:698571")) "len") ";\n{\n  " (span (|@| (class "type") (id "F:698580")) "int") " " (span (|@| (class "variable-name") (id "F:698584")) "x") ", " (span (|@| (class "variable-name") (id "F:698587")) "hpos") ";\n\n  xassert (updated_window && updated_row);\n  BLOCK_INPUT;\n\n  " (span (|@| (class "comment-delimiter") (id "F:698655")) "/* ") (span (|@| (class "comment") (id "F:698658")) "Write glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:698673")) "*/") "\n\n  hpos = start - updated_row->glyphs[updated_area];\n  x = draw_glyphs (updated_window, output_cursor.x,\n                   updated_row, updated_area,\n                   hpos, hpos + len,\n                   DRAW_NORMAL_TEXT, 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:698866")) "/* ") (span (|@| (class "comment") (id "F:698869")) "Invalidate old phys cursor if the glyph at its hpos is redrawn.  ") (span (|@| (class "comment-delimiter") (id "F:698934")) "*/") "\n  " (span (|@| (class "keyword") (id "F:698939")) "if") " (updated_area == TEXT_AREA\n      && updated_window->phys_cursor_on_p\n      && updated_window->phys_cursor.vpos == output_cursor.vpos\n      && updated_window->phys_cursor.hpos >= hpos\n      && updated_window->phys_cursor.hpos < hpos + len)\n    updated_window->phys_cursor_on_p = 0;\n\n  UNBLOCK_INPUT;\n\n  " (span (|@| (class "comment-delimiter") (id "F:699244")) "/* ") (span (|@| (class "comment") (id "F:699247")) "Advance the output cursor.  ") (span (|@| (class "comment-delimiter") (id "F:699275")) "*/") "\n  output_cursor.hpos += len;\n  output_cursor.x = x;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:699334")) "/* ") (span (|@| (class "comment") (id "F:699337")) "EXPORT for RIF:\n   Insert LEN glyphs from START at the nominal cursor position.  ") (span (|@| (class "comment-delimiter") (id "F:699418")) "*/") "\n\n" (span (|@| (class "type") (id "F:699422")) "void") "\n" (span (|@| (class "function-name") (id "F:699427")) "x_insert_glyphs") " (start, len)\n     " (span (|@| (class "keyword") (id "F:699461")) "struct") " " (span (|@| (class "type") (id "F:699468")) "glyph") " *" (span (|@| (class "variable-name") (id "F:699475")) "start") ";\n     " (span (|@| (class "type") (id "F:699487")) "int") " " (span (|@| (class "variable-name") (id "F:699491")) "len") ";\n{\n  " (span (|@| (class "keyword") (id "F:699500")) "struct") " " (span (|@| (class "type") (id "F:699507")) "frame") " *" (span (|@| (class "variable-name") (id "F:699514")) "f") ";\n  " (span (|@| (class "keyword") (id "F:699519")) "struct") " " (span (|@| (class "type") (id "F:699526")) "window") " *" (span (|@| (class "variable-name") (id "F:699534")) "w") ";\n  " (span (|@| (class "type") (id "F:699539")) "int") " " (span (|@| (class "variable-name") (id "F:699543")) "line_height") ", " (span (|@| (class "variable-name") (id "F:699556")) "shift_by_width") ", " (span (|@| (class "variable-name") (id "F:699572")) "shifted_region_width") ";\n  " (span (|@| (class "keyword") (id "F:699596")) "struct") " " (span (|@| (class "type") (id "F:699603")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:699614")) "row") ";\n  " (span (|@| (class "keyword") (id "F:699621")) "struct") " " (span (|@| (class "type") (id "F:699628")) "glyph") " *" (span (|@| (class "variable-name") (id "F:699635")) "glyph") ";\n  " (span (|@| (class "type") (id "F:699644")) "int") " " (span (|@| (class "variable-name") (id "F:699648")) "frame_x") ", " (span (|@| (class "variable-name") (id "F:699657")) "frame_y") ";\n  " (span (|@| (class "type") (id "F:699668")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:699678")) "hpos") ";\n\n  xassert (updated_window && updated_row);\n  BLOCK_INPUT;\n  w = updated_window;\n  f = XFRAME (WINDOW_FRAME (w));\n\n  " (span (|@| (class "comment-delimiter") (id "F:699801")) "/* ") (span (|@| (class "comment") (id "F:699804")) "Get the height of the line we are in.  ") (span (|@| (class "comment-delimiter") (id "F:699843")) "*/") "\n  row = updated_row;\n  line_height = row->height;\n\n  " (span (|@| (class "comment-delimiter") (id "F:699899")) "/* ") (span (|@| (class "comment") (id "F:699902")) "Get the width of the glyphs to insert.  ") (span (|@| (class "comment-delimiter") (id "F:699942")) "*/") "\n  shift_by_width = 0;\n  " (span (|@| (class "keyword") (id "F:699969")) "for") " (glyph = start; glyph < start + len; ++glyph)\n    shift_by_width += glyph->pixel_width;\n\n  " (span (|@| (class "comment-delimiter") (id "F:700064")) "/* ") (span (|@| (class "comment") (id "F:700067")) "Get the width of the region to shift right.  ") (span (|@| (class "comment-delimiter") (id "F:700112")) "*/") "\n  shifted_region_width = (window_box_width (w, updated_area)\n                          - output_cursor.x\n                          - shift_by_width);\n\n  " (span (|@| (class "comment-delimiter") (id "F:700226")) "/* ") (span (|@| (class "comment") (id "F:700229")) "Shift right.  ") (span (|@| (class "comment-delimiter") (id "F:700243")) "*/") "\n  frame_x = window_box_left (w, updated_area) + output_cursor.x;\n  frame_y = WINDOW_TO_FRAME_PIXEL_Y (w, output_cursor.y);\n\n  FRAME_RIF (f)->shift_glyphs_for_insert (f, frame_x, frame_y, shifted_region_width,\n                                          line_height, shift_by_width);\n\n  " (span (|@| (class "comment-delimiter") (id "F:700530")) "/* ") (span (|@| (class "comment") (id "F:700533")) "Write the glyphs.  ") (span (|@| (class "comment-delimiter") (id "F:700552")) "*/") "\n  hpos = start - row->glyphs[updated_area];\n  draw_glyphs (w, output_cursor.x, row, updated_area,\n               hpos, hpos + len,\n               DRAW_NORMAL_TEXT, 0);\n\n  " (span (|@| (class "comment-delimiter") (id "F:700712")) "/* ") (span (|@| (class "comment") (id "F:700715")) "Advance the output cursor.  ") (span (|@| (class "comment-delimiter") (id "F:700743")) "*/") "\n  output_cursor.hpos += len;\n  output_cursor.x += shift_by_width;\n  UNBLOCK_INPUT;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:700833")) "/* ") (span (|@| (class "comment") (id "F:700836")) "EXPORT for RIF:\n   Erase the current text line from the nominal cursor position\n   (inclusive) to pixel column TO_X (exclusive).  The idea is that\n   everything from TO_X onward is already erased.\n\n   TO_X is a pixel position relative to updated_area of\n   updated_window.  TO_X == -1 means clear to the end of this area.  ") (span (|@| (class "comment-delimiter") (id "F:701159")) "*/") "\n\n" (span (|@| (class "type") (id "F:701163")) "void") "\n" (span (|@| (class "function-name") (id "F:701168")) "x_clear_end_of_line") " (to_x)\n     " (span (|@| (class "type") (id "F:701200")) "int") " " (span (|@| (class "variable-name") (id "F:701204")) "to_x") ";\n{\n  " (span (|@| (class "keyword") (id "F:701214")) "struct") " " (span (|@| (class "type") (id "F:701221")) "frame") " *" (span (|@| (class "variable-name") (id "F:701228")) "f") ";\n  " (span (|@| (class "keyword") (id "F:701233")) "struct") " " (span (|@| (class "type") (id "F:701240")) "window") " *" (span (|@| (class "variable-name") (id "F:701248")) "w") " = updated_window;\n  " (span (|@| (class "type") (id "F:701270")) "int") " " (span (|@| (class "variable-name") (id "F:701274")) "max_x") ", " (span (|@| (class "variable-name") (id "F:701281")) "min_y") ", " (span (|@| (class "variable-name") (id "F:701288")) "max_y") ";\n  " (span (|@| (class "type") (id "F:701297")) "int") " " (span (|@| (class "variable-name") (id "F:701301")) "from_x") ", " (span (|@| (class "variable-name") (id "F:701309")) "from_y") ", " (span (|@| (class "variable-name") (id "F:701317")) "to_y") ";\n\n  xassert (updated_window && updated_row);\n  f = XFRAME (w->frame);\n\n  " (span (|@| (class "keyword") (id "F:701395")) "if") " (updated_row->full_width_p)\n    max_x = WINDOW_TOTAL_WIDTH (w);\n  " (span (|@| (class "keyword") (id "F:701464")) "else") "\n    max_x = window_box_width (w, updated_area);\n  max_y = window_text_bottom_y (w);\n\n  " (span (|@| (class "comment-delimiter") (id "F:701556")) "/* ") (span (|@| (class "comment") (id "F:701559")) "TO_X == 0 means don't do anything.  TO_X < 0 means clear to end\n     of window.  For TO_X > 0, truncate to end of drawing area.  ") (span (|@| (class "comment-delimiter") (id "F:701688")) "*/") "\n  " (span (|@| (class "keyword") (id "F:701693")) "if") " (to_x == 0)\n    " (span (|@| (class "keyword") (id "F:701712")) "return") ";\n  " (span (|@| (class "keyword") (id "F:701722")) "else") " " (span (|@| (class "keyword") (id "F:701727")) "if") " (to_x < 0)\n    to_x = max_x;\n  " (span (|@| (class "keyword") (id "F:701761")) "else") "\n    to_x = min (to_x, max_x);\n\n  to_y = min (max_y, output_cursor.y + updated_row->height);\n\n  " (span (|@| (class "comment-delimiter") (id "F:701861")) "/* ") (span (|@| (class "comment") (id "F:701864")) "Notice if the cursor will be cleared by this operation.  ") (span (|@| (class "comment-delimiter") (id "F:701921")) "*/") "\n  " (span (|@| (class "keyword") (id "F:701926")) "if") " (" (span (|@| (class "negation-char") (id "F:701930")) "!") "updated_row->full_width_p)\n    notice_overwritten_cursor (w, updated_area,\n                               output_cursor.x, -1,\n                               updated_row->y,\n                               MATRIX_ROW_BOTTOM_Y (updated_row));\n\n  from_x = output_cursor.x;\n\n  " (span (|@| (class "comment-delimiter") (id "F:702141")) "/* ") (span (|@| (class "comment") (id "F:702144")) "Translate to frame coordinates.  ") (span (|@| (class "comment-delimiter") (id "F:702177")) "*/") "\n  " (span (|@| (class "keyword") (id "F:702182")) "if") " (updated_row->full_width_p)\n    {\n      from_x = WINDOW_TO_FRAME_PIXEL_X (w, from_x);\n      to_x = WINDOW_TO_FRAME_PIXEL_X (w, to_x);\n    }\n  " (span (|@| (class "keyword") (id "F:702327")) "else") "\n    {\n      " (span (|@| (class "type") (id "F:702344")) "int") " " (span (|@| (class "variable-name") (id "F:702348")) "area_left") " = window_box_left (w, updated_area);\n      from_x += area_left;\n      to_x += area_left;\n    }\n\n  min_y = WINDOW_HEADER_LINE_HEIGHT (w);\n  from_y = WINDOW_TO_FRAME_PIXEL_Y (w, max (min_y, output_cursor.y));\n  to_y = WINDOW_TO_FRAME_PIXEL_Y (w, to_y);\n\n  " (span (|@| (class "comment-delimiter") (id "F:702612")) "/* ") (span (|@| (class "comment") (id "F:702615")) "Prevent inadvertently clearing to end of the X window.  ") (span (|@| (class "comment-delimiter") (id "F:702671")) "*/") "\n  " (span (|@| (class "keyword") (id "F:702676")) "if") " (to_x > from_x && to_y > from_y)\n    {\n      BLOCK_INPUT;\n      FRAME_RIF (f)->clear_frame_area (f, from_x, from_y,\n                                       to_x - from_x, to_y - from_y);\n      UNBLOCK_INPUT;\n    }\n}\n\n" (span (|@| (class "preprocessor") (id "F:702895")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:702902")) "/* ") (span (|@| (class "comment") (id "F:702905")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:702924")) "*/") "\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:702931")) "/***********************************************************************") (span (|@| (class "comment") (id "F:703003")) "\n                             Cursor types\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:703096")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:703100")) "/* ") (span (|@| (class "comment") (id "F:703103")) "Value is the internal representation of the specified cursor type\n   ARG.  If type is BAR_CURSOR, return in *WIDTH the specified width\n   of the bar cursor.  ") (span (|@| (class "comment-delimiter") (id "F:703261")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:703265")) "static") " " (span (|@| (class "keyword") (id "F:703272")) "enum") " " (span (|@| (class "type") (id "F:703277")) "text_cursor_kinds") "\n" (span (|@| (class "function-name") (id "F:703295")) "get_specified_cursor_type") " (arg, width)\n     " (span (|@| (class "type") (id "F:703339")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:703351")) "arg") ";\n     " (span (|@| (class "type") (id "F:703361")) "int") " *" (span (|@| (class "variable-name") (id "F:703366")) "width") ";\n{\n  " (span (|@| (class "keyword") (id "F:703377")) "enum") " " (span (|@| (class "type") (id "F:703382")) "text_cursor_kinds") " " (span (|@| (class "variable-name") (id "F:703400")) "type") ";\n\n  " (span (|@| (class "keyword") (id "F:703409")) "if") " (NILP (arg))\n    " (span (|@| (class "keyword") (id "F:703429")) "return") " NO_CURSOR;\n\n  " (span (|@| (class "keyword") (id "F:703450")) "if") " (EQ (arg, Qbox))\n    " (span (|@| (class "keyword") (id "F:703474")) "return") " FILLED_BOX_CURSOR;\n\n  " (span (|@| (class "keyword") (id "F:703503")) "if") " (EQ (arg, Qhollow))\n    " (span (|@| (class "keyword") (id "F:703530")) "return") " HOLLOW_BOX_CURSOR;\n\n  " (span (|@| (class "keyword") (id "F:703559")) "if") " (EQ (arg, Qbar))\n    {\n      *width = 2;\n      " (span (|@| (class "keyword") (id "F:703609")) "return") " BAR_CURSOR;\n    }\n\n  " (span (|@| (class "keyword") (id "F:703637")) "if") " (CONSP (arg)\n      && EQ (XCAR (arg), Qbar)\n      && INTEGERP (XCDR (arg))\n      && XINT (XCDR (arg)) >= 0)\n    {\n      *width = XINT (XCDR (arg));\n      " (span (|@| (class "keyword") (id "F:703794")) "return") " BAR_CURSOR;\n    }\n\n  " (span (|@| (class "keyword") (id "F:703822")) "if") " (EQ (arg, Qhbar))\n    {\n      *width = 2;\n      " (span (|@| (class "keyword") (id "F:703873")) "return") " HBAR_CURSOR;\n    }\n\n  " (span (|@| (class "keyword") (id "F:703902")) "if") " (CONSP (arg)\n      && EQ (XCAR (arg), Qhbar)\n      && INTEGERP (XCDR (arg))\n      && XINT (XCDR (arg)) >= 0)\n    {\n      *width = XINT (XCDR (arg));\n      " (span (|@| (class "keyword") (id "F:704060")) "return") " HBAR_CURSOR;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:704089")) "/* ") (span (|@| (class "comment") (id "F:704092")) "Treat anything unknown as \"hollow box cursor\".\n     It was bad to signal an error; people have trouble fixing\n     .Xdefaults with Emacs, when it has something bad in it.  ") (span (|@| (class "comment-delimiter") (id "F:704264")) "*/") "\n  type = HOLLOW_BOX_CURSOR;\n\n  " (span (|@| (class "keyword") (id "F:704298")) "return") " type;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:704314")) "/* ") (span (|@| (class "comment") (id "F:704317")) "Set the default cursor types for specified frame.  ") (span (|@| (class "comment-delimiter") (id "F:704368")) "*/") "\n" (span (|@| (class "type") (id "F:704371")) "void") "\n" (span (|@| (class "function-name") (id "F:704376")) "set_frame_cursor_types") " (f, arg)\n     " (span (|@| (class "keyword") (id "F:704413")) "struct") " " (span (|@| (class "type") (id "F:704420")) "frame") " *" (span (|@| (class "variable-name") (id "F:704427")) "f") ";\n     " (span (|@| (class "type") (id "F:704435")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:704447")) "arg") ";\n{\n  " (span (|@| (class "type") (id "F:704456")) "int") " " (span (|@| (class "variable-name") (id "F:704460")) "width") ";\n  " (span (|@| (class "type") (id "F:704469")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:704481")) "tem") ";\n\n  FRAME_DESIRED_CURSOR (f) = get_specified_cursor_type (arg, &width);\n  FRAME_CURSOR_WIDTH (f) = width;\n\n  " (span (|@| (class "comment-delimiter") (id "F:704594")) "/* ") (span (|@| (class "comment") (id "F:704597")) "By default, set up the blink-off state depending on the on-state.  ") (span (|@| (class "comment-delimiter") (id "F:704664")) "*/") "\n\n  tem = Fassoc (arg, Vblink_cursor_alist);\n  " (span (|@| (class "keyword") (id "F:704713")) "if") " (" (span (|@| (class "negation-char") (id "F:704717")) "!") "NILP (tem))\n    {\n      FRAME_BLINK_OFF_CURSOR (f)\n        = get_specified_cursor_type (XCDR (tem), &width);\n      FRAME_BLINK_OFF_CURSOR_WIDTH (f) = width;\n    }\n  " (span (|@| (class "keyword") (id "F:704876")) "else") "\n    FRAME_BLINK_OFF_CURSOR (f) = DEFAULT_CURSOR;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:704934")) "/* ") (span (|@| (class "comment") (id "F:704937")) "Return the cursor we want to be displayed in window W.  Return\n   width of bar/hbar cursor through WIDTH arg.  Return with\n   ACTIVE_CURSOR arg set to 1 if cursor in window W is `active'\n   (i.e. if the `system caret' should track this cursor).\n\n   In a mini-buffer window, we want the cursor only to appear if we\n   are reading input from this window.  For the selected window, we\n   want the cursor type given by the frame parameter or buffer local\n   setting of cursor-type.  If explicitly marked off, draw no cursor.\n   In all other cases, we want a hollow box cursor.  ") (span (|@| (class "comment-delimiter") (id "F:705511")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:705515")) "static") " " (span (|@| (class "keyword") (id "F:705522")) "enum") " " (span (|@| (class "type") (id "F:705527")) "text_cursor_kinds") "\n" (span (|@| (class "function-name") (id "F:705545")) "get_window_cursor_type") " (w, " (span (|@| (class "type") (id "F:705572")) "glyph") ", width, active_cursor)\n     " (span (|@| (class "keyword") (id "F:705606")) "struct") " " (span (|@| (class "type") (id "F:705613")) "window") " *" (span (|@| (class "variable-name") (id "F:705621")) "w") ";\n     " (span (|@| (class "keyword") (id "F:705629")) "struct") " " (span (|@| (class "type") (id "F:705636")) "glyph") " *" (span (|@| (class "variable-name") (id "F:705643")) "glyph") ";\n     " (span (|@| (class "type") (id "F:705655")) "int") " *" (span (|@| (class "variable-name") (id "F:705660")) "width") ";\n     " (span (|@| (class "type") (id "F:705672")) "int") " *" (span (|@| (class "variable-name") (id "F:705677")) "active_cursor") ";\n{\n  " (span (|@| (class "keyword") (id "F:705696")) "struct") " " (span (|@| (class "type") (id "F:705703")) "frame") " *" (span (|@| (class "variable-name") (id "F:705710")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "keyword") (id "F:705735")) "struct") " " (span (|@| (class "type") (id "F:705742")) "buffer") " *" (span (|@| (class "variable-name") (id "F:705750")) "b") " = XBUFFER (w->buffer);\n  " (span (|@| (class "type") (id "F:705777")) "int") " " (span (|@| (class "variable-name") (id "F:705781")) "cursor_type") " = DEFAULT_CURSOR;\n  " (span (|@| (class "type") (id "F:705813")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:705825")) "alt_cursor") ";\n  " (span (|@| (class "type") (id "F:705839")) "int") " " (span (|@| (class "variable-name") (id "F:705843")) "non_selected") " = 0;\n\n  *active_cursor = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:705887")) "/* ") (span (|@| (class "comment") (id "F:705890")) "Echo area ") (span (|@| (class "comment-delimiter") (id "F:705900")) "*/") "\n  " (span (|@| (class "keyword") (id "F:705905")) "if") " (cursor_in_echo_area\n      && FRAME_HAS_MINIBUF_P (f)\n      && EQ (FRAME_MINIBUF_WINDOW (f), echo_area_window))\n    {\n      " (span (|@| (class "keyword") (id "F:706032")) "if") " (w == XWINDOW (echo_area_window))\n        {\n          " (span (|@| (class "keyword") (id "F:706075")) "if") " (EQ (b->cursor_type, Qt) || NILP (b->cursor_type))\n            {\n              *width = FRAME_CURSOR_WIDTH (f);\n              " (span (|@| (class "keyword") (id "F:706183")) "return") " FRAME_DESIRED_CURSOR (f);\n            }\n          " (span (|@| (class "keyword") (id "F:706226")) "else") "\n            " (span (|@| (class "keyword") (id "F:706236")) "return") " get_specified_cursor_type (b->cursor_type, width);\n        }\n\n      *active_cursor = 0;\n      non_selected = 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:706357")) "/* ") (span (|@| (class "comment") (id "F:706360")) "Detect a nonselected window or nonselected frame.  ") (span (|@| (class "comment-delimiter") (id "F:706411")) "*/") "\n  " (span (|@| (class "keyword") (id "F:706416")) "else") " " (span (|@| (class "keyword") (id "F:706421")) "if") " (w != XWINDOW (f->selected_window)\n" (span (|@| (class "preprocessor") (id "F:706459")) "#ifdef") " HAVE_WINDOW_SYSTEM\n           || f != FRAME_X_DISPLAY_INFO (f)->x_highlight_frame\n" (span (|@| (class "preprocessor") (id "F:706541")) "#endif") "\n           )\n    {\n      *active_cursor = 0;\n\n      " (span (|@| (class "keyword") (id "F:706593")) "if") " (MINI_WINDOW_P (w) && minibuf_level == 0)\n        " (span (|@| (class "keyword") (id "F:706639")) "return") " NO_CURSOR;\n\n      non_selected = 1;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:706691")) "/* ") (span (|@| (class "comment") (id "F:706694")) "Never display a cursor in a window in which cursor-type is nil.  ") (span (|@| (class "comment-delimiter") (id "F:706759")) "*/") "\n  " (span (|@| (class "keyword") (id "F:706764")) "if") " (NILP (b->cursor_type))\n    " (span (|@| (class "keyword") (id "F:706795")) "return") " NO_CURSOR;\n\n  " (span (|@| (class "comment-delimiter") (id "F:706816")) "/* ") (span (|@| (class "comment") (id "F:706819")) "Get the normal cursor type for this window.  ") (span (|@| (class "comment-delimiter") (id "F:706864")) "*/") "\n  " (span (|@| (class "keyword") (id "F:706869")) "if") " (EQ (b->cursor_type, Qt))\n    {\n      cursor_type = FRAME_DESIRED_CURSOR (f);\n      *width = FRAME_CURSOR_WIDTH (f);\n    }\n  " (span (|@| (class "keyword") (id "F:706997")) "else") "\n    cursor_type = get_specified_cursor_type (b->cursor_type, width);\n\n  " (span (|@| (class "comment-delimiter") (id "F:707074")) "/* ") (span (|@| (class "comment") (id "F:707077")) "Use cursor-in-non-selected-windows instead\n     for non-selected window or frame.  ") (span (|@| (class "comment-delimiter") (id "F:707160")) "*/") "\n  " (span (|@| (class "keyword") (id "F:707165")) "if") " (non_selected)\n    {\n      alt_cursor = b->cursor_in_non_selected_windows;\n      " (span (|@| (class "keyword") (id "F:707249")) "if") " (" (span (|@| (class "negation-char") (id "F:707253")) "!") "EQ (Qt, alt_cursor))\n        " (span (|@| (class "keyword") (id "F:707276")) "return") " get_specified_cursor_type (alt_cursor, width);\n      " (span (|@| (class "comment-delimiter") (id "F:707336")) "/* ") (span (|@| (class "comment") (id "F:707339")) "t means modify the normal cursor type.  ") (span (|@| (class "comment-delimiter") (id "F:707379")) "*/") "\n      " (span (|@| (class "keyword") (id "F:707388")) "if") " (cursor_type == FILLED_BOX_CURSOR)\n        cursor_type = HOLLOW_BOX_CURSOR;\n      " (span (|@| (class "keyword") (id "F:707466")) "else") " " (span (|@| (class "keyword") (id "F:707471")) "if") " (cursor_type == BAR_CURSOR && *width > 1)\n        --*width;\n      " (span (|@| (class "keyword") (id "F:707533")) "return") " cursor_type;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:707562")) "/* ") (span (|@| (class "comment") (id "F:707565")) "Use normal cursor if not blinked off.  ") (span (|@| (class "comment-delimiter") (id "F:707604")) "*/") "\n  " (span (|@| (class "keyword") (id "F:707609")) "if") " (" (span (|@| (class "negation-char") (id "F:707613")) "!") "w->cursor_off_p)\n    {\n" (span (|@| (class "preprocessor") (id "F:707637")) "#ifdef") " HAVE_WINDOW_SYSTEM\n      " (span (|@| (class "keyword") (id "F:707669")) "if") " (glyph != " (span (|@| (class "constant") (id "F:707682")) "NULL") " && glyph->type == IMAGE_GLYPH)\n        {\n          " (span (|@| (class "keyword") (id "F:707724")) "if") " (cursor_type == FILLED_BOX_CURSOR)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:707776")) "/* ") (span (|@| (class "comment") (id "F:707779")) "Using a block cursor on large images can be very annoying.\n                 So use a hollow cursor for \"large\" images.\n                 If image is not transparent (no mask), also use hollow cursor.  ") (span (|@| (class "comment-delimiter") (id "F:707951")) "*/") "\n              " (span (|@| (class "keyword") (id "F:707961")) "struct") " " (span (|@| (class "type") (id "F:707968")) "image") " *" (span (|@| (class "variable-name") (id "F:707975")) "img") " = IMAGE_FROM_ID (f, glyph->u.img_id);\n              " (span (|@| (class "keyword") (id "F:708024")) "if") " (img != " (span (|@| (class "constant") (id "F:708035")) "NULL") " && IMAGEP (img->spec))\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:708071")) "/* ") (span (|@| (class "comment") (id "F:708074")) "Arbitrarily, interpret \"Large\" as >32x32 and >NxN\n                     where N = size of default frame font size.\n                     This should cover most of the \"tiny\" icons people may use.  ") (span (|@| (class "comment-delimiter") (id "F:708241")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:708248")) "if") " (" (span (|@| (class "negation-char") (id "F:708252")) "!") "img->mask\n                      || img->width > max (32, WINDOW_FRAME_COLUMN_WIDTH (w))\n                      || img->height > max (32, WINDOW_FRAME_LINE_HEIGHT (w)))\n                    cursor_type = HOLLOW_BOX_CURSOR;\n                }\n            }\n          " (span (|@| (class "keyword") (id "F:708445")) "else") " " (span (|@| (class "keyword") (id "F:708450")) "if") " (cursor_type != NO_CURSOR)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:708494")) "/* ") (span (|@| (class "comment") (id "F:708497")) "Display current only supports BOX and HOLLOW cursors for images.\n                 So for now, unconditionally use a HOLLOW cursor when cursor is\n                 not a solid box cursor.  ") (span (|@| (class "comment-delimiter") (id "F:708656")) "*/") "\n              cursor_type = HOLLOW_BOX_CURSOR;\n            }\n      }\n" (span (|@| (class "preprocessor") (id "F:708714")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:708727")) "return") " cursor_type;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:708756")) "/* ") (span (|@| (class "comment") (id "F:708759")) "Cursor is blinked off, so determine how to \"toggle\" it.  ") (span (|@| (class "comment-delimiter") (id "F:708816")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:708822")) "/* ") (span (|@| (class "comment") (id "F:708825")) "First look for an entry matching the buffer's cursor-type in blink-cursor-alist.  ") (span (|@| (class "comment-delimiter") (id "F:708907")) "*/") "\n  " (span (|@| (class "keyword") (id "F:708912")) "if") " ((alt_cursor = Fassoc (b->cursor_type, Vblink_cursor_alist), " (span (|@| (class "negation-char") (id "F:708976")) "!") "NILP (alt_cursor)))\n    " (span (|@| (class "keyword") (id "F:709001")) "return") " get_specified_cursor_type (XCDR (alt_cursor), width);\n\n  " (span (|@| (class "comment-delimiter") (id "F:709065")) "/* ") (span (|@| (class "comment") (id "F:709068")) "Then see if frame has specified a specific blink off cursor type.  ") (span (|@| (class "comment-delimiter") (id "F:709135")) "*/") "\n  " (span (|@| (class "keyword") (id "F:709140")) "if") " (FRAME_BLINK_OFF_CURSOR (f) != DEFAULT_CURSOR)\n    {\n      *width = FRAME_BLINK_OFF_CURSOR_WIDTH (f);\n      " (span (|@| (class "keyword") (id "F:709251")) "return") " FRAME_BLINK_OFF_CURSOR (f);\n    }\n\n" (span (|@| (class "preprocessor") (id "F:709293")) "#if") " 0\n  " (span (|@| (class "comment-delimiter") (id "F:709301")) "/* ") (span (|@| (class "comment") (id "F:709304")) "Some people liked having a permanently visible blinking cursor,\n     while others had very strong opinions against it.  So it was\n     decided to remove it.  KFS 2003-09-03 ") (span (|@| (class "comment-delimiter") (id "F:709477")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:709483")) "/* ") (span (|@| (class "comment") (id "F:709486")) "Finally perform built-in cursor blinking:\n       filled box      <->   hollow box\n       wide [h]bar     <->   narrow [h]bar\n       narrow [h]bar   <->   no cursor\n       other type      <->   no cursor  ") (span (|@| (class "comment-delimiter") (id "F:709690")) "*/") "\n\n  " (span (|@| (class "keyword") (id "F:709696")) "if") " (cursor_type == FILLED_BOX_CURSOR)\n    " (span (|@| (class "keyword") (id "F:709738")) "return") " HOLLOW_BOX_CURSOR;\n\n  " (span (|@| (class "keyword") (id "F:709767")) "if") " ((cursor_type == BAR_CURSOR || cursor_type == HBAR_CURSOR) && *width > 1)\n    {\n      *width = 1;\n      " (span (|@| (class "keyword") (id "F:709874")) "return") " cursor_type;\n    }\n" (span (|@| (class "preprocessor") (id "F:709900")) "#endif") "\n\n  " (span (|@| (class "keyword") (id "F:709910")) "return") " NO_CURSOR;\n}\n\n\n" (span (|@| (class "preprocessor") (id "F:709932")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "comment-delimiter") (id "F:709959")) "/* ") (span (|@| (class "comment") (id "F:709962")) "Notice when the text cursor of window W has been completely\n   overwritten by a drawing operation that outputs glyphs in AREA\n   starting at X0 and ending at X1 in the line starting at Y0 and\n   ending at Y1.  X coordinates are area-relative.  X1 < 0 means all\n   the rest of the line after X0 has been written.  Y coordinates\n   are window-relative.  ") (span (|@| (class "comment-delimiter") (id "F:710314")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:710318")) "static") " " (span (|@| (class "type") (id "F:710325")) "void") "\n" (span (|@| (class "function-name") (id "F:710330")) "notice_overwritten_cursor") " (w, area, x0, x1, y0, y1)\n     " (span (|@| (class "keyword") (id "F:710387")) "struct") " " (span (|@| (class "type") (id "F:710394")) "window") " *" (span (|@| (class "variable-name") (id "F:710402")) "w") ";\n     " (span (|@| (class "keyword") (id "F:710410")) "enum") " " (span (|@| (class "type") (id "F:710415")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:710430")) "area") ";\n     " (span (|@| (class "type") (id "F:710441")) "int") " " (span (|@| (class "variable-name") (id "F:710445")) "x0") ", " (span (|@| (class "variable-name") (id "F:710449")) "y0") ", " (span (|@| (class "variable-name") (id "F:710453")) "x1") ", " (span (|@| (class "variable-name") (id "F:710457")) "y1") ";\n{\n  " (span (|@| (class "type") (id "F:710465")) "int") " " (span (|@| (class "variable-name") (id "F:710469")) "cx0") ", " (span (|@| (class "variable-name") (id "F:710474")) "cx1") ", " (span (|@| (class "variable-name") (id "F:710479")) "cy0") ", " (span (|@| (class "variable-name") (id "F:710484")) "cy1") ";\n  " (span (|@| (class "keyword") (id "F:710491")) "struct") " " (span (|@| (class "type") (id "F:710498")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:710509")) "row") ";\n\n  " (span (|@| (class "keyword") (id "F:710517")) "if") " (" (span (|@| (class "negation-char") (id "F:710521")) "!") "w->phys_cursor_on_p)\n    " (span (|@| (class "keyword") (id "F:710547")) "return") ";\n  " (span (|@| (class "keyword") (id "F:710557")) "if") " (area != TEXT_AREA)\n    " (span (|@| (class "keyword") (id "F:710584")) "return") ";\n\n  " (span (|@| (class "keyword") (id "F:710595")) "if") " (w->phys_cursor.vpos < 0\n      || w->phys_cursor.vpos >= w->current_matrix->nrows\n      || (row = w->current_matrix->rows + w->phys_cursor.vpos,\n          " (span (|@| (class "negation-char") (id "F:710746")) "!") "(row->enabled_p && row->displays_text_p)))\n    " (span (|@| (class "keyword") (id "F:710794")) "return") ";\n\n  " (span (|@| (class "keyword") (id "F:710805")) "if") " (row->cursor_in_fringe_p)\n    {\n      row->cursor_in_fringe_p = 0;\n      draw_fringe_bitmap (w, row, row->reversed_p);\n      w->phys_cursor_on_p = 0;\n      " (span (|@| (class "keyword") (id "F:710964")) "return") ";\n    }\n\n  cx0 = w->phys_cursor.x;\n  cx1 = cx0 + w->phys_cursor_width;\n  " (span (|@| (class "keyword") (id "F:711043")) "if") " (x0 > cx0 || (x1 >= 0 && x1 < cx1))\n    " (span (|@| (class "keyword") (id "F:711086")) "return") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:711097")) "/* ") (span (|@| (class "comment") (id "F:711100")) "The cursor image will be completely removed from the\n     screen if the output area intersects the cursor area in\n     y-direction.  When we draw in [y0 y1[, and some part of\n     the cursor is at y < y0, that part must have been drawn\n     before.  When scrolling, the cursor is erased before\n     actually scrolling, so we don't come here.  When not\n     scrolling, the rows above the old cursor row must have\n     changed, and in this case these rows must have written\n     over the cursor image.\n\n     Likewise if part of the cursor is below y1, with the\n     exception of the cursor being in the first blank row at\n     the buffer and window end because update_text_area\n     doesn't draw that row.  (Except when it does, but\n     that's handled in update_text_area.)  ") (span (|@| (class "comment-delimiter") (id "F:711874")) "*/") "\n\n  cy0 = w->phys_cursor.y;\n  cy1 = cy0 + w->phys_cursor_height;\n  " (span (|@| (class "keyword") (id "F:711943")) "if") " ((y0 < cy0 || y0 >= cy1) && (y1 <= cy0 || y1 >= cy1))\n    " (span (|@| (class "keyword") (id "F:712004")) "return") ";\n\n  w->phys_cursor_on_p = 0;\n}\n\n" (span (|@| (class "preprocessor") (id "F:712043")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:712050")) "/* ") (span (|@| (class "comment") (id "F:712053")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:712072")) "*/") "\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:712078")) "/************************************************************************") (span (|@| (class "comment") (id "F:712151")) "\n                              Mouse Face\n ***********************************************************************") (span (|@| (class "comment-delimiter") (id "F:712244")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:712248")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "comment-delimiter") (id "F:712275")) "/* ") (span (|@| (class "comment") (id "F:712278")) "EXPORT for RIF:\n   Fix the display of area AREA of overlapping row ROW in window W\n   with respect to the overlapping part OVERLAPS.  ") (span (|@| (class "comment-delimiter") (id "F:712412")) "*/") "\n\n" (span (|@| (class "type") (id "F:712416")) "void") "\n" (span (|@| (class "function-name") (id "F:712421")) "x_fix_overlapping_area") " (w, row, area, overlaps)\n     " (span (|@| (class "keyword") (id "F:712474")) "struct") " " (span (|@| (class "type") (id "F:712481")) "window") " *" (span (|@| (class "variable-name") (id "F:712489")) "w") ";\n     " (span (|@| (class "keyword") (id "F:712497")) "struct") " " (span (|@| (class "type") (id "F:712504")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:712515")) "row") ";\n     " (span (|@| (class "keyword") (id "F:712525")) "enum") " " (span (|@| (class "type") (id "F:712530")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:712545")) "area") ";\n     " (span (|@| (class "type") (id "F:712556")) "int") " " (span (|@| (class "variable-name") (id "F:712560")) "overlaps") ";\n{\n  " (span (|@| (class "type") (id "F:712574")) "int") " " (span (|@| (class "variable-name") (id "F:712578")) "i") ", " (span (|@| (class "variable-name") (id "F:712581")) "x") ";\n\n  BLOCK_INPUT;\n\n  x = 0;\n  " (span (|@| (class "keyword") (id "F:712612")) "for") " (i = 0; i < row->used[area];)\n    {\n      " (span (|@| (class "keyword") (id "F:712658")) "if") " (row->glyphs[area][i].overlaps_vertically_p)\n        {\n          " (span (|@| (class "type") (id "F:712712")) "int") " " (span (|@| (class "variable-name") (id "F:712716")) "start") " = i, " (span (|@| (class "variable-name") (id "F:712727")) "start_x") " = x;\n\n          " (span (|@| (class "keyword") (id "F:712744")) "do") "\n            {\n              x += row->glyphs[area][i].pixel_width;\n              ++i;\n            }\n          " (span (|@| (class "keyword") (id "F:712822")) "while") " (i < row->used[area]\n                 && row->glyphs[area][i].overlaps_vertically_p);\n\n          draw_glyphs (w, start_x, row, area,\n                       start, i,\n                       DRAW_NORMAL_TEXT, overlaps);\n        }\n      " (span (|@| (class "keyword") (id "F:713006")) "else") "\n        {\n          x += row->glyphs[area][i].pixel_width;\n          ++i;\n        }\n    }\n\n  UNBLOCK_INPUT;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:713095")) "/* ") (span (|@| (class "comment") (id "F:713098")) "EXPORT:\n   Draw the cursor glyph of window W in glyph row ROW.  See the\n   comment of draw_glyphs for the meaning of HL.  ") (span (|@| (class "comment-delimiter") (id "F:713220")) "*/") "\n\n" (span (|@| (class "type") (id "F:713224")) "void") "\n" (span (|@| (class "function-name") (id "F:713229")) "draw_phys_cursor_glyph") " (w, row, hl)\n     " (span (|@| (class "keyword") (id "F:713270")) "struct") " " (span (|@| (class "type") (id "F:713277")) "window") " *" (span (|@| (class "variable-name") (id "F:713285")) "w") ";\n     " (span (|@| (class "keyword") (id "F:713293")) "struct") " " (span (|@| (class "type") (id "F:713300")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:713311")) "row") ";\n     " (span (|@| (class "keyword") (id "F:713321")) "enum") " " (span (|@| (class "type") (id "F:713326")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:713343")) "hl") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:713351")) "/* ") (span (|@| (class "comment") (id "F:713354")) "If cursor hpos is out of bounds, don't draw garbage.  This can\n     happen in mini-buffer windows when switching between echo area\n     glyphs and mini-buffer.  ") (span (|@| (class "comment-delimiter") (id "F:713515")) "*/") "\n  " (span (|@| (class "keyword") (id "F:713520")) "if") " ((row->reversed_p\n       ? (w->phys_cursor.hpos >= 0)\n       : (w->phys_cursor.hpos < row->used[TEXT_AREA])))\n    {\n      " (span (|@| (class "type") (id "F:713645")) "int") " " (span (|@| (class "variable-name") (id "F:713649")) "on_p") " = w->phys_cursor_on_p;\n      " (span (|@| (class "type") (id "F:713683")) "int") " " (span (|@| (class "variable-name") (id "F:713687")) "x1") ";\n      x1 = draw_glyphs (w, w->phys_cursor.x, row, TEXT_AREA,\n                        w->phys_cursor.hpos, w->phys_cursor.hpos + 1,\n                        hl, 0);\n      w->phys_cursor_on_p = on_p;\n\n      " (span (|@| (class "keyword") (id "F:713853")) "if") " (hl == DRAW_CURSOR)\n        w->phys_cursor_width = x1 - w->phys_cursor.x;\n      " (span (|@| (class "comment-delimiter") (id "F:713929")) "/* ") (span (|@| (class "comment") (id "F:713932")) "When we erase the cursor, and ROW is overlapped by other\n         rows, make sure that these overlapping parts of other rows\n         are redrawn.  ") (span (|@| (class "comment-delimiter") (id "F:714066")) "*/") "\n      " (span (|@| (class "keyword") (id "F:714075")) "else") " " (span (|@| (class "keyword") (id "F:714080")) "if") " (hl == DRAW_NORMAL_TEXT && row->overlapped_p)\n        {\n          w->phys_cursor_width = x1 - w->phys_cursor.x;\n\n          " (span (|@| (class "keyword") (id "F:714185")) "if") " (row > w->current_matrix->rows\n              && MATRIX_ROW_OVERLAPS_SUCC_P (row - 1))\n            x_fix_overlapping_area (w, row - 1, TEXT_AREA,\n                                    OVERLAPS_ERASED_CURSOR);\n\n          " (span (|@| (class "keyword") (id "F:714356")) "if") " (MATRIX_ROW_BOTTOM_Y (row) < window_text_bottom_y (w)\n              && MATRIX_ROW_OVERLAPS_PRED_P (row + 1))\n            x_fix_overlapping_area (w, row + 1, TEXT_AREA,\n                                    OVERLAPS_ERASED_CURSOR);\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:714559")) "/* ") (span (|@| (class "comment") (id "F:714562")) "EXPORT:\n   Erase the image of a cursor of window W from the screen.  ") (span (|@| (class "comment-delimiter") (id "F:714631")) "*/") "\n\n" (span (|@| (class "type") (id "F:714635")) "void") "\n" (span (|@| (class "function-name") (id "F:714640")) "erase_phys_cursor") " (w)\n     " (span (|@| (class "keyword") (id "F:714667")) "struct") " " (span (|@| (class "type") (id "F:714674")) "window") " *" (span (|@| (class "variable-name") (id "F:714682")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:714689")) "struct") " " (span (|@| (class "type") (id "F:714696")) "frame") " *" (span (|@| (class "variable-name") (id "F:714703")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:714728")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:714742")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n  " (span (|@| (class "type") (id "F:714780")) "int") " " (span (|@| (class "variable-name") (id "F:714784")) "hpos") " = w->phys_cursor.hpos;\n  " (span (|@| (class "type") (id "F:714814")) "int") " " (span (|@| (class "variable-name") (id "F:714818")) "vpos") " = w->phys_cursor.vpos;\n  " (span (|@| (class "type") (id "F:714848")) "int") " " (span (|@| (class "variable-name") (id "F:714852")) "mouse_face_here_p") " = 0;\n  " (span (|@| (class "keyword") (id "F:714877")) "struct") " " (span (|@| (class "type") (id "F:714884")) "glyph_matrix") " *" (span (|@| (class "variable-name") (id "F:714898")) "active_glyphs") " = w->current_matrix;\n  " (span (|@| (class "keyword") (id "F:714935")) "struct") " " (span (|@| (class "type") (id "F:714942")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:714953")) "cursor_row") ";\n  " (span (|@| (class "keyword") (id "F:714967")) "struct") " " (span (|@| (class "type") (id "F:714974")) "glyph") " *" (span (|@| (class "variable-name") (id "F:714981")) "cursor_glyph") ";\n  " (span (|@| (class "keyword") (id "F:714997")) "enum") " " (span (|@| (class "type") (id "F:715002")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:715019")) "hl") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:715026")) "/* ") (span (|@| (class "comment") (id "F:715029")) "No cursor displayed or row invalidated => nothing to do on the\n     screen.  ") (span (|@| (class "comment-delimiter") (id "F:715106")) "*/") "\n  " (span (|@| (class "keyword") (id "F:715111")) "if") " (w->phys_cursor_type == NO_CURSOR)\n    " (span (|@| (class "keyword") (id "F:715153")) "goto") " " (span (|@| (class "constant") (id "F:715158")) "mark_cursor_off") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:715178")) "/* ") (span (|@| (class "comment") (id "F:715181")) "VPOS >= active_glyphs->nrows means that window has been resized.\n     Don't bother to erase the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:715286")) "*/") "\n  " (span (|@| (class "keyword") (id "F:715291")) "if") " (vpos >= active_glyphs->nrows)\n    " (span (|@| (class "keyword") (id "F:715329")) "goto") " " (span (|@| (class "constant") (id "F:715334")) "mark_cursor_off") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:715354")) "/* ") (span (|@| (class "comment") (id "F:715357")) "If row containing cursor is marked invalid, there is nothing we\n     can do.  ") (span (|@| (class "comment-delimiter") (id "F:715435")) "*/") "\n  cursor_row = MATRIX_ROW (active_glyphs, vpos);\n  " (span (|@| (class "keyword") (id "F:715489")) "if") " (" (span (|@| (class "negation-char") (id "F:715493")) "!") "cursor_row->enabled_p)\n    " (span (|@| (class "keyword") (id "F:715521")) "goto") " " (span (|@| (class "constant") (id "F:715526")) "mark_cursor_off") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:715546")) "/* ") (span (|@| (class "comment") (id "F:715549")) "If line spacing is > 0, old cursor may only be partially visible in\n     window after split-window.  So adjust visible height.  ") (span (|@| (class "comment-delimiter") (id "F:715677")) "*/") "\n  cursor_row->visible_height = min (cursor_row->visible_height,\n                                    window_text_bottom_y (w) - cursor_row->y);\n\n  " (span (|@| (class "comment-delimiter") (id "F:715798")) "/* ") (span (|@| (class "comment") (id "F:715801")) "If row is completely invisible, don't attempt to delete a cursor which\n     isn't there.  This can happen if cursor is at top of a window, and\n     we switch to a buffer with a header line in that window.  ") (span (|@| (class "comment-delimiter") (id "F:716007")) "*/") "\n  " (span (|@| (class "keyword") (id "F:716012")) "if") " (cursor_row->visible_height <= 0)\n    " (span (|@| (class "keyword") (id "F:716053")) "goto") " " (span (|@| (class "constant") (id "F:716058")) "mark_cursor_off") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:716078")) "/* ") (span (|@| (class "comment") (id "F:716081")) "If cursor is in the fringe, erase by drawing actual bitmap there.  ") (span (|@| (class "comment-delimiter") (id "F:716148")) "*/") "\n  " (span (|@| (class "keyword") (id "F:716153")) "if") " (cursor_row->cursor_in_fringe_p)\n    {\n      cursor_row->cursor_in_fringe_p = 0;\n      draw_fringe_bitmap (w, cursor_row, cursor_row->reversed_p);\n      " (span (|@| (class "keyword") (id "F:716309")) "goto") " " (span (|@| (class "constant") (id "F:716314")) "mark_cursor_off") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:716340")) "/* ") (span (|@| (class "comment") (id "F:716343")) "This can happen when the new row is shorter than the old one.\n     In this case, either draw_glyphs or clear_end_of_line\n     should have cleared the cursor.  Note that we wouldn't be\n     able to erase the cursor in this case because we don't have a\n     cursor glyph at hand.  ") (span (|@| (class "comment-delimiter") (id "F:716622")) "*/") "\n  " (span (|@| (class "keyword") (id "F:716627")) "if") " ((cursor_row->reversed_p\n       ? (w->phys_cursor.hpos < 0)\n       : (w->phys_cursor.hpos >= cursor_row->used[TEXT_AREA])))\n    " (span (|@| (class "keyword") (id "F:716758")) "goto") " " (span (|@| (class "constant") (id "F:716763")) "mark_cursor_off") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:716783")) "/* ") (span (|@| (class "comment") (id "F:716786")) "If the cursor is in the mouse face area, redisplay that when\n     we clear the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:716874")) "*/") "\n  " (span (|@| (class "keyword") (id "F:716879")) "if") " (" (span (|@| (class "negation-char") (id "F:716883")) "!") " NILP (dpyinfo->mouse_face_window)\n      && w == XWINDOW (dpyinfo->mouse_face_window)\n      && (vpos > dpyinfo->mouse_face_beg_row\n          || (vpos == dpyinfo->mouse_face_beg_row\n              && hpos >= dpyinfo->mouse_face_beg_col))\n      && (vpos < dpyinfo->mouse_face_end_row\n          || (vpos == dpyinfo->mouse_face_end_row\n              && hpos < dpyinfo->mouse_face_end_col))\n      " (span (|@| (class "comment-delimiter") (id "F:717247")) "/* ") (span (|@| (class "comment") (id "F:717250")) "Don't redraw the cursor's spot in mouse face if it is at the\n         end of a line (on a newline).  The cursor appears there, but\n         mouse highlighting does not.  ") (span (|@| (class "comment-delimiter") (id "F:717406")) "*/") "\n      && cursor_row->used[TEXT_AREA] > hpos && hpos >= 0)\n    mouse_face_here_p = 1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:717497")) "/* ") (span (|@| (class "comment") (id "F:717500")) "Maybe clear the display under the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:717543")) "*/") "\n  " (span (|@| (class "keyword") (id "F:717548")) "if") " (w->phys_cursor_type == HOLLOW_BOX_CURSOR)\n    {\n      " (span (|@| (class "type") (id "F:717606")) "int") " " (span (|@| (class "variable-name") (id "F:717610")) "x") ", " (span (|@| (class "variable-name") (id "F:717613")) "y") ", " (span (|@| (class "variable-name") (id "F:717616")) "left_x") ";\n      " (span (|@| (class "type") (id "F:717630")) "int") " " (span (|@| (class "variable-name") (id "F:717634")) "header_line_height") " = WINDOW_HEADER_LINE_HEIGHT (w);\n      " (span (|@| (class "type") (id "F:717692")) "int") " " (span (|@| (class "variable-name") (id "F:717696")) "width") ";\n\n      cursor_glyph = get_phys_cursor_glyph (w);\n      " (span (|@| (class "keyword") (id "F:717758")) "if") " (cursor_glyph == " (span (|@| (class "constant") (id "F:717778")) "NULL") ")\n        " (span (|@| (class "keyword") (id "F:717785")) "goto") " " (span (|@| (class "constant") (id "F:717790")) "mark_cursor_off") ";\n\n      width = cursor_glyph->pixel_width;\n      left_x = window_box_left_offset (w, TEXT_AREA);\n      x = w->phys_cursor.x;\n      " (span (|@| (class "keyword") (id "F:717937")) "if") " (x < left_x)\n        width -= left_x - x;\n      width = min (width, window_box_width (w, TEXT_AREA) - x);\n      y = WINDOW_TO_FRAME_PIXEL_Y (w, max (header_line_height, cursor_row->y));\n      x = WINDOW_TEXT_TO_FRAME_PIXEL_X (w, max (x, left_x));\n\n      " (span (|@| (class "keyword") (id "F:718187")) "if") " (width > 0)\n        FRAME_RIF (f)->clear_frame_area (f, x, y, width, cursor_row->visible_height);\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:718290")) "/* ") (span (|@| (class "comment") (id "F:718293")) "Erase the cursor by redrawing the character underneath it.  ") (span (|@| (class "comment-delimiter") (id "F:718353")) "*/") "\n  " (span (|@| (class "keyword") (id "F:718358")) "if") " (mouse_face_here_p)\n    hl = DRAW_MOUSE_FACE;\n  " (span (|@| (class "keyword") (id "F:718409")) "else") "\n    hl = DRAW_NORMAL_TEXT;\n  draw_phys_cursor_glyph (w, cursor_row, hl);\n\n " (span (|@| (class "constant") (id "F:718489")) "mark_cursor_off") ":\n  w->phys_cursor_on_p = 0;\n  w->phys_cursor_type = NO_CURSOR;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:718572")) "/* ") (span (|@| (class "comment") (id "F:718575")) "EXPORT:\n   Display or clear cursor of window W.  If ON is zero, clear the\n   cursor.  If it is non-zero, display the cursor.  If ON is nonzero,\n   where to put the cursor is specified by HPOS, VPOS, X and Y.  ") (span (|@| (class "comment-delimiter") (id "F:718784")) "*/") "\n\n" (span (|@| (class "type") (id "F:718788")) "void") "\n" (span (|@| (class "function-name") (id "F:718793")) "display_and_set_cursor") " (w, on, hpos, vpos, x, y)\n     " (span (|@| (class "keyword") (id "F:718847")) "struct") " " (span (|@| (class "type") (id "F:718854")) "window") " *" (span (|@| (class "variable-name") (id "F:718862")) "w") ";\n     " (span (|@| (class "type") (id "F:718870")) "int") " " (span (|@| (class "variable-name") (id "F:718874")) "on") ", " (span (|@| (class "variable-name") (id "F:718878")) "hpos") ", " (span (|@| (class "variable-name") (id "F:718884")) "vpos") ", " (span (|@| (class "variable-name") (id "F:718890")) "x") ", " (span (|@| (class "variable-name") (id "F:718893")) "y") ";\n{\n  " (span (|@| (class "keyword") (id "F:718900")) "struct") " " (span (|@| (class "type") (id "F:718907")) "frame") " *" (span (|@| (class "variable-name") (id "F:718914")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:718939")) "int") " " (span (|@| (class "variable-name") (id "F:718943")) "new_cursor_type") ";\n  " (span (|@| (class "type") (id "F:718962")) "int") " " (span (|@| (class "variable-name") (id "F:718966")) "new_cursor_width") ";\n  " (span (|@| (class "type") (id "F:718986")) "int") " " (span (|@| (class "variable-name") (id "F:718990")) "active_cursor") ";\n  " (span (|@| (class "keyword") (id "F:719007")) "struct") " " (span (|@| (class "type") (id "F:719014")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:719025")) "glyph_row") ";\n  " (span (|@| (class "keyword") (id "F:719038")) "struct") " " (span (|@| (class "type") (id "F:719045")) "glyph") " *" (span (|@| (class "variable-name") (id "F:719052")) "glyph") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:719062")) "/* ") (span (|@| (class "comment") (id "F:719065")) "This is pointless on invisible frames, and dangerous on garbaged\n     windows and frames; in the latter case, the frame or window may\n     be in the midst of changing its size, and x and y may be off the\n     window.  ") (span (|@| (class "comment-delimiter") (id "F:719283")) "*/") "\n  " (span (|@| (class "keyword") (id "F:719288")) "if") " (" (span (|@| (class "negation-char") (id "F:719292")) "!") " FRAME_VISIBLE_P (f)\n      || FRAME_GARBAGED_P (f)\n      || vpos >= w->current_matrix->nrows\n      || hpos >= w->current_matrix->matrix_w)\n    " (span (|@| (class "keyword") (id "F:719436")) "return") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:719447")) "/* ") (span (|@| (class "comment") (id "F:719450")) "If cursor is off and we want it off, return quickly.  ") (span (|@| (class "comment-delimiter") (id "F:719504")) "*/") "\n  " (span (|@| (class "keyword") (id "F:719509")) "if") " (" (span (|@| (class "negation-char") (id "F:719513")) "!") "on && " (span (|@| (class "negation-char") (id "F:719520")) "!") "w->phys_cursor_on_p)\n    " (span (|@| (class "keyword") (id "F:719546")) "return") ";\n\n  glyph_row = MATRIX_ROW (w->current_matrix, vpos);\n  " (span (|@| (class "comment-delimiter") (id "F:719609")) "/* ") (span (|@| (class "comment") (id "F:719612")) "If cursor row is not enabled, we don't really know where to\n     display the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:719698")) "*/") "\n  " (span (|@| (class "keyword") (id "F:719703")) "if") " (" (span (|@| (class "negation-char") (id "F:719707")) "!") "glyph_row->enabled_p)\n    {\n      w->phys_cursor_on_p = 0;\n      " (span (|@| (class "keyword") (id "F:719773")) "return") ";\n    }\n\n  glyph = " (span (|@| (class "constant") (id "F:719798")) "NULL") ";\n  " (span (|@| (class "keyword") (id "F:719806")) "if") " (" (span (|@| (class "negation-char") (id "F:719810")) "!") "glyph_row->exact_window_width_line_p\n      || (0 <= hpos && hpos < glyph_row->used[TEXT_AREA]))\n    glyph = glyph_row->glyphs[TEXT_AREA] + hpos;\n\n  xassert (interrupt_input_blocked);\n\n  " (span (|@| (class "comment-delimiter") (id "F:719997")) "/* ") (span (|@| (class "comment") (id "F:720000")) "Set new_cursor_type to the cursor we want to be displayed.  ") (span (|@| (class "comment-delimiter") (id "F:720060")) "*/") "\n  new_cursor_type = get_window_cursor_type (w, glyph,\n                                            &new_cursor_width, &active_cursor);\n\n  " (span (|@| (class "comment-delimiter") (id "F:720165")) "/* ") (span (|@| (class "comment") (id "F:720168")) "If cursor is currently being shown and we don't want it to be or\n     it is in the wrong place, or the cursor type is not what we want,\n     erase it.  ") (span (|@| (class "comment-delimiter") (id "F:720320")) "*/") "\n  " (span (|@| (class "keyword") (id "F:720325")) "if") " (w->phys_cursor_on_p\n      && (" (span (|@| (class "negation-char") (id "F:720359")) "!") "on\n          || w->phys_cursor.x != x\n          || w->phys_cursor.y != y\n          || new_cursor_type != w->phys_cursor_type\n          || ((new_cursor_type == BAR_CURSOR || new_cursor_type == HBAR_CURSOR)\n              && new_cursor_width != w->phys_cursor_width)))\n    erase_phys_cursor (w);\n\n  " (span (|@| (class "comment-delimiter") (id "F:720621")) "/* ") (span (|@| (class "comment") (id "F:720624")) "Don't check phys_cursor_on_p here because that flag is only set\n     to zero in some cases where we know that the cursor has been\n     completely erased, to avoid the extra work of erasing the cursor\n     twice.  In other words, phys_cursor_on_p can be 1 and the cursor\n     still not be visible, or it has only been partly erased.  ") (span (|@| (class "comment-delimiter") (id "F:720957")) "*/") "\n  " (span (|@| (class "keyword") (id "F:720962")) "if") " (on)\n    {\n      w->phys_cursor_ascent = glyph_row->ascent;\n      w->phys_cursor_height = glyph_row->height;\n\n      " (span (|@| (class "comment-delimiter") (id "F:721081")) "/* ") (span (|@| (class "comment") (id "F:721084")) "Set phys_cursor_.* before x_draw_.* is called because some\n         of them may need the information.  ") (span (|@| (class "comment-delimiter") (id "F:721180")) "*/") "\n      w->phys_cursor.x = x;\n      w->phys_cursor.y = glyph_row->y;\n      w->phys_cursor.hpos = hpos;\n      w->phys_cursor.vpos = vpos;\n    }\n\n  FRAME_RIF (f)->draw_window_cursor (w, glyph_row, x, y,\n                                     new_cursor_type, new_cursor_width,\n                                     on, active_cursor);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:721515")) "/* ") (span (|@| (class "comment") (id "F:721518")) "Switch the display of W's cursor on or off, according to the value\n   of ON.  ") (span (|@| (class "comment-delimiter") (id "F:721596")) "*/") "\n\n" (span (|@| (class "type") (id "F:721600")) "void") "\n" (span (|@| (class "function-name") (id "F:721605")) "update_window_cursor") " (w, on)\n     " (span (|@| (class "keyword") (id "F:721639")) "struct") " " (span (|@| (class "type") (id "F:721646")) "window") " *" (span (|@| (class "variable-name") (id "F:721654")) "w") ";\n     " (span (|@| (class "type") (id "F:721662")) "int") " " (span (|@| (class "variable-name") (id "F:721666")) "on") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:721674")) "/* ") (span (|@| (class "comment") (id "F:721677")) "Don't update cursor in windows whose frame is in the process\n     of being deleted.  ") (span (|@| (class "comment-delimiter") (id "F:721762")) "*/") "\n  " (span (|@| (class "keyword") (id "F:721767")) "if") " (w->current_matrix)\n    {\n      BLOCK_INPUT;\n      display_and_set_cursor (w, on, w->phys_cursor.hpos, w->phys_cursor.vpos,\n                              w->phys_cursor.x, w->phys_cursor.y);\n      UNBLOCK_INPUT;\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:721971")) "/* ") (span (|@| (class "comment") (id "F:721974")) "Call update_window_cursor with parameter ON_P on all leaf windows\n   in the window tree rooted at W.  ") (span (|@| (class "comment-delimiter") (id "F:722076")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:722080")) "static") " " (span (|@| (class "type") (id "F:722087")) "void") "\n" (span (|@| (class "function-name") (id "F:722092")) "update_cursor_in_window_tree") " (w, on_p)\n     " (span (|@| (class "keyword") (id "F:722136")) "struct") " " (span (|@| (class "type") (id "F:722143")) "window") " *" (span (|@| (class "variable-name") (id "F:722151")) "w") ";\n     " (span (|@| (class "type") (id "F:722159")) "int") " " (span (|@| (class "variable-name") (id "F:722163")) "on_p") ";\n{\n  " (span (|@| (class "keyword") (id "F:722173")) "while") " (w)\n    {\n      " (span (|@| (class "keyword") (id "F:722195")) "if") " (" (span (|@| (class "negation-char") (id "F:722199")) "!") "NILP (w->hchild))\n        update_cursor_in_window_tree (XWINDOW (w->hchild), on_p);\n      " (span (|@| (class "keyword") (id "F:722283")) "else") " " (span (|@| (class "keyword") (id "F:722288")) "if") " (" (span (|@| (class "negation-char") (id "F:722292")) "!") "NILP (w->vchild))\n        update_cursor_in_window_tree (XWINDOW (w->vchild), on_p);\n      " (span (|@| (class "keyword") (id "F:722376")) "else") "\n        update_window_cursor (w, on_p);\n\n      w = NILP (w->next) ? 0 : XWINDOW (w->next);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:722475")) "/* ") (span (|@| (class "comment") (id "F:722478")) "EXPORT:\n   Display the cursor on window W, or clear it, according to ON_P.\n   Don't change the cursor's position.  ") (span (|@| (class "comment-delimiter") (id "F:722593")) "*/") "\n\n" (span (|@| (class "type") (id "F:722597")) "void") "\n" (span (|@| (class "function-name") (id "F:722602")) "x_update_cursor") " (f, on_p)\n     " (span (|@| (class "keyword") (id "F:722633")) "struct") " " (span (|@| (class "type") (id "F:722640")) "frame") " *" (span (|@| (class "variable-name") (id "F:722647")) "f") ";\n     " (span (|@| (class "type") (id "F:722655")) "int") " " (span (|@| (class "variable-name") (id "F:722659")) "on_p") ";\n{\n  update_cursor_in_window_tree (XWINDOW (f->root_window), on_p);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:722736")) "/* ") (span (|@| (class "comment") (id "F:722739")) "EXPORT:\n   Clear the cursor of window W to background color, and mark the\n   cursor as not shown.  This is used when the text where the cursor\n   is about to be rewritten.  ") (span (|@| (class "comment-delimiter") (id "F:722912")) "*/") "\n\n" (span (|@| (class "type") (id "F:722916")) "void") "\n" (span (|@| (class "function-name") (id "F:722921")) "x_clear_cursor") " (w)\n     " (span (|@| (class "keyword") (id "F:722945")) "struct") " " (span (|@| (class "type") (id "F:722952")) "window") " *" (span (|@| (class "variable-name") (id "F:722960")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:722967")) "if") " (FRAME_VISIBLE_P (XFRAME (w->frame)) && w->phys_cursor_on_p)\n    update_window_cursor (w, 0);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:723068")) "/* ") (span (|@| (class "comment") (id "F:723071")) "EXPORT:\n   Display the active region described by mouse_face_* according to DRAW.  ") (span (|@| (class "comment-delimiter") (id "F:723154")) "*/") "\n\n" (span (|@| (class "type") (id "F:723158")) "void") "\n" (span (|@| (class "function-name") (id "F:723163")) "show_mouse_face") " (dpyinfo, draw)\n     " (span (|@| (class "type") (id "F:723200")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:723214")) "dpyinfo") ";\n     " (span (|@| (class "keyword") (id "F:723228")) "enum") " " (span (|@| (class "type") (id "F:723233")) "draw_glyphs_face") " " (span (|@| (class "variable-name") (id "F:723250")) "draw") ";\n{\n  " (span (|@| (class "keyword") (id "F:723260")) "struct") " " (span (|@| (class "type") (id "F:723267")) "window") " *" (span (|@| (class "variable-name") (id "F:723275")) "w") " = XWINDOW (dpyinfo->mouse_face_window);\n  " (span (|@| (class "keyword") (id "F:723319")) "struct") " " (span (|@| (class "type") (id "F:723326")) "frame") " *" (span (|@| (class "variable-name") (id "F:723333")) "f") " = XFRAME (WINDOW_FRAME (w));\n\n  " (span (|@| (class "keyword") (id "F:723367")) "if") " (" (span (|@| (class "comment-delimiter") (id "F:723371")) "/* ") (span (|@| (class "comment") (id "F:723374")) "If window is in the process of being destroyed, don't bother\n         to do anything.  ") (span (|@| (class "comment-delimiter") (id "F:723454")) "*/") "\n      w->current_matrix != " (span (|@| (class "constant") (id "F:723484")) "NULL") "\n      " (span (|@| (class "comment-delimiter") (id "F:723495")) "/* ") (span (|@| (class "comment") (id "F:723498")) "Don't update mouse highlight if hidden ") (span (|@| (class "comment-delimiter") (id "F:723537")) "*/") "\n      && (draw != DRAW_MOUSE_FACE || " (span (|@| (class "negation-char") (id "F:723577")) "!") "dpyinfo->mouse_face_hidden)\n      " (span (|@| (class "comment-delimiter") (id "F:723612")) "/* ") (span (|@| (class "comment") (id "F:723615")) "Recognize when we are called to operate on rows that don't exist\n         anymore.  This can happen when a window is split.  ") (span (|@| (class "comment-delimiter") (id "F:723733")) "*/") "\n      && dpyinfo->mouse_face_end_row < w->current_matrix->nrows)\n    {\n      " (span (|@| (class "type") (id "F:723813")) "int") " " (span (|@| (class "variable-name") (id "F:723817")) "phys_cursor_on_p") " = w->phys_cursor_on_p;\n      " (span (|@| (class "keyword") (id "F:723863")) "struct") " " (span (|@| (class "type") (id "F:723870")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:723881")) "row") ", *" (span (|@| (class "variable-name") (id "F:723887")) "first") ", *" (span (|@| (class "variable-name") (id "F:723895")) "last") ";\n\n      first = MATRIX_ROW (w->current_matrix, dpyinfo->mouse_face_beg_row);\n      last = MATRIX_ROW (w->current_matrix, dpyinfo->mouse_face_end_row);\n\n      " (span (|@| (class "keyword") (id "F:724058")) "for") " (row = first; row <= last && row->enabled_p; ++row)\n        {\n          " (span (|@| (class "type") (id "F:724120")) "int") " " (span (|@| (class "variable-name") (id "F:724124")) "start_hpos") ", " (span (|@| (class "variable-name") (id "F:724136")) "end_hpos") ", " (span (|@| (class "variable-name") (id "F:724146")) "start_x") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:724159")) "/* ") (span (|@| (class "comment") (id "F:724162")) "For all but the first row, the highlight starts at column 0.  ") (span (|@| (class "comment-delimiter") (id "F:724224")) "*/") "\n          " (span (|@| (class "keyword") (id "F:724230")) "if") " (row == first)\n            {\n              start_hpos = dpyinfo->mouse_face_beg_col;\n              start_x = dpyinfo->mouse_face_beg_x;\n            }\n          " (span (|@| (class "keyword") (id "F:724358")) "else") "\n            {\n              start_hpos = 0;\n              start_x = 0;\n            }\n\n          " (span (|@| (class "keyword") (id "F:724424")) "if") " (row == last)\n            end_hpos = dpyinfo->mouse_face_end_col;\n          " (span (|@| (class "keyword") (id "F:724489")) "else") "\n            {\n              end_hpos = row->used[TEXT_AREA];\n              " (span (|@| (class "keyword") (id "F:724548")) "if") " (draw == DRAW_NORMAL_TEXT)\n                row->fill_line_p = 1; " (span (|@| (class "comment-delimiter") (id "F:724602")) "/* ") (span (|@| (class "comment") (id "F:724605")) "Clear to end of line ") (span (|@| (class "comment-delimiter") (id "F:724626")) "*/") "\n            }\n\n          " (span (|@| (class "keyword") (id "F:724640")) "if") " (end_hpos > start_hpos)\n            {\n              draw_glyphs (w, start_x, row, TEXT_AREA,\n                           start_hpos, end_hpos,\n                           draw, 0);\n\n              row->mouse_face_p\n                = draw == DRAW_MOUSE_FACE || draw == DRAW_IMAGE_RAISED;\n            }\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:724867")) "/* ") (span (|@| (class "comment") (id "F:724870")) "When we've written over the cursor, arrange for it to\n         be displayed again.  ") (span (|@| (class "comment-delimiter") (id "F:724947")) "*/") "\n      " (span (|@| (class "keyword") (id "F:724956")) "if") " (phys_cursor_on_p && " (span (|@| (class "negation-char") (id "F:724980")) "!") "w->phys_cursor_on_p)\n        {\n          BLOCK_INPUT;\n          display_and_set_cursor (w, 1,\n                                  w->phys_cursor.hpos, w->phys_cursor.vpos,\n                                  w->phys_cursor.x, w->phys_cursor.y);\n          UNBLOCK_INPUT;\n        }\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:725175")) "/* ") (span (|@| (class "comment") (id "F:725178")) "Change the mouse cursor.  ") (span (|@| (class "comment-delimiter") (id "F:725204")) "*/") "\n  " (span (|@| (class "keyword") (id "F:725209")) "if") " (draw == DRAW_NORMAL_TEXT && " (span (|@| (class "negation-char") (id "F:725241")) "!") "EQ (dpyinfo->mouse_face_window, f->tool_bar_window))\n    FRAME_RIF (f)->define_frame_cursor (f, FRAME_X_OUTPUT (f)->text_cursor);\n  " (span (|@| (class "keyword") (id "F:725374")) "else") " " (span (|@| (class "keyword") (id "F:725379")) "if") " (draw == DRAW_MOUSE_FACE)\n    FRAME_RIF (f)->define_frame_cursor (f, FRAME_X_OUTPUT (f)->hand_cursor);\n  " (span (|@| (class "keyword") (id "F:725487")) "else") "\n    FRAME_RIF (f)->define_frame_cursor (f, FRAME_X_OUTPUT (f)->nontext_cursor);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:725575")) "/* ") (span (|@| (class "comment") (id "F:725578")) "EXPORT:\n   Clear out the mouse-highlighted active region.\n   Redraw it un-highlighted first.  Value is non-zero if mouse\n   face was actually drawn unhighlighted.  ") (span (|@| (class "comment-delimiter") (id "F:725742")) "*/") "\n\n" (span (|@| (class "type") (id "F:725746")) "int") "\n" (span (|@| (class "function-name") (id "F:725750")) "clear_mouse_face") " (dpyinfo)\n     " (span (|@| (class "type") (id "F:725782")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:725796")) "dpyinfo") ";\n{\n  " (span (|@| (class "type") (id "F:725809")) "int") " " (span (|@| (class "variable-name") (id "F:725813")) "cleared") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:725829")) "if") " (" (span (|@| (class "negation-char") (id "F:725833")) "!") "dpyinfo->mouse_face_hidden && " (span (|@| (class "negation-char") (id "F:725864")) "!") "NILP (dpyinfo->mouse_face_window))\n    {\n      show_mouse_face (dpyinfo, DRAW_NORMAL_TEXT);\n      cleared = 1;\n    }\n\n  dpyinfo->mouse_face_beg_row = dpyinfo->mouse_face_beg_col = -1;\n  dpyinfo->mouse_face_end_row = dpyinfo->mouse_face_end_col = -1;\n  dpyinfo->mouse_face_window = Qnil;\n  dpyinfo->mouse_face_overlay = Qnil;\n  " (span (|@| (class "keyword") (id "F:726192")) "return") " cleared;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:726212")) "/* ") (span (|@| (class "comment") (id "F:726215")) "EXPORT:\n   Non-zero if physical cursor of window W is within mouse face.  ") (span (|@| (class "comment-delimiter") (id "F:726289")) "*/") "\n\n" (span (|@| (class "type") (id "F:726293")) "int") "\n" (span (|@| (class "function-name") (id "F:726297")) "cursor_in_mouse_face_p") " (w)\n     " (span (|@| (class "keyword") (id "F:726329")) "struct") " " (span (|@| (class "type") (id "F:726336")) "window") " *" (span (|@| (class "variable-name") (id "F:726344")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:726351")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:726365")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (XFRAME (w->frame));\n  " (span (|@| (class "type") (id "F:726419")) "int") " " (span (|@| (class "variable-name") (id "F:726423")) "in_mouse_face") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:726445")) "if") " (WINDOWP (dpyinfo->mouse_face_window)\n      && XWINDOW (dpyinfo->mouse_face_window) == w)\n    {\n      " (span (|@| (class "type") (id "F:726550")) "int") " " (span (|@| (class "variable-name") (id "F:726554")) "hpos") " = w->phys_cursor.hpos;\n      " (span (|@| (class "type") (id "F:726588")) "int") " " (span (|@| (class "variable-name") (id "F:726592")) "vpos") " = w->phys_cursor.vpos;\n\n      " (span (|@| (class "keyword") (id "F:726627")) "if") " (vpos >= dpyinfo->mouse_face_beg_row\n          && vpos <= dpyinfo->mouse_face_end_row\n          && (vpos > dpyinfo->mouse_face_beg_row\n              || hpos >= dpyinfo->mouse_face_beg_col)\n          && (vpos < dpyinfo->mouse_face_end_row\n              || hpos < dpyinfo->mouse_face_end_col\n              || dpyinfo->mouse_face_past_end))\n        in_mouse_face = 1;\n    }\n\n  " (span (|@| (class "keyword") (id "F:726955")) "return") " in_mouse_face;\n}\n\n\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:726984")) "/* ") (span (|@| (class "comment") (id "F:726987")) "This function sets the mouse_face_* elements of DPYINFO, assuming\n   the mouse cursor is on a glyph with buffer charpos MOUSE_CHARPOS in\n   window WINDOW.  START_CHARPOS and END_CHARPOS are buffer positions\n   for the overlay or run of text properties specifying the mouse\n   face.  BEFORE_STRING and AFTER_STRING, if non-nil, are a\n   before-string and after-string that must also be highlighted.\n   DISPLAY_STRING, if non-nil, is a display string that may cover some\n   or all of the highlighted text.  ") (span (|@| (class "comment-delimiter") (id "F:727492")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:727496")) "static") " " (span (|@| (class "type") (id "F:727503")) "void") "\n" (span (|@| (class "function-name") (id "F:727508")) "mouse_face_from_buffer_pos") " (" (span (|@| (class "type") (id "F:727536")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:727548")) "window") ",\n                            " (span (|@| (class "type") (id "F:727563")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:727577")) "dpyinfo") ",\n                            " (span (|@| (class "type") (id "F:727593")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:727603")) "mouse_charpos") ",\n                            " (span (|@| (class "type") (id "F:727625")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:727635")) "start_charpos") ",\n                            " (span (|@| (class "type") (id "F:727657")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:727667")) "end_charpos") ",\n                            " (span (|@| (class "type") (id "F:727687")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:727699")) "before_string") ",\n                            " (span (|@| (class "type") (id "F:727721")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:727733")) "after_string") ",\n                            " (span (|@| (class "type") (id "F:727754")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:727766")) "display_string") ")\n{\n  " (span (|@| (class "keyword") (id "F:727786")) "struct") " " (span (|@| (class "type") (id "F:727793")) "window") " *" (span (|@| (class "variable-name") (id "F:727801")) "w") " = XWINDOW (window);\n  " (span (|@| (class "keyword") (id "F:727825")) "struct") " " (span (|@| (class "type") (id "F:727832")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:727843")) "first") " = MATRIX_FIRST_TEXT_ROW (w->current_matrix);\n  " (span (|@| (class "keyword") (id "F:727896")) "struct") " " (span (|@| (class "type") (id "F:727903")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:727914")) "row") ";\n  " (span (|@| (class "keyword") (id "F:727921")) "struct") " " (span (|@| (class "type") (id "F:727928")) "glyph") " *" (span (|@| (class "variable-name") (id "F:727935")) "glyph") ", *" (span (|@| (class "variable-name") (id "F:727943")) "end") ";\n  " (span (|@| (class "type") (id "F:727950")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:727960")) "ignore") ";\n  " (span (|@| (class "type") (id "F:727970")) "int") " " (span (|@| (class "variable-name") (id "F:727974")) "x") ";\n\n  xassert (NILP (display_string) || STRINGP (display_string));\n  xassert (NILP (before_string) || STRINGP (before_string));\n  xassert (NILP (after_string) || STRINGP (after_string));\n\n  " (span (|@| (class "comment-delimiter") (id "F:728164")) "/* ") (span (|@| (class "comment") (id "F:728167")) "Find the first highlighted glyph.  ") (span (|@| (class "comment-delimiter") (id "F:728202")) "*/") "\n  " (span (|@| (class "keyword") (id "F:728207")) "if") " (start_charpos < MATRIX_ROW_START_CHARPOS (first))\n    {\n      dpyinfo->mouse_face_beg_col = 0;\n      dpyinfo->mouse_face_beg_row = MATRIX_ROW_VPOS (first, w->current_matrix);\n      dpyinfo->mouse_face_beg_x = first->x;\n      dpyinfo->mouse_face_beg_y = first->y;\n    }\n  " (span (|@| (class "keyword") (id "F:728482")) "else") "\n    {\n      row = row_containing_pos (w, start_charpos, first, " (span (|@| (class "constant") (id "F:728550")) "NULL") ", 0);\n      " (span (|@| (class "keyword") (id "F:728566")) "if") " (row == " (span (|@| (class "constant") (id "F:728577")) "NULL") ")\n        row = MATRIX_ROW (w->current_matrix, XFASTINT (w->window_end_vpos));\n\n      " (span (|@| (class "comment-delimiter") (id "F:728660")) "/* ") (span (|@| (class "comment") (id "F:728663")) "If the before-string or display-string contains newlines,\n         row_containing_pos skips to its last row.  Move back.  ") (span (|@| (class "comment-delimiter") (id "F:728778")) "*/") "\n      " (span (|@| (class "keyword") (id "F:728787")) "if") " (" (span (|@| (class "negation-char") (id "F:728791")) "!") "NILP (before_string) || " (span (|@| (class "negation-char") (id "F:728816")) "!") "NILP (display_string))\n        {\n          " (span (|@| (class "keyword") (id "F:728846")) "struct") " " (span (|@| (class "type") (id "F:728853")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:728864")) "prev") ";\n          " (span (|@| (class "keyword") (id "F:728873")) "while") " ((prev = row - 1, prev >= first)\n                 && MATRIX_ROW_END_CHARPOS (prev) == start_charpos\n                 && prev->used[TEXT_AREA] > 0)\n            {\n              " (span (|@| (class "keyword") (id "F:729012")) "struct") " " (span (|@| (class "type") (id "F:729019")) "glyph") " *" (span (|@| (class "variable-name") (id "F:729026")) "beg") " = prev->glyphs[TEXT_AREA];\n              glyph = beg + prev->used[TEXT_AREA];\n              " (span (|@| (class "keyword") (id "F:729108")) "while") " (--glyph >= beg && INTEGERP (glyph->object));\n              " (span (|@| (class "keyword") (id "F:729167")) "if") " (glyph < beg\n                  || " (span (|@| (class "negation-char") (id "F:729190")) "!") "(EQ (glyph->object, before_string)\n                       || EQ (glyph->object, display_string)))\n                " (span (|@| (class "keyword") (id "F:729277")) "break") ";\n              row = prev;\n            }\n        }\n\n      glyph = row->glyphs[TEXT_AREA];\n      end = glyph + row->used[TEXT_AREA];\n      x = row->x;\n      dpyinfo->mouse_face_beg_y = row->y;\n      dpyinfo->mouse_face_beg_row = MATRIX_ROW_VPOS (row, w->current_matrix);\n\n      " (span (|@| (class "comment-delimiter") (id "F:729539")) "/* ") (span (|@| (class "comment") (id "F:729542")) "Skip truncation glyphs at the start of the glyph row.  ") (span (|@| (class "comment-delimiter") (id "F:729597")) "*/") "\n      " (span (|@| (class "keyword") (id "F:729606")) "if") " (row->displays_text_p)\n        " (span (|@| (class "keyword") (id "F:729633")) "for") " (; glyph < end\n               && INTEGERP (glyph->object)\n               && glyph->charpos < 0;\n             ++glyph)\n          x += glyph->pixel_width;\n\n      " (span (|@| (class "comment-delimiter") (id "F:729769")) "/* ") (span (|@| (class "comment") (id "F:729772")) "Scan the glyph row, stopping before BEFORE_STRING or\n         DISPLAY_STRING or START_CHARPOS.  ") (span (|@| (class "comment-delimiter") (id "F:729861")) "*/") "\n      " (span (|@| (class "keyword") (id "F:729870")) "for") " (; glyph < end\n             && " (span (|@| (class "negation-char") (id "F:729898")) "!") "INTEGERP (glyph->object)\n             && " (span (|@| (class "negation-char") (id "F:729933")) "!") "EQ (glyph->object, before_string)\n             && " (span (|@| (class "negation-char") (id "F:729977")) "!") "EQ (glyph->object, display_string)\n             && " (span (|@| (class "negation-char") (id "F:730022")) "!") "(BUFFERP (glyph->object)\n                  && glyph->charpos >= start_charpos);\n           ++glyph)\n        x += glyph->pixel_width;\n\n      dpyinfo->mouse_face_beg_x = x;\n      dpyinfo->mouse_face_beg_col = glyph - row->glyphs[TEXT_AREA];\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:730243")) "/* ") (span (|@| (class "comment") (id "F:730246")) "Find the last highlighted glyph.  ") (span (|@| (class "comment-delimiter") (id "F:730280")) "*/") "\n  row = row_containing_pos (w, end_charpos, first, " (span (|@| (class "constant") (id "F:730334")) "NULL") ", 0);\n  " (span (|@| (class "keyword") (id "F:730346")) "if") " (row == " (span (|@| (class "constant") (id "F:730357")) "NULL") ")\n    {\n      row = MATRIX_ROW (w->current_matrix, XFASTINT (w->window_end_vpos));\n      dpyinfo->mouse_face_past_end = 1;\n    }\n  " (span (|@| (class "keyword") (id "F:730492")) "else") " " (span (|@| (class "keyword") (id "F:730497")) "if") " (" (span (|@| (class "negation-char") (id "F:730501")) "!") "NILP (after_string))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:730535")) "/* ") (span (|@| (class "comment") (id "F:730538")) "If the after-string has newlines, advance to its last row.  ") (span (|@| (class "comment-delimiter") (id "F:730598")) "*/") "\n      " (span (|@| (class "keyword") (id "F:730607")) "struct") " " (span (|@| (class "type") (id "F:730614")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:730625")) "next") ";\n      " (span (|@| (class "keyword") (id "F:730637")) "struct") " " (span (|@| (class "type") (id "F:730644")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:730655")) "last") "\n        = MATRIX_ROW (w->current_matrix, XFASTINT (w->window_end_vpos));\n\n      " (span (|@| (class "keyword") (id "F:730733")) "for") " (next = row + 1;\n           next <= last\n             && next->used[TEXT_AREA] > 0\n             && EQ (next->glyphs[TEXT_AREA]->object, after_string);\n           ++next)\n        row = next;\n    }\n\n  glyph = row->glyphs[TEXT_AREA];\n  end = glyph + row->used[TEXT_AREA];\n  x = row->x;\n  dpyinfo->mouse_face_end_y = row->y;\n  dpyinfo->mouse_face_end_row = MATRIX_ROW_VPOS (row, w->current_matrix);\n\n  " (span (|@| (class "comment-delimiter") (id "F:731100")) "/* ") (span (|@| (class "comment") (id "F:731103")) "Skip truncation glyphs at the start of the row.  ") (span (|@| (class "comment-delimiter") (id "F:731152")) "*/") "\n  " (span (|@| (class "keyword") (id "F:731157")) "if") " (row->displays_text_p)\n    " (span (|@| (class "keyword") (id "F:731187")) "for") " (; glyph < end\n           && INTEGERP (glyph->object)\n           && glyph->charpos < 0;\n         ++glyph)\n      x += glyph->pixel_width;\n\n  " (span (|@| (class "comment-delimiter") (id "F:731310")) "/* ") (span (|@| (class "comment") (id "F:731313")) "Scan the glyph row, stopping at END_CHARPOS or when we encounter\n     AFTER_STRING.  ") (span (|@| (class "comment-delimiter") (id "F:731398")) "*/") "\n  " (span (|@| (class "keyword") (id "F:731403")) "for") " (; glyph < end\n         && " (span (|@| (class "negation-char") (id "F:731427")) "!") "INTEGERP (glyph->object)\n         && " (span (|@| (class "negation-char") (id "F:731458")) "!") "EQ (glyph->object, after_string)\n         && " (span (|@| (class "negation-char") (id "F:731497")) "!") "(BUFFERP (glyph->object) && glyph->charpos >= end_charpos);\n       ++glyph)\n    x += glyph->pixel_width;\n\n  " (span (|@| (class "comment-delimiter") (id "F:731606")) "/* ") (span (|@| (class "comment") (id "F:731609")) "If we found AFTER_STRING, consume it and stop.  ") (span (|@| (class "comment-delimiter") (id "F:731657")) "*/") "\n  " (span (|@| (class "keyword") (id "F:731662")) "if") " (EQ (glyph->object, after_string))\n    {\n      " (span (|@| (class "keyword") (id "F:731712")) "for") " (; EQ (glyph->object, after_string) && glyph < end; ++glyph)\n        x += glyph->pixel_width;\n    }\n  " (span (|@| (class "keyword") (id "F:731811")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:731828")) "/* ") (span (|@| (class "comment") (id "F:731831")) "If there's no after-string, we must check if we overshot,\n         which might be the case if we stopped after a string glyph.\n         That glyph may belong to a before-string or display-string\n         associated with the end position, which must not be\n         highlighted.  ") (span (|@| (class "comment-delimiter") (id "F:732082")) "*/") "\n      " (span (|@| (class "type") (id "F:732091")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:732103")) "prev_object") ";\n      " (span (|@| (class "type") (id "F:732122")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:732132")) "pos") ";\n\n      " (span (|@| (class "keyword") (id "F:732144")) "while") " (glyph > row->glyphs[TEXT_AREA])\n        {\n          prev_object = (glyph - 1)->object;\n          " (span (|@| (class "keyword") (id "F:732227")) "if") " (" (span (|@| (class "negation-char") (id "F:732231")) "!") "STRINGP (prev_object) || EQ (prev_object, display_string))\n            " (span (|@| (class "keyword") (id "F:732296")) "break") ";\n\n          pos = string_buffer_position (w, prev_object, end_charpos);\n          " (span (|@| (class "keyword") (id "F:732370")) "if") " (pos && pos < end_charpos)\n            " (span (|@| (class "keyword") (id "F:732405")) "break") ";\n\n          " (span (|@| (class "keyword") (id "F:732416")) "for") " (; glyph > row->glyphs[TEXT_AREA]\n                 && EQ ((glyph - 1)->object, prev_object);\n               --glyph)\n            x -= (glyph - 1)->pixel_width;\n        }\n    }\n\n  dpyinfo->mouse_face_end_x = x;\n  dpyinfo->mouse_face_end_col = glyph - row->glyphs[TEXT_AREA];\n  dpyinfo->mouse_face_window = window;\n  dpyinfo->mouse_face_face_id\n    = face_at_buffer_position (w, mouse_charpos, 0, 0, &ignore,\n                               mouse_charpos + 1,\n                               " (span (|@| (class "negation-char") (id "F:732831")) "!") "dpyinfo->mouse_face_hidden, -1);\n  show_mouse_face (dpyinfo, DRAW_MOUSE_FACE);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:732915")) "/* ") (span (|@| (class "comment") (id "F:732918")) "Find the position of the glyph for position POS in OBJECT in\n   window W's current matrix, and return in *X, *Y the pixel\n   coordinates, and return in *HPOS, *VPOS the column/row of the glyph.\n\n   RIGHT_P non-zero means return the position of the right edge of the\n   glyph, RIGHT_P zero means return the left edge position.\n\n   If no glyph for POS exists in the matrix, return the position of\n   the glyph with the next smaller position that is in the matrix, if\n   RIGHT_P is zero.  If RIGHT_P is non-zero, and no glyph for POS\n   exists in the matrix, return the position of the glyph with the\n   next larger position in OBJECT.\n\n   Value is non-zero if a glyph was found.  ") (span (|@| (class "comment-delimiter") (id "F:733596")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:733600")) "static") " " (span (|@| (class "type") (id "F:733607")) "int") "\n" (span (|@| (class "function-name") (id "F:733611")) "fast_find_string_pos") " (w, pos, object, hpos, vpos, x, y, right_p)\n     " (span (|@| (class "keyword") (id "F:733681")) "struct") " " (span (|@| (class "type") (id "F:733688")) "window") " *" (span (|@| (class "variable-name") (id "F:733696")) "w") ";\n     " (span (|@| (class "type") (id "F:733704")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:733714")) "pos") ";\n     " (span (|@| (class "type") (id "F:733724")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:733736")) "object") ";\n     " (span (|@| (class "type") (id "F:733749")) "int") " *" (span (|@| (class "variable-name") (id "F:733754")) "hpos") ", *" (span (|@| (class "variable-name") (id "F:733761")) "vpos") ", *" (span (|@| (class "variable-name") (id "F:733768")) "x") ", *" (span (|@| (class "variable-name") (id "F:733772")) "y") ";\n     " (span (|@| (class "type") (id "F:733780")) "int") " " (span (|@| (class "variable-name") (id "F:733784")) "right_p") ";\n{\n  " (span (|@| (class "type") (id "F:733797")) "int") " " (span (|@| (class "variable-name") (id "F:733801")) "yb") " = window_text_bottom_y (w);\n  " (span (|@| (class "keyword") (id "F:733834")) "struct") " " (span (|@| (class "type") (id "F:733841")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:733852")) "r") ";\n  " (span (|@| (class "keyword") (id "F:733857")) "struct") " " (span (|@| (class "type") (id "F:733864")) "glyph") " *" (span (|@| (class "variable-name") (id "F:733871")) "best_glyph") " = " (span (|@| (class "constant") (id "F:733884")) "NULL") ";\n  " (span (|@| (class "keyword") (id "F:733892")) "struct") " " (span (|@| (class "type") (id "F:733899")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:733910")) "best_row") " = " (span (|@| (class "constant") (id "F:733921")) "NULL") ";\n  " (span (|@| (class "type") (id "F:733929")) "int") " " (span (|@| (class "variable-name") (id "F:733933")) "best_x") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:733948")) "for") " (r = MATRIX_FIRST_TEXT_ROW (w->current_matrix);\n       r->enabled_p && r->y < yb;\n       ++r)\n    {\n      " (span (|@| (class "keyword") (id "F:734058")) "struct") " " (span (|@| (class "type") (id "F:734065")) "glyph") " *" (span (|@| (class "variable-name") (id "F:734072")) "g") " = r->glyphs[TEXT_AREA];\n      " (span (|@| (class "keyword") (id "F:734104")) "struct") " " (span (|@| (class "type") (id "F:734111")) "glyph") " *" (span (|@| (class "variable-name") (id "F:734118")) "e") " = g + r->used[TEXT_AREA];\n      " (span (|@| (class "type") (id "F:734152")) "int") " " (span (|@| (class "variable-name") (id "F:734156")) "gx") ";\n\n      " (span (|@| (class "keyword") (id "F:734167")) "for") " (gx = r->x; g < e; gx += g->pixel_width, ++g)\n        " (span (|@| (class "keyword") (id "F:734218")) "if") " (EQ (g->object, object))\n          {\n            " (span (|@| (class "keyword") (id "F:734256")) "if") " (g->charpos == pos)\n              {\n                best_glyph = g;\n                best_x = gx;\n                best_row = r;\n                " (span (|@| (class "keyword") (id "F:734339")) "goto") " " (span (|@| (class "constant") (id "F:734344")) "found") ";\n              }\n            " (span (|@| (class "keyword") (id "F:734365")) "else") " " (span (|@| (class "keyword") (id "F:734370")) "if") " (best_glyph == " (span (|@| (class "constant") (id "F:734388")) "NULL") "\n                     || ((eabs (g->charpos - pos)\n                         < eabs (best_glyph->charpos - pos))\n                         && (right_p\n                             ? g->charpos < pos\n                             : g->charpos > pos)))\n              {\n                best_glyph = g;\n                best_x = gx;\n                best_row = r;\n              }\n          }\n    }\n\n " (span (|@| (class "constant") (id "F:734622")) "found") ":\n\n  " (span (|@| (class "keyword") (id "F:734632")) "if") " (best_glyph)\n    {\n      *x = best_x;\n      *hpos = best_glyph - best_row->glyphs[TEXT_AREA];\n\n      " (span (|@| (class "keyword") (id "F:734736")) "if") " (right_p)\n        {\n          *x += best_glyph->pixel_width;\n          ++*hpos;\n        }\n\n      *y = best_row->y;\n      *vpos = best_row - w->current_matrix->rows;\n    }\n\n  " (span (|@| (class "keyword") (id "F:734885")) "return") " best_glyph != " (span (|@| (class "constant") (id "F:734906")) "NULL") ";\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:734916")) "/* ") (span (|@| (class "comment") (id "F:734919")) "See if position X, Y is within a hot-spot of an image.  ") (span (|@| (class "comment-delimiter") (id "F:734975")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:734979")) "static") " " (span (|@| (class "type") (id "F:734986")) "int") "\n" (span (|@| (class "function-name") (id "F:734990")) "on_hot_spot_p") " (hot_spot, x, y)\n     " (span (|@| (class "type") (id "F:735026")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:735038")) "hot_spot") ";\n     " (span (|@| (class "type") (id "F:735053")) "int") " " (span (|@| (class "variable-name") (id "F:735057")) "x") ", " (span (|@| (class "variable-name") (id "F:735060")) "y") ";\n{\n  " (span (|@| (class "keyword") (id "F:735067")) "if") " (" (span (|@| (class "negation-char") (id "F:735071")) "!") "CONSP (hot_spot))\n    " (span (|@| (class "keyword") (id "F:735094")) "return") " 0;\n\n  " (span (|@| (class "keyword") (id "F:735107")) "if") " (EQ (XCAR (hot_spot), Qrect))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:735152")) "/* ") (span (|@| (class "comment") (id "F:735155")) "CDR is (Top-Left . Bottom-Right) = ((x0 . y0) . (x1 . y1))  ") (span (|@| (class "comment-delimiter") (id "F:735215")) "*/") "\n      " (span (|@| (class "type") (id "F:735224")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:735236")) "rect") " = XCDR (hot_spot);\n      " (span (|@| (class "type") (id "F:735266")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:735278")) "tem") ";\n      " (span (|@| (class "keyword") (id "F:735289")) "if") " (" (span (|@| (class "negation-char") (id "F:735293")) "!") "CONSP (rect))\n        " (span (|@| (class "keyword") (id "F:735309")) "return") " 0;\n      " (span (|@| (class "keyword") (id "F:735325")) "if") " (" (span (|@| (class "negation-char") (id "F:735329")) "!") "CONSP (XCAR (rect)))\n        " (span (|@| (class "keyword") (id "F:735352")) "return") " 0;\n      " (span (|@| (class "keyword") (id "F:735368")) "if") " (" (span (|@| (class "negation-char") (id "F:735372")) "!") "CONSP (XCDR (rect)))\n        " (span (|@| (class "keyword") (id "F:735395")) "return") " 0;\n      " (span (|@| (class "keyword") (id "F:735411")) "if") " (" (span (|@| (class "negation-char") (id "F:735415")) "!") "(tem = XCAR (XCAR (rect)), INTEGERP (tem) && x >= XINT (tem)))\n        " (span (|@| (class "keyword") (id "F:735480")) "return") " 0;\n      " (span (|@| (class "keyword") (id "F:735496")) "if") " (" (span (|@| (class "negation-char") (id "F:735500")) "!") "(tem = XCDR (XCAR (rect)), INTEGERP (tem) && y >= XINT (tem)))\n        " (span (|@| (class "keyword") (id "F:735565")) "return") " 0;\n      " (span (|@| (class "keyword") (id "F:735581")) "if") " (" (span (|@| (class "negation-char") (id "F:735585")) "!") "(tem = XCAR (XCDR (rect)), INTEGERP (tem) && x <= XINT (tem)))\n        " (span (|@| (class "keyword") (id "F:735650")) "return") " 0;\n      " (span (|@| (class "keyword") (id "F:735666")) "if") " (" (span (|@| (class "negation-char") (id "F:735670")) "!") "(tem = XCDR (XCDR (rect)), INTEGERP (tem) && y <= XINT (tem)))\n        " (span (|@| (class "keyword") (id "F:735735")) "return") " 0;\n      " (span (|@| (class "keyword") (id "F:735751")) "return") " 1;\n    }\n  " (span (|@| (class "keyword") (id "F:735769")) "else") " " (span (|@| (class "keyword") (id "F:735774")) "if") " (EQ (XCAR (hot_spot), Qcircle))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:735821")) "/* ") (span (|@| (class "comment") (id "F:735824")) "CDR is (Center . Radius) = ((x0 . y0) . r) ") (span (|@| (class "comment-delimiter") (id "F:735867")) "*/") "\n      " (span (|@| (class "type") (id "F:735876")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:735888")) "circ") " = XCDR (hot_spot);\n      " (span (|@| (class "type") (id "F:735918")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:735930")) "lr") ", " (span (|@| (class "variable-name") (id "F:735934")) "lx0") ", " (span (|@| (class "variable-name") (id "F:735939")) "ly0") ";\n      " (span (|@| (class "keyword") (id "F:735950")) "if") " (CONSP (circ)\n          && CONSP (XCAR (circ))\n          && (lr = XCDR (circ), INTEGERP (lr) || FLOATP (lr))\n          && (lx0 = XCAR (XCAR (circ)), INTEGERP (lx0))\n          && (ly0 = XCDR (XCAR (circ)), INTEGERP (ly0)))\n        {\n          " (span (|@| (class "type") (id "F:736153")) "double") " " (span (|@| (class "variable-name") (id "F:736160")) "r") " = XFLOATINT (lr);\n          " (span (|@| (class "type") (id "F:736183")) "double") " " (span (|@| (class "variable-name") (id "F:736190")) "dx") " = XINT (lx0) - x;\n          " (span (|@| (class "type") (id "F:736214")) "double") " " (span (|@| (class "variable-name") (id "F:736221")) "dy") " = XINT (ly0) - y;\n          " (span (|@| (class "keyword") (id "F:736245")) "return") " (dx * dx + dy * dy <= r * r);\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:736293")) "else") " " (span (|@| (class "keyword") (id "F:736298")) "if") " (EQ (XCAR (hot_spot), Qpoly))\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:736343")) "/* ") (span (|@| (class "comment") (id "F:736346")) "CDR is [x0 y0 x1 y1 x2 y2 ...x(n-1) y(n-1)] ") (span (|@| (class "comment-delimiter") (id "F:736390")) "*/") "\n      " (span (|@| (class "keyword") (id "F:736399")) "if") " (VECTORP (XCDR (hot_spot)))\n        {\n          " (span (|@| (class "keyword") (id "F:736436")) "struct") " " (span (|@| (class "type") (id "F:736443")) "Lisp_Vector") " *" (span (|@| (class "variable-name") (id "F:736456")) "v") " = XVECTOR (XCDR (hot_spot));\n          " (span (|@| (class "type") (id "F:736490")) "Lisp_Object") " *" (span (|@| (class "variable-name") (id "F:736503")) "poly") " = v->contents;\n          " (span (|@| (class "type") (id "F:736526")) "int") " " (span (|@| (class "variable-name") (id "F:736530")) "n") " = v->size;\n          " (span (|@| (class "type") (id "F:736546")) "int") " " (span (|@| (class "variable-name") (id "F:736550")) "i") ";\n          " (span (|@| (class "type") (id "F:736556")) "int") " " (span (|@| (class "variable-name") (id "F:736560")) "inside") " = 0;\n          " (span (|@| (class "type") (id "F:736575")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:736587")) "lx") ", " (span (|@| (class "variable-name") (id "F:736591")) "ly") ";\n          " (span (|@| (class "type") (id "F:736598")) "int") " " (span (|@| (class "variable-name") (id "F:736602")) "x0") ", " (span (|@| (class "variable-name") (id "F:736606")) "y0") ";\n\n          " (span (|@| (class "comment-delimiter") (id "F:736614")) "/* ") (span (|@| (class "comment") (id "F:736617")) "Need an even number of coordinates, and at least 3 edges.  ") (span (|@| (class "comment-delimiter") (id "F:736676")) "*/") "\n          " (span (|@| (class "keyword") (id "F:736682")) "if") " (n < 6 || n & 1)\n            " (span (|@| (class "keyword") (id "F:736707")) "return") " 0;\n\n          " (span (|@| (class "comment-delimiter") (id "F:736721")) "/* ") (span (|@| (class "comment") (id "F:736724")) "Count edge segments intersecting line from (X,Y) to (X,infinity).\n             If count is odd, we are inside polygon.  Pixels on edges\n             may or may not be included depending on actual geometry of the\n             polygon.  ") (span (|@| (class "comment-delimiter") (id "F:736938")) "*/") "\n          " (span (|@| (class "keyword") (id "F:736944")) "if") " ((lx = poly[n-2], " (span (|@| (class "negation-char") (id "F:736965")) "!") "INTEGERP (lx))\n              || (ly = poly[n-1], " (span (|@| (class "negation-char") (id "F:737008")) "!") "INTEGERP (lx)))\n            " (span (|@| (class "keyword") (id "F:737030")) "return") " 0;\n          x0 = XINT (lx), y0 = XINT (ly);\n          " (span (|@| (class "keyword") (id "F:737078")) "for") " (i = 0; i < n; i += 2)\n            {\n              " (span (|@| (class "type") (id "F:737119")) "int") " " (span (|@| (class "variable-name") (id "F:737123")) "x1") " = x0, " (span (|@| (class "variable-name") (id "F:737132")) "y1") " = y0;\n              " (span (|@| (class "keyword") (id "F:737148")) "if") " ((lx = poly[i], " (span (|@| (class "negation-char") (id "F:737167")) "!") "INTEGERP (lx))\n                  || (ly = poly[i+1], " (span (|@| (class "negation-char") (id "F:737207")) "!") "INTEGERP (ly)))\n                " (span (|@| (class "keyword") (id "F:737226")) "return") " 0;\n              x0 = XINT (lx), y0 = XINT (ly);\n\n              " (span (|@| (class "comment-delimiter") (id "F:737283")) "/* ") (span (|@| (class "comment") (id "F:737286")) "Does this segment cross the X line?  ") (span (|@| (class "comment-delimiter") (id "F:737323")) "*/") "\n              " (span (|@| (class "keyword") (id "F:737333")) "if") " (x0 >= x)\n                {\n                  " (span (|@| (class "keyword") (id "F:737354")) "if") " (x1 >= x)\n                    " (span (|@| (class "keyword") (id "F:737373")) "continue") ";\n                }\n              " (span (|@| (class "keyword") (id "F:737394")) "else") " " (span (|@| (class "keyword") (id "F:737399")) "if") " (x1 < x)\n                " (span (|@| (class "keyword") (id "F:737413")) "continue") ";\n              " (span (|@| (class "keyword") (id "F:737430")) "if") " (y > y0 && y > y1)\n                " (span (|@| (class "keyword") (id "F:737454")) "continue") ";\n              " (span (|@| (class "keyword") (id "F:737471")) "if") " (y < y0 + ((y1 - y0) * (x - x0)) / (x1 - x0))\n                inside = " (span (|@| (class "negation-char") (id "F:737531")) "!") "inside;\n            }\n          " (span (|@| (class "keyword") (id "F:737550")) "return") " inside;\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:737576")) "return") " 0;\n}\n\n" (span (|@| (class "type") (id "F:737589")) "Lisp_Object") "\n" (span (|@| (class "function-name") (id "F:737601")) "find_hot_spot") " (map, x, y)\n     " (span (|@| (class "type") (id "F:737632")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:737644")) "map") ";\n     " (span (|@| (class "type") (id "F:737654")) "int") " " (span (|@| (class "variable-name") (id "F:737658")) "x") ", " (span (|@| (class "variable-name") (id "F:737661")) "y") ";\n{\n  " (span (|@| (class "keyword") (id "F:737668")) "while") " (CONSP (map))\n    {\n      " (span (|@| (class "keyword") (id "F:737700")) "if") " (CONSP (XCAR (map))\n          && on_hot_spot_p (XCAR (XCAR (map)), x, y))\n        " (span (|@| (class "keyword") (id "F:737771")) "return") " XCAR (map);\n      map = XCDR (map);\n    }\n\n  " (span (|@| (class "keyword") (id "F:737823")) "return") " Qnil;\n}\n\nDEFUN (" (span (|@| (class "string") (id "F:737846")) "\"lookup-image-map\"") ", Flookup_image_map, Slookup_image_map,\n       3, 3, 0,\n       doc: " (span (|@| (class "comment-delimiter") (id "F:737932")) "/* ") (span (|@| (class "comment") (id "F:737935")) "Lookup in image map MAP coordinates X and Y.\nAn image map is an alist where each element has the format (AREA ID PLIST).\nAn AREA is specified as either a rectangle, a circle, or a polygon:\nA rectangle is a cons (rect . ((x0 . y0) . (x1 . y1))) specifying the\npixel coordinates of the upper left and bottom right corners.\nA circle is a cons (circle . ((x0 . y0) . r)) specifying the center\nand the radius of the circle; r may be a float or integer.\nA polygon is a cons (poly . [x0 y0 x1 y1 ...]) where each pair in the\nvector describes one corner in the polygon.\nReturns the alist element for the first matching AREA in MAP.  ") (span (|@| (class "comment-delimiter") (id "F:738560")) "*/") ")\n     (map, x, y)\n     " (span (|@| (class "type") (id "F:738586")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:738598")) "map") ";\n     " (span (|@| (class "type") (id "F:738608")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:738620")) "x") ", " (span (|@| (class "variable-name") (id "F:738623")) "y") ";\n{\n  " (span (|@| (class "keyword") (id "F:738630")) "if") " (NILP (map))\n    " (span (|@| (class "keyword") (id "F:738650")) "return") " Qnil;\n\n  CHECK_NUMBER (x);\n  CHECK_NUMBER (y);\n\n  " (span (|@| (class "keyword") (id "F:738707")) "return") " find_hot_spot (map, XINT (x), XINT (y));\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:738759")) "/* ") (span (|@| (class "comment") (id "F:738762")) "Display frame CURSOR, optionally using shape defined by POINTER.  ") (span (|@| (class "comment-delimiter") (id "F:738828")) "*/") "\n" (span (|@| (class "keyword") (id "F:738831")) "static") " " (span (|@| (class "type") (id "F:738838")) "void") "\n" (span (|@| (class "function-name") (id "F:738843")) "define_frame_cursor1") " (f, cursor, pointer)\n     " (span (|@| (class "keyword") (id "F:738890")) "struct") " " (span (|@| (class "type") (id "F:738897")) "frame") " *" (span (|@| (class "variable-name") (id "F:738904")) "f") ";\n     " (span (|@| (class "type") (id "F:738912")) "Cursor") " " (span (|@| (class "variable-name") (id "F:738919")) "cursor") ";\n     " (span (|@| (class "type") (id "F:738932")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:738944")) "pointer") ";\n{\n  " (span (|@| (class "comment-delimiter") (id "F:738957")) "/* ") (span (|@| (class "comment") (id "F:738960")) "Do not change cursor shape while dragging mouse.  ") (span (|@| (class "comment-delimiter") (id "F:739010")) "*/") "\n  " (span (|@| (class "keyword") (id "F:739015")) "if") " (" (span (|@| (class "negation-char") (id "F:739019")) "!") "NILP (do_mouse_tracking))\n    " (span (|@| (class "keyword") (id "F:739050")) "return") ";\n\n  " (span (|@| (class "keyword") (id "F:739061")) "if") " (" (span (|@| (class "negation-char") (id "F:739065")) "!") "NILP (pointer))\n    {\n      " (span (|@| (class "keyword") (id "F:739094")) "if") " (EQ (pointer, Qarrow))\n        cursor = FRAME_X_OUTPUT (f)->nontext_cursor;\n      " (span (|@| (class "keyword") (id "F:739172")) "else") " " (span (|@| (class "keyword") (id "F:739177")) "if") " (EQ (pointer, Qhand))\n        cursor = FRAME_X_OUTPUT (f)->hand_cursor;\n      " (span (|@| (class "keyword") (id "F:739251")) "else") " " (span (|@| (class "keyword") (id "F:739256")) "if") " (EQ (pointer, Qtext))\n        cursor = FRAME_X_OUTPUT (f)->text_cursor;\n      " (span (|@| (class "keyword") (id "F:739330")) "else") " " (span (|@| (class "keyword") (id "F:739335")) "if") " (EQ (pointer, intern (" (span (|@| (class "string") (id "F:739360")) "\"hdrag\"") ")))\n        cursor = FRAME_X_OUTPUT (f)->horizontal_drag_cursor;\n" (span (|@| (class "preprocessor") (id "F:739425")) "#ifdef") " HAVE_X_WINDOWS\n      " (span (|@| (class "keyword") (id "F:739453")) "else") " " (span (|@| (class "keyword") (id "F:739458")) "if") " (EQ (pointer, intern (" (span (|@| (class "string") (id "F:739483")) "\"vdrag\"") ")))\n        cursor = FRAME_X_DISPLAY_INFO (f)->vertical_scroll_bar_cursor;\n" (span (|@| (class "preprocessor") (id "F:739558")) "#endif") "\n      " (span (|@| (class "keyword") (id "F:739571")) "else") " " (span (|@| (class "keyword") (id "F:739576")) "if") " (EQ (pointer, intern (" (span (|@| (class "string") (id "F:739601")) "\"hourglass\"") ")))\n        cursor = FRAME_X_OUTPUT (f)->hourglass_cursor;\n      " (span (|@| (class "keyword") (id "F:739670")) "else") " " (span (|@| (class "keyword") (id "F:739675")) "if") " (EQ (pointer, Qmodeline))\n        cursor = FRAME_X_OUTPUT (f)->modeline_cursor;\n      " (span (|@| (class "keyword") (id "F:739757")) "else") "\n        cursor = FRAME_X_OUTPUT (f)->nontext_cursor;\n    }\n\n  " (span (|@| (class "keyword") (id "F:739817")) "if") " (cursor != No_Cursor)\n    FRAME_RIF (f)->define_frame_cursor (f, cursor);\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:739897")) "/* ") (span (|@| (class "comment") (id "F:739900")) "Take proper action when mouse has moved to the mode or header line\n   or marginal area AREA of window W, x-position X and y-position Y.\n   X is relative to the start of the text display area of W, so the\n   width of bitmap areas and scroll bars must be subtracted to get a\n   position relative to the start of the mode line.  ") (span (|@| (class "comment-delimiter") (id "F:740226")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:740230")) "static") " " (span (|@| (class "type") (id "F:740237")) "void") "\n" (span (|@| (class "function-name") (id "F:740242")) "note_mode_line_or_margin_highlight") " (" (span (|@| (class "type") (id "F:740278")) "window") ", x, y, area)\n     " (span (|@| (class "type") (id "F:740303")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:740315")) "window") ";\n     " (span (|@| (class "type") (id "F:740328")) "int") " " (span (|@| (class "variable-name") (id "F:740332")) "x") ", " (span (|@| (class "variable-name") (id "F:740335")) "y") ";\n     " (span (|@| (class "keyword") (id "F:740343")) "enum") " " (span (|@| (class "type") (id "F:740348")) "window_part") " " (span (|@| (class "variable-name") (id "F:740360")) "area") ";\n{\n  " (span (|@| (class "keyword") (id "F:740370")) "struct") " " (span (|@| (class "type") (id "F:740377")) "window") " *" (span (|@| (class "variable-name") (id "F:740385")) "w") " = XWINDOW (window);\n  " (span (|@| (class "keyword") (id "F:740409")) "struct") " " (span (|@| (class "type") (id "F:740416")) "frame") " *" (span (|@| (class "variable-name") (id "F:740423")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:740448")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:740462")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n  " (span (|@| (class "type") (id "F:740500")) "Cursor") " " (span (|@| (class "variable-name") (id "F:740507")) "cursor") " = FRAME_X_OUTPUT (f)->nontext_cursor;\n  " (span (|@| (class "type") (id "F:740554")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:740566")) "pointer") " = Qnil;\n  " (span (|@| (class "type") (id "F:740584")) "int") " " (span (|@| (class "variable-name") (id "F:740588")) "charpos") ", " (span (|@| (class "variable-name") (id "F:740597")) "dx") ", " (span (|@| (class "variable-name") (id "F:740601")) "dy") ", " (span (|@| (class "variable-name") (id "F:740605")) "width") ", " (span (|@| (class "variable-name") (id "F:740612")) "height") ";\n  " (span (|@| (class "type") (id "F:740622")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:740634")) "string") ", " (span (|@| (class "variable-name") (id "F:740642")) "object") " = Qnil;\n  " (span (|@| (class "type") (id "F:740659")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:740671")) "pos") ", " (span (|@| (class "variable-name") (id "F:740676")) "help") ";\n\n  " (span (|@| (class "type") (id "F:740685")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:740697")) "mouse_face") ";\n  " (span (|@| (class "type") (id "F:740711")) "int") " " (span (|@| (class "variable-name") (id "F:740715")) "original_x_pixel") " = x;\n  " (span (|@| (class "keyword") (id "F:740739")) "struct") " " (span (|@| (class "type") (id "F:740746")) "glyph") " * " (span (|@| (class "variable-name") (id "F:740754")) "glyph") " = " (span (|@| (class "constant") (id "F:740762")) "NULL") ", * " (span (|@| (class "variable-name") (id "F:740770")) "row_start_glyph") " = " (span (|@| (class "constant") (id "F:740788")) "NULL") ";\n  " (span (|@| (class "keyword") (id "F:740796")) "struct") " " (span (|@| (class "type") (id "F:740803")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:740814")) "row") ";\n\n  " (span (|@| (class "keyword") (id "F:740822")) "if") " (area == ON_MODE_LINE || area == ON_HEADER_LINE)\n    {\n      " (span (|@| (class "type") (id "F:740886")) "int") " " (span (|@| (class "variable-name") (id "F:740890")) "x0") ";\n      " (span (|@| (class "keyword") (id "F:740900")) "struct") " " (span (|@| (class "type") (id "F:740907")) "glyph") " *" (span (|@| (class "variable-name") (id "F:740914")) "end") ";\n\n      string = mode_line_string (w, area, &x, &y, &charpos,\n                                 &object, &dx, &dy, &width, &height);\n\n      row = (area == ON_MODE_LINE\n             ? MATRIX_MODE_LINE_ROW (w->current_matrix)\n             : MATRIX_HEADER_LINE_ROW (w->current_matrix));\n\n      " (span (|@| (class "comment-delimiter") (id "F:741166")) "/* ") (span (|@| (class "comment") (id "F:741169")) "Find glyph ") (span (|@| (class "comment-delimiter") (id "F:741180")) "*/") "\n      " (span (|@| (class "keyword") (id "F:741189")) "if") " (row->mode_line_p && row->enabled_p)\n        {\n          glyph = row_start_glyph = row->glyphs[TEXT_AREA];\n          end = glyph + row->used[TEXT_AREA];\n\n          " (span (|@| (class "keyword") (id "F:741328")) "for") " (x0 = original_x_pixel;\n               glyph < end && x0 >= glyph->pixel_width;\n               ++glyph)\n            x0 -= glyph->pixel_width;\n\n          " (span (|@| (class "keyword") (id "F:741457")) "if") " (glyph >= end)\n            glyph = " (span (|@| (class "constant") (id "F:741488")) "NULL") ";\n        }\n    }\n  " (span (|@| (class "keyword") (id "F:741505")) "else") "\n    {\n      x -= WINDOW_LEFT_SCROLL_BAR_AREA_WIDTH (w);\n      string = marginal_area_string (w, area, &x, &y, &charpos,\n                                     &object, &dx, &dy, &width, &height);\n    }\n\n  help = Qnil;\n\n  " (span (|@| (class "keyword") (id "F:741701")) "if") " (IMAGEP (object))\n    {\n      " (span (|@| (class "type") (id "F:741734")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:741746")) "image_map") ", " (span (|@| (class "variable-name") (id "F:741757")) "hotspot") ";\n      " (span (|@| (class "keyword") (id "F:741772")) "if") " ((image_map = Fplist_get (XCDR (object), QCmap),\n           " (span (|@| (class "negation-char") (id "F:741828")) "!") "NILP (image_map))\n          && (hotspot = find_hot_spot (image_map, dx, dy),\n              CONSP (hotspot))\n          && (hotspot = XCDR (hotspot), CONSP (hotspot)))\n        {\n          " (span (|@| (class "type") (id "F:741980")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:741992")) "area_id") ", " (span (|@| (class "variable-name") (id "F:742001")) "plist") ";\n\n          area_id = XCAR (hotspot);\n          " (span (|@| (class "comment-delimiter") (id "F:742041")) "/* ") (span (|@| (class "comment") (id "F:742044")) "Could check AREA_ID to see if we enter/leave this hot-spot.\n             If so, we could look for mouse-enter, mouse-leave\n             properties in PLIST (and do something...).  ") (span (|@| (class "comment-delimiter") (id "F:742210")) "*/") "\n          hotspot = XCDR (hotspot);\n          " (span (|@| (class "keyword") (id "F:742245")) "if") " (CONSP (hotspot)\n              && (plist = XCAR (hotspot), CONSP (plist)))\n            {\n              pointer = Fplist_get (plist, Qpointer);\n              " (span (|@| (class "keyword") (id "F:742377")) "if") " (NILP (pointer))\n                pointer = Qhand;\n              help = Fplist_get (plist, Qhelp_echo);\n              " (span (|@| (class "keyword") (id "F:742469")) "if") " (" (span (|@| (class "negation-char") (id "F:742473")) "!") "NILP (help))\n                {\n                  help_echo_string = help;\n                  " (span (|@| (class "comment-delimiter") (id "F:742524")) "/* ") (span (|@| (class "comment") (id "F:742527")) "Is this correct?  ++kfs ") (span (|@| (class "comment-delimiter") (id "F:742551")) "*/") "\n                  XSETWINDOW (help_echo_window, w);\n                  help_echo_object = w->buffer;\n                  help_echo_pos = charpos;\n                }\n            }\n        }\n      " (span (|@| (class "keyword") (id "F:742675")) "if") " (NILP (pointer))\n        pointer = Fplist_get (XCDR (object), QCpointer);\n    }\n\n  " (span (|@| (class "keyword") (id "F:742754")) "if") " (STRINGP (string))\n    {\n      pos = make_number (charpos);\n      " (span (|@| (class "comment-delimiter") (id "F:742823")) "/* ") (span (|@| (class "comment") (id "F:742826")) "If we're on a string with `help-echo' text property, arrange\n         for the help to be displayed.  This is done by setting the\n         global variable help_echo_string to the help string.  ") (span (|@| (class "comment-delimiter") (id "F:743004")) "*/") "\n      " (span (|@| (class "keyword") (id "F:743013")) "if") " (NILP (help))\n        {\n          help = Fget_text_property (pos, Qhelp_echo, string);\n          " (span (|@| (class "keyword") (id "F:743092")) "if") " (" (span (|@| (class "negation-char") (id "F:743096")) "!") "NILP (help))\n            {\n              help_echo_string = help;\n              XSETWINDOW (help_echo_window, w);\n              help_echo_object = string;\n              help_echo_pos = charpos;\n            }\n        }\n\n      " (span (|@| (class "keyword") (id "F:743273")) "if") " (NILP (pointer))\n        pointer = Fget_text_property (pos, Qpointer, string);\n\n     " (span (|@| (class "comment-delimiter") (id "F:743354")) "/* ") (span (|@| (class "comment") (id "F:743357")) "Change the mouse pointer according to what is under X/Y.  ") (span (|@| (class "comment-delimiter") (id "F:743415")) "*/") "\n      " (span (|@| (class "keyword") (id "F:743424")) "if") " (NILP (pointer) && ((area == ON_MODE_LINE) || (area == ON_HEADER_LINE)))\n        {\n          " (span (|@| (class "type") (id "F:743506")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:743518")) "map") ";\n          map = Fget_text_property (pos, Qlocal_map, string);\n          " (span (|@| (class "keyword") (id "F:743581")) "if") " (" (span (|@| (class "negation-char") (id "F:743585")) "!") "KEYMAPP (map))\n            map = Fget_text_property (pos, Qkeymap, string);\n          " (span (|@| (class "keyword") (id "F:743658")) "if") " (" (span (|@| (class "negation-char") (id "F:743662")) "!") "KEYMAPP (map))\n            cursor = dpyinfo->vertical_scroll_bar_cursor;\n        }\n\n     " (span (|@| (class "comment-delimiter") (id "F:743738")) "/* ") (span (|@| (class "comment") (id "F:743741")) "Change the mouse face according to what is under X/Y.  ") (span (|@| (class "comment-delimiter") (id "F:743796")) "*/") "\n      mouse_face = Fget_text_property (pos, Qmouse_face, string);\n      " (span (|@| (class "keyword") (id "F:743871")) "if") " (" (span (|@| (class "negation-char") (id "F:743875")) "!") "NILP (mouse_face)\n          && ((area == ON_MODE_LINE) || (area == ON_HEADER_LINE))\n          && glyph)\n        {\n          " (span (|@| (class "type") (id "F:743972")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:743984")) "b") ", " (span (|@| (class "variable-name") (id "F:743987")) "e") ";\n\n          " (span (|@| (class "keyword") (id "F:743994")) "struct") " " (span (|@| (class "type") (id "F:744001")) "glyph") " * " (span (|@| (class "variable-name") (id "F:744009")) "tmp_glyph") ";\n\n          " (span (|@| (class "type") (id "F:744024")) "int") " " (span (|@| (class "variable-name") (id "F:744028")) "gpos") ";\n          " (span (|@| (class "type") (id "F:744037")) "int") " " (span (|@| (class "variable-name") (id "F:744041")) "gseq_length") ";\n          " (span (|@| (class "type") (id "F:744057")) "int") " " (span (|@| (class "variable-name") (id "F:744061")) "total_pixel_width") ";\n          " (span (|@| (class "type") (id "F:744083")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:744093")) "ignore") ";\n\n          " (span (|@| (class "type") (id "F:744105")) "int") " " (span (|@| (class "variable-name") (id "F:744109")) "vpos") ", " (span (|@| (class "variable-name") (id "F:744115")) "hpos") ";\n\n          b = Fprevious_single_property_change (make_number (charpos + 1),\n                                                Qmouse_face, string, Qnil);\n          " (span (|@| (class "keyword") (id "F:744227")) "if") " (NILP (b))\n            b = make_number (0);\n\n          e = Fnext_single_property_change (pos, Qmouse_face, string, Qnil);\n          " (span (|@| (class "keyword") (id "F:744341")) "if") " (NILP (e))\n            e = make_number (SCHARS (string));\n\n          " (span (|@| (class "comment-delimiter") (id "F:744399")) "/* ") (span (|@| (class "comment") (id "F:744402")) "Calculate the position(glyph position: GPOS) of GLYPH in\n             displayed string. GPOS is different from CHARPOS.\n\n             CHARPOS is the position of glyph in internal string\n             object. A mode line string format has structures which\n             is converted to a flatten by emacs lisp interpreter.\n             The internal string is an element of the structures.\n             The displayed string is the flatten string. ") (span (|@| (class "comment-delimiter") (id "F:744803")) "*/") "\n          gpos = 0;\n          " (span (|@| (class "keyword") (id "F:744822")) "if") " (glyph > row_start_glyph)\n            {\n              tmp_glyph = glyph - 1;\n              " (span (|@| (class "keyword") (id "F:744895")) "while") " (tmp_glyph >= row_start_glyph\n                     && tmp_glyph->charpos >= XINT (b)\n                     && EQ (tmp_glyph->object, glyph->object))\n                {\n                  tmp_glyph--;\n                  gpos++;\n                }\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:745069")) "/* ") (span (|@| (class "comment") (id "F:745072")) "Calculate the lenght(glyph sequence length: GSEQ_LENGTH) of\n             displayed string holding GLYPH.\n\n             GSEQ_LENGTH is different from SCHARS (STRING).\n             SCHARS (STRING) returns the length of the internal string. ") (span (|@| (class "comment-delimiter") (id "F:745289")) "*/") "\n          " (span (|@| (class "keyword") (id "F:745295")) "for") " (tmp_glyph = glyph, gseq_length = gpos;\n               tmp_glyph->charpos < XINT (e);\n               tmp_glyph++, gseq_length++)\n              {\n                " (span (|@| (class "keyword") (id "F:745425")) "if") " (" (span (|@| (class "negation-char") (id "F:745429")) "!") "EQ (tmp_glyph->object, glyph->object))\n                  " (span (|@| (class "keyword") (id "F:745473")) "break") ";\n              }\n\n          total_pixel_width = 0;\n          " (span (|@| (class "keyword") (id "F:745519")) "for") " (tmp_glyph = glyph - gpos; tmp_glyph != glyph; tmp_glyph++)\n            total_pixel_width += tmp_glyph->pixel_width;\n\n          " (span (|@| (class "comment-delimiter") (id "F:745637")) "/* ") (span (|@| (class "comment") (id "F:745640")) "Pre calculation of re-rendering position ") (span (|@| (class "comment-delimiter") (id "F:745681")) "*/") "\n          vpos = (x - gpos);\n          hpos = (area == ON_MODE_LINE\n                  ? (w->current_matrix)->nrows - 1\n                  : 0);\n\n          " (span (|@| (class "comment-delimiter") (id "F:745789")) "/* ") (span (|@| (class "comment") (id "F:745792")) "If the re-rendering position is included in the last\n             re-rendering area, we should do nothing. ") (span (|@| (class "comment-delimiter") (id "F:745892")) "*/") "\n          " (span (|@| (class "keyword") (id "F:745898")) "if") " ( EQ (window, dpyinfo->mouse_face_window)\n               && dpyinfo->mouse_face_beg_col <= vpos\n               && vpos < dpyinfo->mouse_face_end_col\n               && dpyinfo->mouse_face_beg_row == hpos )\n            " (span (|@| (class "keyword") (id "F:746090")) "return") ";\n\n          " (span (|@| (class "keyword") (id "F:746102")) "if") " (clear_mouse_face (dpyinfo))\n            cursor = No_Cursor;\n\n          dpyinfo->mouse_face_beg_col = vpos;\n          dpyinfo->mouse_face_beg_row = hpos;\n\n          dpyinfo->mouse_face_beg_x   = original_x_pixel - (total_pixel_width + dx);\n          dpyinfo->mouse_face_beg_y   = 0;\n\n          dpyinfo->mouse_face_end_col = vpos + gseq_length;\n          dpyinfo->mouse_face_end_row = dpyinfo->mouse_face_beg_row;\n\n          dpyinfo->mouse_face_end_x   = 0;\n          dpyinfo->mouse_face_end_y   = 0;\n\n          dpyinfo->mouse_face_past_end = 0;\n          dpyinfo->mouse_face_window  = window;\n\n          dpyinfo->mouse_face_face_id = face_at_string_position (w, string,\n                                                                 charpos,\n                                                                 0, 0, 0, &ignore,\n                                                                 glyph->face_id, 1);\n          show_mouse_face (dpyinfo, DRAW_MOUSE_FACE);\n\n          " (span (|@| (class "keyword") (id "F:746816")) "if") " (NILP (pointer))\n            pointer = Qhand;\n        }\n      " (span (|@| (class "keyword") (id "F:746867")) "else") " " (span (|@| (class "keyword") (id "F:746872")) "if") " ((area == ON_MODE_LINE) || (area == ON_HEADER_LINE))\n        clear_mouse_face (dpyinfo);\n    }\n  define_frame_cursor1 (f, cursor, pointer);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:747012")) "/* ") (span (|@| (class "comment") (id "F:747015")) "EXPORT:\n   Take proper action when the mouse has moved to position X, Y on\n   frame F as regards highlighting characters that have mouse-face\n   properties.  Also de-highlighting chars where the mouse was before.\n   X and Y can be negative or out of range.  ") (span (|@| (class "comment-delimiter") (id "F:747273")) "*/") "\n\n" (span (|@| (class "type") (id "F:747277")) "void") "\n" (span (|@| (class "function-name") (id "F:747282")) "note_mouse_highlight") " (f, x, y)\n     " (span (|@| (class "keyword") (id "F:747318")) "struct") " " (span (|@| (class "type") (id "F:747325")) "frame") " *" (span (|@| (class "variable-name") (id "F:747332")) "f") ";\n     " (span (|@| (class "type") (id "F:747340")) "int") " " (span (|@| (class "variable-name") (id "F:747344")) "x") ", " (span (|@| (class "variable-name") (id "F:747347")) "y") ";\n{\n  " (span (|@| (class "type") (id "F:747354")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:747368")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n  " (span (|@| (class "keyword") (id "F:747406")) "enum") " " (span (|@| (class "type") (id "F:747411")) "window_part") " " (span (|@| (class "variable-name") (id "F:747423")) "part") ";\n  " (span (|@| (class "type") (id "F:747431")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:747443")) "window") ";\n  " (span (|@| (class "keyword") (id "F:747453")) "struct") " " (span (|@| (class "type") (id "F:747460")) "window") " *" (span (|@| (class "variable-name") (id "F:747468")) "w") ";\n  " (span (|@| (class "type") (id "F:747473")) "Cursor") " " (span (|@| (class "variable-name") (id "F:747480")) "cursor") " = No_Cursor;\n  " (span (|@| (class "type") (id "F:747502")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:747514")) "pointer") " = Qnil;  " (span (|@| (class "comment-delimiter") (id "F:747531")) "/* ") (span (|@| (class "comment") (id "F:747534")) "Takes precedence over cursor!  ") (span (|@| (class "comment-delimiter") (id "F:747565")) "*/") "\n  " (span (|@| (class "keyword") (id "F:747570")) "struct") " " (span (|@| (class "type") (id "F:747577")) "buffer") " *" (span (|@| (class "variable-name") (id "F:747585")) "b") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:747591")) "/* ") (span (|@| (class "comment") (id "F:747594")) "When a menu is active, don't highlight because this looks odd.  ") (span (|@| (class "comment-delimiter") (id "F:747658")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:747661")) "#if") " " (span (|@| (class "preprocessor") (id "F:747665")) "defined") " (USE_X_TOOLKIT) || " (span (|@| (class "preprocessor") (id "F:747692")) "defined") " (USE_GTK) || " (span (|@| (class "preprocessor") (id "F:747713")) "defined") " (HAVE_NS)\n  " (span (|@| (class "keyword") (id "F:747733")) "if") " (popup_activated ())\n    " (span (|@| (class "keyword") (id "F:747761")) "return") ";\n" (span (|@| (class "preprocessor") (id "F:747769")) "#endif") "\n\n  " (span (|@| (class "keyword") (id "F:747779")) "if") " (NILP (Vmouse_highlight)\n      || " (span (|@| (class "negation-char") (id "F:747816")) "!") "f->glyphs_initialized_p\n      || f->pointer_invisible)\n    " (span (|@| (class "keyword") (id "F:747876")) "return") ";\n\n  dpyinfo->mouse_face_mouse_x = x;\n  dpyinfo->mouse_face_mouse_y = y;\n  dpyinfo->mouse_face_mouse_frame = f;\n\n  " (span (|@| (class "keyword") (id "F:747997")) "if") " (dpyinfo->mouse_face_defer)\n    " (span (|@| (class "keyword") (id "F:748032")) "return") ";\n\n  " (span (|@| (class "keyword") (id "F:748043")) "if") " (gc_in_progress)\n    {\n      dpyinfo->mouse_face_deferred_gc = 1;\n      " (span (|@| (class "keyword") (id "F:748118")) "return") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:748135")) "/* ") (span (|@| (class "comment") (id "F:748138")) "Which window is that in?  ") (span (|@| (class "comment-delimiter") (id "F:748164")) "*/") "\n  window = window_from_coordinates (f, x, y, &part, 0, 0, 1);\n\n  " (span (|@| (class "comment-delimiter") (id "F:748232")) "/* ") (span (|@| (class "comment") (id "F:748235")) "If we were displaying active text in another window, clear that.\n     Also clear if we move out of text area in same window.  ") (span (|@| (class "comment-delimiter") (id "F:748361")) "*/") "\n  " (span (|@| (class "keyword") (id "F:748366")) "if") " (" (span (|@| (class "negation-char") (id "F:748370")) "!") " EQ (window, dpyinfo->mouse_face_window)\n      || (part != ON_TEXT && part != ON_MODE_LINE && part != ON_HEADER_LINE\n          && " (span (|@| (class "negation-char") (id "F:748494")) "!") "NILP (dpyinfo->mouse_face_window)))\n    clear_mouse_face (dpyinfo);\n\n  " (span (|@| (class "comment-delimiter") (id "F:748566")) "/* ") (span (|@| (class "comment") (id "F:748569")) "Not on a window -> return.  ") (span (|@| (class "comment-delimiter") (id "F:748597")) "*/") "\n  " (span (|@| (class "keyword") (id "F:748602")) "if") " (" (span (|@| (class "negation-char") (id "F:748606")) "!") "WINDOWP (window))\n    " (span (|@| (class "keyword") (id "F:748629")) "return") ";\n\n  " (span (|@| (class "comment-delimiter") (id "F:748640")) "/* ") (span (|@| (class "comment") (id "F:748643")) "Reset help_echo_string. It will get recomputed below.  ") (span (|@| (class "comment-delimiter") (id "F:748698")) "*/") "\n  help_echo_string = Qnil;\n\n  " (span (|@| (class "comment-delimiter") (id "F:748731")) "/* ") (span (|@| (class "comment") (id "F:748734")) "Convert to window-relative pixel coordinates.  ") (span (|@| (class "comment-delimiter") (id "F:748781")) "*/") "\n  w = XWINDOW (window);\n  frame_to_window_pixel_xy (w, &x, &y);\n\n  " (span (|@| (class "comment-delimiter") (id "F:748851")) "/* ") (span (|@| (class "comment") (id "F:748854")) "Handle tool-bar window differently since it doesn't display a\n     buffer.  ") (span (|@| (class "comment-delimiter") (id "F:748930")) "*/") "\n  " (span (|@| (class "keyword") (id "F:748935")) "if") " (EQ (window, f->tool_bar_window))\n    {\n      note_tool_bar_highlight (f, x, y);\n      " (span (|@| (class "keyword") (id "F:749025")) "return") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:749042")) "/* ") (span (|@| (class "comment") (id "F:749045")) "Mouse is on the mode, header line or margin?  ") (span (|@| (class "comment-delimiter") (id "F:749091")) "*/") "\n  " (span (|@| (class "keyword") (id "F:749096")) "if") " (part == ON_MODE_LINE || part == ON_HEADER_LINE\n      || part == ON_LEFT_MARGIN || part == ON_RIGHT_MARGIN)\n    {\n      note_mode_line_or_margin_highlight (window, x, y, part);\n      " (span (|@| (class "keyword") (id "F:749282")) "return") ";\n    }\n\n  " (span (|@| (class "keyword") (id "F:749299")) "if") " (part == ON_VERTICAL_BORDER)\n    {\n      cursor = FRAME_X_OUTPUT (f)->horizontal_drag_cursor;\n      help_echo_string = build_string (" (span (|@| (class "string") (id "F:749435")) "\"drag-mouse-1: resize\"") ");\n    }\n  " (span (|@| (class "keyword") (id "F:749468")) "else") " " (span (|@| (class "keyword") (id "F:749473")) "if") " (part == ON_LEFT_FRINGE || part == ON_RIGHT_FRINGE\n           || part == ON_SCROLL_BAR)\n    cursor = FRAME_X_OUTPUT (f)->nontext_cursor;\n  " (span (|@| (class "keyword") (id "F:749608")) "else") "\n    cursor = FRAME_X_OUTPUT (f)->text_cursor;\n\n  " (span (|@| (class "comment-delimiter") (id "F:749662")) "/* ") (span (|@| (class "comment") (id "F:749665")) "Are we in a window whose display is up to date?\n     And verify the buffer's text has not changed.  ") (span (|@| (class "comment-delimiter") (id "F:749765")) "*/") "\n  b = XBUFFER (w->buffer);\n  " (span (|@| (class "keyword") (id "F:749797")) "if") " (part == ON_TEXT\n      && EQ (w->window_end_valid, w->buffer)\n      && XFASTINT (w->last_modified) == BUF_MODIFF (b)\n      && XFASTINT (w->last_overlay_modified) == BUF_OVERLAY_MODIFF (b))\n    {\n      " (span (|@| (class "type") (id "F:750001")) "int") " " (span (|@| (class "variable-name") (id "F:750005")) "hpos") ", " (span (|@| (class "variable-name") (id "F:750011")) "vpos") ", " (span (|@| (class "variable-name") (id "F:750017")) "i") ", " (span (|@| (class "variable-name") (id "F:750020")) "dx") ", " (span (|@| (class "variable-name") (id "F:750024")) "dy") ", " (span (|@| (class "variable-name") (id "F:750028")) "area") ";\n      " (span (|@| (class "type") (id "F:750040")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:750050")) "pos") ";\n      " (span (|@| (class "keyword") (id "F:750061")) "struct") " " (span (|@| (class "type") (id "F:750068")) "glyph") " *" (span (|@| (class "variable-name") (id "F:750075")) "glyph") ";\n      " (span (|@| (class "type") (id "F:750088")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:750100")) "object") ";\n      " (span (|@| (class "type") (id "F:750114")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:750126")) "mouse_face") " = Qnil, " (span (|@| (class "variable-name") (id "F:750145")) "overlay") " = Qnil, " (span (|@| (class "variable-name") (id "F:750161")) "position") ";\n      " (span (|@| (class "type") (id "F:750177")) "Lisp_Object") " *" (span (|@| (class "variable-name") (id "F:750190")) "overlay_vec") " = " (span (|@| (class "constant") (id "F:750204")) "NULL") ";\n      " (span (|@| (class "type") (id "F:750216")) "int") " " (span (|@| (class "variable-name") (id "F:750220")) "noverlays") ";\n      " (span (|@| (class "keyword") (id "F:750237")) "struct") " " (span (|@| (class "type") (id "F:750244")) "buffer") " *" (span (|@| (class "variable-name") (id "F:750252")) "obuf") ";\n      " (span (|@| (class "type") (id "F:750264")) "int") " " (span (|@| (class "variable-name") (id "F:750268")) "obegv") ", " (span (|@| (class "variable-name") (id "F:750275")) "ozv") ", " (span (|@| (class "variable-name") (id "F:750280")) "same_region") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:750300")) "/* ") (span (|@| (class "comment") (id "F:750303")) "Find the glyph under X/Y.  ") (span (|@| (class "comment-delimiter") (id "F:750330")) "*/") "\n      glyph = x_y_to_hpos_vpos (w, x, y, &hpos, &vpos, &dx, &dy, &area);\n\n      " (span (|@| (class "comment-delimiter") (id "F:750413")) "/* ") (span (|@| (class "comment") (id "F:750416")) "Look for :pointer property on image.  ") (span (|@| (class "comment-delimiter") (id "F:750454")) "*/") "\n      " (span (|@| (class "keyword") (id "F:750463")) "if") " (glyph != " (span (|@| (class "constant") (id "F:750476")) "NULL") " && glyph->type == IMAGE_GLYPH)\n        {\n          " (span (|@| (class "keyword") (id "F:750518")) "struct") " " (span (|@| (class "type") (id "F:750525")) "image") " *" (span (|@| (class "variable-name") (id "F:750532")) "img") " = IMAGE_FROM_ID (f, glyph->u.img_id);\n          " (span (|@| (class "keyword") (id "F:750577")) "if") " (img != " (span (|@| (class "constant") (id "F:750588")) "NULL") " && IMAGEP (img->spec))\n            {\n              " (span (|@| (class "type") (id "F:750630")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:750642")) "image_map") ", " (span (|@| (class "variable-name") (id "F:750653")) "hotspot") ";\n              " (span (|@| (class "keyword") (id "F:750669")) "if") " ((image_map = Fplist_get (XCDR (img->spec), QCmap),\n                   " (span (|@| (class "negation-char") (id "F:750729")) "!") "NILP (image_map))\n                  && (hotspot = find_hot_spot (image_map,\n                                               glyph->slice.x + dx,\n                                               glyph->slice.y + dy),\n                      CONSP (hotspot))\n                  && (hotspot = XCDR (hotspot), CONSP (hotspot)))\n                {\n                  " (span (|@| (class "type") (id "F:750944")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:750956")) "area_id") ", " (span (|@| (class "variable-name") (id "F:750965")) "plist") ";\n\n                  area_id = XCAR (hotspot);\n                  " (span (|@| (class "comment-delimiter") (id "F:751007")) "/* ") (span (|@| (class "comment") (id "F:751010")) "Could check AREA_ID to see if we enter/leave this hot-spot.\n                     If so, we could look for mouse-enter, mouse-leave\n                     properties in PLIST (and do something...).  ") (span (|@| (class "comment-delimiter") (id "F:751178")) "*/") "\n                  hotspot = XCDR (hotspot);\n                  " (span (|@| (class "keyword") (id "F:751215")) "if") " (CONSP (hotspot)\n                      && (plist = XCAR (hotspot), CONSP (plist)))\n                    {\n                      pointer = Fplist_get (plist, Qpointer);\n                      " (span (|@| (class "keyword") (id "F:751351")) "if") " (NILP (pointer))\n                        pointer = Qhand;\n                      help_echo_string = Fplist_get (plist, Qhelp_echo);\n                      " (span (|@| (class "keyword") (id "F:751458")) "if") " (" (span (|@| (class "negation-char") (id "F:751462")) "!") "NILP (help_echo_string))\n                        {\n                          help_echo_window = window;\n                          help_echo_object = glyph->object;\n                          help_echo_pos = glyph->charpos;\n                        }\n                    }\n                }\n              " (span (|@| (class "keyword") (id "F:751625")) "if") " (NILP (pointer))\n                pointer = Fplist_get (XCDR (img->spec), QCpointer);\n            }\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:751716")) "/* ") (span (|@| (class "comment") (id "F:751719")) "Clear mouse face if X/Y not over text.  ") (span (|@| (class "comment-delimiter") (id "F:751759")) "*/") "\n      " (span (|@| (class "keyword") (id "F:751768")) "if") " (glyph == " (span (|@| (class "constant") (id "F:751781")) "NULL") "\n          || area != TEXT_AREA\n          || " (span (|@| (class "negation-char") (id "F:751816")) "!") "MATRIX_ROW (w->current_matrix, vpos)->displays_text_p)\n        {\n          " (span (|@| (class "keyword") (id "F:751878")) "if") " (clear_mouse_face (dpyinfo))\n            cursor = No_Cursor;\n          " (span (|@| (class "keyword") (id "F:751938")) "if") " (NILP (pointer))\n            {\n              " (span (|@| (class "keyword") (id "F:751972")) "if") " (area != TEXT_AREA)\n                cursor = FRAME_X_OUTPUT (f)->nontext_cursor;\n              " (span (|@| (class "keyword") (id "F:752049")) "else") "\n                pointer = Vvoid_text_area_pointer;\n            }\n          " (span (|@| (class "keyword") (id "F:752101")) "goto") " " (span (|@| (class "constant") (id "F:752106")) "set_cursor") ";\n        }\n\n      pos = glyph->charpos;\n      object = glyph->object;\n      " (span (|@| (class "keyword") (id "F:752186")) "if") " (" (span (|@| (class "negation-char") (id "F:752190")) "!") "STRINGP (object) && " (span (|@| (class "negation-char") (id "F:752211")) "!") "BUFFERP (object))\n        " (span (|@| (class "keyword") (id "F:752231")) "goto") " " (span (|@| (class "constant") (id "F:752236")) "set_cursor") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:752255")) "/* ") (span (|@| (class "comment") (id "F:752258")) "If we get an out-of-range value, return now; avoid an error.  ") (span (|@| (class "comment-delimiter") (id "F:752320")) "*/") "\n      " (span (|@| (class "keyword") (id "F:752329")) "if") " (BUFFERP (object) && pos > BUF_Z (b))\n        " (span (|@| (class "keyword") (id "F:752371")) "goto") " " (span (|@| (class "constant") (id "F:752376")) "set_cursor") ";\n\n      " (span (|@| (class "comment-delimiter") (id "F:752395")) "/* ") (span (|@| (class "comment") (id "F:752398")) "Make the window's buffer temporarily current for\n         overlays_at and compute_char_face.  ") (span (|@| (class "comment-delimiter") (id "F:752485")) "*/") "\n      obuf = current_buffer;\n      current_buffer = b;\n      obegv = BEGV;\n      ozv = ZV;\n      BEGV = BEG;\n      ZV = Z;\n\n      " (span (|@| (class "comment-delimiter") (id "F:752618")) "/* ") (span (|@| (class "comment") (id "F:752621")) "Is this char mouse-active or does it have help-echo?  ") (span (|@| (class "comment-delimiter") (id "F:752675")) "*/") "\n      position = make_number (pos);\n\n      " (span (|@| (class "keyword") (id "F:752721")) "if") " (BUFFERP (object))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:752749")) "/* ") (span (|@| (class "comment") (id "F:752752")) "Put all the overlays we want in a vector in overlay_vec.  ") (span (|@| (class "comment-delimiter") (id "F:752810")) "*/") "\n          GET_OVERLAYS_AT (pos, overlay_vec, noverlays, " (span (|@| (class "constant") (id "F:752862")) "NULL") ", 0);\n          " (span (|@| (class "comment-delimiter") (id "F:752875")) "/* ") (span (|@| (class "comment") (id "F:752878")) "Sort overlays into increasing priority order.  ") (span (|@| (class "comment-delimiter") (id "F:752925")) "*/") "\n          noverlays = sort_overlays (overlay_vec, noverlays, w);\n        }\n      " (span (|@| (class "keyword") (id "F:752995")) "else") "\n        noverlays = 0;\n\n      same_region = (EQ (window, dpyinfo->mouse_face_window)\n                     && vpos >= dpyinfo->mouse_face_beg_row\n                     && vpos <= dpyinfo->mouse_face_end_row\n                     && (vpos > dpyinfo->mouse_face_beg_row\n                         || hpos >= dpyinfo->mouse_face_beg_col)\n                     && (vpos < dpyinfo->mouse_face_end_row\n                         || hpos < dpyinfo->mouse_face_end_col\n                         || dpyinfo->mouse_face_past_end));\n\n      " (span (|@| (class "keyword") (id "F:753394")) "if") " (same_region)\n        cursor = No_Cursor;\n\n      " (span (|@| (class "comment-delimiter") (id "F:753439")) "/* ") (span (|@| (class "comment") (id "F:753442")) "Check mouse-face highlighting.  ") (span (|@| (class "comment-delimiter") (id "F:753474")) "*/") "\n      " (span (|@| (class "keyword") (id "F:753483")) "if") " (" (span (|@| (class "negation-char") (id "F:753487")) "!") " same_region\n          " (span (|@| (class "comment-delimiter") (id "F:753504")) "/* ") (span (|@| (class "comment") (id "F:753507")) "If there exists an overlay with mouse-face overlapping\n             the one we are currently highlighting, we have to\n             check if we enter the overlapping overlay, and then\n             highlight only that.  ") (span (|@| (class "comment-delimiter") (id "F:753704")) "*/") "\n          || (OVERLAYP (dpyinfo->mouse_face_overlay)\n              && mouse_face_overlay_overlaps (dpyinfo->mouse_face_overlay)))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:753829")) "/* ") (span (|@| (class "comment") (id "F:753832")) "Find the highest priority overlay with a mouse-face.  ") (span (|@| (class "comment-delimiter") (id "F:753886")) "*/") "\n          overlay = Qnil;\n          " (span (|@| (class "keyword") (id "F:753911")) "for") " (i = noverlays - 1; i >= 0 && NILP (overlay); --i)\n            {\n              mouse_face = Foverlay_get (overlay_vec[i], Qmouse_face);\n              " (span (|@| (class "keyword") (id "F:754044")) "if") " (" (span (|@| (class "negation-char") (id "F:754048")) "!") "NILP (mouse_face))\n                overlay = overlay_vec[i];\n            }\n\n          " (span (|@| (class "comment-delimiter") (id "F:754107")) "/* ") (span (|@| (class "comment") (id "F:754110")) "If we're highlighting the same overlay as before, there's\n             no need to do that again.  ") (span (|@| (class "comment-delimiter") (id "F:754201")) "*/") "\n          " (span (|@| (class "keyword") (id "F:754207")) "if") " (" (span (|@| (class "negation-char") (id "F:754211")) "!") "NILP (overlay) && EQ (overlay, dpyinfo->mouse_face_overlay))\n            " (span (|@| (class "keyword") (id "F:754278")) "goto") " " (span (|@| (class "constant") (id "F:754283")) "check_help_echo") ";\n          dpyinfo->mouse_face_overlay = overlay;\n\n          " (span (|@| (class "comment-delimiter") (id "F:754346")) "/* ") (span (|@| (class "comment") (id "F:754349")) "Clear the display of the old active region, if any.  ") (span (|@| (class "comment-delimiter") (id "F:754402")) "*/") "\n          " (span (|@| (class "keyword") (id "F:754408")) "if") " (clear_mouse_face (dpyinfo))\n            cursor = No_Cursor;\n\n          " (span (|@| (class "comment-delimiter") (id "F:754469")) "/* ") (span (|@| (class "comment") (id "F:754472")) "If no overlay applies, get a text property.  ") (span (|@| (class "comment-delimiter") (id "F:754517")) "*/") "\n          " (span (|@| (class "keyword") (id "F:754523")) "if") " (NILP (overlay))\n            mouse_face = Fget_text_property (position, Qmouse_face, object);\n\n          " (span (|@| (class "comment-delimiter") (id "F:754617")) "/* ") (span (|@| (class "comment") (id "F:754620")) "Next, compute the bounds of the mouse highlighting and\n             display it.  ") (span (|@| (class "comment-delimiter") (id "F:754694")) "*/") "\n          " (span (|@| (class "keyword") (id "F:754700")) "if") " (" (span (|@| (class "negation-char") (id "F:754704")) "!") "NILP (mouse_face) && STRINGP (object))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:754758")) "/* ") (span (|@| (class "comment") (id "F:754761")) "The mouse-highlighting comes from a display string\n                 with a mouse-face.  ") (span (|@| (class "comment-delimiter") (id "F:754835")) "*/") "\n              " (span (|@| (class "type") (id "F:754845")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:754857")) "b") ", " (span (|@| (class "variable-name") (id "F:754860")) "e") ";\n              " (span (|@| (class "type") (id "F:754870")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:754880")) "ignore") ";\n\n              b = Fprevious_single_property_change\n                (make_number (pos + 1), Qmouse_face, object, Qnil);\n              e = Fnext_single_property_change\n                (position, Qmouse_face, object, Qnil);\n              " (span (|@| (class "keyword") (id "F:755075")) "if") " (NILP (b))\n                b = make_number (0);\n              " (span (|@| (class "keyword") (id "F:755119")) "if") " (NILP (e))\n                e = make_number (SCHARS (object) - 1);\n\n              fast_find_string_pos (w, XINT (b), object,\n                                    &dpyinfo->mouse_face_beg_col,\n                                    &dpyinfo->mouse_face_beg_row,\n                                    &dpyinfo->mouse_face_beg_x,\n                                    &dpyinfo->mouse_face_beg_y, 0);\n              fast_find_string_pos (w, XINT (e), object,\n                                    &dpyinfo->mouse_face_end_col,\n                                    &dpyinfo->mouse_face_end_row,\n                                    &dpyinfo->mouse_face_end_x,\n                                    &dpyinfo->mouse_face_end_y, 1);\n              dpyinfo->mouse_face_past_end = 0;\n              dpyinfo->mouse_face_window = window;\n              dpyinfo->mouse_face_face_id\n                = face_at_string_position (w, object, pos, 0, 0, 0, &ignore,\n                                           glyph->face_id, 1);\n              show_mouse_face (dpyinfo, DRAW_MOUSE_FACE);\n              cursor = No_Cursor;\n            }\n          " (span (|@| (class "keyword") (id "F:755878")) "else") "\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:755897")) "/* ") (span (|@| (class "comment") (id "F:755900")) "The mouse-highlighting, if any, comes from an overlay\n                 or text property in the buffer.  ") (span (|@| (class "comment-delimiter") (id "F:755990")) "*/") "\n              " (span (|@| (class "type") (id "F:756000")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:756012")) "buffer") ", " (span (|@| (class "variable-name") (id "F:756020")) "display_string") ";\n\n              " (span (|@| (class "keyword") (id "F:756044")) "if") " (STRINGP (object))\n                {\n                  " (span (|@| (class "comment-delimiter") (id "F:756074")) "/* ") (span (|@| (class "comment") (id "F:756077")) "If we are on a display string with no mouse-face,\n                     check if the text under it has one.  ") (span (|@| (class "comment-delimiter") (id "F:756171")) "*/") "\n                  " (span (|@| (class "keyword") (id "F:756178")) "struct") " " (span (|@| (class "type") (id "F:756185")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:756196")) "r") " = MATRIX_ROW (w->current_matrix, vpos);\n                  " (span (|@| (class "type") (id "F:756242")) "int") " " (span (|@| (class "variable-name") (id "F:756246")) "start") " = MATRIX_ROW_START_CHARPOS (r);\n                  pos = string_buffer_position (w, object, start);\n                  " (span (|@| (class "keyword") (id "F:756341")) "if") " (pos > 0)\n                    {\n                      mouse_face = get_char_property_and_overlay\n                        (make_number (pos), Qmouse_face, w->buffer, &overlay);\n                      buffer = w->buffer;\n                      display_string = object;\n                    }\n                }\n              " (span (|@| (class "keyword") (id "F:756551")) "else") "\n                {\n                  buffer = object;\n                  display_string = Qnil;\n                }\n\n              " (span (|@| (class "keyword") (id "F:756620")) "if") " (" (span (|@| (class "negation-char") (id "F:756624")) "!") "NILP (mouse_face))\n                {\n                  " (span (|@| (class "type") (id "F:756652")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:756664")) "before") ", " (span (|@| (class "variable-name") (id "F:756672")) "after") ";\n                  " (span (|@| (class "type") (id "F:756683")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:756695")) "before_string") ", " (span (|@| (class "variable-name") (id "F:756710")) "after_string") ";\n\n                  " (span (|@| (class "keyword") (id "F:756729")) "if") " (NILP (overlay))\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:756765")) "/* ") (span (|@| (class "comment") (id "F:756768")) "Handle the text property case.  ") (span (|@| (class "comment-delimiter") (id "F:756800")) "*/") "\n                      before = Fprevious_single_property_change\n                        (make_number (pos + 1), Qmouse_face, buffer,\n                         Fmarker_position (w->start));\n                      after = Fnext_single_property_change\n                        (make_number (pos), Qmouse_face, buffer,\n                         make_number (BUF_Z (XBUFFER (buffer))\n                                      - XFASTINT (w->window_end_pos)));\n                      before_string = after_string = Qnil;\n                    }\n                  " (span (|@| (class "keyword") (id "F:757167")) "else") "\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:757188")) "/* ") (span (|@| (class "comment") (id "F:757191")) "Handle the overlay case.  ") (span (|@| (class "comment-delimiter") (id "F:757217")) "*/") "\n                      before = Foverlay_start (overlay);\n                      after = Foverlay_end (overlay);\n                      before_string = Foverlay_get (overlay, Qbefore_string);\n                      after_string = Foverlay_get (overlay, Qafter_string);\n\n                      " (span (|@| (class "keyword") (id "F:757438")) "if") " (" (span (|@| (class "negation-char") (id "F:757442")) "!") "STRINGP (before_string)) before_string = Qnil;\n                      " (span (|@| (class "keyword") (id "F:757498")) "if") " (" (span (|@| (class "negation-char") (id "F:757502")) "!") "STRINGP (after_string))  after_string = Qnil;\n                    }\n\n                  mouse_face_from_buffer_pos (window, dpyinfo, pos,\n                                              XFASTINT (before),\n                                              XFASTINT (after),\n                                              before_string, after_string,\n                                              display_string);\n                  cursor = No_Cursor;\n                }\n            }\n        }\n\n    " (span (|@| (class "constant") (id "F:757782")) "check_help_echo") ":\n\n      " (span (|@| (class "comment-delimiter") (id "F:757806")) "/* ") (span (|@| (class "comment") (id "F:757809")) "Look for a `help-echo' property.  ") (span (|@| (class "comment-delimiter") (id "F:757843")) "*/") "\n      " (span (|@| (class "keyword") (id "F:757852")) "if") " (NILP (help_echo_string)) {\n        " (span (|@| (class "type") (id "F:757884")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:757896")) "help") ", " (span (|@| (class "variable-name") (id "F:757902")) "overlay") ";\n\n        " (span (|@| (class "comment-delimiter") (id "F:757913")) "/* ") (span (|@| (class "comment") (id "F:757916")) "Check overlays first.  ") (span (|@| (class "comment-delimiter") (id "F:757939")) "*/") "\n        help = overlay = Qnil;\n        " (span (|@| (class "keyword") (id "F:757967")) "for") " (i = noverlays - 1; i >= 0 && NILP (help); --i)\n          {\n            overlay = overlay_vec[i];\n            help = Foverlay_get (overlay, Qhelp_echo);\n          }\n\n        " (span (|@| (class "keyword") (id "F:758110")) "if") " (" (span (|@| (class "negation-char") (id "F:758114")) "!") "NILP (help))\n          {\n            help_echo_string = help;\n            help_echo_window = window;\n            help_echo_object = overlay;\n            help_echo_pos = pos;\n          }\n        " (span (|@| (class "keyword") (id "F:758260")) "else") "\n          {\n            " (span (|@| (class "type") (id "F:758275")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:758287")) "object") " = glyph->object;\n            " (span (|@| (class "type") (id "F:758316")) "int") " " (span (|@| (class "variable-name") (id "F:758320")) "charpos") " = glyph->charpos;\n\n            " (span (|@| (class "comment-delimiter") (id "F:758352")) "/* ") (span (|@| (class "comment") (id "F:758355")) "Try text properties.  ") (span (|@| (class "comment-delimiter") (id "F:758377")) "*/") "\n            " (span (|@| (class "keyword") (id "F:758385")) "if") " (STRINGP (object)\n                && charpos >= 0\n                && charpos < SCHARS (object))\n              {\n                help = Fget_text_property (make_number (charpos),\n                                           Qhelp_echo, object);\n                " (span (|@| (class "keyword") (id "F:758548")) "if") " (NILP (help))\n                  {\n                    " (span (|@| (class "comment-delimiter") (id "F:758577")) "/* ") (span (|@| (class "comment") (id "F:758580")) "If the string itself doesn't specify a help-echo,\n                       see if the buffer text ``under'' it does.  ") (span (|@| (class "comment-delimiter") (id "F:758682")) "*/") "\n                    " (span (|@| (class "keyword") (id "F:758691")) "struct") " " (span (|@| (class "type") (id "F:758698")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:758709")) "r") "\n                      = MATRIX_ROW (w->current_matrix, vpos);\n                    " (span (|@| (class "type") (id "F:758765")) "int") " " (span (|@| (class "variable-name") (id "F:758769")) "start") " = MATRIX_ROW_START_CHARPOS (r);\n                    " (span (|@| (class "type") (id "F:758813")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:758823")) "pos") " = string_buffer_position (w, object, start);\n                    " (span (|@| (class "keyword") (id "F:758878")) "if") " (pos > 0)\n                      {\n                        help = Fget_char_property (make_number (pos),\n                                                   Qhelp_echo, w->buffer);\n                        " (span (|@| (class "keyword") (id "F:758986")) "if") " (" (span (|@| (class "negation-char") (id "F:758990")) "!") "NILP (help))\n                          {\n                            charpos = pos;\n                            object = w->buffer;\n                          }\n                      }\n                  }\n              }\n            " (span (|@| (class "keyword") (id "F:759097")) "else") " " (span (|@| (class "keyword") (id "F:759102")) "if") " (BUFFERP (object)\n                     && charpos >= BEGV\n                     && charpos < ZV)\n              help = Fget_text_property (make_number (charpos), Qhelp_echo,\n                                         object);\n\n            " (span (|@| (class "keyword") (id "F:759263")) "if") " (" (span (|@| (class "negation-char") (id "F:759267")) "!") "NILP (help))\n              {\n                help_echo_string = help;\n                help_echo_window = window;\n                help_echo_object = object;\n                help_echo_pos = charpos;\n              }\n          }\n      }\n\n      " (span (|@| (class "comment-delimiter") (id "F:759431")) "/* ") (span (|@| (class "comment") (id "F:759434")) "Look for a `pointer' property.  ") (span (|@| (class "comment-delimiter") (id "F:759466")) "*/") "\n      " (span (|@| (class "keyword") (id "F:759475")) "if") " (NILP (pointer))\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:759501")) "/* ") (span (|@| (class "comment") (id "F:759504")) "Check overlays first.  ") (span (|@| (class "comment-delimiter") (id "F:759527")) "*/") "\n          " (span (|@| (class "keyword") (id "F:759533")) "for") " (i = noverlays - 1; i >= 0 && NILP (pointer); --i)\n            pointer = Foverlay_get (overlay_vec[i], Qpointer);\n\n          " (span (|@| (class "keyword") (id "F:759648")) "if") " (NILP (pointer))\n            {\n              " (span (|@| (class "type") (id "F:759682")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:759694")) "object") " = glyph->object;\n              " (span (|@| (class "type") (id "F:759725")) "int") " " (span (|@| (class "variable-name") (id "F:759729")) "charpos") " = glyph->charpos;\n\n              " (span (|@| (class "comment-delimiter") (id "F:759763")) "/* ") (span (|@| (class "comment") (id "F:759766")) "Try text properties.  ") (span (|@| (class "comment-delimiter") (id "F:759788")) "*/") "\n              " (span (|@| (class "keyword") (id "F:759798")) "if") " (STRINGP (object)\n                  && charpos >= 0\n                  && charpos < SCHARS (object))\n                {\n                  pointer = Fget_text_property (make_number (charpos),\n                                                Qpointer, object);\n                  " (span (|@| (class "keyword") (id "F:759963")) "if") " (NILP (pointer))\n                    {\n                      " (span (|@| (class "comment-delimiter") (id "F:759999")) "/* ") (span (|@| (class "comment") (id "F:760002")) "If the string itself doesn't specify a pointer,\n                         see if the buffer text ``under'' it does.  ") (span (|@| (class "comment-delimiter") (id "F:760097")) "*/") "\n                      " (span (|@| (class "keyword") (id "F:760108")) "struct") " " (span (|@| (class "type") (id "F:760115")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:760126")) "r") "\n                        = MATRIX_ROW (w->current_matrix, vpos);\n                      " (span (|@| (class "type") (id "F:760179")) "int") " " (span (|@| (class "variable-name") (id "F:760183")) "start") " = MATRIX_ROW_START_CHARPOS (r);\n                      " (span (|@| (class "type") (id "F:760229")) "EMACS_INT") " " (span (|@| (class "variable-name") (id "F:760239")) "pos") " = string_buffer_position (w, object,\n                                                              start);\n                      " (span (|@| (class "keyword") (id "F:760309")) "if") " (pos > 0)\n                        pointer = Fget_char_property (make_number (pos),\n                                                      Qpointer, w->buffer);\n                    }\n                }\n              " (span (|@| (class "keyword") (id "F:760427")) "else") " " (span (|@| (class "keyword") (id "F:760432")) "if") " (BUFFERP (object)\n                       && charpos >= BEGV\n                       && charpos < ZV)\n                pointer = Fget_text_property (make_number (charpos),\n                                              Qpointer, object);\n            }\n        }\n\n      BEGV = obegv;\n      ZV = ozv;\n      current_buffer = obuf;\n    }\n\n " (span (|@| (class "constant") (id "F:760676")) "set_cursor") ":\n\n  define_frame_cursor1 (f, cursor, pointer);\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:760738")) "/* ") (span (|@| (class "comment") (id "F:760741")) "EXPORT for RIF:\n   Clear any mouse-face on window W.  This function is part of the\n   redisplay interface, and is called from try_window_id and similar\n   functions to ensure the mouse-highlight is off.  ") (span (|@| (class "comment-delimiter") (id "F:760945")) "*/") "\n\n" (span (|@| (class "type") (id "F:760949")) "void") "\n" (span (|@| (class "function-name") (id "F:760954")) "x_clear_window_mouse_face") " (w)\n     " (span (|@| (class "keyword") (id "F:760989")) "struct") " " (span (|@| (class "type") (id "F:760996")) "window") " *" (span (|@| (class "variable-name") (id "F:761004")) "w") ";\n{\n  " (span (|@| (class "type") (id "F:761011")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:761025")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (XFRAME (w->frame));\n  " (span (|@| (class "type") (id "F:761079")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:761091")) "window") ";\n\n  BLOCK_INPUT;\n  XSETWINDOW (window, w);\n  " (span (|@| (class "keyword") (id "F:761143")) "if") " (EQ (window, dpyinfo->mouse_face_window))\n    clear_mouse_face (dpyinfo);\n  UNBLOCK_INPUT;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:761241")) "/* ") (span (|@| (class "comment") (id "F:761244")) "EXPORT:\n   Just discard the mouse face information for frame F, if any.\n   This is used when the size of F is changed.  ") (span (|@| (class "comment-delimiter") (id "F:761364")) "*/") "\n\n" (span (|@| (class "type") (id "F:761368")) "void") "\n" (span (|@| (class "function-name") (id "F:761373")) "cancel_mouse_face") " (f)\n     " (span (|@| (class "keyword") (id "F:761400")) "struct") " " (span (|@| (class "type") (id "F:761407")) "frame") " *" (span (|@| (class "variable-name") (id "F:761414")) "f") ";\n{\n  " (span (|@| (class "type") (id "F:761421")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:761433")) "window") ";\n  " (span (|@| (class "type") (id "F:761443")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:761457")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n\n  window = dpyinfo->mouse_face_window;\n  " (span (|@| (class "keyword") (id "F:761535")) "if") " (" (span (|@| (class "negation-char") (id "F:761539")) "!") " NILP (window) && XFRAME (XWINDOW (window)->frame) == f)\n    {\n      dpyinfo->mouse_face_beg_row = dpyinfo->mouse_face_beg_col = -1;\n      dpyinfo->mouse_face_end_row = dpyinfo->mouse_face_end_col = -1;\n      dpyinfo->mouse_face_window = Qnil;\n    }\n}\n\n\n" (span (|@| (class "preprocessor") (id "F:761794")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:761801")) "/* ") (span (|@| (class "comment") (id "F:761804")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:761823")) "*/") "\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:761829")) "/***********************************************************************") (span (|@| (class "comment") (id "F:761901")) "\n                           Exposure Events\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:761995")) "*/") "\n\n" (span (|@| (class "preprocessor") (id "F:761999")) "#ifdef") " HAVE_WINDOW_SYSTEM\n\n" (span (|@| (class "comment-delimiter") (id "F:762026")) "/* ") (span (|@| (class "comment") (id "F:762029")) "Redraw the part of glyph row area AREA of glyph row ROW on window W\n   which intersects rectangle R.  R is in window-relative coordinates.  ") (span (|@| (class "comment-delimiter") (id "F:762169")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:762173")) "static") " " (span (|@| (class "type") (id "F:762180")) "void") "\n" (span (|@| (class "function-name") (id "F:762185")) "expose_area") " (w, row, r, area)\n     " (span (|@| (class "keyword") (id "F:762220")) "struct") " " (span (|@| (class "type") (id "F:762227")) "window") " *" (span (|@| (class "variable-name") (id "F:762235")) "w") ";\n     " (span (|@| (class "keyword") (id "F:762243")) "struct") " " (span (|@| (class "type") (id "F:762250")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:762261")) "row") ";\n     " (span (|@| (class "type") (id "F:762271")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:762283")) "r") ";\n     " (span (|@| (class "keyword") (id "F:762291")) "enum") " " (span (|@| (class "type") (id "F:762296")) "glyph_row_area") " " (span (|@| (class "variable-name") (id "F:762311")) "area") ";\n{\n  " (span (|@| (class "keyword") (id "F:762321")) "struct") " " (span (|@| (class "type") (id "F:762328")) "glyph") " *" (span (|@| (class "variable-name") (id "F:762335")) "first") " = row->glyphs[area];\n  " (span (|@| (class "keyword") (id "F:762364")) "struct") " " (span (|@| (class "type") (id "F:762371")) "glyph") " *" (span (|@| (class "variable-name") (id "F:762378")) "end") " = row->glyphs[area] + row->used[area];\n  " (span (|@| (class "keyword") (id "F:762423")) "struct") " " (span (|@| (class "type") (id "F:762430")) "glyph") " *" (span (|@| (class "variable-name") (id "F:762437")) "last") ";\n  " (span (|@| (class "type") (id "F:762445")) "int") " " (span (|@| (class "variable-name") (id "F:762449")) "first_x") ", " (span (|@| (class "variable-name") (id "F:762458")) "start_x") ", " (span (|@| (class "variable-name") (id "F:762467")) "x") ";\n\n  " (span (|@| (class "keyword") (id "F:762473")) "if") " (area == TEXT_AREA && row->fill_line_p)\n    " (span (|@| (class "comment-delimiter") (id "F:762520")) "/* ") (span (|@| (class "comment") (id "F:762523")) "If row extends face to end of line write the whole line.  ") (span (|@| (class "comment-delimiter") (id "F:762581")) "*/") "\n    draw_glyphs (w, 0, row, area,\n                 0, row->used[area],\n                 DRAW_NORMAL_TEXT, 0);\n  " (span (|@| (class "keyword") (id "F:762668")) "else") "\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:762685")) "/* ") (span (|@| (class "comment") (id "F:762688")) "Set START_X to the window-relative start position for drawing glyphs of\n         AREA.  The first glyph of the text area can be partially visible.\n         The first glyphs of other areas cannot.  ") (span (|@| (class "comment-delimiter") (id "F:762871")) "*/") "\n      start_x = window_box_left_offset (w, area);\n      x = start_x;\n      " (span (|@| (class "keyword") (id "F:762949")) "if") " (area == TEXT_AREA)\n        x += row->x;\n\n      " (span (|@| (class "comment-delimiter") (id "F:762993")) "/* ") (span (|@| (class "comment") (id "F:762996")) "Find the first glyph that must be redrawn.  ") (span (|@| (class "comment-delimiter") (id "F:763040")) "*/") "\n      " (span (|@| (class "keyword") (id "F:763049")) "while") " (first < end\n             && x + first->pixel_width < r->x)\n        {\n          x += first->pixel_width;\n          ++first;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:763161")) "/* ") (span (|@| (class "comment") (id "F:763164")) "Find the last one.  ") (span (|@| (class "comment-delimiter") (id "F:763184")) "*/") "\n      last = first;\n      first_x = x;\n      " (span (|@| (class "keyword") (id "F:763232")) "while") " (last < end\n             && x < r->x + r->width)\n        {\n          x += last->pixel_width;\n          ++last;\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:763331")) "/* ") (span (|@| (class "comment") (id "F:763334")) "Repaint.  ") (span (|@| (class "comment-delimiter") (id "F:763344")) "*/") "\n      " (span (|@| (class "keyword") (id "F:763353")) "if") " (last > first)\n        draw_glyphs (w, first_x - start_x, row, area,\n                     first - row->glyphs[area], last - row->glyphs[area],\n                     DRAW_NORMAL_TEXT, 0);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:763517")) "/* ") (span (|@| (class "comment") (id "F:763520")) "Redraw the parts of the glyph row ROW on window W intersecting\n   rectangle R.  R is in window-relative coordinates.  Value is\n   non-zero if mouse-face was overwritten.  ") (span (|@| (class "comment-delimiter") (id "F:763691")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:763695")) "static") " " (span (|@| (class "type") (id "F:763702")) "int") "\n" (span (|@| (class "function-name") (id "F:763706")) "expose_line") " (w, row, r)\n     " (span (|@| (class "keyword") (id "F:763735")) "struct") " " (span (|@| (class "type") (id "F:763742")) "window") " *" (span (|@| (class "variable-name") (id "F:763750")) "w") ";\n     " (span (|@| (class "keyword") (id "F:763758")) "struct") " " (span (|@| (class "type") (id "F:763765")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:763776")) "row") ";\n     " (span (|@| (class "type") (id "F:763786")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:763798")) "r") ";\n{\n  xassert (row->enabled_p);\n\n  " (span (|@| (class "keyword") (id "F:763834")) "if") " (row->mode_line_p || w->pseudo_window_p)\n    draw_glyphs (w, 0, row, TEXT_AREA,\n                 0, row->used[TEXT_AREA],\n                 DRAW_NORMAL_TEXT, 0);\n  " (span (|@| (class "keyword") (id "F:763972")) "else") "\n    {\n      " (span (|@| (class "keyword") (id "F:763989")) "if") " (row->used[LEFT_MARGIN_AREA])\n        expose_area (w, row, r, LEFT_MARGIN_AREA);\n      " (span (|@| (class "keyword") (id "F:764072")) "if") " (row->used[TEXT_AREA])\n        expose_area (w, row, r, TEXT_AREA);\n      " (span (|@| (class "keyword") (id "F:764141")) "if") " (row->used[RIGHT_MARGIN_AREA])\n        expose_area (w, row, r, RIGHT_MARGIN_AREA);\n      draw_row_fringe_bitmaps (w, row);\n    }\n\n  " (span (|@| (class "keyword") (id "F:764269")) "return") " row->mouse_face_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:764299")) "/* ") (span (|@| (class "comment") (id "F:764302")) "Redraw those parts of glyphs rows during expose event handling that\n   overlap other rows.  Redrawing of an exposed line writes over parts\n   of lines overlapping that exposed line; this function fixes that.\n\n   W is the window being exposed.  FIRST_OVERLAPPING_ROW is the first\n   row in W's current matrix that is exposed and overlaps other rows.\n   LAST_OVERLAPPING_ROW is the last such row.  ") (span (|@| (class "comment-delimiter") (id "F:764698")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:764702")) "static") " " (span (|@| (class "type") (id "F:764709")) "void") "\n" (span (|@| (class "function-name") (id "F:764714")) "expose_overlaps") " (w, first_overlapping_row, last_overlapping_row, r)\n     " (span (|@| (class "keyword") (id "F:764787")) "struct") " " (span (|@| (class "type") (id "F:764794")) "window") " *" (span (|@| (class "variable-name") (id "F:764802")) "w") ";\n     " (span (|@| (class "keyword") (id "F:764810")) "struct") " " (span (|@| (class "type") (id "F:764817")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:764828")) "first_overlapping_row") ";\n     " (span (|@| (class "keyword") (id "F:764856")) "struct") " " (span (|@| (class "type") (id "F:764863")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:764874")) "last_overlapping_row") ";\n     " (span (|@| (class "type") (id "F:764901")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:764913")) "r") ";\n{\n  " (span (|@| (class "keyword") (id "F:764920")) "struct") " " (span (|@| (class "type") (id "F:764927")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:764938")) "row") ";\n\n  " (span (|@| (class "keyword") (id "F:764946")) "for") " (row = first_overlapping_row; row <= last_overlapping_row; ++row)\n    " (span (|@| (class "keyword") (id "F:765020")) "if") " (row->overlapping_p)\n      {\n        xassert (row->enabled_p && " (span (|@| (class "negation-char") (id "F:765080")) "!") "row->mode_line_p);\n\n        row->clip = r;\n        " (span (|@| (class "keyword") (id "F:765118")) "if") " (row->used[LEFT_MARGIN_AREA])\n          x_fix_overlapping_area (w, row, LEFT_MARGIN_AREA, OVERLAPS_BOTH);\n\n        " (span (|@| (class "keyword") (id "F:765222")) "if") " (row->used[TEXT_AREA])\n          x_fix_overlapping_area (w, row, TEXT_AREA, OVERLAPS_BOTH);\n\n        " (span (|@| (class "keyword") (id "F:765312")) "if") " (row->used[RIGHT_MARGIN_AREA])\n          x_fix_overlapping_area (w, row, RIGHT_MARGIN_AREA, OVERLAPS_BOTH);\n        row->clip = " (span (|@| (class "constant") (id "F:765429")) "NULL") ";\n      }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:765447")) "/* ") (span (|@| (class "comment") (id "F:765450")) "Return non-zero if W's cursor intersects rectangle R.  ") (span (|@| (class "comment-delimiter") (id "F:765505")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:765509")) "static") " " (span (|@| (class "type") (id "F:765516")) "int") "\n" (span (|@| (class "function-name") (id "F:765520")) "phys_cursor_in_rect_p") " (w, r)\n     " (span (|@| (class "keyword") (id "F:765554")) "struct") " " (span (|@| (class "type") (id "F:765561")) "window") " *" (span (|@| (class "variable-name") (id "F:765569")) "w") ";\n     " (span (|@| (class "type") (id "F:765577")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:765589")) "r") ";\n{\n  " (span (|@| (class "type") (id "F:765596")) "XRectangle") " " (span (|@| (class "variable-name") (id "F:765607")) "cr") ", " (span (|@| (class "variable-name") (id "F:765611")) "result") ";\n  " (span (|@| (class "keyword") (id "F:765621")) "struct") " " (span (|@| (class "type") (id "F:765628")) "glyph") " *" (span (|@| (class "variable-name") (id "F:765635")) "cursor_glyph") ";\n  " (span (|@| (class "keyword") (id "F:765651")) "struct") " " (span (|@| (class "type") (id "F:765658")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:765669")) "row") ";\n\n  " (span (|@| (class "keyword") (id "F:765677")) "if") " (w->phys_cursor.vpos >= 0\n      && w->phys_cursor.vpos < w->current_matrix->nrows\n      && (row = MATRIX_ROW (w->current_matrix, w->phys_cursor.vpos),\n          row->enabled_p)\n      && row->cursor_in_fringe_p)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:765896")) "/* ") (span (|@| (class "comment") (id "F:765899")) "Cursor is in the fringe.  ") (span (|@| (class "comment-delimiter") (id "F:765925")) "*/") "\n      cr.x = window_box_right_offset (w,\n                                      (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)\n                                       ? RIGHT_MARGIN_AREA\n                                       : TEXT_AREA));\n      cr.y = row->y;\n      cr.width = WINDOW_RIGHT_FRINGE_WIDTH (w);\n      cr.height = row->height;\n      " (span (|@| (class "keyword") (id "F:766182")) "return") " x_intersect_rectangles (&cr, r, &result);\n    }\n\n  cursor_glyph = get_phys_cursor_glyph (w);\n  " (span (|@| (class "keyword") (id "F:766284")) "if") " (cursor_glyph)\n    {\n      " (span (|@| (class "comment-delimiter") (id "F:766314")) "/* ") (span (|@| (class "comment") (id "F:766317")) "r is relative to W's box, but w->phys_cursor.x is relative\n         to left edge of W's TEXT area.  Adjust it.  ") (span (|@| (class "comment-delimiter") (id "F:766422")) "*/") "\n      cr.x = window_box_left_offset (w, TEXT_AREA) + w->phys_cursor.x;\n      cr.y = w->phys_cursor.y;\n      cr.width = cursor_glyph->pixel_width;\n      cr.height = w->phys_cursor_height;\n      " (span (|@| (class "comment-delimiter") (id "F:766618")) "/* ") (span (|@| (class "comment") (id "F:766621")) "++KFS: W32 version used W32-specific IntersectRect here, but\n         I assume the effect is the same -- and this is portable.  ") (span (|@| (class "comment-delimiter") (id "F:766742")) "*/") "\n      " (span (|@| (class "keyword") (id "F:766751")) "return") " x_intersect_rectangles (&cr, r, &result);\n    }\n  " (span (|@| (class "comment-delimiter") (id "F:766808")) "/* ") (span (|@| (class "comment") (id "F:766811")) "If we don't understand the format, pretend we're not in the hot-spot.  ") (span (|@| (class "comment-delimiter") (id "F:766882")) "*/") "\n  " (span (|@| (class "keyword") (id "F:766887")) "return") " 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:766901")) "/* ") (span (|@| (class "comment") (id "F:766904")) "EXPORT:\n   Draw a vertical window border to the right of window W if W doesn't\n   have vertical scroll bars.  ") (span (|@| (class "comment-delimiter") (id "F:767014")) "*/") "\n\n" (span (|@| (class "type") (id "F:767018")) "void") "\n" (span (|@| (class "function-name") (id "F:767023")) "x_draw_vertical_border") " (w)\n     " (span (|@| (class "keyword") (id "F:767055")) "struct") " " (span (|@| (class "type") (id "F:767062")) "window") " *" (span (|@| (class "variable-name") (id "F:767070")) "w") ";\n{\n  " (span (|@| (class "keyword") (id "F:767077")) "struct") " " (span (|@| (class "type") (id "F:767084")) "frame") " *" (span (|@| (class "variable-name") (id "F:767091")) "f") " = XFRAME (WINDOW_FRAME (w));\n\n  " (span (|@| (class "comment-delimiter") (id "F:767125")) "/* ") (span (|@| (class "comment") (id "F:767128")) "We could do better, if we knew what type of scroll-bar the adjacent\n     windows (on either side) have...  But we don't :-(\n     However, I think this works ok.  ++KFS 2003-04-25 ") (span (|@| (class "comment-delimiter") (id "F:767307")) "*/") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:767313")) "/* ") (span (|@| (class "comment") (id "F:767316")) "Redraw borders between horizontally adjacent windows.  Don't\n     do it for frames with vertical scroll bars because either the\n     right scroll bar of a window, or the left scroll bar of its\n     neighbor will suffice as a border.  ") (span (|@| (class "comment-delimiter") (id "F:767550")) "*/") "\n  " (span (|@| (class "keyword") (id "F:767555")) "if") " (FRAME_HAS_VERTICAL_SCROLL_BARS (XFRAME (w->frame)))\n    " (span (|@| (class "keyword") (id "F:767615")) "return") ";\n\n  " (span (|@| (class "keyword") (id "F:767626")) "if") " (" (span (|@| (class "negation-char") (id "F:767630")) "!") "WINDOW_RIGHTMOST_P (w)\n      && " (span (|@| (class "negation-char") (id "F:767663")) "!") "WINDOW_HAS_VERTICAL_SCROLL_BAR_ON_RIGHT (w))\n    {\n      " (span (|@| (class "type") (id "F:767721")) "int") " " (span (|@| (class "variable-name") (id "F:767725")) "x0") ", " (span (|@| (class "variable-name") (id "F:767729")) "x1") ", " (span (|@| (class "variable-name") (id "F:767733")) "y0") ", " (span (|@| (class "variable-name") (id "F:767737")) "y1") ";\n\n      window_box_edges (w, -1, &x0, &y0, &x1, &y1);\n      y1 -= 1;\n\n      " (span (|@| (class "keyword") (id "F:767816")) "if") " (WINDOW_LEFT_FRINGE_WIDTH (w) == 0)\n        x1 -= 1;\n\n      FRAME_RIF (f)->draw_vertical_window_border (w, x1, y0, y1);\n    }\n  " (span (|@| (class "keyword") (id "F:767947")) "else") " " (span (|@| (class "keyword") (id "F:767952")) "if") " (" (span (|@| (class "negation-char") (id "F:767956")) "!") "WINDOW_LEFTMOST_P (w)\n           && " (span (|@| (class "negation-char") (id "F:767986")) "!") "WINDOW_HAS_VERTICAL_SCROLL_BAR_ON_LEFT (w))\n    {\n      " (span (|@| (class "type") (id "F:768043")) "int") " " (span (|@| (class "variable-name") (id "F:768047")) "x0") ", " (span (|@| (class "variable-name") (id "F:768051")) "x1") ", " (span (|@| (class "variable-name") (id "F:768055")) "y0") ", " (span (|@| (class "variable-name") (id "F:768059")) "y1") ";\n\n      window_box_edges (w, -1, &x0, &y0, &x1, &y1);\n      y1 -= 1;\n\n      " (span (|@| (class "keyword") (id "F:768138")) "if") " (WINDOW_LEFT_FRINGE_WIDTH (w) == 0)\n        x0 -= 1;\n\n      FRAME_RIF (f)->draw_vertical_window_border (w, x0, y0, y1);\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:768271")) "/* ") (span (|@| (class "comment") (id "F:768274")) "Redraw the part of window W intersection rectangle FR.  Pixel\n   coordinates in FR are frame-relative.  Call this function with\n   input blocked.  Value is non-zero if the exposure overwrites\n   mouse-face.  ") (span (|@| (class "comment-delimiter") (id "F:768482")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:768486")) "static") " " (span (|@| (class "type") (id "F:768493")) "int") "\n" (span (|@| (class "function-name") (id "F:768497")) "expose_window") " (w, fr)\n     " (span (|@| (class "keyword") (id "F:768524")) "struct") " " (span (|@| (class "type") (id "F:768531")) "window") " *" (span (|@| (class "variable-name") (id "F:768539")) "w") ";\n     " (span (|@| (class "type") (id "F:768547")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:768559")) "fr") ";\n{\n  " (span (|@| (class "keyword") (id "F:768567")) "struct") " " (span (|@| (class "type") (id "F:768574")) "frame") " *" (span (|@| (class "variable-name") (id "F:768581")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:768606")) "XRectangle") " " (span (|@| (class "variable-name") (id "F:768617")) "wr") ", " (span (|@| (class "variable-name") (id "F:768621")) "r") ";\n  " (span (|@| (class "type") (id "F:768626")) "int") " " (span (|@| (class "variable-name") (id "F:768630")) "mouse_face_overwritten_p") " = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:768663")) "/* ") (span (|@| (class "comment") (id "F:768666")) "If window is not yet fully initialized, do nothing.  This can\n     happen when toolkit scroll bars are used and a window is split.\n     Reconfiguring the scroll bar will generate an expose for a newly\n     created window.  ") (span (|@| (class "comment-delimiter") (id "F:768889")) "*/") "\n  " (span (|@| (class "keyword") (id "F:768894")) "if") " (w->current_matrix == " (span (|@| (class "constant") (id "F:768919")) "NULL") ")\n    " (span (|@| (class "keyword") (id "F:768929")) "return") " 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:768942")) "/* ") (span (|@| (class "comment") (id "F:768945")) "When we're currently updating the window, display and current\n     matrix usually don't agree.  Arrange for a thorough display\n     later.  ") (span (|@| (class "comment-delimiter") (id "F:769085")) "*/") "\n  " (span (|@| (class "keyword") (id "F:769090")) "if") " (w == updated_window)\n    {\n      SET_FRAME_GARBAGED (f);\n      " (span (|@| (class "keyword") (id "F:769157")) "return") " 0;\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:769176")) "/* ") (span (|@| (class "comment") (id "F:769179")) "Frame-relative pixel rectangle of W.  ") (span (|@| (class "comment-delimiter") (id "F:769217")) "*/") "\n  wr.x = WINDOW_LEFT_EDGE_X (w);\n  wr.y = WINDOW_TOP_EDGE_Y (w);\n  wr.width = WINDOW_TOTAL_WIDTH (w);\n  wr.height = WINDOW_TOTAL_HEIGHT (w);\n\n  " (span (|@| (class "keyword") (id "F:769364")) "if") " (x_intersect_rectangles (fr, &wr, &r))\n    {\n      " (span (|@| (class "type") (id "F:769418")) "int") " " (span (|@| (class "variable-name") (id "F:769422")) "yb") " = window_text_bottom_y (w);\n      " (span (|@| (class "keyword") (id "F:769459")) "struct") " " (span (|@| (class "type") (id "F:769466")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:769477")) "row") ";\n      " (span (|@| (class "type") (id "F:769488")) "int") " " (span (|@| (class "variable-name") (id "F:769492")) "cursor_cleared_p") ";\n      " (span (|@| (class "keyword") (id "F:769516")) "struct") " " (span (|@| (class "type") (id "F:769523")) "glyph_row") " *" (span (|@| (class "variable-name") (id "F:769534")) "first_overlapping_row") ", *" (span (|@| (class "variable-name") (id "F:769558")) "last_overlapping_row") ";\n\n      TRACE ((stderr, " (span (|@| (class "string") (id "F:769603")) "\"expose_window (%d, %d, %d, %d)\\n\"") ",\n              r.x, r.y, r.width, r.height));\n\n      " (span (|@| (class "comment-delimiter") (id "F:769684")) "/* ") (span (|@| (class "comment") (id "F:769687")) "Convert to window coordinates.  ") (span (|@| (class "comment-delimiter") (id "F:769719")) "*/") "\n      r.x -= WINDOW_LEFT_EDGE_X (w);\n      r.y -= WINDOW_TOP_EDGE_Y (w);\n\n      " (span (|@| (class "comment-delimiter") (id "F:769802")) "/* ") (span (|@| (class "comment") (id "F:769805")) "Turn off the cursor.  ") (span (|@| (class "comment-delimiter") (id "F:769827")) "*/") "\n      " (span (|@| (class "keyword") (id "F:769836")) "if") " (" (span (|@| (class "negation-char") (id "F:769840")) "!") "w->pseudo_window_p\n          && phys_cursor_in_rect_p (w, &r))\n        {\n          x_clear_cursor (w);\n          cursor_cleared_p = 1;\n        }\n      " (span (|@| (class "keyword") (id "F:769957")) "else") "\n        cursor_cleared_p = 0;\n\n      " (span (|@| (class "comment-delimiter") (id "F:769992")) "/* ") (span (|@| (class "comment") (id "F:769995")) "Update lines intersecting rectangle R.  ") (span (|@| (class "comment-delimiter") (id "F:770035")) "*/") "\n      first_overlapping_row = last_overlapping_row = " (span (|@| (class "constant") (id "F:770091")) "NULL") ";\n      " (span (|@| (class "keyword") (id "F:770103")) "for") " (row = w->current_matrix->rows;\n           row->enabled_p;\n           ++row)\n        {\n          " (span (|@| (class "type") (id "F:770176")) "int") " " (span (|@| (class "variable-name") (id "F:770180")) "y0") " = row->y;\n          " (span (|@| (class "type") (id "F:770196")) "int") " " (span (|@| (class "variable-name") (id "F:770200")) "y1") " = MATRIX_ROW_BOTTOM_Y (row);\n\n          " (span (|@| (class "keyword") (id "F:770236")) "if") " ((y0 >= r.y && y0 < r.y + r.height)\n              || (y1 > r.y && y1 < r.y + r.height)\n              || (r.y >= y0 && r.y < y1)\n              || (r.y + r.height > y0 && r.y + r.height < y1))\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:770423")) "/* ") (span (|@| (class "comment") (id "F:770426")) "A header line may be overlapping, but there is no need\n                 to fix overlapping areas for them.  KFS 2005-02-12 ") (span (|@| (class "comment-delimiter") (id "F:770535")) "*/") "\n              " (span (|@| (class "keyword") (id "F:770545")) "if") " (row->overlapping_p && " (span (|@| (class "negation-char") (id "F:770571")) "!") "row->mode_line_p)\n                {\n                  " (span (|@| (class "keyword") (id "F:770598")) "if") " (first_overlapping_row == " (span (|@| (class "constant") (id "F:770627")) "NULL") ")\n                    first_overlapping_row = row;\n                  last_overlapping_row = row;\n                }\n\n              row->clip = fr;\n              " (span (|@| (class "keyword") (id "F:770735")) "if") " (expose_line (w, row, &r))\n                mouse_face_overwritten_p = 1;\n              row->clip = " (span (|@| (class "constant") (id "F:770816")) "NULL") ";\n            }\n          " (span (|@| (class "keyword") (id "F:770832")) "else") " " (span (|@| (class "keyword") (id "F:770837")) "if") " (row->overlapping_p)\n            {\n              " (span (|@| (class "comment-delimiter") (id "F:770875")) "/* ") (span (|@| (class "comment") (id "F:770878")) "We must redraw a row overlapping the exposed area.  ") (span (|@| (class "comment-delimiter") (id "F:770930")) "*/") "\n              " (span (|@| (class "keyword") (id "F:770940")) "if") " (y0 < r.y\n                  ? y0 + row->phys_height > r.y\n                  : y0 + row->ascent - row->phys_ascent < r.y +r.height)\n                {\n                  " (span (|@| (class "keyword") (id "F:771054")) "if") " (first_overlapping_row == " (span (|@| (class "constant") (id "F:771083")) "NULL") ")\n                    first_overlapping_row = row;\n                  last_overlapping_row = row;\n                }\n            }\n\n          " (span (|@| (class "keyword") (id "F:771171")) "if") " (y1 >= yb)\n            " (span (|@| (class "keyword") (id "F:771190")) "break") ";\n        }\n\n      " (span (|@| (class "comment-delimiter") (id "F:771207")) "/* ") (span (|@| (class "comment") (id "F:771210")) "Display the mode line if there is one.  ") (span (|@| (class "comment-delimiter") (id "F:771250")) "*/") "\n      " (span (|@| (class "keyword") (id "F:771259")) "if") " (WINDOW_WANTS_MODELINE_P (w)\n          && (row = MATRIX_MODE_LINE_ROW (w->current_matrix),\n              row->enabled_p)\n          && row->y < r.y + r.height)\n        {\n          " (span (|@| (class "keyword") (id "F:771406")) "if") " (expose_line (w, row, &r))\n            mouse_face_overwritten_p = 1;\n        }\n\n      " (span (|@| (class "keyword") (id "F:771481")) "if") " (" (span (|@| (class "negation-char") (id "F:771485")) "!") "w->pseudo_window_p)\n        {\n          " (span (|@| (class "comment-delimiter") (id "F:771512")) "/* ") (span (|@| (class "comment") (id "F:771515")) "Fix the display of overlapping rows.  ") (span (|@| (class "comment-delimiter") (id "F:771553")) "*/") "\n          " (span (|@| (class "keyword") (id "F:771559")) "if") " (first_overlapping_row)\n            expose_overlaps (w, first_overlapping_row, last_overlapping_row,\n                             fr);\n\n          " (span (|@| (class "comment-delimiter") (id "F:771673")) "/* ") (span (|@| (class "comment") (id "F:771676")) "Draw border between windows.  ") (span (|@| (class "comment-delimiter") (id "F:771706")) "*/") "\n          x_draw_vertical_border (w);\n\n          " (span (|@| (class "comment-delimiter") (id "F:771744")) "/* ") (span (|@| (class "comment") (id "F:771747")) "Turn the cursor on again.  ") (span (|@| (class "comment-delimiter") (id "F:771774")) "*/") "\n          " (span (|@| (class "keyword") (id "F:771780")) "if") " (cursor_cleared_p)\n            update_window_cursor (w, 1);\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:771848")) "return") " mouse_face_overwritten_p;\n}\n\n\n\n" (span (|@| (class "comment-delimiter") (id "F:771886")) "/* ") (span (|@| (class "comment") (id "F:771889")) "Redraw (parts) of all windows in the window tree rooted at W that\n   intersect R.  R contains frame pixel coordinates.  Value is\n   non-zero if the exposure overwrites mouse-face.  ") (span (|@| (class "comment-delimiter") (id "F:772070")) "*/") "\n\n" (span (|@| (class "keyword") (id "F:772074")) "static") " " (span (|@| (class "type") (id "F:772081")) "int") "\n" (span (|@| (class "function-name") (id "F:772085")) "expose_window_tree") " (w, r)\n     " (span (|@| (class "keyword") (id "F:772116")) "struct") " " (span (|@| (class "type") (id "F:772123")) "window") " *" (span (|@| (class "variable-name") (id "F:772131")) "w") ";\n     " (span (|@| (class "type") (id "F:772139")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:772151")) "r") ";\n{\n  " (span (|@| (class "keyword") (id "F:772158")) "struct") " " (span (|@| (class "type") (id "F:772165")) "frame") " *" (span (|@| (class "variable-name") (id "F:772172")) "f") " = XFRAME (w->frame);\n  " (span (|@| (class "type") (id "F:772197")) "int") " " (span (|@| (class "variable-name") (id "F:772201")) "mouse_face_overwritten_p") " = 0;\n\n  " (span (|@| (class "keyword") (id "F:772234")) "while") " (w && " (span (|@| (class "negation-char") (id "F:772246")) "!") "FRAME_GARBAGED_P (f))\n    {\n      " (span (|@| (class "keyword") (id "F:772281")) "if") " (" (span (|@| (class "negation-char") (id "F:772285")) "!") "NILP (w->hchild))\n        mouse_face_overwritten_p\n          |= expose_window_tree (XWINDOW (w->hchild), r);\n      " (span (|@| (class "keyword") (id "F:772387")) "else") " " (span (|@| (class "keyword") (id "F:772392")) "if") " (" (span (|@| (class "negation-char") (id "F:772396")) "!") "NILP (w->vchild))\n        mouse_face_overwritten_p\n          |= expose_window_tree (XWINDOW (w->vchild), r);\n      " (span (|@| (class "keyword") (id "F:772498")) "else") "\n        mouse_face_overwritten_p |= expose_window (w, r);\n\n      w = NILP (w->next) ? " (span (|@| (class "constant") (id "F:772582")) "NULL") " : XWINDOW (w->next);\n    }\n\n  " (span (|@| (class "keyword") (id "F:772617")) "return") " mouse_face_overwritten_p;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:772654")) "/* ") (span (|@| (class "comment") (id "F:772657")) "EXPORT:\n   Redisplay an exposed area of frame F.  X and Y are the upper-left\n   corner of the exposed rectangle.  W and H are width and height of\n   the exposed area.  All are pixel values.  W or H zero means redraw\n   the entire frame.  ") (span (|@| (class "comment-delimiter") (id "F:772895")) "*/") "\n\n" (span (|@| (class "type") (id "F:772899")) "void") "\n" (span (|@| (class "function-name") (id "F:772904")) "expose_frame") " (f, x, y, w, h)\n     " (span (|@| (class "keyword") (id "F:772938")) "struct") " " (span (|@| (class "type") (id "F:772945")) "frame") " *" (span (|@| (class "variable-name") (id "F:772952")) "f") ";\n     " (span (|@| (class "type") (id "F:772960")) "int") " " (span (|@| (class "variable-name") (id "F:772964")) "x") ", " (span (|@| (class "variable-name") (id "F:772967")) "y") ", " (span (|@| (class "variable-name") (id "F:772970")) "w") ", " (span (|@| (class "variable-name") (id "F:772973")) "h") ";\n{\n  " (span (|@| (class "type") (id "F:772980")) "XRectangle") " " (span (|@| (class "variable-name") (id "F:772991")) "r") ";\n  " (span (|@| (class "type") (id "F:772996")) "int") " " (span (|@| (class "variable-name") (id "F:773000")) "mouse_face_overwritten_p") " = 0;\n\n  TRACE ((stderr, " (span (|@| (class "string") (id "F:773049")) "\"expose_frame \"") "));\n\n  " (span (|@| (class "comment-delimiter") (id "F:773071")) "/* ") (span (|@| (class "comment") (id "F:773074")) "No need to redraw if frame will be redrawn soon.  ") (span (|@| (class "comment-delimiter") (id "F:773124")) "*/") "\n  " (span (|@| (class "keyword") (id "F:773129")) "if") " (FRAME_GARBAGED_P (f))\n    {\n      TRACE ((stderr, " (span (|@| (class "string") (id "F:773183")) "\" garbaged\\n\"") "));\n      " (span (|@| (class "keyword") (id "F:773206")) "return") ";\n    }\n\n  " (span (|@| (class "comment-delimiter") (id "F:773223")) "/* ") (span (|@| (class "comment") (id "F:773226")) "If basic faces haven't been realized yet, there is no point in\n     trying to redraw anything.  This can happen when we get an expose\n     event while Emacs is starting, e.g. by moving another window.  ") (span (|@| (class "comment-delimiter") (id "F:773428")) "*/") "\n  " (span (|@| (class "keyword") (id "F:773433")) "if") " (FRAME_FACE_CACHE (f) == " (span (|@| (class "constant") (id "F:773461")) "NULL") "\n      || FRAME_FACE_CACHE (f)->used < BASIC_FACE_ID_SENTINEL)\n    {\n      TRACE ((stderr, " (span (|@| (class "string") (id "F:773556")) "\" no faces\\n\"") "));\n      " (span (|@| (class "keyword") (id "F:773579")) "return") ";\n    }\n\n  " (span (|@| (class "keyword") (id "F:773596")) "if") " (w == 0 || h == 0)\n    {\n      r.x = r.y = 0;\n      r.width = FRAME_COLUMN_WIDTH (f) * FRAME_COLS (f);\n      r.height = FRAME_LINE_HEIGHT (f) * FRAME_LINES (f);\n    }\n  " (span (|@| (class "keyword") (id "F:773768")) "else") "\n    {\n      r.x = x;\n      r.y = y;\n      r.width = w;\n      r.height = h;\n    }\n\n  TRACE ((stderr, " (span (|@| (class "string") (id "F:773873")) "\"(%d, %d, %d, %d)\\n\"") ", r.x, r.y, r.width, r.height));\n  mouse_face_overwritten_p = expose_window_tree (XWINDOW (f->root_window), &r);\n\n  " (span (|@| (class "keyword") (id "F:774009")) "if") " (WINDOWP (f->tool_bar_window))\n    mouse_face_overwritten_p\n      |= expose_window (XWINDOW (f->tool_bar_window), &r);\n\n" (span (|@| (class "preprocessor") (id "F:774132")) "#ifdef") " HAVE_X_WINDOWS\n" (span (|@| (class "preprocessor") (id "F:774154")) "#if") (span (|@| (class "negation-char") (id "F:774157")) (span (|@| (class "preprocessor") (id "F:774157")) "n")) (span (|@| (class "preprocessor") (id "F:774158")) "def") " MSDOS\n" (span (|@| (class "preprocessor") (id "F:774168")) "#if") (span (|@| (class "negation-char") (id "F:774171")) (span (|@| (class "preprocessor") (id "F:774171")) "n")) (span (|@| (class "preprocessor") (id "F:774172")) "def") " USE_X_TOOLKIT\n  " (span (|@| (class "keyword") (id "F:774192")) "if") " (WINDOWP (f->menu_bar_window))\n    mouse_face_overwritten_p\n      |= expose_window (XWINDOW (f->menu_bar_window), &r);\n" (span (|@| (class "preprocessor") (id "F:774314")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:774321")) "/* ") (span (|@| (class "comment") (id "F:774324")) "not USE_X_TOOLKIT ") (span (|@| (class "comment-delimiter") (id "F:774342")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:774345")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:774352")) "#endif") "\n\n  " (span (|@| (class "comment-delimiter") (id "F:774362")) "/* ") (span (|@| (class "comment") (id "F:774365")) "Some window managers support a focus-follows-mouse style with\n     delayed raising of frames.  Imagine a partially obscured frame,\n     and moving the mouse into partially obscured mouse-face on that\n     frame.  The visible part of the mouse-face will be highlighted,\n     then the WM raises the obscured frame.  With at least one WM, KDE\n     2.1, Emacs is not getting any event for the raising of the frame\n     (even tried with SubstructureRedirectMask), only Expose events.\n     These expose events will draw text normally, i.e. not\n     highlighted.  Which means we must redo the highlight here.\n     Subsume it under ``we love X''.  --gerd 2001-08-15  ") (span (|@| (class "comment-delimiter") (id "F:775024")) "*/") "\n  " (span (|@| (class "comment-delimiter") (id "F:775029")) "/* ") (span (|@| (class "comment") (id "F:775032")) "Included in Windows version because Windows most likely does not\n     do the right thing if any third party tool offers\n     focus-follows-mouse with delayed raise.  --jason 2001-10-12  ") (span (|@| (class "comment-delimiter") (id "F:775218")) "*/") "\n  " (span (|@| (class "keyword") (id "F:775223")) "if") " (mouse_face_overwritten_p && " (span (|@| (class "negation-char") (id "F:775255")) "!") "FRAME_GARBAGED_P (f))\n    {\n      " (span (|@| (class "type") (id "F:775290")) "Display_Info") " *" (span (|@| (class "variable-name") (id "F:775304")) "dpyinfo") " = FRAME_X_DISPLAY_INFO (f);\n      " (span (|@| (class "keyword") (id "F:775346")) "if") " (f == dpyinfo->mouse_face_mouse_frame)\n        {\n          " (span (|@| (class "type") (id "F:775394")) "int") " " (span (|@| (class "variable-name") (id "F:775398")) "x") " = dpyinfo->mouse_face_mouse_x;\n          " (span (|@| (class "type") (id "F:775434")) "int") " " (span (|@| (class "variable-name") (id "F:775438")) "y") " = dpyinfo->mouse_face_mouse_y;\n          clear_mouse_face (dpyinfo);\n          note_mouse_highlight (f, x, y);\n        }\n    }\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:775550")) "/* ") (span (|@| (class "comment") (id "F:775553")) "EXPORT:\n   Determine the intersection of two rectangles R1 and R2.  Return\n   the intersection in *RESULT.  Value is non-zero if RESULT is not\n   empty.  ") (span (|@| (class "comment-delimiter") (id "F:775707")) "*/") "\n\n" (span (|@| (class "type") (id "F:775711")) "int") "\n" (span (|@| (class "function-name") (id "F:775715")) "x_intersect_rectangles") " (r1, r2, result)\n     " (span (|@| (class "type") (id "F:775760")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:775772")) "r1") ", *" (span (|@| (class "variable-name") (id "F:775777")) "r2") ", *" (span (|@| (class "variable-name") (id "F:775782")) "result") ";\n{\n  " (span (|@| (class "type") (id "F:775794")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:775806")) "left") ", *" (span (|@| (class "variable-name") (id "F:775813")) "right") ";\n  " (span (|@| (class "type") (id "F:775822")) "XRectangle") " *" (span (|@| (class "variable-name") (id "F:775834")) "upper") ", *" (span (|@| (class "variable-name") (id "F:775842")) "lower") ";\n  " (span (|@| (class "type") (id "F:775851")) "int") " " (span (|@| (class "variable-name") (id "F:775855")) "intersection_p") " = 0;\n\n  " (span (|@| (class "comment-delimiter") (id "F:775878")) "/* ") (span (|@| (class "comment") (id "F:775881")) "Rearrange so that R1 is the left-most rectangle.  ") (span (|@| (class "comment-delimiter") (id "F:775931")) "*/") "\n  " (span (|@| (class "keyword") (id "F:775936")) "if") " (r1->x < r2->x)\n    left = r1, right = r2;\n  " (span (|@| (class "keyword") (id "F:775984")) "else") "\n    left = r2, right = r1;\n\n  " (span (|@| (class "comment-delimiter") (id "F:776019")) "/* ") (span (|@| (class "comment") (id "F:776022")) "X0 of the intersection is right.x0, if this is inside R1,\n     otherwise there is no intersection.  ") (span (|@| (class "comment-delimiter") (id "F:776122")) "*/") "\n  " (span (|@| (class "keyword") (id "F:776127")) "if") " (right->x <= left->x + left->width)\n    {\n      result->x = right->x;\n\n      " (span (|@| (class "comment-delimiter") (id "F:776207")) "/* ") (span (|@| (class "comment") (id "F:776210")) "The right end of the intersection is the minimum of the\n         the right ends of left and right.  ") (span (|@| (class "comment-delimiter") (id "F:776303")) "*/") "\n      result->width = (min (left->x + left->width, right->x + right->width)\n                       - result->x);\n\n      " (span (|@| (class "comment-delimiter") (id "F:776412")) "/* ") (span (|@| (class "comment") (id "F:776415")) "Same game for Y.  ") (span (|@| (class "comment-delimiter") (id "F:776433")) "*/") "\n      " (span (|@| (class "keyword") (id "F:776442")) "if") " (r1->y < r2->y)\n        upper = r1, lower = r2;\n      " (span (|@| (class "keyword") (id "F:776492")) "else") "\n        upper = r2, lower = r1;\n\n      " (span (|@| (class "comment-delimiter") (id "F:776529")) "/* ") (span (|@| (class "comment") (id "F:776532")) "The upper end of the intersection is lower.y0, if this is inside\n         of upper.  Otherwise, there is no intersection.  ") (span (|@| (class "comment-delimiter") (id "F:776648")) "*/") "\n      " (span (|@| (class "keyword") (id "F:776657")) "if") " (lower->y <= upper->y + upper->height)\n        {\n          result->y = lower->y;\n\n          " (span (|@| (class "comment-delimiter") (id "F:776731")) "/* ") (span (|@| (class "comment") (id "F:776734")) "The lower end of the intersection is the minimum of the lower\n             ends of upper and lower.  ") (span (|@| (class "comment-delimiter") (id "F:776828")) "*/") "\n          result->height = (min (lower->y + lower->height,\n                                 upper->y + upper->height)\n                            - result->y);\n          intersection_p = 1;\n        }\n    }\n\n  " (span (|@| (class "keyword") (id "F:776970")) "return") " intersection_p;\n}\n\n" (span (|@| (class "preprocessor") (id "F:776996")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:777003")) "/* ") (span (|@| (class "comment") (id "F:777006")) "HAVE_WINDOW_SYSTEM ") (span (|@| (class "comment-delimiter") (id "F:777025")) "*/") "\n\n\f\n" (span (|@| (class "comment-delimiter") (id "F:777031")) "/***********************************************************************") (span (|@| (class "comment") (id "F:777103")) "\n                            Initialization\n **********************************************************************") (span (|@| (class "comment-delimiter") (id "F:777197")) "*/") "\n\n" (span (|@| (class "type") (id "F:777201")) "void") "\n" (span (|@| (class "function-name") (id "F:777206")) "syms_of_xdisp") " ()\n{\n  Vwith_echo_area_save_vector = Qnil;\n  staticpro (&Vwith_echo_area_save_vector);\n\n  Vmessage_stack = Qnil;\n  staticpro (&Vmessage_stack);\n\n  Qinhibit_redisplay = intern_c_string (" (span (|@| (class "string") (id "F:777405")) "\"inhibit-redisplay\"") ");\n  staticpro (&Qinhibit_redisplay);\n\n  message_dolog_marker1 = Fmake_marker ();\n  staticpro (&message_dolog_marker1);\n  message_dolog_marker2 = Fmake_marker ();\n  staticpro (&message_dolog_marker2);\n  message_dolog_marker3 = Fmake_marker ();\n  staticpro (&message_dolog_marker3);\n\n" (span (|@| (class "preprocessor") (id "F:777707")) "#if") " GLYPH_DEBUG\n  defsubr (&Sdump_frame_glyph_matrix);\n  defsubr (&Sdump_glyph_matrix);\n  defsubr (&Sdump_glyph_row);\n  defsubr (&Sdump_tool_bar_row);\n  defsubr (&Strace_redisplay);\n  defsubr (&Strace_to_stderr);\n" (span (|@| (class "preprocessor") (id "F:777920")) "#endif") "\n" (span (|@| (class "preprocessor") (id "F:777927")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  defsubr (&Stool_bar_lines_needed);\n  defsubr (&Slookup_image_map);\n" (span (|@| (class "preprocessor") (id "F:778022")) "#endif") "\n  defsubr (&Sformat_mode_line);\n  defsubr (&Sinvisible_p);\n  defsubr (&Scurrent_bidi_paragraph_direction);\n\n  staticpro (&Qmenu_bar_update_hook);\n  Qmenu_bar_update_hook = intern_c_string (" (span (|@| (class "string") (id "F:778218")) "\"menu-bar-update-hook\"") ");\n\n  staticpro (&Qoverriding_terminal_local_map);\n  Qoverriding_terminal_local_map = intern_c_string (" (span (|@| (class "string") (id "F:778343")) "\"overriding-terminal-local-map\"") ");\n\n  staticpro (&Qoverriding_local_map);\n  Qoverriding_local_map = intern_c_string (" (span (|@| (class "string") (id "F:778459")) "\"overriding-local-map\"") ");\n\n  staticpro (&Qwindow_scroll_functions);\n  Qwindow_scroll_functions = intern_c_string (" (span (|@| (class "string") (id "F:778572")) "\"window-scroll-functions\"") ");\n\n  staticpro (&Qwindow_text_change_functions);\n  Qwindow_text_change_functions = intern_c_string (" (span (|@| (class "string") (id "F:778698")) "\"window-text-change-functions\"") ");\n\n  staticpro (&Qredisplay_end_trigger_functions);\n  Qredisplay_end_trigger_functions = intern_c_string (" (span (|@| (class "string") (id "F:778835")) "\"redisplay-end-trigger-functions\"") ");\n\n  staticpro (&Qinhibit_point_motion_hooks);\n  Qinhibit_point_motion_hooks = intern_c_string (" (span (|@| (class "string") (id "F:778965")) "\"inhibit-point-motion-hooks\"") ");\n\n  Qeval = intern_c_string (" (span (|@| (class "string") (id "F:779024")) "\"eval\"") ");\n  staticpro (&Qeval);\n\n  QCdata = intern_c_string (" (span (|@| (class "string") (id "F:779084")) "\":data\"") ");\n  staticpro (&QCdata);\n  Qdisplay = intern_c_string (" (span (|@| (class "string") (id "F:779147")) "\"display\"") ");\n  staticpro (&Qdisplay);\n  Qspace_width = intern_c_string (" (span (|@| (class "string") (id "F:779218")) "\"space-width\"") ");\n  staticpro (&Qspace_width);\n  Qraise = intern_c_string (" (span (|@| (class "string") (id "F:779291")) "\"raise\"") ");\n  staticpro (&Qraise);\n  Qslice = intern_c_string (" (span (|@| (class "string") (id "F:779352")) "\"slice\"") ");\n  staticpro (&Qslice);\n  Qspace = intern_c_string (" (span (|@| (class "string") (id "F:779413")) "\"space\"") ");\n  staticpro (&Qspace);\n  Qmargin = intern_c_string (" (span (|@| (class "string") (id "F:779475")) "\"margin\"") ");\n  staticpro (&Qmargin);\n  Qpointer = intern_c_string (" (span (|@| (class "string") (id "F:779540")) "\"pointer\"") ");\n  staticpro (&Qpointer);\n  Qleft_margin = intern_c_string (" (span (|@| (class "string") (id "F:779611")) "\"left-margin\"") ");\n  staticpro (&Qleft_margin);\n  Qright_margin = intern_c_string (" (span (|@| (class "string") (id "F:779691")) "\"right-margin\"") ");\n  staticpro (&Qright_margin);\n  Qcenter = intern_c_string (" (span (|@| (class "string") (id "F:779767")) "\"center\"") ");\n  staticpro (&Qcenter);\n  Qline_height = intern_c_string (" (span (|@| (class "string") (id "F:779836")) "\"line-height\"") ");\n  staticpro (&Qline_height);\n  QCalign_to = intern_c_string (" (span (|@| (class "string") (id "F:779913")) "\":align-to\"") ");\n  staticpro (&QCalign_to);\n  QCrelative_width = intern_c_string (" (span (|@| (class "string") (id "F:779992")) "\":relative-width\"") ");\n  staticpro (&QCrelative_width);\n  QCrelative_height = intern_c_string (" (span (|@| (class "string") (id "F:780084")) "\":relative-height\"") ");\n  staticpro (&QCrelative_height);\n  QCeval = intern_c_string (" (span (|@| (class "string") (id "F:780167")) "\":eval\"") ");\n  staticpro (&QCeval);\n  QCpropertize = intern_c_string (" (span (|@| (class "string") (id "F:780234")) "\":propertize\"") ");\n  staticpro (&QCpropertize);\n  QCfile = intern_c_string (" (span (|@| (class "string") (id "F:780307")) "\":file\"") ");\n  staticpro (&QCfile);\n  Qfontified = intern_c_string (" (span (|@| (class "string") (id "F:780372")) "\"fontified\"") ");\n  staticpro (&Qfontified);\n  Qfontification_functions = intern_c_string (" (span (|@| (class "string") (id "F:780459")) "\"fontification-functions\"") ");\n  staticpro (&Qfontification_functions);\n  Qtrailing_whitespace = intern_c_string (" (span (|@| (class "string") (id "F:780570")) "\"trailing-whitespace\"") ");\n  staticpro (&Qtrailing_whitespace);\n  Qescape_glyph = intern_c_string (" (span (|@| (class "string") (id "F:780666")) "\"escape-glyph\"") ");\n  staticpro (&Qescape_glyph);\n  Qnobreak_space = intern_c_string (" (span (|@| (class "string") (id "F:780749")) "\"nobreak-space\"") ");\n  staticpro (&Qnobreak_space);\n  Qimage = intern_c_string (" (span (|@| (class "string") (id "F:780826")) "\"image\"") ");\n  staticpro (&Qimage);\n  Qtext = intern_c_string (" (span (|@| (class "string") (id "F:780886")) "\"text\"") ");\n  staticpro (&Qtext);\n  Qboth = intern_c_string (" (span (|@| (class "string") (id "F:780944")) "\"both\"") ");\n  staticpro (&Qboth);\n  Qboth_horiz = intern_c_string (" (span (|@| (class "string") (id "F:781008")) "\"both-horiz\"") ");\n  staticpro (&Qboth_horiz);\n  QCmap = intern_c_string (" (span (|@| (class "string") (id "F:781078")) "\":map\"") ");\n  staticpro (&QCmap);\n  QCpointer = intern_c_string (" (span (|@| (class "string") (id "F:781140")) "\":pointer\"") ");\n  staticpro (&QCpointer);\n  Qrect = intern_c_string (" (span (|@| (class "string") (id "F:781206")) "\"rect\"") ");\n  staticpro (&Qrect);\n  Qcircle = intern_c_string (" (span (|@| (class "string") (id "F:781266")) "\"circle\"") ");\n  staticpro (&Qcircle);\n  Qpoly = intern_c_string (" (span (|@| (class "string") (id "F:781328")) "\"poly\"") ");\n  staticpro (&Qpoly);\n  Qmessage_truncate_lines = intern_c_string (" (span (|@| (class "string") (id "F:781404")) "\"message-truncate-lines\"") ");\n  staticpro (&Qmessage_truncate_lines);\n  Qgrow_only = intern_c_string (" (span (|@| (class "string") (id "F:781503")) "\"grow-only\"") ");\n  staticpro (&Qgrow_only);\n  Qinhibit_menubar_update = intern_c_string (" (span (|@| (class "string") (id "F:781589")) "\"inhibit-menubar-update\"") ");\n  staticpro (&Qinhibit_menubar_update);\n  Qinhibit_eval_during_redisplay = intern_c_string (" (span (|@| (class "string") (id "F:781708")) "\"inhibit-eval-during-redisplay\"") ");\n  staticpro (&Qinhibit_eval_during_redisplay);\n  Qposition = intern_c_string (" (span (|@| (class "string") (id "F:781820")) "\"position\"") ");\n  staticpro (&Qposition);\n  Qbuffer_position = intern_c_string (" (span (|@| (class "string") (id "F:781897")) "\"buffer-position\"") ");\n  staticpro (&Qbuffer_position);\n  Qobject = intern_c_string (" (span (|@| (class "string") (id "F:781979")) "\"object\"") ");\n  staticpro (&Qobject);\n  Qbar = intern_c_string (" (span (|@| (class "string") (id "F:782040")) "\"bar\"") ");\n  staticpro (&Qbar);\n  Qhbar = intern_c_string (" (span (|@| (class "string") (id "F:782096")) "\"hbar\"") ");\n  staticpro (&Qhbar);\n  Qbox = intern_c_string (" (span (|@| (class "string") (id "F:782153")) "\"box\"") ");\n  staticpro (&Qbox);\n  Qhollow = intern_c_string (" (span (|@| (class "string") (id "F:782211")) "\"hollow\"") ");\n  staticpro (&Qhollow);\n  Qhand = intern_c_string (" (span (|@| (class "string") (id "F:782273")) "\"hand\"") ");\n  staticpro (&Qhand);\n  Qarrow = intern_c_string (" (span (|@| (class "string") (id "F:782332")) "\"arrow\"") ");\n  staticpro (&Qarrow);\n  Qtext = intern_c_string (" (span (|@| (class "string") (id "F:782392")) "\"text\"") ");\n  staticpro (&Qtext);\n  Qrisky_local_variable = intern_c_string (" (span (|@| (class "string") (id "F:782466")) "\"risky-local-variable\"") ");\n  staticpro (&Qrisky_local_variable);\n  Qinhibit_free_realized_faces = intern_c_string (" (span (|@| (class "string") (id "F:782579")) "\"inhibit-free-realized-faces\"") ");\n  staticpro (&Qinhibit_free_realized_faces);\n\n  list_of_error = Fcons (Fcons (intern_c_string (" (span (|@| (class "string") (id "F:782706")) "\"error\"") "),\n                                Fcons (intern_c_string (" (span (|@| (class "string") (id "F:782744")) "\"void-variable\"") "), Qnil)),\n                         Qnil);\n  staticpro (&list_of_error);\n\n  Qlast_arrow_position = intern_c_string (" (span (|@| (class "string") (id "F:782854")) "\"last-arrow-position\"") ");\n  staticpro (&Qlast_arrow_position);\n  Qlast_arrow_string = intern_c_string (" (span (|@| (class "string") (id "F:782955")) "\"last-arrow-string\"") ");\n  staticpro (&Qlast_arrow_string);\n\n  Qoverlay_arrow_string = intern_c_string (" (span (|@| (class "string") (id "F:783056")) "\"overlay-arrow-string\"") ");\n  staticpro (&Qoverlay_arrow_string);\n  Qoverlay_arrow_bitmap = intern_c_string (" (span (|@| (class "string") (id "F:783162")) "\"overlay-arrow-bitmap\"") ");\n  staticpro (&Qoverlay_arrow_bitmap);\n\n  echo_buffer[0] = echo_buffer[1] = Qnil;\n  staticpro (&echo_buffer[0]);\n  staticpro (&echo_buffer[1]);\n\n  echo_area_buffer[0] = echo_area_buffer[1] = Qnil;\n  staticpro (&echo_area_buffer[0]);\n  staticpro (&echo_area_buffer[1]);\n\n  Vmessages_buffer_name = make_pure_c_string (" (span (|@| (class "string") (id "F:783502")) "\"*Messages*\"") ");\n  staticpro (&Vmessages_buffer_name);\n\n  mode_line_proptrans_alist = Qnil;\n  staticpro (&mode_line_proptrans_alist);\n  mode_line_string_list = Qnil;\n  staticpro (&mode_line_string_list);\n  mode_line_string_face = Qnil;\n  staticpro (&mode_line_string_face);\n  mode_line_string_face_prop = Qnil;\n  staticpro (&mode_line_string_face_prop);\n  Vmode_line_unwind_vector = Qnil;\n  staticpro (&Vmode_line_unwind_vector);\n\n  help_echo_string = Qnil;\n  staticpro (&help_echo_string);\n  help_echo_object = Qnil;\n  staticpro (&help_echo_object);\n  help_echo_window = Qnil;\n  staticpro (&help_echo_window);\n  previous_help_echo_string = Qnil;\n  staticpro (&previous_help_echo_string);\n  help_echo_pos = -1;\n\n  Qright_to_left = intern_c_string (" (span (|@| (class "string") (id "F:784248")) "\"right-to-left\"") ");\n  staticpro (&Qright_to_left);\n  Qleft_to_right = intern_c_string (" (span (|@| (class "string") (id "F:784333")) "\"left-to-right\"") ");\n  staticpro (&Qleft_to_right);\n\n" (span (|@| (class "preprocessor") (id "F:784383")) "#ifdef") " HAVE_WINDOW_SYSTEM\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:784424")) "\"x-stretch-cursor\"") ", &x_stretch_cursor_p,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:784474")) "/* ") (span (|@| (class "comment") (id "F:784477")) "*Non-nil means draw block cursor as wide as the glyph under it.\nFor example, if a block cursor is over a tab, it will be drawn as\nwide as that tab on the display.  ") (span (|@| (class "comment-delimiter") (id "F:784641")) "*/") ");\n  x_stretch_cursor_p = 0;\n" (span (|@| (class "preprocessor") (id "F:784672")) "#endif") "\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:784695")) "\"show-trailing-whitespace\"") ", &Vshow_trailing_whitespace,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:784760")) "/* ") (span (|@| (class "comment") (id "F:784763")) "*Non-nil means highlight trailing whitespace.\nThe face used for trailing whitespace is `trailing-whitespace'.  ") (span (|@| (class "comment-delimiter") (id "F:784874")) "*/") ");\n  Vshow_trailing_whitespace = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:784931")) "\"nobreak-char-display\"") ", &Vnobreak_char_display,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:784988")) "/* ") (span (|@| (class "comment") (id "F:784991")) "*Control highlighting of nobreak space and soft hyphen.\nA value of t means highlight the character itself (for nobreak space,\nuse face `nobreak-space').\nA value of nil means no highlighting.\nOther values mean display the escape glyph followed by an ordinary\nspace or ordinary hyphen.  ") (span (|@| (class "comment-delimiter") (id "F:785276")) "*/") ");\n  Vnobreak_char_display = Qt;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:785327")) "\"void-text-area-pointer\"") ", &Vvoid_text_area_pointer,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:785388")) "/* ") (span (|@| (class "comment") (id "F:785391")) "*The pointer shape to show in void text areas.\nA value of nil means to show the text pointer.  Other options are `arrow',\n`text', `hand', `vdrag', `hdrag', `modeline', and `hourglass'.  ") (span (|@| (class "comment-delimiter") (id "F:785577")) "*/") ");\n  Vvoid_text_area_pointer = Qarrow;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:785634")) "\"inhibit-redisplay\"") ", &Vinhibit_redisplay,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:785685")) "/* ") (span (|@| (class "comment") (id "F:785688")) "Non-nil means don't actually do any redisplay.\nThis is used for internal purposes.  ") (span (|@| (class "comment-delimiter") (id "F:785772")) "*/") ");\n  Vinhibit_redisplay = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:785822")) "\"global-mode-string\"") ", &Vglobal_mode_string,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:785875")) "/* ") (span (|@| (class "comment") (id "F:785878")) "String (or mode line construct) included (normally) in `mode-line-format'.  ") (span (|@| (class "comment-delimiter") (id "F:785954")) "*/") ");\n  Vglobal_mode_string = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:786005")) "\"overlay-arrow-position\"") ", &Voverlay_arrow_position,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:786066")) "/* ") (span (|@| (class "comment") (id "F:786069")) "Marker for where to display an arrow on top of the buffer text.\nThis must be the beginning of a line in order to work.\nSee also `overlay-arrow-string'.  ") (span (|@| (class "comment-delimiter") (id "F:786222")) "*/") ");\n  Voverlay_arrow_position = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:786277")) "\"overlay-arrow-string\"") ", &Voverlay_arrow_string,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:786334")) "/* ") (span (|@| (class "comment") (id "F:786337")) "String to display as an arrow in non-window frames.\nSee also `overlay-arrow-position'.  ") (span (|@| (class "comment-delimiter") (id "F:786425")) "*/") ");\n  Voverlay_arrow_string = make_pure_c_string (" (span (|@| (class "string") (id "F:786476")) "\"=>\"") ");\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:786499")) "\"overlay-arrow-variable-list\"") ", &Voverlay_arrow_variable_list,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:786570")) "/* ") (span (|@| (class "comment") (id "F:786573")) "List of variables (symbols) which hold markers for overlay arrows.\nThe symbols on this list are examined during redisplay to determine\nwhere to display overlay arrows.  ") (span (|@| (class "comment-delimiter") (id "F:786742")) "*/") ");\n  Voverlay_arrow_variable_list\n    = Fcons (intern_c_string (" (span (|@| (class "string") (id "F:786808")) "\"overlay-arrow-position\"") "), Qnil);\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:786857")) "\"scroll-step\"") ", &scroll_step,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:786895")) "/* ") (span (|@| (class "comment") (id "F:786898")) "*The number of lines to try scrolling a window by when point moves out.\nIf that fails to bring point back on frame, point is centered instead.\nIf this is zero, point is always centered after it moves off frame.\nIf you want scrolling to always be a line at a time, you should set\n`scroll-conservatively' to a large value rather than set this to 1.  ") (span (|@| (class "comment-delimiter") (id "F:787246")) "*/") ");\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:787266")) "\"scroll-conservatively\"") ", &scroll_conservatively,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:787324")) "/* ") (span (|@| (class "comment") (id "F:787327")) "*Scroll up to this many lines, to bring point back on screen.\nIf point moves off-screen, redisplay will scroll by up to\n`scroll-conservatively' lines in order to bring point just barely\nonto the screen again.  If that cannot be done, then redisplay\nrecenters point as usual.\n\nA value of zero means always recenter point if it moves off screen.  ") (span (|@| (class "comment-delimiter") (id "F:787672")) "*/") ");\n  scroll_conservatively = 0;\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:787721")) "\"scroll-margin\"") ", &scroll_margin,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:787763")) "/* ") (span (|@| (class "comment") (id "F:787766")) "*Number of lines of margin at the top and bottom of a window.\nRecenter the window whenever point gets within this many lines\nof the top or bottom of the window.  ") (span (|@| (class "comment-delimiter") (id "F:787928")) "*/") ");\n  scroll_margin = 0;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:787970")) "\"display-pixels-per-inch\"") ",  &Vdisplay_pixels_per_inch,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:788034")) "/* ") (span (|@| (class "comment") (id "F:788037")) "Pixels per inch value for non-window system displays.\nValue is a number or a cons (WIDTH-DPI . HEIGHT-DPI).  ") (span (|@| (class "comment-delimiter") (id "F:788146")) "*/") ");\n  Vdisplay_pixels_per_inch = make_float (72.0);\n\n" (span (|@| (class "preprocessor") (id "F:788200")) "#if") " GLYPH_DEBUG\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:788230")) "\"debug-end-pos\"") ", &debug_end_pos, doc: " (span (|@| (class "comment-delimiter") (id "F:788268")) "/* ") (span (|@| (class "comment") (id "F:788271")) "Don't ask.  ") (span (|@| (class "comment-delimiter") (id "F:788283")) "*/") ");\n" (span (|@| (class "preprocessor") (id "F:788288")) "#endif") "\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:788311")) "\"truncate-partial-width-windows\"") ",\n               &Vtruncate_partial_width_windows,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:788396")) "/* ") (span (|@| (class "comment") (id "F:788399")) "Non-nil means truncate lines in windows narrower than the frame.\nFor an integer value, truncate lines in each window narrower than the\nfull frame width, provided the window width is less than that integer;\notherwise, respect the value of `truncate-lines'.\n\nFor any other non-nil value, truncate lines in all windows that do\nnot span the full frame width.\n\nA value of nil means to respect the value of `truncate-lines'.\n\nIf `word-wrap' is enabled, you might want to reduce this.  ") (span (|@| (class "comment-delimiter") (id "F:788878")) "*/") ");\n  Vtruncate_partial_width_windows = make_number (50);\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:788953")) "\"mode-line-inverse-video\"") ", &mode_line_inverse_video,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:789015")) "/* ") (span (|@| (class "comment") (id "F:789018")) "When nil, display the mode-line/header-line/menu-bar in the default face.\nAny other value means to use the appropriate face, `mode-line',\n`header-line', or `menu' respectively.  ") (span (|@| (class "comment-delimiter") (id "F:789196")) "*/") ");\n  mode_line_inverse_video = 1;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:789248")) "\"line-number-display-limit\"") ", &Vline_number_display_limit,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:789315")) "/* ") (span (|@| (class "comment") (id "F:789318")) "*Maximum buffer size for which line number should be displayed.\nIf the buffer is bigger than this, the line number does not appear\nin the mode line.  A value of nil means no limit.  ") (span (|@| (class "comment-delimiter") (id "F:789500")) "*/") ");\n  Vline_number_display_limit = Qnil;\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:789557")) "\"line-number-display-limit-width\"") ",\n              &line_number_display_limit_width,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:789642")) "/* ") (span (|@| (class "comment") (id "F:789645")) "*Maximum line width (in characters) for line number display.\nIf the average length of the lines near point is bigger than this, then the\nline number may be omitted from the mode line.  ") (span (|@| (class "comment-delimiter") (id "F:789830")) "*/") ");\n  line_number_display_limit_width = 200;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:789892")) "\"highlight-nonselected-windows\"") ", &highlight_nonselected_windows,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:789966")) "/* ") (span (|@| (class "comment") (id "F:789969")) "*Non-nil means highlight region even in nonselected windows.  ") (span (|@| (class "comment-delimiter") (id "F:790031")) "*/") ");\n  highlight_nonselected_windows = 0;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:790089")) "\"multiple-frames\"") ", &multiple_frames,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:790135")) "/* ") (span (|@| (class "comment") (id "F:790138")) "Non-nil if more than one frame is visible on this display.\nMinibuffer-only frames don't count, but iconified frames do.\nThis variable is not guaranteed to be accurate except while processing\n`frame-title-format' and `icon-title-format'.  ") (span (|@| (class "comment-delimiter") (id "F:790376")) "*/") ");\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:790397")) "\"frame-title-format\"") ", &Vframe_title_format,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:790450")) "/* ") (span (|@| (class "comment") (id "F:790453")) "Template for displaying the title bar of visible frames.\n\\(Assuming the window manager supports this feature.)\n\nThis variable has the same structure as `mode-line-format', except that\nthe %c and %l constructs are ignored.  It is used only on frames for\nwhich no explicit name has been set \\(see `modify-frame-parameters').  ") (span (|@| (class "comment-delimiter") (id "F:790777")) "*/") ");\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:790798")) "\"icon-title-format\"") ", &Vicon_title_format,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:790849")) "/* ") (span (|@| (class "comment") (id "F:790852")) "Template for displaying the title bar of an iconified frame.\n\\(Assuming the window manager supports this feature.)\nThis variable has the same structure as `mode-line-format' (which see),\nand is used only on frames for which no explicit name has been set\n\\(see `modify-frame-parameters').  ") (span (|@| (class "comment-delimiter") (id "F:791141")) "*/") ");\n  Vicon_title_format\n    = Vframe_title_format\n    = pure_cons (intern_c_string (" (span (|@| (class "string") (id "F:791227")) "\"multiple-frames\"") "),\n                 pure_cons (make_pure_c_string (" (span (|@| (class "string") (id "F:791281")) "\"%b\"") "),\n                            pure_cons (pure_cons (empty_unibyte_string,\n                                                  pure_cons (intern_c_string (" (span (|@| (class "string") (id "F:791375")) "\"invocation-name\"") "),\n                                                             pure_cons (make_pure_c_string (" (span (|@| (class "string") (id "F:791438")) "\"@\"") "),\n                                                                        pure_cons (intern_c_string (" (span (|@| (class "string") (id "F:791481")) "\"system-name\"") "),\n                                                                                   Qnil)))),\n                                       Qnil)));\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:791556")) "\"message-log-max\"") ", &Vmessage_log_max,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:791603")) "/* ") (span (|@| (class "comment") (id "F:791606")) "Maximum number of lines to keep in the message log buffer.\nIf nil, disable message logging.  If t, log messages but don't truncate\nthe buffer when it becomes large.  ") (span (|@| (class "comment-delimiter") (id "F:791772")) "*/") ");\n  Vmessage_log_max = make_number (100);\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:791833")) "\"window-size-change-functions\"") ", &Vwindow_size_change_functions,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:791906")) "/* ") (span (|@| (class "comment") (id "F:791909")) "Functions called before redisplay, if window sizes have changed.\nThe value should be a list of functions that take one argument.\nJust before redisplay, for each frame, if any of its windows have changed\nsize since the last redisplay, or have been split or deleted,\nall the functions in the list are called, with the frame as argument.  ") (span (|@| (class "comment-delimiter") (id "F:792245")) "*/") ");\n  Vwindow_size_change_functions = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:792306")) "\"window-scroll-functions\"") ", &Vwindow_scroll_functions,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:792369")) "/* ") (span (|@| (class "comment") (id "F:792372")) "List of functions to call before redisplaying a window with scrolling.\nEach function is called with two arguments, the window and its new\ndisplay-start position.  Note that these functions are also called by\n`set-window-buffer'.  Also note that the value of `window-end' is not\nvalid when these functions are called.  ") (span (|@| (class "comment-delimiter") (id "F:792690")) "*/") ");\n  Vwindow_scroll_functions = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:792746")) "\"window-text-change-functions\"") ",\n               &Vwindow_text_change_functions,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:792827")) "/* ") (span (|@| (class "comment") (id "F:792830")) "Functions to call in redisplay when text in the window might change.  ") (span (|@| (class "comment-delimiter") (id "F:792900")) "*/") ");\n  Vwindow_text_change_functions = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:792961")) "\"redisplay-end-trigger-functions\"") ", &Vredisplay_end_trigger_functions,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:793040")) "/* ") (span (|@| (class "comment") (id "F:793043")) "Functions called when redisplay of a window reaches the end trigger.\nEach function is called with two arguments, the window and the end trigger value.\nSee `set-window-redisplay-end-trigger'.  ") (span (|@| (class "comment-delimiter") (id "F:793235")) "*/") ");\n  Vredisplay_end_trigger_functions = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:793299")) "\"mouse-autoselect-window\"") ", &Vmouse_autoselect_window,\n     doc: " (span (|@| (class "comment-delimiter") (id "F:793363")) "/* ") (span (|@| (class "comment") (id "F:793366")) "*Non-nil means autoselect window with mouse pointer.\nIf nil, do not autoselect windows.\nA positive number means delay autoselection by that many seconds: a\nwindow is autoselected only after the mouse has remained in that\nwindow for the duration of the delay.\nA negative number has a similar effect, but causes windows to be\nautoselected only after the mouse has stopped moving.  \\(Because of\nthe way Emacs compares mouse events, you will occasionally wait twice\nthat time before the window gets selected.\\)\nAny other value means to autoselect window instantaneously when the\nmouse pointer enters it.\n\nAutoselection selects the minibuffer only if it is active, and never\nunselects the minibuffer if it is active.\n\nWhen customizing this variable make sure that the actual value of\n`focus-follows-mouse' matches the behavior of your window manager.  ") (span (|@| (class "comment-delimiter") (id "F:794213")) "*/") ");\n  Vmouse_autoselect_window = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:794269")) "\"auto-resize-tool-bars\"") ", &Vauto_resize_tool_bars,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:794328")) "/* ") (span (|@| (class "comment") (id "F:794331")) "*Non-nil means automatically resize tool-bars.\nThis dynamically changes the tool-bar's height to the minimum height\nthat is needed to make all tool-bar items visible.\nIf value is `grow-only', the tool-bar's height is only increased\nautomatically; to decrease the tool-bar height, use \\\\[recenter].  ") (span (|@| (class "comment-delimiter") (id "F:794630")) "*/") ");\n  Vauto_resize_tool_bars = Qt;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:794682")) "\"auto-raise-tool-bar-buttons\"") ", &auto_raise_tool_bar_buttons_p,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:794754")) "/* ") (span (|@| (class "comment") (id "F:794757")) "*Non-nil means raise tool-bar buttons when the mouse moves over them.  ") (span (|@| (class "comment-delimiter") (id "F:794828")) "*/") ");\n  auto_raise_tool_bar_buttons_p = 1;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:794886")) "\"make-cursor-line-fully-visible\"") ", &make_cursor_line_fully_visible_p,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:794964")) "/* ") (span (|@| (class "comment") (id "F:794967")) "*Non-nil means to scroll (recenter) cursor line if it is not fully visible.  ") (span (|@| (class "comment-delimiter") (id "F:795044")) "*/") ");\n  make_cursor_line_fully_visible_p = 1;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:795105")) "\"tool-bar-border\"") ", &Vtool_bar_border,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:795152")) "/* ") (span (|@| (class "comment") (id "F:795155")) "*Border below tool-bar in pixels.\nIf an integer, use it as the height of the border.\nIf it is one of `internal-border-width' or `border-width', use the\nvalue of the corresponding frame parameter.\nOtherwise, no border is added below the tool-bar.  ") (span (|@| (class "comment-delimiter") (id "F:795402")) "*/") ");\n  Vtool_bar_border = Qinternal_border_width;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:795468")) "\"tool-bar-button-margin\"") ", &Vtool_bar_button_margin,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:795529")) "/* ") (span (|@| (class "comment") (id "F:795532")) "*Margin around tool-bar buttons in pixels.\nIf an integer, use that for both horizontal and vertical margins.\nOtherwise, value should be a pair of integers `(HORZ . VERT)' with\nHORZ specifying the horizontal margin, and VERT specifying the\nvertical margin.  ") (span (|@| (class "comment-delimiter") (id "F:795789")) "*/") ");\n  Vtool_bar_button_margin = make_number (DEFAULT_TOOL_BAR_BUTTON_MARGIN);\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:795883")) "\"tool-bar-button-relief\"") ", &tool_bar_button_relief,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:795943")) "/* ") (span (|@| (class "comment") (id "F:795946")) "*Relief thickness of tool-bar buttons.  ") (span (|@| (class "comment-delimiter") (id "F:795986")) "*/") ");\n  tool_bar_button_relief = DEFAULT_TOOL_BAR_BUTTON_RELIEF;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:796066")) "\"tool-bar-style\"") ", &Vtool_bar_style,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:796111")) "/* ") (span (|@| (class "comment") (id "F:796114")) "*Tool bar style to use.\nIt can be one of\n image      - show images only\n text       - show text only\n both       - show both, text under image\n both-horiz - show text to the right of the image\n any other  - use system default or image if no system default.  ") (span (|@| (class "comment-delimiter") (id "F:796372")) "*/") ");\n  Vtool_bar_style = Qnil;\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:796418")) "\"tool-bar-max-label-size\"") ", &tool_bar_max_label_size,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:796480")) "/* ") (span (|@| (class "comment") (id "F:796483")) "*Maximum number of characters a label can have to be shown.\nThe tool bar style must also show labels for this to have any effect, see\n`tool-bar-style'.  ") (span (|@| (class "comment-delimiter") (id "F:796636")) "*/") ");\n  tool_bar_max_label_size = DEFAULT_TOOL_BAR_LABEL_SIZE;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:796714")) "\"fontification-functions\"") ", &Vfontification_functions,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:796777")) "/* ") (span (|@| (class "comment") (id "F:796780")) "List of functions to call to fontify regions of text.\nEach function is called with one argument POS.  Functions must\nfontify a region starting at POS in the current buffer, and give\nfontified regions the property `fontified'.  ") (span (|@| (class "comment-delimiter") (id "F:797007")) "*/") ");\n  Vfontification_functions = Qnil;\n  Fmake_variable_buffer_local (Qfontification_functions);\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:797121")) "\"unibyte-display-via-language-environment\"") ",\n               &unibyte_display_via_language_environment,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:797232")) "/* ") (span (|@| (class "comment") (id "F:797235")) "*Non-nil means display unibyte text according to language environment.\nSpecifically, this means that raw bytes in the range 160-255 decimal\nare displayed by converting them to the equivalent multibyte characters\naccording to the current language environment.  As a result, they are\ndisplayed according to the current fontset.\n\nNote that this variable affects only how these bytes are displayed,\nbut does not change the fact they are interpreted as raw bytes.  ") (span (|@| (class "comment-delimiter") (id "F:797695")) "*/") ");\n  unibyte_display_via_language_environment = 0;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:797764")) "\"max-mini-window-height\"") ", &Vmax_mini_window_height,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:797825")) "/* ") (span (|@| (class "comment") (id "F:797828")) "*Maximum height for resizing mini-windows.\nIf a float, it specifies a fraction of the mini-window frame's height.\nIf an integer, it specifies a number of lines.  ") (span (|@| (class "comment-delimiter") (id "F:797990")) "*/") ");\n  Vmax_mini_window_height = make_float (0.25);\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:798058")) "\"resize-mini-windows\"") ", &Vresize_mini_windows,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:798113")) "/* ") (span (|@| (class "comment") (id "F:798116")) "*How to resize mini-windows.\nA value of nil means don't automatically resize mini-windows.\nA value of t means resize them to fit the text displayed in them.\nA value of `grow-only', the default, means let mini-windows grow\nonly, until their display becomes empty, at which point the windows\ngo back to their normal size.  ") (span (|@| (class "comment-delimiter") (id "F:798437")) "*/") ");\n  Vresize_mini_windows = Qgrow_only;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:798495")) "\"blink-cursor-alist\"") ", &Vblink_cursor_alist,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:798548")) "/* ") (span (|@| (class "comment") (id "F:798551")) "Alist specifying how to blink the cursor off.\nEach element has the form (ON-STATE . OFF-STATE).  Whenever the\n`cursor-type' frame-parameter or variable equals ON-STATE,\ncomparing using `equal', Emacs uses OFF-STATE to specify\nhow to blink it off.  ON-STATE and OFF-STATE are values for\nthe `cursor-type' frame parameter.\n\nIf a frame's ON-STATE has no entry in this list,\nthe frame's other specifications determine how to blink the cursor off.  ") (span (|@| (class "comment-delimiter") (id "F:798995")) "*/") ");\n  Vblink_cursor_alist = Qnil;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:799046")) "\"auto-hscroll-mode\"") ", &automatic_hscrolling_p,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:799101")) "/* ") (span (|@| (class "comment") (id "F:799104")) "*Non-nil means scroll the display automatically to make point visible.  ") (span (|@| (class "comment-delimiter") (id "F:799176")) "*/") ");\n  automatic_hscrolling_p = 1;\n  Qauto_hscroll_mode = intern_c_string (" (span (|@| (class "string") (id "F:799251")) "\"auto-hscroll-mode\"") ");\n  staticpro (&Qauto_hscroll_mode);\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:799323")) "\"hscroll-margin\"") ", &hscroll_margin,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:799367")) "/* ") (span (|@| (class "comment") (id "F:799370")) "*How many columns away from the window edge point is allowed to get\nbefore automatic hscrolling will horizontally scroll the window.  ") (span (|@| (class "comment-delimiter") (id "F:799504")) "*/") ");\n  hscroll_margin = 5;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:799547")) "\"hscroll-step\"") ", &Vhscroll_step,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:799588")) "/* ") (span (|@| (class "comment") (id "F:799591")) "*How many columns to scroll the window when point gets too close to the edge.\nWhen point is less than `hscroll-margin' columns from the window\nedge, automatic hscrolling will scroll the window by the amount of columns\ndetermined by this variable.  If its value is a positive integer, scroll that\nmany columns.  If it's a positive floating-point number, it specifies the\nfraction of the window's width to scroll.  If it's nil or zero, point will be\ncentered horizontally after the scroll.  Any other value, including negative\nnumbers, are treated as if the value were zero.\n\nAutomatic hscrolling always moves point outside the scroll margin, so if\npoint was more than scroll step columns inside the margin, the window will\nscroll more than the value given by the scroll step.\n\nNote that the lower bound for automatic hscrolling specified by `scroll-left'\nand `scroll-right' overrides this variable's effect.  ") (span (|@| (class "comment-delimiter") (id "F:800499")) "*/") ");\n  Vhscroll_step = make_number (0);\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:800555")) "\"message-truncate-lines\"") ", &message_truncate_lines,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:800615")) "/* ") (span (|@| (class "comment") (id "F:800618")) "If non-nil, messages are truncated instead of resizing the echo area.\nBind this around calls to `message' to let it take effect.  ") (span (|@| (class "comment-delimiter") (id "F:800748")) "*/") ");\n  message_truncate_lines = 0;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:800799")) "\"menu-bar-update-hook\"") ",  &Vmenu_bar_update_hook,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:800857")) "/* ") (span (|@| (class "comment") (id "F:800860")) "Normal hook run to update the menu bar definitions.\nRedisplay runs this hook before it redisplays the menu bar.\nThis is used to update submenus such as Buffers,\nwhose contents depend on various data.  ") (span (|@| (class "comment-delimiter") (id "F:801061")) "*/") ");\n  Vmenu_bar_update_hook = Qnil;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:801114")) "\"menu-updating-frame\"") ", &Vmenu_updating_frame,\n               doc: " (span (|@| (class "comment-delimiter") (id "F:801173")) "/* ") (span (|@| (class "comment") (id "F:801176")) "Frame for which we are updating a menu.\nThe enable predicate for a menu binding should check this variable.  ") (span (|@| (class "comment-delimiter") (id "F:801285")) "*/") ");\n  Vmenu_updating_frame = Qnil;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:801337")) "\"inhibit-menubar-update\"") ", &inhibit_menubar_update,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:801397")) "/* ") (span (|@| (class "comment") (id "F:801400")) "Non-nil means don't update menu bars.  Internal use only.  ") (span (|@| (class "comment-delimiter") (id "F:801459")) "*/") ");\n  inhibit_menubar_update = 0;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:801510")) "\"wrap-prefix\"") ", &Vwrap_prefix,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:801549")) "/* ") (span (|@| (class "comment") (id "F:801552")) "Prefix prepended to all continuation lines at display time.\nThe value may be a string, an image, or a stretch-glyph; it is\ninterpreted in the same way as the value of a `display' text property.\n\nThis variable is overridden by any `wrap-prefix' text or overlay\nproperty.\n\nTo add a prefix to non-continuation lines, use `line-prefix'.  ") (span (|@| (class "comment-delimiter") (id "F:801886")) "*/") ");\n  Vwrap_prefix = Qnil;\n  staticpro (&Qwrap_prefix);\n  Qwrap_prefix = intern_c_string (" (span (|@| (class "string") (id "F:801977")) "\"wrap-prefix\"") ");\n  Fmake_variable_buffer_local (Qwrap_prefix);\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:802055")) "\"line-prefix\"") ", &Vline_prefix,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:802094")) "/* ") (span (|@| (class "comment") (id "F:802097")) "Prefix prepended to all non-continuation lines at display time.\nThe value may be a string, an image, or a stretch-glyph; it is\ninterpreted in the same way as the value of a `display' text property.\n\nThis variable is overridden by any `line-prefix' text or overlay\nproperty.\n\nTo add a prefix to continuation lines, use `wrap-prefix'.  ") (span (|@| (class "comment-delimiter") (id "F:802431")) "*/") ");\n  Vline_prefix = Qnil;\n  staticpro (&Qline_prefix);\n  Qline_prefix = intern_c_string (" (span (|@| (class "string") (id "F:802522")) "\"line-prefix\"") ");\n  Fmake_variable_buffer_local (Qline_prefix);\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:802600")) "\"inhibit-eval-during-redisplay\"") ", &inhibit_eval_during_redisplay,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:802674")) "/* ") (span (|@| (class "comment") (id "F:802677")) "Non-nil means don't eval Lisp during redisplay.  ") (span (|@| (class "comment-delimiter") (id "F:802726")) "*/") ");\n  inhibit_eval_during_redisplay = 0;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:802784")) "\"inhibit-free-realized-faces\"") ", &inhibit_free_realized_faces,\n    doc: " (span (|@| (class "comment-delimiter") (id "F:802854")) "/* ") (span (|@| (class "comment") (id "F:802857")) "Non-nil means don't free realized faces.  Internal use only.  ") (span (|@| (class "comment-delimiter") (id "F:802919")) "*/") ");\n  inhibit_free_realized_faces = 0;\n\n" (span (|@| (class "preprocessor") (id "F:802960")) "#if") " GLYPH_DEBUG\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:802991")) "\"inhibit-try-window-id\"") ", &inhibit_try_window_id,\n               doc: " (span (|@| (class "comment-delimiter") (id "F:803053")) "/* ") (span (|@| (class "comment") (id "F:803056")) "Inhibit try_window_id display optimization.  ") (span (|@| (class "comment-delimiter") (id "F:803101")) "*/") ");\n  inhibit_try_window_id = 0;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:803151")) "\"inhibit-try-window-reusing\"") ", &inhibit_try_window_reusing,\n               doc: " (span (|@| (class "comment-delimiter") (id "F:803223")) "/* ") (span (|@| (class "comment") (id "F:803226")) "Inhibit try_window_reusing display optimization.  ") (span (|@| (class "comment-delimiter") (id "F:803276")) "*/") ");\n  inhibit_try_window_reusing = 0;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:803331")) "\"inhibit-try-cursor-movement\"") ", &inhibit_try_cursor_movement,\n               doc: " (span (|@| (class "comment-delimiter") (id "F:803405")) "/* ") (span (|@| (class "comment") (id "F:803408")) "Inhibit try_cursor_movement display optimization.  ") (span (|@| (class "comment-delimiter") (id "F:803459")) "*/") ");\n  inhibit_try_cursor_movement = 0;\n" (span (|@| (class "preprocessor") (id "F:803499")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:803506")) "/* ") (span (|@| (class "comment") (id "F:803509")) "GLYPH_DEBUG ") (span (|@| (class "comment-delimiter") (id "F:803521")) "*/") "\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:803539")) "\"overline-margin\"") ", &overline_margin,\n               doc: " (span (|@| (class "comment-delimiter") (id "F:803589")) "/* ") (span (|@| (class "comment") (id "F:803592")) "*Space between overline and text, in pixels.\nThe default value is 2: the height of the overline (1 pixel) plus 1 pixel\nmargin to the caracter height.  ") (span (|@| (class "comment-delimiter") (id "F:803743")) "*/") ");\n  overline_margin = 2;\n\n  DEFVAR_INT (" (span (|@| (class "string") (id "F:803786")) "\"underline-minimum-offset\"") ",\n               &underline_minimum_offset,\n     doc: " (span (|@| (class "comment-delimiter") (id "F:803859")) "/* ") (span (|@| (class "comment") (id "F:803862")) "Minimum distance between baseline and underline.\nThis can improve legibility of underlined text at small font sizes,\nparticularly when using variable `x-use-underline-position-properties'\nwith fonts that specify an UNDERLINE_POSITION relatively close to the\nbaseline.  The default value is 1.  ") (span (|@| (class "comment-delimiter") (id "F:804156")) "*/") ");\n  underline_minimum_offset = 1;\n\n  DEFVAR_BOOL (" (span (|@| (class "string") (id "F:804209")) "\"display-hourglass\"") ", &display_hourglass_p,\n               doc: " (span (|@| (class "comment-delimiter") (id "F:804265")) "/* ") (span (|@| (class "comment") (id "F:804268")) "Non-zero means Emacs displays an hourglass pointer on window systems.  ") (span (|@| (class "comment-delimiter") (id "F:804339")) "*/") ");\n  display_hourglass_p = 1;\n\n  DEFVAR_LISP (" (span (|@| (class "string") (id "F:804387")) "\"hourglass-delay\"") ", &Vhourglass_delay,\n               doc: " (span (|@| (class "comment-delimiter") (id "F:804438")) "/* ") (span (|@| (class "comment") (id "F:804441")) "*Seconds to wait before displaying an hourglass pointer.\nValue must be an integer or float.  ") (span (|@| (class "comment-delimiter") (id "F:804534")) "*/") ");\n  Vhourglass_delay = make_number (DEFAULT_HOURGLASS_DELAY);\n\n  hourglass_atimer = " (span (|@| (class "constant") (id "F:804621")) "NULL") ";\n  hourglass_shown_p = 0;\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:804656")) "/* ") (span (|@| (class "comment") (id "F:804659")) "Initialize this module when Emacs starts.  ") (span (|@| (class "comment-delimiter") (id "F:804702")) "*/") "\n\n" (span (|@| (class "type") (id "F:804706")) "void") "\n" (span (|@| (class "function-name") (id "F:804711")) "init_xdisp") " ()\n{\n  " (span (|@| (class "type") (id "F:804729")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:804741")) "root_window") ";\n  " (span (|@| (class "keyword") (id "F:804756")) "struct") " " (span (|@| (class "type") (id "F:804763")) "window") " *" (span (|@| (class "variable-name") (id "F:804771")) "mini_w") ";\n\n  current_header_line_height = current_mode_line_height = -1;\n\n  CHARPOS (this_line_start_pos) = 0;\n\n  mini_w = XWINDOW (minibuf_window);\n  root_window = FRAME_ROOT_WINDOW (XFRAME (WINDOW_FRAME (mini_w)));\n\n  " (span (|@| (class "keyword") (id "F:804989")) "if") " (" (span (|@| (class "negation-char") (id "F:804993")) "!") "noninteractive)\n    {\n      " (span (|@| (class "keyword") (id "F:805022")) "struct") " " (span (|@| (class "type") (id "F:805029")) "frame") " *" (span (|@| (class "variable-name") (id "F:805036")) "f") " = XFRAME (WINDOW_FRAME (XWINDOW (root_window)));\n      " (span (|@| (class "type") (id "F:805093")) "int") " " (span (|@| (class "variable-name") (id "F:805097")) "i") ";\n\n      XWINDOW (root_window)->top_line = make_number (FRAME_TOP_MARGIN (f));\n      set_window_height (root_window,\n                         FRAME_LINES (f) - 1 - FRAME_TOP_MARGIN (f),\n                         0);\n      mini_w->top_line = make_number (FRAME_LINES (f) - 1);\n      set_window_height (minibuf_window, 1, 0);\n\n      XWINDOW (root_window)->total_cols = make_number (FRAME_COLS (f));\n      mini_w->total_cols = make_number (FRAME_COLS (f));\n\n      scratch_glyph_row.glyphs[TEXT_AREA] = scratch_glyphs;\n      scratch_glyph_row.glyphs[TEXT_AREA + 1]\n        = scratch_glyphs + MAX_SCRATCH_GLYPHS;\n\n      " (span (|@| (class "comment-delimiter") (id "F:805663")) "/* ") (span (|@| (class "comment") (id "F:805666")) "The default ellipsis glyphs `...'.  ") (span (|@| (class "comment-delimiter") (id "F:805702")) "*/") "\n      " (span (|@| (class "keyword") (id "F:805711")) "for") " (i = 0; i < 3; ++i)\n        default_invis_vector[i] = make_number (" (span (|@| (class "string") (id "F:805775")) "'.'") ");\n    }\n\n  {\n    " (span (|@| (class "comment-delimiter") (id "F:805796")) "/* ") (span (|@| (class "comment") (id "F:805799")) "Allocate the buffer for frame titles.\n       Also used for `format-mode-line'.  ") (span (|@| (class "comment-delimiter") (id "F:805879")) "*/") "\n    " (span (|@| (class "type") (id "F:805886")) "int") " " (span (|@| (class "variable-name") (id "F:805890")) "size") " = 100;\n    mode_line_noprop_buf = (" (span (|@| (class "type") (id "F:805930")) "char") " *) xmalloc (size);\n    mode_line_noprop_buf_end = mode_line_noprop_buf + size;\n    mode_line_noprop_ptr = mode_line_noprop_buf;\n    mode_line_target = MODE_LINE_DISPLAY;\n  }\n\n  help_echo_showing_p = 0;\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:806140")) "/* ") (span (|@| (class "comment") (id "F:806143")) "Since w32 does not support atimers, it defines its own implementation of\n   the following three functions in w32fns.c.  ") (span (|@| (class "comment-delimiter") (id "F:806263")) "*/") "\n" (span (|@| (class "preprocessor") (id "F:806266")) "#if") (span (|@| (class "negation-char") (id "F:806269")) (span (|@| (class "preprocessor") (id "F:806269")) "n")) (span (|@| (class "preprocessor") (id "F:806270")) "def") " WINDOWSNT\n\n" (span (|@| (class "comment-delimiter") (id "F:806285")) "/* ") (span (|@| (class "comment") (id "F:806288")) "Platform-independent portion of hourglass implementation. ") (span (|@| (class "comment-delimiter") (id "F:806346")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:806350")) "/* ") (span (|@| (class "comment") (id "F:806353")) "Return non-zero if houglass timer has been started or hourglass is shown.  ") (span (|@| (class "comment-delimiter") (id "F:806428")) "*/") "\n" (span (|@| (class "type") (id "F:806431")) "int") "\n" (span (|@| (class "function-name") (id "F:806435")) "hourglass_started") " ()\n{\n  " (span (|@| (class "keyword") (id "F:806460")) "return") " hourglass_shown_p || hourglass_atimer != " (span (|@| (class "constant") (id "F:806508")) "NULL") ";\n}\n\n" (span (|@| (class "comment-delimiter") (id "F:806517")) "/* ") (span (|@| (class "comment") (id "F:806520")) "Cancel a currently active hourglass timer, and start a new one.  ") (span (|@| (class "comment-delimiter") (id "F:806585")) "*/") "\n" (span (|@| (class "type") (id "F:806588")) "void") "\n" (span (|@| (class "function-name") (id "F:806593")) "start_hourglass") " ()\n{\n" (span (|@| (class "preprocessor") (id "F:806614")) "#if") " " (span (|@| (class "preprocessor") (id "F:806618")) "defined") " (HAVE_WINDOW_SYSTEM)\n  " (span (|@| (class "type") (id "F:806649")) "EMACS_TIME") " " (span (|@| (class "variable-name") (id "F:806660")) "delay") ";\n  " (span (|@| (class "type") (id "F:806669")) "int") " " (span (|@| (class "variable-name") (id "F:806673")) "secs") ", " (span (|@| (class "variable-name") (id "F:806679")) "usecs") " = 0;\n\n  cancel_hourglass ();\n\n  " (span (|@| (class "keyword") (id "F:806717")) "if") " (INTEGERP (Vhourglass_delay)\n      && XINT (Vhourglass_delay) > 0)\n    secs = XFASTINT (Vhourglass_delay);\n  " (span (|@| (class "keyword") (id "F:806829")) "else") " " (span (|@| (class "keyword") (id "F:806834")) "if") " (FLOATP (Vhourglass_delay)\n           && XFLOAT_DATA (Vhourglass_delay) > 0)\n    {\n      " (span (|@| (class "type") (id "F:806919")) "Lisp_Object") " " (span (|@| (class "variable-name") (id "F:806931")) "tem") ";\n      tem = Ftruncate (Vhourglass_delay, Qnil);\n      secs = XFASTINT (tem);\n      usecs = (XFLOAT_DATA (Vhourglass_delay) - secs) * 1000000;\n    }\n  " (span (|@| (class "keyword") (id "F:807086")) "else") "\n    secs = DEFAULT_HOURGLASS_DELAY;\n\n  EMACS_SET_SECS_USECS (delay, secs, usecs);\n  hourglass_atimer = start_atimer (ATIMER_RELATIVE, delay,\n                                   show_hourglass, " (span (|@| (class "constant") (id "F:807255")) "NULL") ");\n" (span (|@| (class "preprocessor") (id "F:807262")) "#endif") "\n}\n\n\n" (span (|@| (class "comment-delimiter") (id "F:807273")) "/* ") (span (|@| (class "comment") (id "F:807276")) "Cancel the hourglass cursor timer if active, hide a busy cursor if\n   shown.  ") (span (|@| (class "comment-delimiter") (id "F:807354")) "*/") "\n" (span (|@| (class "type") (id "F:807357")) "void") "\n" (span (|@| (class "function-name") (id "F:807362")) "cancel_hourglass") " ()\n{\n" (span (|@| (class "preprocessor") (id "F:807384")) "#if") " " (span (|@| (class "preprocessor") (id "F:807388")) "defined") " (HAVE_WINDOW_SYSTEM)\n  " (span (|@| (class "keyword") (id "F:807419")) "if") " (hourglass_atimer)\n    {\n      cancel_atimer (hourglass_atimer);\n      hourglass_atimer = " (span (|@| (class "constant") (id "F:807512")) "NULL") ";\n    }\n\n  " (span (|@| (class "keyword") (id "F:807527")) "if") " (hourglass_shown_p)\n    hide_hourglass ();\n" (span (|@| (class "preprocessor") (id "F:807573")) "#endif") "\n}\n" (span (|@| (class "preprocessor") (id "F:807582")) "#endif") " " (span (|@| (class "comment-delimiter") (id "F:807589")) "/* ") (span (|@| (class "comment") (id "F:807592")) "! WINDOWSNT  ") (span (|@| (class "comment-delimiter") (id "F:807605")) "*/") "\n\n" (span (|@| (class "comment-delimiter") (id "F:807609")) "/* ") (span (|@| (class "comment") (id "F:807612")) "arch-tag: eacc864d-bb6a-4b74-894a-1a4399a1358b\n   (do not change this comment) ") (span (|@| (class "comment-delimiter") (id "F:807691")) "*/") "\n") "\n" "    ") "\n") "\n")